{
 "userName": "Cotterzz",
 "date": "2025-10-10T18:02:29.227Z",
 "numShaders": 183,
 "shaders": [
  {
   "ver": "0.1",
   "info": {
    "id": "td3GDN",
    "date": "1568534348",
    "viewed": 214,
    "name": "ManyWaves",
    "description": "This is my first attempt at writing a shader.",
    "likes": 1,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "texture",
     "blending",
     "sinewaves"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 col = vec4(0.00,1.00,1.00,1.00);\n    float progress = fragCoord.x + (iTime*200.00);\n    float scale = 10.00;\n    \n    if(iMouse.y>5.00){scale=iMouse.y;}\n    \n    float groundHeighta = (((sin(progress/50.00))+2.00)*iResolution.y)/scale;\n    float groundHeightb = (((sin(progress/70.00))+2.00)*iResolution.y)/scale;\n    float groundHeightc = (((sin(progress/130.00))+2.00)*iResolution.y)/scale;\n    float groundHeightd = (((sin(progress/23.00))+2.00)*iResolution.y)/scale;\n    \n    float groundHeight = groundHeighta + groundHeightb + groundHeightc + groundHeightd;\n    \n    col = texture(iChannel0, vec2(progress/512.00,fragCoord.y/groundHeight));\n    col = col+texture(iChannel0, vec2(uv.x,fragCoord.y/groundHeight));\n\n    fragColor = vec4(col);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3s3GRj",
    "date": "1568836353",
    "viewed": 115,
    "name": "Animandelbrot",
    "description": "my third attempt at a mandelbrot set\n(i had to swap the do-while loop with a for loop)\nthis is much nicer, great for exploring the set\nI've colored the convergence in as well.\nmouse-x scales and mouse-y changes the colour",
    "likes": 1,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "fractal",
     "mandelbrot",
     "chaos",
     "iteration"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    float scale = 10.00/iMouse.x;\n    if(scale>3.00){scale=3.00;}\n    float cx = -1.782/scale;//-10.00+((iMouse.x)/iResolution.x);\n    float cy = -0.50;//+((iMouse.y)/iResolution.y);\n    float limit = 4.00;\n    float ax=(cx+uv.x)*scale;\n    float ay=(cy+uv.y)*scale;\n    float a1=ax;\n    float b1=ay;\n    int lp=0;\n    for(int i=0;i<255;++i){\n        float a2=(a1*a1)-(b1*b1)+ax;\n        float b2=2.0*a1*b1+ay;\n        a1=a2;\n        b1=b2;\n        lp=i;\n        if(((a1*a1)+(b1*b1))>limit){break;}\n    }\n    vec3 col = vec3(a1*b1,a1*b1,a1*b1);\n    if(lp==254){\n        col = vec3(sin(((a1*a1)/(b1*b1))/(iMouse.y/3.00)), sin((a1/b1)/(iMouse.y/5.00)),sin(((b1/a1)/(a1/b1))/(iMouse.y/7.00)));\n    }\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wdd3Rj",
    "date": "1568900103",
    "viewed": 110,
    "name": "Animandelbrot 2",
    "description": "another version, this time zooming and changing the escape limit over time",
    "likes": 3,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "fractal",
     "mandelbrot",
     "time"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    float slow = 2.00;\n    float scale = slow/iTime;\n    //if(scale>3.00){scale=3.00;}\n    float cx = -1.782/scale;//-10.00+((iMouse.x)/iResolution.x);\n    float cy = -0.50;//+((iMouse.y)/iResolution.y);\n    float limit =((sin(iTime*3.30)+1.00)*100.00) + 3.6;//iMouse.x;//iTime/slow;\n    float ax=(cx+uv.x)*scale;\n    float ay=(cy+uv.y)*scale;\n    float a1=ax;\n    float b1=ay;\n    int lp=0;\n    for(int i=0;i<255;++i){\n        float a2=(a1*a1)-(b1*b1)+ax;\n        float b2=2.0*a1*b1+ay;\n        a1=a2;\n        b1=b2;\n        lp=i;\n        if(((a1*a1)+(b1*b1))>limit){break;}\n    }\n    vec3 col = vec3(a1*b1,a1*b1,a1*b1);\n    if(lp==254){\n        col = vec3(sin(((a1*a1)/(b1*b1))/(iTime/(1.00*slow))), sin((a1/b1)/(iTime/(2.00*slow))),sin(((b1/a1)/(a1/b1))/(iTime/(3.00*slow))));\n    }\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wsd3R2",
    "date": "1568911332",
    "viewed": 124,
    "name": "Animandelbrot 3",
    "description": "Another go at animating the mandelbrot, this time by changing the number of iterations",
    "likes": 0,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "mandelbrot",
     "animated",
     "iterated"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    float slow = 0.10;\n    float scale = 100.00/(iMouse.x*iMouse.x);\n    if(scale>3.00){scale=3.00;}\n    float cx = -1.782/scale;//-10.00+((iMouse.x)/iResolution.x);\n    float cy = -0.50;//+((iMouse.y)/iResolution.y);\n    float limit =3.2 + 10.00*(sin(iTime)+1.00);\n    float ax=(cx+uv.x)*scale;\n    float ay=(cy+uv.y)*scale;\n    float a1=ax;\n    float b1=ay;\n    int lp=0;\n    float count = 251.00*(sin(iTime)+1.00);\n    int icount = 4 + int(floor(count));\n    for(int i=0;i<icount;++i){\n        float a2=(a1*a1)-(b1*b1)+ax;\n        float b2=2.0*a1*b1+ay;\n        a1=a2;\n        b1=b2;\n        lp=i;\n        if(((a1*a1)+(b1*b1))>limit){break;}\n    }\n    vec3 col = vec3(sin(a1*b1),sin(a1/b1),uv.y);\n    if(lp==(icount-1)){\n        col = vec3(0.0,0.0,0.0);\n        //col = vec3(sin(((a1*a1)/(b1*b1))/(iTime/(1.00*slow))), sin((a1/b1)/(iTime/(2.00*slow))),sin(((b1/a1)/(a1/b1))/(iTime/(3.00*slow))));\n    }\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wd33Rf",
    "date": "1568935176",
    "viewed": 232,
    "name": "Emergent BehaviAAAAAA",
    "description": "Trying to create lettering with a shader, led to some unexpected emergent behavior.\nSeizure warning with this one, sorry.",
    "likes": 1,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "typography",
     "letters"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec2 vect2d(vec2 p1, vec2 p2) {\n    vec2 temp;\n    temp.x = (p2.x - p1.x);\n    temp.y = -1.0 * (p2.y - p1.y);\n    return temp;}\n\nbool pointInRectangle(in vec2 A, in vec2 B, in vec2 C, in vec2 D, in vec2 m ) {\n    vec2 AB = vect2d(A, B);  float C1 = -1.0 * (AB.y*A.x + AB.x*A.y); float  D1 = (AB.y*m.x + AB.x*m.y) + C1;\n    vec2 AD = vect2d(A, D);  float C2 = -1.0 * (AD.y*A.x + AD.x*A.y); float D2 = (AD.y*m.x + AD.x*m.y) + C2;\n    vec2 BC = vect2d(B, C);  float C3 = -1.0 * (BC.y*B.x + BC.x*B.y); float D3 = (BC.y*m.x + BC.x*m.y) + C3;\n    vec2 CD = vect2d(C, D);  float C4 = -1.0 * (CD.y*C.x + CD.x*C.y); float D4 = (CD.y*m.x + CD.x*m.y) + C4;\n    return     0.0 >= D1 && 0.0 >= D4 && 0.0 <= D2 && 0.0 >= D3;}\n\nfloat inCharacter ( in vec2 position, in int character){\n    if (character == 65){\n        vec2 tl = vec2(0.4,0.9);\n        vec2 tr = vec2(0.6,0.95);\n        vec2 br = vec2(0.9,0.1);\n        vec2 bl = vec2(0.1,0.1);\n        if (pointInRectangle(tl,tr,br,bl,position)){\n            vec2 itl = vec2(0.5,0.66);\n        \tvec2 itr = vec2(0.5,0.66);\n        \tvec2 ibr = vec2(0.7,0.1);\n        \tvec2 ibl = vec2(0.3,0.1);\n            if (pointInRectangle(itl,itr,ibr,ibl,position)){\n                \n                return step (0.1,abs(0.4-position.y));\n                    } else { return 0.0;}\n            \n        } else {return 1.0;}\n        //float l2 = step((position.x * 3.00),(position.y+0.4));\n        //float l1 = step((position.y+0.8),(position.x * 3.00));\n        //return l1+l2;\n    }\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //if (((fragCoord.x * 2.00) + 5.00)>fragCoord.y){\n        //col = vec3 (0.0,0.0,0.0);\n    //}\n    float fcol = inCharacter(mod(fragCoord,iTime/100.00)/(iTime/100.00), 65);\n    col = vec3(fcol,fcol,fcol);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tsGGRy",
    "date": "1570443745",
    "viewed": 662,
    "name": "Visualiser 203",
    "description": "Really simple - just a load of squares, each one gives you the level of each semitone.\nOctave 9 is incomplete, and there isn't enough resolution in the data for octave 0 to be read properly.",
    "likes": 12,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "fft",
     "spectrum",
     "audio",
     "rgb"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4df3Rn",
       "filepath": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// check out new version here: https://www.shadertoy.com/view/tcG3Rm\n\n#define TWO_PI 6.28318530718\n\n#define C9 8372.02\n#define Db9 8870.\n#define D9 9398.\n#define Eb9 9974.\n#define E9 10548.\n#define F9 11176.\n#define Gb9 11840.\n#define G9 12544.\n#define Ab9 13290.\n#define A9 14080.\n#define Bb9 14918.\n#define B9 15804.\n\nfloat notes[] = float[](C9, Db9, D9,Eb9,E9,F9,Gb9,G9,Ab9,A9,Bb9,B9);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float notes[12] = float[12](C9, Db9, D9,Eb9,E9,F9,Gb9,G9,Ab9,A9,Bb9,B9);\n    \n    int octave = int(floor(uv.y * 10.0));\n    int semitone = int(floor(uv.x * 12.0));\n    \n    float disty = abs(fract(uv.y*10.0)-0.5);\n    float distx = abs(fract(uv.x*12.0)-0.5);\n    float dist = max(distx, disty);\n \n    float frequency = notes[semitone]/pow(2.0, 9.0-float(octave));\n    \n    float freqv = texture(iChannel0, vec2(frequency/10000.,0.0)).r; // Turned out this is wrong, I realised years later it should be 11025, not 10000\n\tfreqv *=freqv;\n    freqv *=freqv;\n    float bright = step(dist*2.0, freqv);\n\t\n    float c = 0.6;\n    vec4 col = ( c + c*cos( TWO_PI*(uv.x-0.15) + vec4(0,23,21,0)  ) );\n\tfragColor = col*bright;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3dcXRn",
    "date": "1571254079",
    "viewed": 163,
    "name": "Dancing Julia",
    "description": "Forked from https://www.shadertoy.com/view/wsKGDc\nAnimating a julia set to audio, whilst trying to preserve the aesthetic of the original",
    "likes": 5,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "fractal",
     "julia",
     "fft",
     "audio"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdfGzn",
       "filepath": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// from https://www.shadertoy.com/view/wsKGDc\n\n\n#define MAX_ITER 1000.\n#define R 100.\n#define S(a,b,c) smoothstep(a,b,c)\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n//conversion helper\nfloat f(float n, vec3 hsl){\n    float k = mod(n+hsl.x*12., 12.);\n    float a = hsl.y*min(hsl.z, 1.-hsl.z);\n    return hsl.z-a*max(min(k-3., min(9.-k, 1.)),-1.);\n}\n// hsl in range <0, 1>^3\nvec3 hsl2rgb(vec3 hsl){\n    return vec3(f(0.,hsl), f(8.,hsl), f(4.,hsl));\n}\n\nvec3 hue2rgb(float hue){\n    \n    float fftc = texture(iChannel0, vec2(hue,0.0)).r;\n    if(hue<1.0){hue=fftc;};\n    //return (hsl2rgb(vec3(fftc, 1., .5))+hsl2rgb(vec3(hue, 1., .5)))/2.;\n    return hsl2rgb(vec3(hue, 1., .5));\n}\n\nvec2 Rain(vec2 uv, float t){\n    t*= 40.;\n    vec2 aspect = vec2(3.,1.);\n    vec2 st = uv*aspect;\n    \n    vec2 id = floor(st);\n    st.y+=t*.22;\n    float n = fract(sin(id.x*256.45)*85.);\n    st.y += n;\n    uv.y += n;\n    id = floor(st);\n    st = fract(st)-.5;\n    \n    t+= fract(sin(id.x*56.45+id.y*485.)*155.)*6.28;\n    \n    float y = -sin(t+sin(t+.5*sin(t)))*0.43;\n    float x = (fract(sin(id.x*384.45)*id.y*288.)-.5)*.6;\n    vec2 p1 = vec2(x, y);\n    vec2 o1 = (st-p1)/aspect;\n    float d = length(o1);\n    \n    float m1 = S(.07, .0, d);\n    \n    vec2 o2 = (fract(uv*aspect.x*vec2(1.,2.)-vec2(p1.x,0.))-.5)/vec2(1.,2.);\n    d = length(o2);\n    \n    float m2 = S(0.2*(.5-st.y), .0, d) * S(-.1, .1, st.y-p1.y);\n    \n    //if(st.x>.46 || st.y>.49) m1 = 1.;\n    \n    return vec2(m1*o1*30.+m2*o2*10.);\n}\n\nvec3 julia(float zx, float zy, float cx, float cy){\n    float iter = 0.;\n    for(int i = 0; i<int(MAX_ITER); i++){\n        if(zx * zx + zy * zy < R*R && iter<MAX_ITER){\n\t\t\tfloat xtemp = zx*zx - zy*zy;\n        \tzy = 2. * zx * zy + cy;\n        \tzx = xtemp + cx;\n        \titer+=1.;\n        } else {\n            break;\n        }\n    }\n\n    /*if(iter>=MAX_ITER)\n        return vec3(1,1,0);*/\n    float dist = length(vec2(zx,zy));\n    float fracIter = log2(log(dist) / log(R)) - 1.;\n    iter -= fracIter;\n    return hue2rgb(sqrt(iter/10.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvo = fragCoord/iResolution.xy;\n    vec2 toCenter = vec2(0.5)-(fragCoord/iResolution.xy);\n    float angle = (atan(toCenter.y,toCenter.x)+PI)/TWO_PI;\n    float radius = length(toCenter)*2.0;\n    float fftJ = texture(iChannel0, vec2(angle,0.0)).r;\n    float wav = texture(iChannel0, vec2(angle,1.0)).r;\n    float fftJr = texture(iChannel0, vec2(0.2,0.0)).r;\n    float wavr = texture(iChannel0, vec2(uvo.x,1.0)).r;\n    float fftJs = texture(iChannel0, vec2(0.5,0.0)).r;\n    float wavs = texture(iChannel0, vec2(0.5,1.0)).r;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m-=.5;\n    m*=2.;\n    uv*=2.;\n    float t = iTime;\n    t*=.7;\n    //vec3 col = julia(uv.x, uv.y, m.x, m.y);\n    //vec3 col = julia(uv.x, uv.y,-.7*cos(t)+(fftJr/4.0),.7*sin(t)+(wavr/4.0));\n    //vec3 col = julia(uv.x, uv.y, -.7*cos(t)+((fftJs-0.5)*0.1), ((fftJs-0.5)*1.0));\n    \n    //vec2 rain = Rain(uv*2., t*5.13);\n    //rain += Rain(uv*3., t*.15) * .25;\n    //uv -= rain * 0.35;\n    //vec3 col = julia(uv.x, uv.y, .7*cos(t), .7*sin(t));\n    vec3 col = julia(uv.x/(fftJs+0.3), uv.y/(fftJs+0.3), -0.75,2.*(fftJr-0.5));\n    fragColor = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wdcXzH",
    "date": "1571420089",
    "viewed": 151,
    "name": "Inside Out Dancing Julia Set",
    "description": "Forked from https://www.shadertoy.com/view/wsKGDc and https://shadertoy.com/view/3dcXRn",
    "likes": 5,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "fractal",
     "julia",
     "fft",
     "audio"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    // Output to screen\n    vec4 col =  texture(iChannel0, uv);\n    //col = vec4(1.0,1.0,0.0,1.0);\n    fragColor = col;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "XdfGzn",
       "filepath": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Dancing Julia\" by Cotterzz. https://shadertoy.com/view/3dcXRn\n// 2019-10-18 14:24:46\n\n// from \"Smooth Julia set with rain\" by martytram https://www.shadertoy.com/view/wsKGDc\n\n\n#define MAX_ITER 1000.\n#define R 100.\n#define S(a,b,c) smoothstep(a,b,c)\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n//conversion helper\nfloat f(float n, vec3 hsl){\n    float k = mod(n+hsl.x*12., 12.);\n    float a = hsl.y*min(hsl.z, 1.-hsl.z);\n    return hsl.z-a*max(min(k-3., min(9.-k, 1.)),-1.);\n}\n// hsl in range <0, 1>^3\nvec3 hsl2rgb(vec3 hsl){\n    return vec3(f(0.,hsl), f(8.,hsl), f(4.,hsl));\n}\n\nvec3 hue2rgb(float hue){\n    \n    float fftc = texture(iChannel0, vec2(hue,0.0)).r;\n    //if(hue<1.0){return hsl2rgb(vec3(0., 1., 0.));} else {return hsl2rgb(vec3(hue, 1., .5));};\n    //return (hsl2rgb(vec3(fftc, 1., .5))+hsl2rgb(vec3(hue, 1., .5)))/2.;\n    return hsl2rgb(vec3(hue, 1., .5));\n}\n\nvec2 Rain(vec2 uv, float t){\n    t*= 40.;\n    vec2 aspect = vec2(3.,1.);\n    vec2 st = uv*aspect;\n    \n    vec2 id = floor(st);\n    st.y+=t*.22;\n    float n = fract(sin(id.x*256.45)*85.);\n    st.y += n;\n    uv.y += n;\n    id = floor(st);\n    st = fract(st)-.5;\n    \n    t+= fract(sin(id.x*56.45+id.y*485.)*155.)*6.28;\n    \n    float y = -sin(t+sin(t+.5*sin(t)))*0.43;\n    float x = (fract(sin(id.x*384.45)*id.y*288.)-.5)*.6;\n    vec2 p1 = vec2(x, y);\n    vec2 o1 = (st-p1)/aspect;\n    float d = length(o1);\n    \n    float m1 = S(.07, .0, d);\n    \n    vec2 o2 = (fract(uv*aspect.x*vec2(1.,2.)-vec2(p1.x,0.))-.5)/vec2(1.,2.);\n    d = length(o2);\n    \n    float m2 = S(0.2*(.5-st.y), .0, d) * S(-.1, .1, st.y-p1.y);\n    \n    //if(st.x>.46 || st.y>.49) m1 = 1.;\n    \n    return vec2(m1*o1*30.+m2*o2*10.);\n}\n\n\nvec3 juliaB(float zx, float zy, float cx, float cy){\n    float iter = 0.;\n    for(int i = 0; i<int(MAX_ITER); i++){\n        if(zx * zx + zy * zy < R*R && iter<MAX_ITER){\n\t\t\tfloat xtemp = zx*zx - zy*zy;\n        \tzy = 2. * zx * zy + cy;\n        \tzx = xtemp + cx;\n        \titer+=1.;\n        } else {\n            break;\n        }\n    }\n\n\n    /*if(iter>=MAX_ITER)\n        return vec3(1,1,0);*/\n    float dist = length(vec2(zx,zy));\n    float fracIter = log2(log(dist) / log(R)) - 1.;\n    iter -= fracIter;\n    return hue2rgb(sqrt(iter/10.));\n}\n\n\nvec3 julia(float zx, float zy, float cx, float cy){\n    float iter = 0.;\n    float nextzx = zx;\n    float nextzy = zy;\n    float nextcx = cx;\n    float nextcy = cy;\n    for(int i = 0; i<int(MAX_ITER); i++){\n        if(zx * zx + zy * zy < R*R && iter<MAX_ITER){\n\t\t\tfloat xtemp = zx*zx - zy*zy;\n        \tzy = 2. * zx * zy + cy;\n        \tzx = xtemp + cx;\n        \titer+=1.;\n        } else {\n            break;\n        }\n    }\n\n    /*if(iter>=MAX_ITER)\n        return vec3(1,1,0);*/\n    float dist = length(vec2(zx,zy));\n    float fracIter = log2(log(dist) / log(R)) - 1.;\n    iter -= fracIter;\n    float firstcol = sqrt(iter/10.);\n    if(firstcol<1.0){\n        firstcol*=firstcol;\n        vec3 nextcol = juliaB(nextzx*firstcol, nextzy*firstcol, nextcx, nextcy);\n        if(nextcol==vec3(0.0,0.0,0.0)){\n            return juliaB(nextzy*firstcol, nextzx*firstcol, nextcx, nextcy);\n        } else {\n            return nextcol;\n        }\n        \n        //if(firstco>0.3){\n            //return vec3(0.,0.,1.);\n       // } else {\n            //return vec3(1.,0.,0.);\n       // }\n        \n    }else {\n        return hue2rgb(firstcol);\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvo = fragCoord/iResolution.xy;\n    vec2 toCenter = vec2(0.5)-(fragCoord/iResolution.xy);\n    float angle = (atan(toCenter.y,toCenter.x)+PI)/TWO_PI;\n    float radius = length(toCenter)*2.0;\n    float fftJ = texture(iChannel0, vec2(angle,0.0)).r;\n    float wav = texture(iChannel0, vec2(angle,1.0)).r;\n    float fftJr = texture(iChannel0, vec2(0.2,0.0)).r;\n    float wavr = texture(iChannel0, vec2(uvo.x,1.0)).r;\n    float fftJs = texture(iChannel0, vec2(0.5,0.0)).r;\n    float wavs = texture(iChannel0, vec2(0.5,1.0)).r;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m-=.5;\n    m*=2.;\n    uv*=2.;\n    float t = iTime;\n    t*=.7;\n    \n\n    // uncomment for rain\n    // vec2 rain = Rain(uv*2., t*5.13);rain += Rain(uv*3., t*.15) * .25;uv -= rain * 0.35;\n    \n    // swap these for mouse control instead of music\n\t //vec3 col = julia(uv.x, uv.y, m.x, m.y);\n   vec3 col = julia(uv.x/(fftJs+0.3), uv.y/(fftJs+0.3), -0.75,2.*(fftJr-0.5));\n    \n    // swap these for the post blurring\n    //fragColor = (vec4(col, 1.0)/1.9 + texture(iChannel1, (uvo*0.98)+0.01)/1.9);\n    fragColor = vec4(col, 1.0);\n}\n\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lcdXRM",
    "date": "1713745869",
    "viewed": 97,
    "name": "Hard to factor",
    "description": "Found this equation on quora and decided to turn it into a shader.\npow(x) doesn't work for negative x, so using a workaround.",
    "likes": 0,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "math",
     "graph",
     "equations"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// from https://www.quora.com/How-do-I-solve-the-following-equation-over-the-integers-x-3-y-2-left-2y-x-right-x-2-y-4-36\n\n// power function without using pow() \nfloat p(in float a, in int b){float r = a;for(int i = 2; i<10; i++){ r = r*a; if(i>=b){ break;} }return r;}\n\n// and using pow for comparison, some setups will only see half the graph\n//float p(in float a, in int b){return pow(a, float(b));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 guv = (uv*20.0)-10.0;\n    float x = guv.x;\n    float y = guv.y;\n    \n    float result = ( 2.0 * p(x,3) * p(y,3) )-( p(x,4) * p(y,2) )-( p(x,2) * p(y,4) ) + 36.0;\n\n    // Output to screen\n    float blue = abs(min(result, 0.0))/1000.0;\n    float red = max(result, 0.0)/100.0;\n    float white = 1.0/(abs(result)+0.001);\n\n    fragColor = vec4(red+white, white, blue+white,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lXdSW7",
    "date": "1719172025",
    "viewed": 47,
    "name": "Batman logo attempt 1",
    "description": "fork of previous shader - trying to find the equation of the batman logo",
    "likes": 0,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "math",
     "graph",
     "equations"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// from https://www.shadertoy.com/view/lcdXRM\n\n#define x2 x*x\n#define x3 x*x*x\n#define x4 x*x*x*x\n#define x5 x*x*x*x*x\n#define x6 x*x*x*x*x*x\n#define x7 x*x*x*x*x*x*x\n\n#define y2 y*y\n#define y3 y*y*y\n#define y4 y*y*y*y\n#define y5 y*y*y*y*y\n#define y6 y*y*y*y*y*y\n#define y7 y*y*y*y*y*y*y\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 guv = (uv*20.0)-10.0;\n    float x = guv.x;\n    float y = guv.y;\n    \n    float result = (2.0 * x4 * y3)-(x4 * y2)-(x2 * y4)+10.0;\n\n    // Output to screen\n    float blue = abs(min(result, 0.0))/1000.0;\n    float red = max(result, 0.0)/100.0;\n    float white = 1.0/(abs(result)+0.001);\n\n    fragColor = vec4(red+white, white, blue+white,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MXdXW7",
    "date": "1719172055",
    "viewed": 53,
    "name": "Unusual tiling",
    "description": "From facebook post",
    "likes": 2,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "math",
     "graph",
     "equations"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2  G = 10.* u/iResolution.y - 10.,\n          s = sin(G),\n          c = cos(G),\n          r = (2.*s*c).yx/(c*c) - c;\n    \n    float v = r.x*r.y;\n \n    O = vec4( v*v*v, \n              1. - ( abs(v) - 1. ) / min(fwidth(v), 10.) , \n              -v*v*v, \n              1 \n            );\n}\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 guv = (uv*10.0)-10.0;\n    float x = guv.x;\n    float y = guv.y;\n    \n\n    float ys = sin(y);\n    float y2s = sin(2.0*y);\n    float yc = cos(y);\n    float ycc = yc*yc;\n    float yss = ys*ys;\n    \n    float xs = sin(x);\n    float x2s = sin(2.0*x);\n    float xc = cos(x);\n    float xcc = xc*xc;\n    float xss = xs*xs;\n    \n    float result = ((y2s/xcc)-xc)*((x2s/ycc)-yc);\n\n    // Output to screen\n    float blue = result;\n    float red = -result;\n    float green=0.0;\n    if (result>-1.0&&result<1.0) {green=1.0;}\n\n    fragColor = vec4(red*red*red, green ,blue*blue*blue,1.0);\n}\n*/",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lXdSD7",
    "date": "1719172015",
    "viewed": 37,
    "name": "Batman logo attempt 2",
    "description": "Another different approach",
    "likes": 0,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "math",
     "graph",
     "equations"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 guv = (uv*10.0)-10.0;\n    float x = guv.x;\n    float y = guv.y;\n    \n\n    float ys = sin(y);\n    float y2s = sin(2.0*y);\n    float yc = cos(y);\n    float ycc = yc*yc;\n    float yss = ys*ys;\n    \n    float xs = sin(x);\n    float x2s = sin(2.0*x);\n    float xc = cos(x);\n    float xcc = xc*xc;\n    float xss = xs*xs;\n    \n    float result = ((y2s/xcc)-xc)*((x2s/ycc)-yc);\n\n    // Output to screen\n    float blue = result;\n    float red = -result;\n    float green=0.0;\n    if (result>-1.0&&result<1.0) {green=1.0;}\n\n    fragColor = vec4(0, green ,0,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "M3cSR2",
    "date": "1719267120",
    "viewed": 53,
    "name": "Batman logo attempt 3",
    "description": "Playing around with different functions with time as well",
    "likes": 1,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "math",
     "graph",
     "equations"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define x2 x*x\n#define x3 x*x*x\n#define x4 x*x*x*x\n#define x5 x*x*x*x*x\n#define x6 x*x*x*x*x*x\n#define x7 x*x*x*x*x*x*x\n\n#define y2 y*y\n#define y3 y*y*y\n#define y4 y*y*y*y\n#define y5 y*y*y*y*y\n#define y6 y*y*y*y*y*y\n#define y7 y*y*y*y*y*y*y\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 guv = (uv*40.0)-20.0;\n    float x = guv.x;\n    float y = guv.y;\n\n    float A = iTime;\n    float B = iTime*iTime;\n    float C = sin(iTime);\n    float D = C*C;\n    float E = cos(iTime);\n    float F = E*E;\n    float G = C*E;\n\n    float ys = sin(y);\n    float y2s = sin(2.0*y);\n    float yc = cos(y);\n    float ycc = yc*yc;\n    float yss = ys*ys;\n    \n    float xs = sin(x);\n    float x2s = sin(2.0*x);\n    float xc = cos(x);\n    float xcc = xc*xc;\n    float xss = xs*xs;\n    \n   \n    \n    float result = (xcc*y4*D)+(ys+x2/G)-(y2+x2/C);\n\n    // Output to screen\n    float blue = abs(min(result, 0.0))/1000.0;\n    float red = max(result, 0.0)/100.0;\n    float white = 1.0/(abs(result)+0.001);\n\n    fragColor = vec4(red, white, blue,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lflyzH",
    "date": "1720803718",
    "viewed": 199,
    "name": "Fork of Corroded beasts.",
    "description": "Forked from https://www.shadertoy.com/view/3dXSDH\nThis version is stuck at time=1.0 for comparing screengrabs.",
    "likes": 5,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "3d",
     "raymarching",
     "live",
     "twitch"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time 1.0\nfloat PI = acos(-1.0);\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fractal(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\nfloat map(vec3 p) {\n\n  \n  float t1 = time;\n  float o = noise(p*3.0 + t1*0.2);\n  p += (noise(p*10.0 + t1*0.7)-0.5)*0.1;\n  p += tunnel(p);\n  \n  float s=10.0;\n  p.xy = (fract(p.xy/s-0.5)-0.5)*s;\n\n  vec3 p1=p;\n  p1.xy *= rot(p.z*0.2+sin(p.z*1.8)*0.2 + t1*0.1);\n  \n  p1=moda(p1.xzy, 5.0, 0.0);\n  float d = cyl(p1.xz-vec2(1,0),0.0+o*0.3-0.1)+0.1;\n  \n  vec3 p2=p;\n  p2.xy *= rot(p.z*1.2+sin(p.z*0.8)*0.3 + t1*0.13);\n  \n  p2=moda(p2.xzy, 9.0,sin(p2.z)*0.9);\n  float d2 = cyl(p2.xz-vec2(1.3,0),0.05);\n  \n  d=smin(d, d2, 0.9);\n  \n  return d;\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat getsss(vec3 p, vec3 r, float dist) {\n  return clamp(map(p+r*dist)*3.0,0.0,1.0);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\nfloat dots(vec3 p, float j) {\n  float v=0.0;\n  \n  p*=4.0+1.0*sin(j);\n  p.x += rnd(floor(p.y));\n\n  p*=PI;\n  v += clamp(0.1-length(vec2(sin(p.x),cos(p.y))),0.0,1.0)*10.3;\n  return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s=vec3(0.0,0.0,-3);\n  vec3 t=vec3(0,0,0);\n  float t2 = time*0.5;\n  s.x += sin(t2*0.7)*0.5;\n  s.y += sin(t2*0.9)*0.5;\n\n  s.z += t2;\n  t.z += t2;\n  s -= tunnel(s);\n  t -= tunnel(t);\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  //vec3 r=normalize(vec3(-uv, 0.7));\n\n  vec3 p=s;\n  int i=0;\n  float mask=1.0;\n  float d = 10000.0;\n\n  float rand=rnd(uv);\n  float dither=0.5+0.1*rand;\n  \n  for(; i<MARCH_STEPS; ++i) {\n    d=map(p);\n    if(abs(d)<0.001) {\n      mask=0.0;\n      break;\n    }\n    p+=r*d*dither;\n  }\n\n  vec3 col=vec3(0);\n  vec3 n = norm(p);\n  vec3 l =normalize(vec3(-0.2,0.2,0.5));\n  float t1=sin(time*0.2);\n  l.xz *= rot(t1);\n  l.xy *= rot(t1*3.2);\n  vec3 h = normalize(l-r);\n  float f = pow(1.0-abs(dot(n,r)), 3.0);\n  float fog = pow(1.0-float(i)/100.0,2.0);\n\n  float aodist=0.7;\n  float ao = getao(p,n,aodist*0.2) * (getao(p,n,aodist*0.35)*0.5+0.5) * (getao(p,n,aodist*0.6)*0.25+0.75);\n  float sss = (getsss(p,r,0.2)+getsss(p,r,0.5)*0.5)*0.9;\n\n  vec3 back = mix(vec3(0.7,0.2,0.1), vec3(1,0.7,0.2), pow(max(0.0,dot(r,l)),5.0));\n\n  float diff = fractal(p*15.0);\n  //diff=abs(diff-0.3)*2;\n  diff=pow(smoothstep(0.1,0.9,diff),5.0)*2.7+0.9;\n  \n  col += max(0.0,dot(n,l)*0.5+0.5) * fog * ao * (vec3(1,0.7,0.3) + pow(max(0.0,dot(n,h)),20.0));\n  col += vec3(0.7,0.2,0.1)*0.5*pow(n.y*0.5+0.5,3.0);\n  col += sss * fog * back * vec3(1,0.2,0.2) * 1.5 * diff;\n  col += 3.0*f*(-n.y*0.5+0.5)*fog;\n  \n  float len = length(p-s);\n  col += back * max(clamp(d,0.0,1.0), clamp(dot(p-s,p-s)/200.0,0.0,1.0));\n\n  vec3 col2 = vec3(0);\n  for(int j=1; j<PART_COUNT; ++j) {\n    float dist = float(j) * 0.2/r.z;\n    if(dist>len) break;\n    vec3 vp = vec3(s.x,s.y,0) + r*dist;\n    vp.xy *=rot(sin(vp.z*10.0+time*0.2));\n    \n    col2 += dots(vp, float(j)) * clamp(1.0-dist/float(PART_COUNT), 0.0,1.0);\n  }\n  col += col2 * back;\n\n  col *= pow(clamp(1.2-length(uv),0.0,1.0)*1.3,1.7);\n  //col = vec3(rnd(uv));\n  \n  fragColor = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MclyRN",
    "date": "0",
    "viewed": 0,
    "name": "Cotterzz base shader",
    "description": "Basic template with snippets etc for other shaders",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "basic",
     "template"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "float sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y; // Normalise just the y coordinates to 1, to avoid distortion.\n    \n    float xoffset = (iResolution.x-iResolution.y)/(2.0*iResolution.y);\n    \n    uv.x -= xoffset; // set the x so the the 0-1 square is in the middle.\n    \n    float pixel = 1.0/iResolution.y; // and this gives us the size of a single pixel\n    \n    float radius = 0.01 + (iMouse.x/iResolution.y)/10.0;\n    \n    vec2 uv2 = uv + pixel; \n    \n    vec2 centre = vec2((iMouse.x/iResolution.y)-xoffset,iMouse.y/iResolution.y) ;//vec2(0.5 + sin(iTime*2.)/5.0, 0.5 + cos(iTime*2.)/5.0);\n    vec2 distv = uv.xy - centre;\n    vec2 distv2 = uv2.xy - centre;\n    float dist = length(distv);\n    float dist2 = length(distv2);\n    // 1. Get height of point of surface on sphere\n\n    float height = sqrt((radius*radius)-(dist*dist));\n    float height2 = sqrt((radius*radius)-(dist2*dist2));\n    vec3 col;// = vec3(1.0, height, height);\n    // 2. Create vector of position of surface on sphere, relative to centre of sphere\n    vec3 position = vec3(uv.x, height, uv.y);\n    vec3 position2 = vec3(uv2.x, height2, uv2.y);\n    //col = position *2.0;\n    // 3. Get normal of point on surface\n    vec3 normal = vec3(distv.x, height, distv.y)/radius;\n    vec3 normal2 = vec3(distv2.x, height2, distv2.y)/radius;\n    //col = normal*2.0;\n    // 4. Get reflection vector of point\n    vec3 incident = vec3(0.0, -1.0, 0.0);\n\n    vec3 reflection = reflect(incident, normal);\n    vec3 reflection2 = reflect(incident, normal2);\n    //col.g = col.g*-1.0;\n    //col = reflection*1.0;\n    // 5. Find intersection between reflection vector and plane\n    vec3 q = position + reflection * 100.0;\n    vec3 q2 = position2 + reflection2 * 100.0;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 1.0;\n    float d = 1.0;//1.7+sin(iTime);\n    float tDenom = a*(q.x-position.x) + b*(q.y-position.y) + c*(q.z-position.z);\n    float tDenom2 = a*(q2.x-position2.x) + b*(q2.y-position2.y) + c*(q2.z-position2.z);\n    bool intersects;\n    bool intersects2;\n    vec3 intersection;\n    vec3 intersection2;\n    float t;\n    if (tDenom < 0.01) {\n        intersects = false;\n    } else {\n        t = - ( a*position.x + b*position.y + c*position.z - d ) / tDenom;\n        intersects = true;\n        intersection = vec3((position.x+t*(q.x-position.x)),(position.y+t*(q.y-position.y)),(position.z+t*(q.z-position.z)));\n        if (tDenom2 < 0.01) {\n            intersects2 = false;\n        } else {\n            intersects2 = true;\n            t = - ( a*position2.x + b*position2.y + c*position2.z - d ) / tDenom2;\n            intersection2 = vec3((position2.x+t*(q2.x-position2.x)),(position2.y+t*(q2.y-position2.y)),(position2.z+t*(q2.z-position2.z)));\n        }\n    }\n    // 6. Get colour of point at position on plane\n    vec2 box = vec2(0.5,0.2);\n    vec2 boxposition = vec2(0.5, 0.2);\n    \n    float boxdist = sdBox(boxposition-intersection.xy, box);\n\n    // get distance from point on sphere to intersection\n    \n    float bdist = distance(intersection2, intersection);\n\n    float f;\n    if(intersects && boxdist<bdist && intersection.z<2.0){\n    f = smoothstep(0.0, bdist , boxdist);\n    float boxdistao = 1.0;//0.8+(-9.0*boxdist);\n    col = mix(vec3(boxdistao,boxdistao,boxdistao),col,  f);\n    }\n    \n    a = 0.0;\n    b = -1.0;\n    c = 0.0;\n    d = 0.0;\n    tDenom = a*(q.x-position.x) + b*(q.y-position.y) + c*(q.z-position.z);\n    if (tDenom < 0.1) {\n        intersects = false;\n    } else {\n        t = - ( a*position.x + b*position.y + c*position.z - d ) / tDenom;\n        intersects = true;\n        intersection = vec3((position.x+t*(q.x-position.x)),(position.y+t*(q.y-position.y)),(position.z+t*(q.z-position.z)));\n    }\n    box = vec2(0.5,0.5);\n    boxposition = vec2(0.5, 0.5);\n    boxdist = sdBox(boxposition-intersection.xz, box);\n    vec2 intersectionoffset = vec2(boxposition.x - box.x/2.0, boxposition.y - box.y/2.0);\n    bdist = iResolution.y * distance(position, intersection);\n    if(intersects){\n        f = smoothstep(-pixel*4.0*sqrt(bdist), pixel*4.0*sqrt(bdist) , boxdist);\n        vec3 groundcol = texture(iChannel0, vec2(intersection.x,intersection.z)).rgb;\n        //groundcol.r *= 2.0;\n        if (intersection.x<0.0 || intersection.x>1.0 || intersection.z<0.0 || intersection.z>1.0){\n        groundcol=vec3(0.0,0.0,0.0);\n//col = vec3(0.0,0.0,0.0);\n        }\n        col = mix(groundcol,col,  f);\n    }\n    vec3 ground = texture(iChannel0, vec2(uv.x, uv.y)).rgb;\n\t//Smoothes the edge of the sphere\n\tfloat g = smoothstep(radius-pixel, radius+pixel, dist);\n\tvec3 fcol = mix( col,ground, g);\n    //fcol.r *= 1.5;\n    //fcol *= height*5.0;\n    if(dist>radius){\n        fcol=ground; \n        if (uv.x<0.0 || uv.x>1.0){\n        fcol=vec3(0.0,0.0,0.0);\n        }\n    }\n    fragColor = vec4(fcol,1.0);\n}\n\n/*\n\n\nvec3 bgCol = vec3(0.6, 0.5, 0.6);\n\n//Sets size of the sphere and brightness of the shine\nfloat sphereScale = 0.5;\nfloat sphereShine = 0.8;\n\n//Sets diffuse colour(red, green, blue), specular colour(red, green, blue), \n//and initial specular point position(x, y)\nvec3 sphereDiff = vec3(0.5, 0.0, 0.5);\nvec3 sphereSpec = vec3(1.0, 1.0, 1.0);\nvec2 specPoint = vec2(0.2, -0.1);\n\n//Main method/function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t//Creates shader pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\t\n\t//Sets the position of the camera\n\tvec2 p = uv * 1.0 - 1.0;\n\t//p.x *= iResolution.x / iResolution.y;\n\t\n\t//Rotates the sphere in a circle\n\tp.x += cos(-iTime) * 0.35;\n\tp.y += sin(-iTime) * 0.35;\n\t\n\t//Rotates the specular point with the sphere\n\tspecPoint.x += cos(-iTime) * 0.35;\n\tspecPoint.y += sin(-iTime) * 0.35;\n\t\n\t//Sets the radius of the sphere to the middle of the screen\n\tfloat radius = sqrt(dot(p, p));\n\t\n\tvec3 col = bgCol;\n\t\n\t//Sets the initial dark shadow around the edge of the sphere\n\tfloat f = smoothstep(sphereScale * 0.9, sphereScale, length(p + specPoint));\n\tcol -= mix(col, vec3(0.0), f) * 0.2;\n\t\n\t//Only carries out the logic if the radius of the sphere is less than the scale\n\tif(radius < sphereScale) {\n\t\tvec3 bg = col;\n\t\t\n\t\t//Sets the diffuse colour of the sphere (solid colour)\n\t\tcol = sphereDiff;\n\t\t\n\t\t//Adds smooth dark borders to help achieve 3D look\n\t\tf = smoothstep(sphereScale * 0.7, sphereScale, radius);\n\t\tcol = mix(col, sphereDiff * 0.45, f);\n\t\t\n\t\t//Adds specular glow to help achive 3D look\n\t\tf = 1.0 - smoothstep(-0.2, 0.6, length(p - specPoint));\n\t\tcol += f * sphereShine * sphereSpec;\n\t\t\n\t\t//Smoothes the edge of the sphere\n\t\tf = smoothstep(sphereScale - 0.005, sphereScale, radius);\n\t\tcol = mix(col, bg, f);\n\t}\t\n\t\n\t//The final output of the shader logic above\n\t//fragColor is a vector with 4 paramaters(red, green, blue, alpha)\n\t//Only 2 need to be used here, as \"col\" is a vector that already carries r, g, and b values\n\tfragColor = vec4(col, 1);\n}\n\n*/",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lcsyz2",
    "date": "0",
    "viewed": 0,
    "name": "Cotterzz ball game shader",
    "description": "Shader built for game prototype",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "game",
     "spheres"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec3 colourGround = vec3(0.820,0.820,0.820);\nvec3 colourPaint  = vec3(0.420,0.420,0.420);\nvec3 colourTeamA  = vec3(0.839,0.000,0.000);\nvec3 colourTeamB  = vec3(0.212,0.800,0.000);\nvec3 colourLight = vec3(1.000,1.000,1.000);\nvec3 colourAmbient = vec3(0.188,0.188,0.188);\nvec2 centre;\nfloat radius;\nfloat pixel;\n\nvec3 contrast ( in vec3 ccol ){\n    ccol.r = ccol.r*(ccol.r+0.5);\n    ccol.g = ccol.g*(ccol.g+0.5);\n    ccol.b = ccol.b*(ccol.b+0.5);\n    return ccol;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec2 tanLineDist( in vec2 C, in float r, in vec2 P, in vec2 F){\n    C.y = -C.y;\n    vec2 d = P-C;\n    vec2 dr = vec2(-d.y, d.x);\n    float dl = length(d);\n    //if(dl>=r){\n        float rho = r/dl;\n        float ad = rho*rho;\n        float bd = rho*sqrt(1.0-ad);//*(1.0-rho)); // (1-rho)*(1-rho) ?\n        vec2 T1 = vec2(C.x + ad*d.x + bd*dr.x, C.y + ad*d.y + bd*dr.y);\n        vec2 T2 = vec2(C.x + ad*d.x - bd*dr.x, C.y + ad*d.y - bd*dr.y);\n\n    //}\n    float ax = T1.x-P.x;\n    float by = P.y-T1.y;\n    float c = (T1.y*P.x)-(T1.x*P.y);\n\n    float ax2 = T2.x-P.x;\n    float by2 = P.y-T2.y;\n    float c2 = (T2.y*P.x)-(T2.x*P.y);\n\n    return  vec2((F.x*-ax)- (F.y*-by)-c, (F.x*-ax2)- (F.y*-by2)-c2);\n}\n\nvec3 getGroundTexture( in vec2 p, in float ar , in float pmult)\n{\n    float gpixel = pixel*pmult*1.2;\n    float lineWidth = 1.0/180.0;\n    float f ;\n    vec2 pn = vec2((p.x-(0.5*ar)), p.y-0.5);\n    vec3 gcol = colourGround;\n    float gdist = distance(p, vec2(ar, 0.5));\n    float cgdist = distance(centre, vec2(ar, 0.5));\n    float lpn = length(pn);\n    float bdist = sdBox(pn, vec2(ar/2.0, 0.5));\n    if(bdist<=0.0-lineWidth){\n        if(bdist >= -lineWidth*2.0){\n            gcol = colourPaint;\n        }\n        \n        if(lpn>(0.2-gpixel)-lineWidth){\n            if(lpn<0.2){\n                f = smoothstep((0.2-gpixel), .2 , lpn);\n                gcol = mix(colourPaint,colourGround,  f);\n                f = smoothstep(0.2-lineWidth, (0.2-gpixel)-lineWidth , lpn);\n                gcol = mix(gcol,colourGround,  f);\n            }\n        if(abs(pn.x)<=lineWidth/2.0 && lpn>=0.19){\n                gcol = colourPaint;\n            }\n        }\n        \n    }\n    \n    gcol = gcol*colourAmbient;\n    float TAdist = sdBox(vec2(pn.x+(0.5*ar), pn.y), vec2(0.0, 0.15));\n    gcol = gcol*(1.0+(colourTeamA/sqrt(TAdist*50.0)));\n\n    //float modRadius = radius*(0.6 + cgdist/2.0);//*(1.0/pow((pn.x+(0.5*ar)), 2.0));\n    float modRadius = radius*(0.7+(cgdist*cgdist*0.15));\n    vec2 isInLight = tanLineDist(centre, modRadius, vec2(ar, -0.65), -p.yx);\n    vec2 isInLight2 = tanLineDist(centre, modRadius, vec2(ar, -0.35), -p.yx);\n    \n    float TBdist = sdBox(vec2(pn.x-(0.5*ar), pn.y), vec2(0.0, 0.15));\n    float inLight= 0.0;\n    \n    if(isInLight.y>=0.0 || isInLight2.y<=0.0){\n        inLight=1.0;} else {\n            inLight= 1.0/(abs(isInLight2.y)/abs(isInLight.y) +1.0);\n        }\n\n    float inLight2= 0.0;\n    \n    if(isInLight.x>=0.0 || isInLight2.x<=0.0){\n        inLight2=1.0;} else {\n            inLight2= 1.0/(abs(isInLight.x)/abs(isInLight2.x) +1.0);\n        } \n\n    if(isInLight.y>=0.0 && isInLight2.x<=0.0){ inLight=0.0;}\n    if(isInLight.y<=0.0 && isInLight2.x>=0.0){ \n        float inLightCross = (inLight+inLight2);\n        inLight=inLight2 = inLightCross;\n\n        \n\n    }\n    if(gdist<cgdist){inLight=1.0;}\n    inLight = min(inLight, inLight2);\n    if(isInLight.y>0.0 && isInLight2.x<=0.0  && (isInLight.x>0.0 || isInLight2.y<0.0)){inLight=1.0;}\n    f = smoothstep(0.0, 1.0,inLight);\n    gcol = mix(gcol,gcol*( 1.0+(colourTeamB/sqrt(TBdist*50.0))),  f);\n\n\n    if(p.x<0.0||p.y<0.0||p.x>1.0*ar||p.y>1.0){gcol = vec3(0.0,0.0,0.0);}\n    gcol = gcol*(2.0+(colourLight/(sqrt(lpn+0.2)/1.2)));\n    //gcol.b *= pn.x*ar;\n    return gcol;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    float border = 0.1;\n    vec2 guv = uv * (1.0 + border*2.0);\n    guv.x -= border*ar;\n    guv.y -= border;\n    vec3 col = vec3(0.0,0.0,0.0);\n    col = getGroundTexture(guv, ar, 1.0);\n    pixel = 1.0/iResolution.y;\n    \n    radius = 0.06;// + (iMouse.y/iResolution.y)/10.0;\n    \n    vec2 guv2 = guv + pixel;\n    centre = vec2((iMouse.x/iResolution.y),iMouse.y/iResolution.y);\n    centre = centre * (1.0 + border*2.0); centre.x -= border*ar; centre.y -= border;\n    vec2 distv = guv.xy - centre;\n    vec2 distv2 = guv2.xy - centre;\n    float dist = length(distv);\n    float dist2 = length(distv2);\n    float height = sqrt((radius*radius)-(dist*dist));\n    float height2 = sqrt((radius*radius)-(dist2*dist2));\n    vec3 position = vec3(guv.x, height, guv.y);\n    vec3 position2 = vec3(guv2.x, height2, guv2.y);\n    vec3 normal = vec3(distv.x, height, distv.y)/radius;\n    vec3 normal2 = vec3(distv2.x, height2, distv2.y)/radius;\n    vec3 incident = vec3(0.0, -1.0, 0.0);\n    vec3 reflection = reflect(incident, normal);\n    vec3 reflection2 = reflect(incident, normal2);\n    vec3 q = position + reflection * 100.0;\n    vec3 q2 = position2 + reflection2 * 100.0;\n\n    float a = 0.0;\n    float b = -1.0;\n    float c = 0.0;\n    float d = 0.0;\n    bool intersects;\n    bool intersects2;\n    vec3 intersection;\n    vec3 intersection2;\n    float t;\n    float f;\n    vec2 box;\n    vec2 boxposition;\n    float boxdist;\n    float bdist;\n    float tDenom = a*(q.x-position.x) + b*(q.y-position.y) + c*(q.z-position.z);\n    if (tDenom < 0.1) {\n        intersects = false;\n    } else {\n        t = - ( a*position.x + b*position.y + c*position.z - d ) / tDenom;\n        intersects = true;\n        intersection = vec3((position.x+t*(q.x-position.x)),(position.y+t*(q.y-position.y)),(position.z+t*(q.z-position.z)));\n    }\n    if(dist<radius){\n    col = vec3(0.6,0.6,0.8);\n    box = vec2(0.5*ar,0.5);\n    boxposition = vec2(0.5*ar, 0.5);\n    boxdist = sdBox(boxposition-intersection.xz, box);\n    vec2 intersectionoffset = vec2(boxposition.x - box.x/2.0, boxposition.y - box.y/2.0);\n    bdist = distance(position, intersection);\n    float bdistpix = iResolution.y * bdist;\n    if(intersects){\n        f = smoothstep(-pixel*4.0*sqrt(bdistpix), pixel*4.0*sqrt(bdistpix) , boxdist);\n        \n        vec3 greflection = vec3(reflection.x, 0.0, reflection.z);\n        float gangle = dot(reflection, greflection);\n        vec3 groundcol = getGroundTexture(vec2(intersection.x,intersection.z), ar, 1.5*gangle*(5.0+bdist));//texture(iChannel1, vec2(intersection.x,intersection.z)).rgb;\n        \n        col = mix((groundcol+col)/2.0,col,  f);\n\n       \n    }\n}\n\n\n\n    a = 1.0;\n    b = 0.0;\n    c = 0.0;\n    d = ar;\n    tDenom = a*(q.x-position.x) + b*(q.y-position.y) + c*(q.z-position.z);\n    float tDenom2 = a*(q2.x-position2.x) + b*(q2.y-position2.y) + c*(q2.z-position2.z);\n\n    \n    if (tDenom < 0.01) {\n        intersects = false;\n    } else {\n        t = - ( a*position.x + b*position.y + c*position.z - d ) / tDenom;\n        intersects = true;\n        intersection = vec3((position.x+t*(q.x-position.x)),(position.y+t*(q.y-position.y)),(position.z+t*(q.z-position.z)));\n        if (tDenom2 < 0.01) {\n            intersects2 = false;\n        } else {\n            intersects2 = true;\n            t = - ( a*position2.x + b*position2.y + c*position2.z - d ) / tDenom2;\n            intersection2 = vec3((position2.x+t*(q2.x-position2.x)),(position2.y+t*(q2.y-position2.y)),(position2.z+t*(q2.z-position2.z)));\n        }\n    }\n    box = vec2(0.15,0.15);\n    boxposition = vec2(0.15, 0.5);\n    \n    boxdist = sdBox(boxposition-intersection.yz, box);\n    bdist = distance(intersection2, intersection);\n\n\n    if(intersects && boxdist<bdist){\n        f = smoothstep(0.0, bdist , boxdist);\n\n        col = mix((colourTeamB+col),col,  f);\n    }\n\n\n    vec3 ground = getGroundTexture(guv, ar, 1.0);\n\t//Smoothes the edge of the sphere\n\tfloat g = smoothstep(radius-pixel*3.0, radius-pixel, dist);\n\tvec3 fcol = mix( col,ground, g);\n\n    \n    fcol *= fcol;\nfcol = contrast(fcol);\n\n    \n    fragColor = vec4(fcol,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4fByD1",
    "date": "1723089556",
    "viewed": 152,
    "name": "Titaniumballz",
    "description": "This is a GLSL renderer for a game I'm developing in C, Raylib and JS\n\nThere are still a few more features to add before it's ready to plug into the game.\nRight now I need to spend some time tidying up the code and optimising.",
    "likes": 4,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "game",
     "lighting",
     "spheres",
     "shadows",
     "ball",
     "25d",
     "orthographic",
     "titaniumballz"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Copyright (c) 2024 John Cotterell johnmdcotterell@gmail.com\n// You may view and edit this code (with this message intact) only on Shadertoy.\n// Anything else requires my permission.\n\n#define numballs 10\n#define black vec3(0.0,0.0,0.0)\n#define white vec3(1.0,1.0,1.0)\n#define grey vec3(0.5,0.5,0.5)\n#define blue vec3(0.0,0.0,1.0)\n#define red vec3(1.0,0.0,0.0)\n#define lime vec3(0.0,1.0,0.0)\n#define green vec3(0.0,0.7,0.0)\n#define cyan vec3(0.0,1.0,1.0)\n#define purple vec3(1.0,0.0,1.0)\n#define yelow vec3(1.0,1.0,0.0)\n#define orange vec3(1.0,0.6,0.0)\n\nvec4 Balls[numballs];\n\nbool outputMode = false; vec3 outputColour; // Easy way to throw a value at the output for debugging\nvoid outputValue (in float value){\n    outputMode = true;\n    if ( value >= 0.0 && value <= 1.0 )\n        { outputColour = vec3(value, value, value); }\n        else if ( value < 0.0 && value > -1.0 )\n        { outputColour = vec3(0.0, 0.0, -value ); }\n        else if ( value > 1.0 )\n        { outputColour = vec3(1.0-(1.0/value), 1.0, 0.0); }\n        else if ( value < -1.0 )\n        { outputColour = vec3(1.0-(1.0/-value), 0.0, 1.0); }\n} // Call outputValue with a float and that value will override the pixel output\nvoid outputValue (in vec3 value){outputMode = true;outputColour = value;} // or directly with a vec3\n\nfloat linePointLength( in vec3 P, in vec3 A, in vec3 B ){\n    vec3 AB = B-A;\n    float lenAB = length(AB);\n    vec3 D = AB/lenAB;\n    vec3 AP = P-A;\n    float d = dot(D, AP);\n    vec3 X = A + D * dot(P-A, D);\n    if(X.y<0.0){return 10.0;} else {return length(X-P);}\n}\n\nvec3 linePoint( in vec3 P, in vec3 A, in vec3 B ){\n    vec3 AB = B-A;\n    float lenAB = length(AB);\n    vec3 D = AB/lenAB;\n    vec3 AP = P-A;\n    float d = dot(D, AP);\n    vec3 X = A + D * dot(P-A, D);\n    return X;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ){\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    float pixel = 1.0/iResolution.y;\n    float cradius = 0.34;\n    float radius = 0.055;\n    vec3 gcol = vec3(0.5,0.6,0.7);\n    vec2 centreL = vec2((ar/2.0)-(cradius),0.5);\n    vec2 centreR = vec2((ar/2.0)+(cradius),0.5);\n    vec2 centre = vec2(0.0,0.0);\n    float segment = 1.256637; // ( 3.1415926 * 2.0 ) / 5.0;\n    float rightAng = 1.5708; // ( 3.1415926 * 2.0 ) / 4.0;\n    vec3 Tcolf;\n    vec3 Tcolb;\n    bool flatTop;\n    float tradius = radius/3.0;\n    float theight = sqrt((radius*radius)-(tradius*tradius));\n    float speed = iTime;\n    float dist = 20.0;\n    float angle;\n    vec3 bcol,col;\n    int currentBall = 10;\n    for(int i=0;i<numballs;i++){\n        angle = float(i) * segment;\n        vec2 rcentre = centreL;\n        if(i>4){\n            angle += speed;\n            rcentre = centreR;} else {\n                angle -= speed;\n            }\n        Balls[i]= vec4( rcentre.x + (cradius * cos(angle)), rcentre.y + (cradius * sin(angle)), 0.0, angle );\n\n        float bdist = distance(uv, Balls[i].xy);\n        if(bdist<radius){\n            dist=bdist;\n            if(bdist<(radius-pixel)){currentBall = i;}\n            centre = vec2(Balls[i].x, Balls[i].y);\n            vec3 TAbcol = vec3(0.9,1.0,0.9);\n            vec3 TAfcol = vec3(0.1,0.7,0.1);\n            vec3 TBbcol = vec3(0.1,0.0,0.0);\n            vec3 TBfcol = vec3(1.0,0.0,0.0);\n            \n            if(i<5){Tcolf=TAfcol;Tcolb=TAbcol;}else{Tcolf=TBfcol;Tcolb=TBbcol;}\n            float f;\n            float ringRadius=0.8;\n            float ringWidth = 0.1;\n            if(i>4){flatTop=true;ringRadius=0.45;}else{flatTop=false;ringRadius=0.8;}\n            if(bdist>radius*(ringRadius+ringWidth)){\n                f = smoothstep(radius*(ringRadius+ringWidth), (radius*(ringRadius+ringWidth))+pixel, bdist);\n                bcol = mix(Tcolf,Tcolb,  f);\n            } else if (bdist<radius*ringRadius){\n                f = smoothstep(radius*ringRadius, (radius*ringRadius)-pixel, bdist);\n                bcol = mix(Tcolf,Tcolb,  f);\n            } else {\n                bcol = Tcolf;\n            }\n        } else if(bdist<dist){ dist=bdist;}\n    }\n\n    float rotation;\n    if(currentBall>4){\n        rotation = Balls[currentBall].w + rightAng;\n    } else {rotation = Balls[currentBall].w - rightAng;}\n    // Spoiler flap\n    float SpFoffset = radius*3.0;// set distance from centre to front\n    float SpBoffset = radius/1.8;// set distance from centre to back\n    float SpFheight = radius*-1.5;// set front and back heights\n    float SpBheight = radius*1.2;\n    float SpWidth = radius/1.6;// set width, length, height of triangle\n    float SpLength = SpFoffset+SpBoffset;\n    float SpHeight = SpBheight-SpFheight;\n    vec3 SpFc = vec3(centre.x + SpFoffset * cos(rotation), 0.0, centre.y + SpFoffset * sin(rotation));// get front point F\n    vec3 SpFl = SpFc; SpFl.x += (SpWidth * sin(rotation)); SpFl.z -= (SpWidth * cos(rotation));// get front points L and R\n    vec3 SpFr = SpFc; SpFr.x -= (SpWidth * sin(rotation)); SpFr.z += (SpWidth * cos(rotation));\n    vec3 SpBc = vec3(centre.x - SpBoffset * cos(rotation), 0.0, centre.y - SpBoffset * sin(rotation));// get back point B\n    vec3 SpBl = SpBc; SpBl.x += (SpWidth * sin(rotation)); SpBl.z -= (SpWidth * cos(rotation));// get back points L and R\n    vec3 SpBr = SpBc; SpBr.x -= (SpWidth * sin(rotation)); SpBr.z += (SpWidth * cos(rotation));\n    float SpBD = linePointLength( vec3(uv.x, 0.0, uv.y), vec3(SpBl.x, 0.0, SpBl.z), vec3(SpBr.x, 0.0, SpBr.z) );// get distance from back\n    float SpFD = linePointLength( vec3(uv.x, 0.0, uv.y), vec3(SpFl.x, 0.0, SpFl.z), vec3(SpFr.x, 0.0, SpFr.z) );// get distance from front\n    float SpH = SpFheight + (SpHeight*(SpFD/SpLength));// get height of current point\n    float inTri = sdTriangle(uv, SpFc.xz, SpBr.xz, SpBl.xz);// is point in triangle\n    //if(inTri<0.0){outputValue(purple);} // uncomment to test where spoiler triangle is\n    \n    float lineDist = linePointLength( vec3(uv.x, 0.0, uv.y) , vec3(SpBc.x, 0.0, SpBc.z)  , vec3(SpFc.x, 0.0, SpFc.z)  );\n    if(currentBall<5){\n        float gfline = 2.7;\n        float gflinew = 0.011;\n        if(lineDist>radius/gfline&&lineDist<(radius/gfline)+gflinew&&dist<radius*0.9)\n            {\n            if(lineDist<(radius/gfline)+(gflinew/5.0)){\n                float p = smoothstep(radius/gfline, radius/gfline + (gflinew/5.0), lineDist);\n                bcol = mix(Tcolb,Tcolf,  p);} else {\n                    float p = smoothstep((radius/gfline)+gflinew, (radius/gfline)+gflinew - (gflinew/5.0), lineDist);\n                    bcol = mix(bcol,Tcolf,  p);\n                }\n            } else if (lineDist<(radius/gfline)+gflinew ){bcol = Tcolb;}\n    }\n    \n    float power = 32.0;\n    float power2 = 32.0;\n    float height = sqrt((radius*radius)-(dist*dist));\n    vec2 distv = uv - centre;\n    vec3 normal = vec3(distv.x, height, distv.y)/radius;\n  \n    if(flatTop){\n        if(height>theight){\n            height=theight;\n            normal = vec3(0.0, 1.0, 0.0);\n            power = power2;\n        }\n        float p = smoothstep(theight-0.01, theight, height);\n        normal = mix(normal,vec3(0.0, 1.0, 0.0),  p);\n        height = mix(height,theight,  p);\n    }\n    if(SpH>height&&currentBall<10){// is spoiler higher than dome\n        float face = 0.7;  \n        if(inTri<0.0){\n        power = power2;\n        float s = smoothstep(0.0, -0.002, inTri);\n        bcol=mix(Tcolb, Tcolf, s);\n        if(inTri<-0.005){\n            s = smoothstep(-0.01, -0.008, inTri);\n            bcol=mix(Tcolb, Tcolf, s);\n        }\n            s = smoothstep(0.0, pixel*6.0, SpH-height);\n            height=mix(height, SpH, s);\n            normal=mix(normal,vec3( face * cos(rotation), 0.9 , face * sin(rotation)), s);\n        } \n        if (inTri<radius/10.0&&inTri>0.0) {\n            power = power2;\n            bcol=Tcolb;\n            float s = smoothstep(0.0, radius/6.0, inTri);\n            height=mix(SpH,height,  s);\n            normal=mix(vec3( face * cos(rotation), 0.9 , face * sin(rotation)),normal, s);\n        }\n    }\n    \n    normal = normal/length(normal);\n\n    vec3 position = vec3(uv.x, height, uv.y);\n        \n    vec3 incident = vec3(0.0, -1.0, 0.0);\n    vec3 reflection = reflect(incident, normal);\n\n    vec3 lcolA = vec3(0.0,0.4,0.0);\n    vec3 lcolB = vec3(0.5,0.0,0.0);\n    vec3 lcolC = vec3(0.4,0.4,0.5);\n\n    vec3 lcolAmbient = (lcolA+lcolB+lcolC+lcolC+lcolC)/(7.0);\n        \n    gcol *= lcolAmbient;\n\n    vec3 lightA = vec3(0.0-0.3, 0.1, 0.5);\n    vec3 lightB = vec3(ar+0.3, 0.1, 0.5);\n    vec3 lightC = vec3(0.5*ar,0.2, 0.5);\n        \n    float f;\n    \n    vec3 goalRT = vec3(ar-0.1, 0.2, 0.65);\n    vec3 goalRB = vec3(ar-0.1, 0.2, 0.35);\n\n    float lightBTG = (goalRT.z-lightB.z)/(lightB.x-goalRT.x);\n    float lightBTGdist = ( (lightB.x - uv.x) * lightBTG) -  (uv.y-lightB.z);\n    float lightBBG = (goalRB.z-lightB.z)/(lightB.x-goalRB.x);\n    float lightBBGdist =    (uv.y-lightB.z)-( (lightB.x - uv.x) * lightBBG);\n    float lightBdist = lightBBGdist*lightBTGdist;\n    \n    vec3 goalLT = vec3(0.1, 0.2, 0.65);\n    vec3 goalLB = vec3(0.1, 0.2, 0.35);\n\n    float lightATG = (goalLT.z-lightA.z)/(lightA.x-goalLT.x);\n    float lightATGdist = ( (lightA.x - uv.x) * lightATG) -  (uv.y-lightA.z);\n    float lightABG = (goalLB.z-lightA.z)/(lightA.x-goalLB.x);\n    float lightABGdist =    (uv.y-lightA.z)-( (lightA.x - uv.x) * lightABG);\n    float lightAdist = lightABGdist*lightATGdist;\n\n    vec3 tolightA = lightA - position;\n    vec3 tolightB = lightB - position;\n    vec3 tolightC = lightC - position;\n\n    float distlA = length(tolightA);\n    float distlB = length(tolightB);\n    float distlC = length(tolightC);\n\n    tolightA = tolightA/distlA;\n    tolightB = tolightB/distlB;\n    tolightC = tolightC/distlC;\n    \n    float lamntA = max(0.0, dot(tolightA, normal));\n    float lamntB = max(0.0, dot(tolightB, normal));\n    float lamntC = max(0.0, dot(tolightC, normal));\n\n    float specamntA = pow(max(0.0, dot(tolightA, reflection)), power);\n    float specamntB = pow(max(0.0, dot(tolightB, reflection)), power);\n    float specamntC = pow(max(0.0, dot(tolightC, reflection)), power);\n    if( dist > radius ){ height = 0.0;}\n    \n    vec3 tlightA = (lcolA*specamntA)+(lcolA*lamntA);\n    vec3 tlightB = (lcolB*specamntB)+(lcolB*lamntB);\n    vec3 tlightC = (lcolC*specamntC)+(lcolC*lamntC);\n    \n    tlightA*=2.0;\n    tlightB*=2.0;\n    tlightC*=3.0;\n    \n    int Btotal;\n    int Atotal;\n    int Ctotal;\n    float Bmost=0.0;\n    float Amost=0.0;\n    float Cmost=0.0;\n        \n    bool Bcast = false;\n    float BcastDepth;\n    bool Acast = false;\n    float AcastDepth;\n    for(int i=0;i<numballs;i++){\n        if(i!=currentBall){\n            vec3 ballcast = Balls[i].xzy;\n            float beamA = linePointLength(ballcast, lightA, vec3(uv.x, height, uv.y));\n            float beamB = linePointLength(ballcast, lightB, vec3(uv.x, height, uv.y));\n            float beamC = linePointLength(ballcast, lightC, vec3(uv.x, height, uv.y)); \n\n            float cradius = radius*1.04;\n               \n            if (beamC>(cradius)){Ctotal+=1;} else if ((cradius-beamC) > Cmost) {Cmost = cradius-beamC;}\n\n            if (beamA>(radius)){ Atotal+=1;} else {\n                if ((radius-beamA) > Amost) {Amost = radius-beamA;}\n                if (height>0.0  && (uv.x>Balls[i].x) ){ Acast = true; AcastDepth=radius-beamA;}\n            }\n\n            if (beamB>(radius)){\n                Btotal+=1;\n            } else {\n                if ((radius-beamB) > Bmost) {Bmost = radius-beamB;}\n                if(height>0.0  && (uv.x<Balls[i].x) ){Bcast = true;BcastDepth=radius-beamB;}\n            }\n\n            }\n        }\n        float lcolAinc = lightA.y/(lightA.x-uv.x);\n        f = smoothstep(0.0, uv.x/40.0, lightAdist);\n        vec3 gacol = mix(gcol,gcol+(lcolA*-lcolAinc*1.2),  f);\n        tlightA = mix(vec3(0.0,0.0,0.0),tlightA,  f);\n        if(Atotal==10){\n            \n            gcol = gacol;\n        }  else {\n            Amost *=100.0;\n            f = smoothstep(0.2 + (dist-radius)*10.0, 0.0, Amost);\n            gcol = mix(gcol,gacol,  f);\n            if(Acast){\n                f = smoothstep(0.0, 0.01, AcastDepth);\n                tlightA = mix(tlightA,vec3(0.0,0.0,0.0),  f);\n            }\n        }\n        \n        float lcolBinc = lightB.y/(lightB.x-uv.x);\n        f = smoothstep(0.0, (ar-uv.x)/40.0, lightBdist);\n        vec3 gbcol = mix(gcol,gcol+(lcolB*lcolBinc*1.2),  f);\n        tlightB = mix(vec3(0.0,0.0,0.0),tlightB,  f);\n        if(Btotal==10){\n            \n            gcol = gbcol;\n        }  else {\n            Bmost *=100.0;\n            f = smoothstep(0.2 + (dist-radius)*10.0, 0.0, Bmost);\n            gcol = mix(gcol,gbcol,  f);\n            if(Bcast){\n                f = smoothstep(0.0, 0.01, BcastDepth);\n                tlightB = mix(tlightB,vec3(0.0,0.0,0.0),  f);\n            }\n        }\n        \n    vec3 VA = vec3(lightC.x-uv.x, lightC.y, lightC.z-uv.y);\n    vec3 VB = vec3(0.0, 1.0, 0.0);\n    VA = VA/length(VA);\n    float lcolCinc = dot(VB,VA );\n    if(Ctotal==10 ||  dist < (radius-pixel)){    \n        gcol = gcol+(lcolC*lcolCinc*1.2);\n    }  else if(dist > (radius-pixel)) {\n        Cmost *=80.0;\n        f = smoothstep(0.4 + (dist-radius)*5.0, 0.0, Cmost);\n        gcol = mix(gcol, gcol+(lcolC*lcolCinc*1.2), f);\n    }\n\n    // Multiplying and then adding light like this is not correct\n    bcol*=(1.0+tlightA+tlightB+tlightC+lcolAmbient)/4.0;\n    bcol+=(tlightA+tlightB+tlightC+lcolAmbient)/4.0;  \n    f = smoothstep(radius-pixel, radius, dist);\n    col = mix(bcol, gcol, f);\n    if( dist > radius ) { col = gcol; }\n\n    if(outputMode){col = outputColour;}\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4fsBRH",
    "date": "1724347841",
    "viewed": 149,
    "name": "Titaniumballz 2",
    "description": "Second attempt at this, from https://www.shadertoy.com/view/4fByD1\n\nSome improvements and a more realistic lighting model, with some gamma and contrast/tone adjustments via the mouse.\n\nFeedback welcome, there's still room for improvement.",
    "likes": 13,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "game",
     "lighting",
     "spheres",
     "shadows",
     "ball",
     "25d",
     "orthographic",
     "titaniumballz"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Copyright (c) 2024 John Cotterell johnmdcotterell@gmail.com\n// You may view and edit this code (with this message intact) only on Shadertoy.\n// Anything else requires my permission.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // GEOMETRY SETTINGS\n    // General\n    uv = fragCoord/iResolution.y;      // Normalised resolution\n    float height = 0.0;                     // This is the z value to go with our uv's x and y\n    ar = iResolution.x/iResolution.y; // Aspect ratio or normalised width\n    pixel = 1.4/iResolution.y;        // Size of pixel, for AA\n    // Zones. Not exclusive. We can be on more than one for purposes of AA mixing\n    bool ZoneRob = false;                  // Are we on the curved fg objects\n    bool ZoneGround = false;                // Are we on the ground\n    bool ZoneWall = false;                  // Are we on the walls\n    bool ZoneGoalWall = false;              // Are we on the goal walls\n    bool ZoneInsideWall = false;            // Are we inside wall of goal\n    // Background\n    border = 0.05;  // Edge border as fraction of screen\n    bar = 1.0; // vary border thickness, set to ar, or not, set to 1.0 \n    vec4 courtyard = vec4( border*bar, border, ar-(border*bar), 1.0-border); // Edge border limits\n    // Difference between current position and edge border limits\n    courtprox = vec4( courtyard.x - uv.x, courtyard.y - uv.y, uv.x - courtyard.z, uv.y - courtyard.w);\n    float goalwidth = 0.2;                   // width of goal\n    float goaltop = 0.5 + (goalwidth/2.0);   // position of goal top\n    float goalbottom = 0.5 - (goalwidth/2.0);// position of goal bottom\n    float goalprox = max((uv.y-goaltop), (goalbottom-uv.y)); // how far current position is from goal limits\n    float wallheightfactor = 1.0;  // multiplier to make up for the fake wall perspective\n    // Foreground\n    Rob Robs[numrobs];\n    float dist = ar; // distance to nearest foreground object\n    int rindex = -1; // index of object\n    vec2 centre = vec2(ar/2.0, 0.5); // centre of current object\n    float radius = 0.0; // radius of current object\n    float cradius = 0.34; // radius of circle\n    vec2 centreL = vec2((ar/2.0)-(cradius),0.5); // centre of left circle\n    vec2 centreR = vec2((ar/2.0)+(cradius),0.5); // centre of right circle\n    float segment = 1.256637; // ( 3.1415926 * 2.0 ) / 5.0;\n    float rightAng = 1.5708; // ( 3.1415926 * 2.0 ) / 4.0;\n    float dradius = 0.055; // default object radius\n    float bradius = 0.02; // ball radius\n    vec2 distv; // vector from current position to centre\n    vec3 normal = vec3(0.0,0.0,1.0); // normal of surface, default is normal of ground\n    vec3 bgnormal = vec3(0.0,0.0,1.0); // normal of walls or ground, default is normal of ground\n    bool flatTop = false;\n    float theight = 0.0;\n    float angle = 0.0;\n    float speed = iTime;\n    \n    for(int i=1;i<numrobs;i++){\n        Robs[i].radius = dradius;\n        angle = float(i) * segment;\n        vec2 rcentre = centreL;\n        if(i>5){\n            angle += speed;\n            Robs[i].rotation = angle + rightAng;\n            rcentre = centreR;} else {\n                \n                angle -= speed;\n                Robs[i].rotation = angle - rightAng;\n            }\n        Robs[i].position = vec3( rcentre.x + (cradius * cos(angle)), rcentre.y + (cradius * sin(angle)), 0.0);\n        \n    }\n    int hasball = 2;\n    float balldist = bradius*1.1 + dradius;\n    Robs[0].position = vec3( Robs[hasball].position.x + (balldist * cos(Robs[hasball].rotation)), Robs[hasball].position.y + (balldist * sin(Robs[hasball].rotation)), Robs[0].radius);\n    Robs[0].radius = bradius;\n    Robs[0].colourA = vec3(1.3,1.3,1.4);\n    Robs[1].colourA = pblue;\n    Robs[2].colourA = ppurple;\n    Robs[3].colourA = pink;\n    Robs[4].colourA = porange;\n    Robs[5].colourA = pyellow;\n    Robs[6].colourA = pblue;\n    Robs[7].colourA = pyellow;\n    Robs[8].colourA = porange;\n    Robs[9].colourA = pink;\n    Robs[10].colourA = ppurple;\n    \n    // COLOUR SETTINGS\n    vec3 bgcol; // final background colour\n    vec3 fgcol; // final foreground colour\n    vec3 col = white;   // final colour\n    vec2 robambient = vec2(1.0, 1.0); // the total Ambient effect of round objects. two vlaues for mixing foreground and bg\n    \n    light lights[numlights];\n    lights[0] = light(vec3(1.0,1.0,1.0),vec3(ar*0.5, 0.5 ,0.5),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.1);\n    lights[1] = light(vec3(1.0,0.4,0.4),vec3(ar*-0.04, 0.5 ,0.05),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.04);\n    lights[2] = light(vec3(0.4,1.0,0.4),vec3(ar*1.04, 0.5 ,0.05),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.04);\n    \n    // CASES\n    if(courtprox.w>0.0 && courtprox.w*bar>courtprox.z && courtprox.w*bar>courtprox.x){\n        // TOP WALL\n        bgcol = pgrey;\n        bgnormal = vec3(0.0,-1.0,0.0);\n        ZoneWall = true;\n        height = courtprox.w * wallheightfactor;\n    } else if(courtprox.y>0.0 && courtprox.y*bar>courtprox.z && courtprox.y*bar>courtprox.x){\n        // BOTTOM WALL\n        bgcol = pgrey;\n        bgnormal = vec3(0.0,1.0,0.0);\n        ZoneWall = true;\n        height = courtprox.y *  wallheightfactor;\n    } else if(goalprox>0.0 && courtprox.x>0.0 || courtprox.x>(border*bar)/2.0){\n        // LEFT WALL\n        bgcol = pgrey;\n        bgnormal = vec3(1.0,0.0,0.0);\n        ZoneWall = true; ZoneGoalWall = true;\n        float cph = courtprox.x/2.2;\n        if(goalprox<cph && courtprox.x<(border*bar)/2.0 ){\n            ZoneInsideWall = true;\n            height = goalprox * wallheightfactor;\n            if(uv.y<0.5){bgnormal = vec3(0.0,1.0,0.0);}else{bgnormal = vec3(0.0,-1.0,0.0);} \n        } else {\n            height = courtprox.x * wallheightfactor;      \n        }\n    } else if(goalprox>0.0 && courtprox.z>0.0 || courtprox.z>(border*bar)/2.0){\n        // RIGHT WALL\n        bgcol = pgrey;\n        bgnormal = vec3(-1.0,0.0,0.0);\n        ZoneWall = true; ZoneGoalWall = true;\n        if(goalprox<courtprox.z/2.2 && courtprox.z<(border*bar)/2.0 ){\n            ZoneInsideWall = true;\n            height = goalprox * wallheightfactor;\n            if(uv.y<0.5){bgnormal = vec3(0.0,1.0,0.0);}else{bgnormal = vec3(0.0,-1.0,0.0);}\n        } else {\n            height = courtprox.z * wallheightfactor;\n          \n        }\n    } else {\n        ZoneGround = true;\n        bgcol = getGroundColour();\n        bgnormal = vec3(0.0,0.0,1.0);\n        //float testbox = sdBox(uv - vec2(0.1,0.5), vec2(0.1,0.1));height=min(testbox, 0.0);\n    }\n    \n    float lightATG = (goaltop-lights[1].position.y)/(lights[1].position.x-courtyard.x);\n    float lightATGdist = ( (lights[1].position.x - uv.x) * lightATG) -  (uv.y-lights[1].position.y);\n    float lightABG = (goalbottom-lights[1].position.y)/(lights[1].position.x-courtyard.x);\n    float lightABGdist =    (uv.y-lights[1].position.y)-( (lights[1].position.x - uv.x) * lightABG);\n    float lightAdist = lightABGdist*lightATGdist;\n    \n    lights[1].shadow.x = 1.0;\n    if(goalprox<0.0||ZoneInsideWall){lights[1].shadow.x = 0.0;} else if(lightAdist>0.0){\n        lights[1].shadow.x = 0.0;\n        f = smoothstep(0.0, 0.2*-courtprox.x, lightAdist);\n        lights[1].shadow.x = mix(1.0, 0.0, f);\n    }\n    \n    lightATG = (goaltop-lights[2].position.y)/(lights[2].position.x-courtyard.z);\n    lightATGdist = ( (lights[2].position.x - uv.x) * lightATG) -  (uv.y-lights[2].position.y);\n    lightABG = (goalbottom-lights[2].position.y)/(lights[2].position.x-courtyard.z);\n    lightABGdist =    (uv.y-lights[2].position.y)-( (lights[2].position.x - uv.x) * lightABG);\n    lightAdist = lightABGdist*lightATGdist;\n    \n    lights[2].shadow.x = 1.0;\n    if(goalprox<0.0||ZoneInsideWall){lights[2].shadow.x = 0.0;} else if(lightAdist>0.0){\n        lights[2].shadow.x= 0.0;\n        f = smoothstep(0.0, 0.2*-courtprox.z, lightAdist);\n        lights[2].shadow.x = mix(1.0, 0.0, f);\n    }\n    lights[1].shadow.y = lights[1].shadow.x;\n    lights[2].shadow.y = lights[2].shadow.x;\n    \n    \n    for(int i=0;i<numrobs;i++){\n        float bdist = distance(uv, Robs[i].position.xy);\n        if(bdist<dist){dist=bdist;}\n        \n        if(bdist<Robs[i].radius&&!ZoneWall){\n            dist=bdist;\n            radius = Robs[i].radius;\n            height = sqrt((radius*radius)-(dist*dist));\n            ZoneRob = true;\n            rindex = i;\n            if(i>5){flatTop=true;}\n            if(bdist<Robs[i].radius-pixel){ZoneGround = false;}\n        } else {\n            float edgedist = distance(uv, Robs[i].position.xy) + (Robs[i].position.z);\n            robambient *= 1.0 - (0.5 * pow(0.8/(edgedist/Robs[i].radius),3.0)); // ambient multiplier for outside of object\n        }\n        \n    }\n    \n    if(ZoneRob){\n        fgcol = Robs[rindex].colourA;\n        centre = vec2(Robs[rindex].position.x, Robs[rindex].position.y);\n        distv = uv - centre;\n        normal = vec3(distv.x, distv.y, height)/radius;\n        height+=Robs[rindex].position.z;\n        \n        if(flatTop){\n            float tradius = radius/2.5;\n            theight = sqrt((radius*radius)-(tradius*tradius));\n            if(height>theight){\n                height=theight;\n                normal = vec3(0.0, 1.0, 0.0);\n            }\n            f = smoothstep(theight-0.01, theight, height);\n            normal = mix(normal,vec3(0.0, 0.0, 1.0),  f);\n            height = mix(height,theight,  f);\n        }\n        \n        robambient *= (0.6 + normal.z/3.0);// ambient multiplier for inside of object\n        float rotation = Robs[rindex].rotation;\n        if(rindex>0){\n            // Spoiler flap - theres probably a simpler way of doing this\n            float SpFoffset = radius*2.0;// set distance from centre to front\n            float SpBoffset = radius/1.0;// set distance from centre to back\n            float SpFheight = radius*-1.0;// set front and back heights\n            float SpBheight = radius*1.4;\n            float SpWidth = radius/1.4;// set width, length, height of triangle\n            float SpLength = SpFoffset+SpBoffset;\n            float SpHeight = SpBheight-SpFheight;\n            vec3 SpFc = vec3(centre.x + SpFoffset * cos(rotation),  centre.y + SpFoffset * sin(rotation), 0.0);// get front point F\n            vec3 SpFl = SpFc; SpFl.x += (SpWidth * sin(rotation)); SpFl.y -= (SpWidth * cos(rotation));// get front points L and R\n            vec3 SpFr = SpFc; SpFr.x -= (SpWidth * sin(rotation)); SpFr.y += (SpWidth * cos(rotation));\n            vec3 SpBc = vec3(centre.x - SpBoffset * cos(rotation), centre.y - SpBoffset * sin(rotation), 0.0);// get back point B\n            vec3 SpBl = SpBc; SpBl.x += (SpWidth * sin(rotation)); SpBl.y -= (SpWidth * cos(rotation));// get back points L and R\n            vec3 SpBr = SpBc; SpBr.x -= (SpWidth * sin(rotation)); SpBr.y += (SpWidth * cos(rotation));\n            float SpBD = linePointLength( vec3(uv.x, uv.y, 0.0), vec3(SpBl.x, SpBl.y, 0.0), vec3(SpBr.x, SpBr.y, 0.0) );// get distance from back\n            float SpFD = linePointLength( vec3(uv.x, uv.y, 0.0), vec3(SpFl.x, SpFl.y, 0.0), vec3(SpFr.x, SpFr.y, 0.0) );// get distance from front\n            float SpH = SpFheight + (SpHeight*(SpFD/SpLength));// get height of current point\n            float inTri = sdTriangle(uv, SpFc.xy, SpBr.xy, SpBl.xy);// is point in triangle\n            //if(inTri<0.0){outputValue(purple);} // uncomment to test where spoiler triangle is\n    \n            float lineDist = linePointLength( vec3(uv.x, uv.y, 0.0) , vec3(SpBc.x, SpBc.y, 0.0)  , vec3(SpFc.x, SpFc.y, 0.0)  );\n\n            if(SpH>height){// is spoiler higher than dome\n                float face = 0.7; \n                if(inTri<0.0&&dist<radius*0.9){\n                    if(dist<radius*0.7){\n                        f = smoothstep(0.0, pixel*5.0, SpH-height);\n                        height=mix(height, SpH,  f);\n                        normal=mix(normal,vec3( face * cos(rotation) , face * sin(rotation), 0.7), f);\n                    } else {\n                        f = smoothstep(radius*0.75, radius*0.95, dist);\n                        height=mix( SpH, height, f);\n                        normal=mix(vec3( face * cos(rotation) , face * sin(rotation), 0.7),normal, f);\n                    }\n                } \n            }\n            \n        }\n        normal = normal/length(normal);\n        for(int i=0;i<numrobs;i++){\n        if(i!=rindex){\n            for(int j=0;j<numlights;j++){\n             if(distance(Robs[i].position, lights[j].position) < distance(Robs[rindex].position, lights[j].position)){\n                vec3 tempBall = Robs[i].position;\n                tempBall.z*=1.2;\n                float beam = linePointLength(tempBall, lights[j].position, vec3(uv.x, uv.y, height)); \n                float cradius = Robs[i].radius*1.2; // cheating and making the ball bigger so shadow seen more easily\n                float blur = distance(Robs[i].position, vec3(uv.x, uv.y, height))/5.0;\n                float shadow = 0.0;\n                if (beam<=(cradius-blur)){shadow = 1.0;} else {\n                    f = smoothstep(cradius-blur, cradius, beam);\n                    shadow = mix(1.0,0.0, f);\n                }\n                lights[j].shadow.y = max(shadow, lights[j].shadow.y);\n                }\n                }\n            }\n        }\n    }\n    \n    if(ZoneGround||ZoneWall){\n        float shadowheight = 0.0;\n        if(ZoneWall){shadowheight = height;};\n        for(int i=0;i<numrobs;i++){\n            for(int j=0;j<numlights;j++){\n                float beam = linePointLength(Robs[i].position, lights[j].position, vec3(uv.x, uv.y, shadowheight)); \n                float cradius = Robs[i].radius;\n                float blur = distance(Robs[i].position, vec3(uv.x, uv.y, shadowheight))/5.0;\n                float shadow = 0.0;\n                if (beam<=(cradius-blur)){shadow = 1.0;} else {\n                    f = smoothstep(cradius-blur, cradius, beam);\n                    shadow = mix(1.0,0.0, f);\n                }\n                lights[j].shadow.x = max(shadow, lights[j].shadow.x);\n            }\n        }\n    }\n    \n    // calculate and multiply ambient\n\n    // these ambient calculations are an approximation based on proximity to walls, ground and objects\n    // it gives us a very rough but dynamic AO value\n    float ambientmulti = (min(0.5+(height*3.0), 1.0));// if you're on the ground, half of ambient light is removed\n    float ambiA = 1.0;float ambiB = 1.0; float ambiC = 0.5;\n    ambientmulti *= sqrt((min(ambiC-(courtprox.w*ambiA), ambiB))*(min(ambiC-courtprox.z*ambiA, ambiB))*(min(ambiC-courtprox.y*ambiA, ambiB))*(min(ambiC-courtprox.x*ambiA, ambiB)));\n    // and again for each wall\n    ambientmulti = robambient.x*ambientmulti;\n    \n    vec3 position = vec3(uv, height);\n    vec3 bgtot = vec3(0.0);\n    vec3 fgtot = vec3(0.0);\n    vec3 sptot = vec3(0.0);\n    for(int j=0;j<numlights;j++){\n        lights[j].difference = lights[j].position - position;\n        lights[j].dist = length(lights[j].difference);\n        lights[j].difference = lights[j].difference/lights[j].dist;\n        lights[j].amount.x = max(0.0, dot(lights[j].difference, normal));\n        lights[j].amount.x = lights[j].amount.x/(lights[j].dist*lights[j].dist);\n        lights[j].amount.y = max(0.0, dot(lights[j].difference, bgnormal));\n        lights[j].amount.y = lights[j].amount.y/(lights[j].dist*lights[j].dist);\n        lights[j].amount.y *= lights[j].intensity * (1.0-lights[j].shadow.x);\n        lights[j].amount.x *= lights[j].intensity * (1.0-lights[j].shadow.y);\n        bgtot += lights[j].colour*lights[j].amount.y;\n        fgtot += lights[j].colour*lights[j].amount.x;\n    }\n\n    bgcol*=ambientmulti+bgtot;\n    \n    if(ZoneRob){\n        // calculate and add specular\n        vec3 incident = vec3(0.0, 0.0, -1.0);\n        vec3 reflection = reflect(incident, normal);\n        for(int j=0;j<numlights;j++){\n            lights[j].amount.z = pow(max(0.0, dot(lights[j].difference, reflection)),32.0);\n            lights[j].amount.z = lights[j].amount.z/(lights[j].dist*lights[j].dist);\n            lights[j].amount.z *= lights[j].intensity * (1.0-lights[j].shadow.y);\n            sptot += lights[j].colour*lights[j].amount.z;\n        }\n    \n        fgcol *= ambientmulti+fgtot;\n        fgcol += sptot; // Add specuialr highlight\n    \n        // Assign forground or background colour or mix them if on AA border\n   \n        if(ZoneGround){\n            f = smoothstep(radius-pixel, radius, dist);\n            col = mix(fgcol,bgcol, f);\n        } else {\n            col = fgcol;\n        }\n    } else {\n        col = bgcol;\n    }\n \n\n\n    f =  iMouse.x/iResolution.x;\n    col = f<0.333?mix(contrast(col, 2.), col, f*3.):f<0.666?mix(col, tanh(col), (f-0.333)*3.):mix(tanh(col), tanh(tanh(col)), (f-0.666)*3.);\n        if(iMouse.y!=0.0){\n        f =  iMouse.y/iResolution.y;\n        col = gammaCorrection(col, 0.8 + f);\n    }\n    if(outputMode){col = outputColour;}\n    fragColor = vec4(col,1.0);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define numrobs 11\n#define numlights 3\n#define black vec3(0.0,0.0,0.0)\n#define white vec3(1.0,1.0,1.0)\n#define grey vec3(0.5,0.5,0.5)\n#define blue vec3(0.0,0.0,1.0)\n#define red vec3(1.0,0.0,0.0)\n#define lime vec3(0.0,1.0,0.0)\n#define green vec3(0.0,0.7,0.0)\n#define cyan vec3(0.0,1.0,1.0)\n#define purple vec3(1.0,0.0,1.0)\n#define yellow vec3(1.0,1.0,0.0)\n#define orange vec3(1.0,0.6,0.0)\n\n#define porange vec3(1.0,0.8,0.6)\n#define pyellow vec3(0.87,0.87,0.7)\n#define pblue vec3(0.8,0.85,1.0)\n#define pgreen vec3(0.7,0.9,0.7)\n#define pink vec3(0.95,0.75,0.75)\n#define ppurple vec3(1.0,0.7,1.0)\n#define pgrey vec3(0.85,0.85,0.85)\n\n// declared here for use in functions\nfloat pixel = 0.0;\nvec4 courtprox = vec4(0.0);\nvec2 uv = vec2(0.0);\nfloat ar = 0.0;\nfloat f = 0.0; // AA mixing number\nfloat border = 0.05;\nfloat bar = 1.0;\n\nstruct light\n{\n    vec3 colour;\n    vec3 position;\n    vec3 difference;\n    vec3 amount;\n    vec2 shadow;\n    float dist;\n    float intensity;\n};\n\nstruct Rob // Round Object. (Players and Ball)\n{\n    vec3 position;\n    vec3 colourA;\n    vec3 colourB;\n    float rotation;\n    float radius;\n};\n\nvec3 getGroundColour(){\n    float linewidth = 0.01;\n    float hlinewidth = linewidth/2.0;\n    float rhlinewidth = hlinewidth + pixel/2.0;\n    vec3 rcol = pgrey;\n    if(courtprox.x>-linewidth&&courtprox.x<=0.0||abs(courtprox.y)<linewidth||courtprox.z>-linewidth&&courtprox.z<=0.0||abs(courtprox.w)<linewidth){\n        rcol = white;\n    }\n    float crad = 0.2;\n    float dfc = distance(uv, vec2(ar/2.0, 0.5));\n    float crdiff = dfc-crad;\n    if(crdiff<rhlinewidth ){\n        f = smoothstep(rhlinewidth-pixel,rhlinewidth , abs(crdiff));\n        rcol = mix(white, pgrey, f);\n    }\n\n    if(crdiff>=hlinewidth-pixel&&abs(uv.x - (ar/2.0))<=hlinewidth){\n        rcol = white;\n    }\n    dfc = distance(uv, vec2(border*bar, 0.5));\n    crdiff = dfc-crad;\n    if(crdiff<rhlinewidth ){\n        f = smoothstep(rhlinewidth-pixel,rhlinewidth , abs(crdiff));\n        rcol = mix(white, rcol, f);\n    }\n    dfc = distance(uv, vec2(ar-(border*bar), 0.5));\n    crdiff = dfc-crad;\n    if(crdiff<rhlinewidth ){\n        f = smoothstep(rhlinewidth-pixel,rhlinewidth , abs(crdiff));\n        rcol = mix(white, rcol, f);\n    }\n    return rcol;\n}\n\nbool outputMode = false; vec3 outputColour; // Easy way to throw a value at the output for debugging\nvoid outputValue (in float value){\n    outputMode = true;\n    if ( value >= 0.0 && value <= 1.0 )\n        { outputColour = vec3(value, value, value); }\n        else if ( value < 0.0 && value > -1.0 )\n        { outputColour = vec3(0.0, 0.0, -value ); }\n        else if ( value > 1.0 )\n        { outputColour = vec3(1.0-(1.0/value), 1.0, 0.0); }\n        else if ( value < -1.0 )\n        { outputColour = vec3(1.0-(1.0/-value), 0.0, 1.0); }\n} // Call outputValue with a float and that value will override the pixel output\nvoid outputValue (in vec3 value){outputMode = true;outputColour = value;} // or directly with a vec3\n\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 gammaCorrection (vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\n\nfloat linePointLength( in vec3 P, in vec3 A, in vec3 B ){\n    vec3 AB = B-A;\n    float lenAB = length(AB);\n    vec3 D = AB/lenAB;\n    vec3 AP = P-A;\n    float d = dot(D, AP);\n    vec3 X = A + D * dot(P-A, D);\n    if(X.z<0.0){return 10.0;} else {return length(X-P);}\n}\n\nvec3 linePoint( in vec3 P, in vec3 A, in vec3 B ){\n    vec3 AB = B-A;\n    float lenAB = length(AB);\n    vec3 D = AB/lenAB;\n    vec3 AP = P-A;\n    float d = dot(D, AP);\n    vec3 X = A + D * dot(P-A, D);\n    return X;\n}\n\n// SD Functions from https://iquilezles.org/articles/distfunctions2d/\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ){\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n/* OLD SHADER\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 Tcolf;\n    vec3 Tcolb;\n    \n    float speed = iTime;\n    float dist = 20.0;\n    float angle;\n    vec3 bcol,col;\n    int currentBall = 10;\n    for(int i=0;i<numballs;i++){\n        angle = float(i) * segment;\n        vec2 rcentre = centreL;\n        if(i>4){\n            angle += speed;\n            rcentre = centreR;} else {\n                angle -= speed;\n            }\n        Balls[i]= vec4( rcentre.x + (cradius * cos(angle)), rcentre.y + (cradius * sin(angle)), 0.0, angle );\n\n        float bdist = distance(uv, Balls[i].xy);\n        if(bdist<radius){\n            dist=bdist;\n            if(bdist<(radius-pixel)){currentBall = i;}\n            centre = vec2(Balls[i].x, Balls[i].y);\n            vec3 TAbcol = vec3(0.9,1.0,0.9);\n            vec3 TAfcol = vec3(0.1,0.7,0.1);\n            vec3 TBbcol = vec3(0.1,0.0,0.0);\n            vec3 TBfcol = vec3(1.0,0.0,0.0);\n            \n            if(i<5){Tcolf=TAfcol;Tcolb=TAbcol;}else{Tcolf=TBfcol;Tcolb=TBbcol;}\n            float f;\n            float ringRadius=0.8;\n            float ringWidth = 0.1;\n            if(i>4){flatTop=true;ringRadius=0.45;}else{flatTop=false;ringRadius=0.8;}\n            if(bdist>radius*(ringRadius+ringWidth)){\n                f = smoothstep(radius*(ringRadius+ringWidth), (radius*(ringRadius+ringWidth))+pixel, bdist);\n                bcol = mix(Tcolf,Tcolb,  f);\n            } else if (bdist<radius*ringRadius){\n                \n                f = smoothstep(radius*ringRadius, (radius*ringRadius)-pixel, bdist);\n                bcol = mix(Tcolf,Tcolb,  f);\n            } else {\n                bcol = Tcolf;\n            }\n\n            \n        } else if(bdist<dist){ dist=bdist;}\n           \n        \n\n    }\n\n    float rotation;\n\n    if(currentBall>4){\n        rotation = Balls[currentBall].w + rightAng;\n    } else {rotation = Balls[currentBall].w - rightAng;}\n\n     //vec2 ball = vec2(Balls[0].x + (radius*1.3 * cos(Balls[0].w- rightAng)), Balls[0].y + (radius*1.3 * sin(Balls[0].w- rightAng)));\n     //if( distance(uv, ball)<radius*0.2){ centre = vec2(ball.x, ball.y); bcol = purple; currentBall=-1;}\n    // Spoiler flap\n    float SpFoffset = radius*3.0;// set distance from centre to front\n    float SpBoffset = radius/1.8;// set distance from centre to back\n    float SpFheight = radius*-1.5;// set front and back heights\n    float SpBheight = radius*1.2;\n    float SpWidth = radius/1.6;// set width, length, height of triangle\n    float SpLength = SpFoffset+SpBoffset;\n    float SpHeight = SpBheight-SpFheight;\n    vec3 SpFc = vec3(centre.x + SpFoffset * cos(rotation), 0.0, centre.y + SpFoffset * sin(rotation));// get front point F\n    vec3 SpFl = SpFc; SpFl.x += (SpWidth * sin(rotation)); SpFl.z -= (SpWidth * cos(rotation));// get front points L and R\n    vec3 SpFr = SpFc; SpFr.x -= (SpWidth * sin(rotation)); SpFr.z += (SpWidth * cos(rotation));\n    vec3 SpBc = vec3(centre.x - SpBoffset * cos(rotation), 0.0, centre.y - SpBoffset * sin(rotation));// get back point B\n    vec3 SpBl = SpBc; SpBl.x += (SpWidth * sin(rotation)); SpBl.z -= (SpWidth * cos(rotation));// get back points L and R\n    vec3 SpBr = SpBc; SpBr.x -= (SpWidth * sin(rotation)); SpBr.z += (SpWidth * cos(rotation));\n    float SpBD = linePointLength( vec3(uv.x, 0.0, uv.y), vec3(SpBl.x, 0.0, SpBl.z), vec3(SpBr.x, 0.0, SpBr.z) );// get distance from back\n    float SpFD = linePointLength( vec3(uv.x, 0.0, uv.y), vec3(SpFl.x, 0.0, SpFl.z), vec3(SpFr.x, 0.0, SpFr.z) );// get distance from front\n    float SpH = SpFheight + (SpHeight*(SpFD/SpLength));// get height of current point\n    float inTri = sdTriangle(uv, SpFc.xz, SpBr.xz, SpBl.xz);// is point in triangle\n    //if(inTri<0.0){outputValue(purple);} // uncomment to test where spoiler triangle is\n    \n    float lineDist = linePointLength( vec3(uv.x, 0.0, uv.y) , vec3(SpBc.x, 0.0, SpBc.z)  , vec3(SpFc.x, 0.0, SpFc.z)  );\n    if(currentBall<5){\n        float gfline = 2.7;\n        float gflinew = 0.011;\n        if(lineDist>radius/gfline&&lineDist<(radius/gfline)+gflinew&&dist<radius*0.9)\n            {\n            if(lineDist<(radius/gfline)+(gflinew/5.0)){\n                float p = smoothstep(radius/gfline, radius/gfline + (gflinew/5.0), lineDist);\n                bcol = mix(Tcolb,Tcolf,  p);} else {\n                    float p = smoothstep((radius/gfline)+gflinew, (radius/gfline)+gflinew - (gflinew/5.0), lineDist);\n                    bcol = mix(bcol,Tcolf,  p);\n                }\n            } else if (lineDist<(radius/gfline)+gflinew ){bcol = Tcolb;}\n    }\n    \n    float power = 32.0;\n    float power2 = 32.0;\n\n    float height = sqrt((radius*radius)-(dist*dist));\n    vec2 distv = uv - centre;\n    vec3 normal = vec3(distv.x, height, distv.y)/radius;\n        \n    if(flatTop){\n        if(height>theight){\n            height=theight;\n            normal = vec3(0.0, 1.0, 0.0);\n            power = power2;\n        }\n        float p = smoothstep(theight-0.01, theight, height);\n        normal = mix(normal,vec3(0.0, 1.0, 0.0),  p);\n        height = mix(height,theight,  p);\n    }\n    if(SpH>height&&currentBall<10){// is spoiler higher than dome\n        float face = 0.7;  \n        if(inTri<0.0){\n        power = power2;\n        float s = smoothstep(0.0, -0.002, inTri);\n        bcol=mix(Tcolb, Tcolf, s);\n        if(inTri<-0.005){\n            s = smoothstep(-0.01, -0.008, inTri);\n            bcol=mix(Tcolb, Tcolf, s);\n        }\n            s = smoothstep(0.0, pixel*6.0, SpH-height);\n            height=mix(height, SpH, s);\n            normal=mix(normal,vec3( face * cos(rotation), 0.9 , face * sin(rotation)), s);\n        } \n        if (inTri<radius/10.0&&inTri>0.0) {\n            power = power2;\n            bcol=Tcolb;\n            float s = smoothstep(0.0, radius/6.0, inTri);\n            height=mix(SpH,height,  s);\n            normal=mix(vec3( face * cos(rotation), 0.9 , face * sin(rotation)),normal, s);\n        }\n    }\n    \n    normal = normal/length(normal);\n\n    vec3 position = vec3(uv.x, height, uv.y);\n        \n    vec3 incident = vec3(0.0, -1.0, 0.0);\n    vec3 reflection = reflect(incident, normal);\n\n    vec3 lcolA = vec3(0.0,0.4,0.0);\n    vec3 lcolB = vec3(0.5,0.0,0.0);\n    vec3 lcolC = vec3(0.4,0.4,0.5);\n\n    vec3 lcolAmbient = (lcolA+lcolB+lcolC+lcolC+lcolC)/(7.0);\n        \n    gcol *= lcolAmbient;\n\n    vec3 lightA = vec3(0.0-0.3, 0.1, 0.5);\n    vec3 lightB = vec3(ar+0.3, 0.1, 0.5);\n    vec3 lightC = vec3(0.5*ar,0.2, 0.5);\n        \n    float f;\n    \n    vec3 goalRT = vec3(ar-0.1, 0.2, 0.65);\n    vec3 goalRB = vec3(ar-0.1, 0.2, 0.35);\n\n    float lightBTG = (goalRT.z-lightB.z)/(lightB.x-goalRT.x);\n    float lightBTGdist = ( (lightB.x - uv.x) * lightBTG) -  (uv.y-lightB.z);\n    float lightBBG = (goalRB.z-lightB.z)/(lightB.x-goalRB.x);\n    float lightBBGdist =    (uv.y-lightB.z)-( (lightB.x - uv.x) * lightBBG);\n    float lightBdist = lightBBGdist*lightBTGdist;\n    \n    vec3 goalLT = vec3(0.1, 0.2, 0.65);\n    vec3 goalLB = vec3(0.1, 0.2, 0.35);\n\n    float lightATG = (goalLT.z-lightA.z)/(lightA.x-goalLT.x);\n    float lightATGdist = ( (lightA.x - uv.x) * lightATG) -  (uv.y-lightA.z);\n    float lightABG = (goalLB.z-lightA.z)/(lightA.x-goalLB.x);\n    float lightABGdist =    (uv.y-lightA.z)-( (lightA.x - uv.x) * lightABG);\n    float lightAdist = lightABGdist*lightATGdist;\n\n    vec3 tolightA = lightA - position;\n    vec3 tolightB = lightB - position;\n    vec3 tolightC = lightC - position;\n\n    float distlA = length(tolightA);\n    float distlB = length(tolightB);\n    float distlC = length(tolightC);\n\n    tolightA = tolightA/distlA;\n    tolightB = tolightB/distlB;\n    tolightC = tolightC/distlC;\n    \n    float lamntA = max(0.0, dot(tolightA, normal));\n    float lamntB = max(0.0, dot(tolightB, normal));\n    float lamntC = max(0.0, dot(tolightC, normal));\n\n    float specamntA = pow(max(0.0, dot(tolightA, reflection)), power);\n    float specamntB = pow(max(0.0, dot(tolightB, reflection)), power);\n    float specamntC = pow(max(0.0, dot(tolightC, reflection)), power);\n    if( dist > radius ){ height = 0.0;}\n    \n    vec3 tlightA = (lcolA*specamntA)+(lcolA*lamntA);\n    vec3 tlightB = (lcolB*specamntB)+(lcolB*lamntB);\n    vec3 tlightC = (lcolC*specamntC)+(lcolC*lamntC);\n    \n    tlightA*=2.0;\n    tlightB*=2.0;\n    tlightC*=3.0;\n    \n    int Btotal;\n    int Atotal;\n    int Ctotal;\n    float Bmost=0.0;\n    float Amost=0.0;\n    float Cmost=0.0;\n        \n    bool Bcast = false;\n    float BcastDepth;\n    bool Acast = false;\n    float AcastDepth;\n    for(int i=0;i<numballs;i++){\n        if(i!=currentBall){\n            vec3 ballcast = Balls[i].xzy;\n            float beamA = linePointLength(ballcast, lightA, vec3(uv.x, height, uv.y));\n            float beamB = linePointLength(ballcast, lightB, vec3(uv.x, height, uv.y));\n            float beamC = linePointLength(ballcast, lightC, vec3(uv.x, height, uv.y)); \n               \n            if (beamC>(radius)){Ctotal+=1;} else if ((radius-beamC) > Cmost) {Cmost = radius-beamC;}\n\n            if (beamA>(radius)){ Atotal+=1;} else {\n                if ((radius-beamA) > Amost) {Amost = radius-beamA;}\n                if (height>0.0  && (uv.x>Balls[i].x) ){ Acast = true; AcastDepth=radius-beamA;}\n            }\n\n            if (beamB>(radius)){\n                Btotal+=1;\n            } else {\n                if ((radius-beamB) > Bmost) {Bmost = radius-beamB;}\n                if(height>0.0  && (uv.x<Balls[i].x) ){Bcast = true;BcastDepth=radius-beamB;}\n            }\n\n            }\n        }\n        float lcolAinc = lightA.y/(lightA.x-uv.x);\n        f = smoothstep(0.0, uv.x/40.0, lightAdist);\n        vec3 gacol = mix(gcol,gcol+(lcolA*-lcolAinc*1.2),  f);\n        tlightA = mix(vec3(0.0,0.0,0.0),tlightA,  f);\n        if(Atotal==10){\n            \n            gcol = gacol;\n        }  else {\n            Amost *=100.0;\n            f = smoothstep(0.2 + (dist-radius)*10.0, 0.0, Amost);\n            gcol = mix(gcol,gacol,  f);\n            if(Acast){\n                f = smoothstep(0.0, 0.01, AcastDepth);\n                tlightA = mix(tlightA,vec3(0.0,0.0,0.0),  f);\n            }\n        }\n        \n        float lcolBinc = lightB.y/(lightB.x-uv.x);\n        f = smoothstep(0.0, (ar-uv.x)/40.0, lightBdist);\n        vec3 gbcol = mix(gcol,gcol+(lcolB*lcolBinc*1.2),  f);\n        tlightB = mix(vec3(0.0,0.0,0.0),tlightB,  f);\n        if(Btotal==10){\n            \n            gcol = gbcol;\n        }  else {\n            Bmost *=100.0;\n            f = smoothstep(0.2 + (dist-radius)*10.0, 0.0, Bmost);\n            gcol = mix(gcol,gbcol,  f);\n            if(Bcast){\n                f = smoothstep(0.0, 0.01, BcastDepth);\n                tlightB = mix(tlightB,vec3(0.0,0.0,0.0),  f);\n            }\n        }\n        \n    vec3 VA = vec3(lightC.x-uv.x, lightC.y, lightC.z-uv.y);\n    vec3 VB = vec3(0.0, 1.0, 0.0);\n    VA = VA/length(VA);\n    float lcolCinc = dot(VB,VA );\n    if(Ctotal==10 ||  dist < (radius-pixel)){    \n        gcol = gcol+(lcolC*lcolCinc*1.2);\n    }  else if(dist > (radius-pixel)) {\n        Cmost *=80.0;\n        f = smoothstep(0.4 + (dist-radius)*5.0, 0.0, Cmost);\n        gcol = mix(gcol, gcol+(lcolC*lcolCinc*1.2), f);\n    }\n\n}\n\n// OLDER SHADER\n\nvec3 colourGround = vec3(0.820,0.820,0.820);\nvec3 colourPaint  = vec3(0.420,0.420,0.420);\nvec3 colourTeamA  = vec3(0.839,0.000,0.000);\nvec3 colourTeamB  = vec3(0.212,0.800,0.000);\nvec3 colourLight = vec3(1.000,1.000,1.000);\nvec3 colourAmbient = vec3(0.188,0.188,0.188);\nvec2 centre;\nfloat radius;\nfloat pixel;\n\nvec2 tanLineDist( in vec2 C, in float r, in vec2 P, in vec2 F){\n    C.y = -C.y;\n    vec2 d = P-C;\n    vec2 dr = vec2(-d.y, d.x);\n    float dl = length(d);\n    //if(dl>=r){\n        float rho = r/dl;\n        float ad = rho*rho;\n        float bd = rho*sqrt(1.0-ad);//*(1.0-rho)); // (1-rho)*(1-rho) ?\n        vec2 T1 = vec2(C.x + ad*d.x + bd*dr.x, C.y + ad*d.y + bd*dr.y);\n        vec2 T2 = vec2(C.x + ad*d.x - bd*dr.x, C.y + ad*d.y - bd*dr.y);\n\n    //}\n    float ax = T1.x-P.x;\n    float by = P.y-T1.y;\n    float c = (T1.y*P.x)-(T1.x*P.y);\n\n    float ax2 = T2.x-P.x;\n    float by2 = P.y-T2.y;\n    float c2 = (T2.y*P.x)-(T2.x*P.y);\n\n    return  vec2((F.x*-ax)- (F.y*-by)-c, (F.x*-ax2)- (F.y*-by2)-c2);\n}\n\nvec3 getGroundTexture( in vec2 p, in float ar , in float pmult)\n{\n    float gpixel = pixel*pmult*1.2;\n    float lineWidth = 1.0/180.0;\n    float f ;\n    vec2 pn = vec2((p.x-(0.5*ar)), p.y-0.5);\n    vec3 gcol = colourGround;\n    \n    float lpn = length(pn);\n    float bdist = sdBox(pn, vec2(ar/2.0, 0.5));\n    if(bdist<=0.0-lineWidth){\n        if(bdist >= -lineWidth*2.0){\n            gcol = colourPaint;\n        }\n        \n        if(lpn>(0.2-gpixel)-lineWidth){\n            if(lpn<0.2){\n                f = smoothstep((0.2-gpixel), .2 , lpn);\n                gcol = mix(colourPaint,colourGround,  f);\n                f = smoothstep(0.2-lineWidth, (0.2-gpixel)-lineWidth , lpn);\n                gcol = mix(gcol,colourGround,  f);\n            }\n        if(abs(pn.x)<=lineWidth/2.0 && lpn>=0.19){\n                gcol = colourPaint;\n            }\n        }\n        \n    }\n    \n    gcol = gcol*colourAmbient;\n    float TAdist = sdBox(vec2(pn.x+(0.5*ar), pn.y), vec2(0.0, 0.15));\n    gcol = gcol*(1.0+(colourTeamA/sqrt(TAdist*50.0)));\n\n    float modRadius = radius;//*(1.0/pow((pn.x+(0.5*ar)), 2.0));\n\n    vec2 isInLight = tanLineDist(centre, modRadius, vec2(ar, -0.65), -p.yx);\n    vec2 isInLight2 = tanLineDist(centre, modRadius, vec2(ar, -0.35), -p.yx);\n    \n    float TBdist = sdBox(vec2(pn.x-(0.5*ar), pn.y), vec2(0.0, 0.15));\n    float inLight= 0.0;\n    \n    if(isInLight.y>=0.0 || isInLight2.y<=0.0){\n        inLight=1.0;} else {\n            inLight= 1.0/(abs(isInLight2.y)/abs(isInLight.y) +1.0);\n        }\n\n    float inLight2= 0.0;\n    \n    if(isInLight.x>=0.0 || isInLight2.x<=0.0){\n        inLight2=1.0;} else {\n            inLight2= 1.0/(abs(isInLight.x)/abs(isInLight2.x) +1.0);\n        } \n\n    if(isInLight.y>=0.0 && isInLight2.x<=0.0){ inLight=0.0;}\n    if(isInLight.y<=0.0 && isInLight2.x>=0.0){ \n        float inLightCross = (inLight+inLight2);\n        inLight=inLight2 = inLightCross;\n\n        \n\n    }\n\n    inLight = min(inLight, inLight2);\n    if(isInLight.y>0.0 && isInLight2.x<=0.0  && (isInLight.x>0.0 || isInLight2.y<0.0)){inLight=1.0;}\n    f = smoothstep(0.0, 1.0,inLight);\n    gcol = mix(gcol,gcol*( 1.0+(colourTeamB/sqrt(TBdist*50.0))),  f);\n\n\n    if(p.x<0.0||p.y<0.0||p.x>1.0*ar||p.y>1.0){gcol = vec3(0.0,0.0,0.0);}\n    gcol = gcol*(2.0+(colourLight/(sqrt(lpn+0.2)/1.2)));\n    //gcol.b *= pn.x*ar;\n    return gcol;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    float border = 0.1;\n    vec2 guv = uv * (1.0 + border*2.0);\n    guv.x -= border*ar;\n    guv.y -= border;\n    vec3 col = vec3(0.0,0.0,0.0);\n    col = getGroundTexture(guv, ar, 1.0);\n    pixel = 1.0/iResolution.y;\n    \n    radius = 0.06;// + (iMouse.y/iResolution.y)/10.0;\n    \n    vec2 guv2 = guv + pixel;\n    centre = vec2((iMouse.x/iResolution.y),iMouse.y/iResolution.y);\n    centre = centre * (1.0 + border*2.0); centre.x -= border*ar; centre.y -= border;\n    vec2 distv = guv.xy - centre;\n    vec2 distv2 = guv2.xy - centre;\n    float dist = length(distv);\n    float dist2 = length(distv2);\n    float height = sqrt((radius*radius)-(dist*dist));\n    float height2 = sqrt((radius*radius)-(dist2*dist2));\n    vec3 position = vec3(guv.x, height, guv.y);\n    vec3 position2 = vec3(guv2.x, height2, guv2.y);\n    vec3 normal = vec3(distv.x, height, distv.y)/radius;\n    vec3 normal2 = vec3(distv2.x, height2, distv2.y)/radius;\n    vec3 incident = vec3(0.0, -1.0, 0.0);\n    vec3 reflection = reflect(incident, normal);\n    vec3 reflection2 = reflect(incident, normal2);\n    vec3 q = position + reflection * 100.0;\n    vec3 q2 = position2 + reflection2 * 100.0;\n\n    float a = 0.0;\n    float b = -1.0;\n    float c = 0.0;\n    float d = 0.0;\n    bool intersects;\n    bool intersects2;\n    vec3 intersection;\n    vec3 intersection2;\n    float t;\n    float f;\n    vec2 box;\n    vec2 boxposition;\n    float boxdist;\n    float bdist;\n    float tDenom = a*(q.x-position.x) + b*(q.y-position.y) + c*(q.z-position.z);\n    if (tDenom < 0.1) {\n        intersects = false;\n    } else {\n        t = - ( a*position.x + b*position.y + c*position.z - d ) / tDenom;\n        intersects = true;\n        intersection = vec3((position.x+t*(q.x-position.x)),(position.y+t*(q.y-position.y)),(position.z+t*(q.z-position.z)));\n    }\n    if(dist<radius){\n    col = vec3(0.6,0.6,0.8);\n    box = vec2(0.5*ar,0.5);\n    boxposition = vec2(0.5*ar, 0.5);\n    boxdist = sdBox(boxposition-intersection.xz, box);\n    vec2 intersectionoffset = vec2(boxposition.x - box.x/2.0, boxposition.y - box.y/2.0);\n    bdist = distance(position, intersection);\n    float bdistpix = iResolution.y * bdist;\n    if(intersects){\n        f = smoothstep(-pixel*4.0*sqrt(bdistpix), pixel*4.0*sqrt(bdistpix) , boxdist);\n        \n        vec3 greflection = vec3(reflection.x, 0.0, reflection.z);\n        float gangle = dot(reflection, greflection);\n        vec3 groundcol = getGroundTexture(vec2(intersection.x,intersection.z), ar, 1.5*gangle*(5.0+bdist));//texture(iChannel1, vec2(intersection.x,intersection.z)).rgb;\n        \n        col = mix((groundcol+col)/2.0,col,  f);\n\n       \n    }\n}\n\n    a = 1.0;\n    b = 0.0;\n    c = 0.0;\n    d = ar;\n    tDenom = a*(q.x-position.x) + b*(q.y-position.y) + c*(q.z-position.z);\n    float tDenom2 = a*(q2.x-position2.x) + b*(q2.y-position2.y) + c*(q2.z-position2.z);\n\n    \n    if (tDenom < 0.01) {\n        intersects = false;\n    } else {\n        t = - ( a*position.x + b*position.y + c*position.z - d ) / tDenom;\n        intersects = true;\n        intersection = vec3((position.x+t*(q.x-position.x)),(position.y+t*(q.y-position.y)),(position.z+t*(q.z-position.z)));\n        if (tDenom2 < 0.01) {\n            intersects2 = false;\n        } else {\n            intersects2 = true;\n            t = - ( a*position2.x + b*position2.y + c*position2.z - d ) / tDenom2;\n            intersection2 = vec3((position2.x+t*(q2.x-position2.x)),(position2.y+t*(q2.y-position2.y)),(position2.z+t*(q2.z-position2.z)));\n        }\n    }\n    box = vec2(0.15,0.15);\n    boxposition = vec2(0.15, 0.5);\n    \n    boxdist = sdBox(boxposition-intersection.yz, box);\n    bdist = distance(intersection2, intersection);\n\n\n    if(intersects && boxdist<bdist){\n        f = smoothstep(0.0, bdist , boxdist);\n\n        col = mix((colourTeamB+col),col,  f);\n    }\n\n\n    vec3 ground = getGroundTexture(guv, ar, 1.0);\n\t//Smoothes the edge of the sphere\n\tfloat g = smoothstep(radius-pixel*3.0, radius-pixel, dist);\n\tvec3 fcol = mix( col,ground, g);\n\n    \n    fcol *= fcol;\nfcol = contrast(fcol);\n\n    \n    fragColor = vec4(fcol,1.0);\n}\n*/",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Mc2fDh",
    "date": "1731324624",
    "viewed": 201,
    "name": "Spheroid - game renderer.",
    "description": "Main shader for a game I'm developing.\nNo SDFs, raymarching etc were used, just sphere intersection and making up the 3D/lighting as I went along, with hand coded AA for each shape.\nNot how I'd do it now, but still it's quite performant.\n",
    "likes": 13,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "game",
     "lighting",
     "spheres",
     "shadows",
     "ball",
     "25d",
     "orthographic",
     "spheroid",
     "spheroid"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Copyright (c) 2024 John Cotterell johnmdcotterell@gmail.com\n// You may view and edit this code (with this message intact) only on Shadertoy.\n// Anything else requires my permission.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord/iResolution.y;\n    ar = iResolution.x/iResolution.y;\n    float height = 0.0;\n    pixel = 1./iResolution.y;\n    float mTime = mod(iTime, 6.2832);\n    bool ZoneRob = false;\n    bool ZoneGround = false;\n    bool ZoneWall = false;\n    bool ZoneGoalWall = false;\n    bool ZoneInsideWall = false;\n    border = 0.05;\n    bar = 1.0;\n    vec4 courtyard = vec4( border*bar, border, ar-(border*bar), 1.0-border);\n    courtprox = vec4( courtyard.x - uv.x, courtyard.y - uv.y, uv.x - courtyard.z, uv.y - courtyard.w);\n    float goalwidth = 0.2;\n    float goaltop = 0.5 + (goalwidth/2.0);  \n    float goalbottom = 0.5 - (goalwidth/2.0);\n    float goalprox = max((uv.y-goaltop), (goalbottom-uv.y));\n    float wallheightfactor = 1.0;\n\n    Rob Robs[numrobs];\n    float dist = ar;\n    int rindex = -1;\n    vec2 centre = vec2(ar/2.0, 0.5);\n    float radius = 0.0;\n    float cradius = 0.34;\n    vec2 centreL = vec2((ar/2.0)-(cradius),0.5);\n    vec2 centreR = vec2((ar/2.0)+(cradius),0.5);\n    float segment = 1.256637;\n    float rightAng = 1.5708;\n    float dradius = 0.048;\n    float bradius = 0.02;\n    vec2 distv; \n    vec3 normal = vec3(0.0,0.0,1.0);\n    vec3 bgnormal = vec3(0.0,0.0,1.0); \n    bool flatTop = false;\n    float theight = 0.0;\n    float angle = 0.0;\n    \n    int activerobs = 11;\n    \n    for(int i=1;i<numrobs;i++){\n    Robs[i].ison = false;\n      if(i<activerobs){\n        Robs[i].ison = true;\n        Robs[i].radius = dradius;\n        angle = float(i) * segment;\n        vec2 rcentre = centreL;\n        if(i>5){\n            Robs[i].colourA = pgreen;\n            Robs[i].colourB = pblack;\n            angle += mTime;\n            Robs[i].rotation = angle + rightAng;\n            rcentre = centreR;} else {\n                Robs[i].colourA = pink;\n                Robs[i].colourB = white;\n                angle -= mTime;\n                Robs[i].rotation = angle - rightAng;\n            }\n        Robs[i].position = vec3( rcentre.x + (cradius * cos(angle)), rcentre.y + (cradius * sin(angle)), 0.0);\n        } \n    }\n    \n    int player = 1;\n    \n    int hasball = 1;\n    int tracter = hasball;\n    int tractee = 0;\n    bool tracting = false;\n    if(tracter>0){tracting = true;}\n    \n    float sinw = sin(mTime*50.0);\n    \n    if(tractee==0 &&tracting){\n        float balldist = dradius+bradius*3.;\n        balldist += sinw/200.0;\n        Robs[0].position = vec3( Robs[hasball].position.x + (balldist * cos(Robs[hasball].rotation)), Robs[hasball].position.y + (balldist * sin(Robs[hasball].rotation)), bradius);\n    } else {\n        Robs[0].position = vec3(ar/4., 0.2, 0.);\n    }\n    Robs[0].radius = bradius;\n    Robs[0].ison = true;\n    Robs[0].colourA = vec3(1.2);\n    Robs[player].colourA = pred;\n    vec3 bgcol;\n    vec3 fgcol; \n    vec3 col = white;  \n    vec2 robambient = vec2(1.0, 1.0);\n    \n    light lights[numlights];\n    lights[0] = light(vec3(1.0,1.0,1.0),vec3(ar*.5, .5 ,.6),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.1, true, true);\n    lights[1] = light(vec3(1.0,0.3,0.3),vec3(ar*-0.04, 0.5 ,0.05),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.03, true, true);\n    lights[3] = light(vec3(0.3,1.0,0.3),vec3(ar*1.04, 0.5 ,0.05),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.025, true, false);\n    \n    lights[2] = light(vec3(0.2,0.2,0.9),vec3(0.0),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.0015, false, false);\n    \n    lights[2].position = Robs[tractee].position;\n    lights[2].position.z = 0.001;\n    lights[2].ison = tracting;\n    if(uv.x>=ar/2.0){\n        lights[1] =  lights[3]; lights[1].ison = true;\n    }\n        vec3 tcol = vec3(0.2,0.2,0.6);\n    if(tracter<6){tcol = vec3(0.5,0.2,0.2);}else{tcol = vec3(0.2,0.5,0.2);}\n    lights[2].colour = tcol;\n\n    if(courtprox.w>0.0 && courtprox.w*bar>courtprox.z && courtprox.w*bar>courtprox.x){\n        bgcol = pgrey;\n        bgnormal = vec3(0.0,-1.0,0.0);\n        ZoneWall = true;\n        height = courtprox.w * wallheightfactor;\n    } else if(courtprox.y>0.0 && courtprox.y*bar>courtprox.z && courtprox.y*bar>courtprox.x){\n        bgcol = pgrey;\n        bgnormal = vec3(0.0,1.0,0.0);\n        ZoneWall = true;\n        height = courtprox.y *  wallheightfactor;\n    } else if(goalprox>0.0 && courtprox.x>0.0 || courtprox.x>(border*bar)/2.0){\n        bgcol = pgrey;\n        bgnormal = vec3(1.0,0.0,0.0);\n        ZoneWall = true; ZoneGoalWall = true;\n        float cph = courtprox.x/2.2;\n        if(goalprox<cph && courtprox.x<(border*bar)/2.0 ){\n            ZoneInsideWall = true;\n            height = goalprox * wallheightfactor;\n            if(uv.y<0.5){bgnormal = vec3(0.0,1.0,0.0);}else{bgnormal = vec3(0.0,-1.0,0.0);} \n        } else {\n            height = courtprox.x * wallheightfactor;      \n        }\n    } else if(goalprox>0.0 && courtprox.z>0.0 || courtprox.z>(border*bar)/2.0){\n        bgcol = pgrey;\n        bgnormal = vec3(-1.0,0.0,0.0);\n        ZoneWall = true; ZoneGoalWall = true;\n        if(goalprox<courtprox.z/2.2 && courtprox.z<(border*bar)/2.0 ){\n            ZoneInsideWall = true;\n            height = goalprox * wallheightfactor;\n            if(uv.y<0.5){bgnormal = vec3(0.0,1.0,0.0);}else{bgnormal = vec3(0.0,-1.0,0.0);}\n        } else {\n            height = courtprox.z * wallheightfactor;\n          \n        }\n    } else {\n        ZoneGround = true;\n        bgcol = getGroundColour();\n        bgnormal = vec3(0.0,0.0,1.0);\n    }\n    \n    float limA = courtyard.x;\n    float limB = courtprox.x;\n    \n    if(uv.x>ar/2.0){ limA = courtyard.z; limB = courtprox.z; }\n    \n    float lightATG = (goaltop-lights[1].position.y)/(lights[1].position.x-limA);\n    float lightATGdist = ( (lights[1].position.x - uv.x) * lightATG) -  (uv.y-lights[1].position.y);\n    float lightABG = (goalbottom-lights[1].position.y)/(lights[1].position.x-limA);\n    float lightABGdist =    (uv.y-lights[1].position.y)-( (lights[1].position.x - uv.x) * lightABG);\n    float lightAdist = lightABGdist*lightATGdist;\n    \n    lights[1].shadow.x = 1.0;\n    \n    if(goalprox<0.0||ZoneInsideWall){lights[1].shadow.x = 0.0;} else if(lightAdist>0.0){\n        lights[1].shadow.x = 0.0;\n        f = smoothstep(0.0, 0.2*-limB, lightAdist);\n        lights[1].shadow.x = mix(1.0, 0.0, f);\n    }\n    \n    lights[1].shadow.y = lights[1].shadow.x;\n    \n    for(int i=0;i<numrobs;i++){\n        if(Robs[i].ison){\n        float bdist = distance(uv, Robs[i].position.xy);\n        if(bdist<dist){dist=bdist;}\n        float edgedist = distance(uv, Robs[i].position.xy) + (Robs[i].position.z);\n        if(bdist<Robs[i].radius){\n            dist=bdist;\n            radius = Robs[i].radius;\n            height = sqrt((radius*radius)-(dist*dist));\n            ZoneRob = true;\n            rindex = i;\n            if(i>5){flatTop=true;}\n            if(bdist<Robs[i].radius-pixel){ZoneGround = false;}\n            robambient.y *= 1.0 - (0.5 * pow(0.8/(edgedist/Robs[i].radius),3.0));\n        } else {\n            robambient *= 1.0 - (0.5 * pow(0.8/(edgedist/Robs[i].radius),3.0));\n        }\n      }\n    }\n    \n    if(ZoneRob){\n        fgcol = Robs[rindex].colourA;\n        centre = vec2(Robs[rindex].position.x, Robs[rindex].position.y);\n        distv = uv - centre;\n        normal = vec3(distv.x, distv.y, height)/radius;\n        height+=Robs[rindex].position.z;\n        \n        if(flatTop){\n            float tradius = radius/2.5;\n            theight = sqrt((radius*radius)-(tradius*tradius));\n            if(height>theight){\n                height=theight;\n                normal = vec3(0.0, 1.0, 0.0);\n            }\n            f = smoothstep(theight-0.01, theight, height);\n            normal = mix(normal,vec3(0.0, 0.0, 1.0),  f);\n            height = mix(height,theight,  f);\n        }\n        \n        robambient.x *= (0.6 + normal.z/3.0);\n        float rotation = Robs[rindex].rotation;\n        if(rindex>0){\n            float SpFoffset = radius*2.0;\n            float SpBoffset = radius/1.0;\n            float SpFheight = radius*-1.0;\n            float SpBheight = radius*1.4;\n            float SpWidth = radius/1.4;\n            float SpLength = SpFoffset+SpBoffset;\n            float SpHeight = SpBheight-SpFheight;\n            vec3 SpFc = vec3(centre.x + SpFoffset * cos(rotation),  centre.y + SpFoffset * sin(rotation), 0.0);\n            vec3 SpFl = SpFc; SpFl.x += (SpWidth * sin(rotation)); SpFl.y -= (SpWidth * cos(rotation));\n            vec3 SpFr = SpFc; SpFr.x -= (SpWidth * sin(rotation)); SpFr.y += (SpWidth * cos(rotation));\n            vec3 SpBc = vec3(centre.x - SpBoffset * cos(rotation), centre.y - SpBoffset * sin(rotation), 0.0);\n            vec3 SpBl = SpBc; SpBl.x += (SpWidth * sin(rotation)); SpBl.y -= (SpWidth * cos(rotation));\n            vec3 SpBr = SpBc; SpBr.x -= (SpWidth * sin(rotation)); SpBr.y += (SpWidth * cos(rotation));\n            float SpFD = linePointLength( vec3(uv.x, uv.y, 0.0), vec3(SpFl.x, SpFl.y, 0.0), vec3(SpFr.x, SpFr.y, 0.0) );\n            float SpH = SpFheight + (SpHeight*(SpFD/SpLength));\n            float inTri = sdTriangle(uv, SpFc.xy, SpBr.xy, SpBl.xy);\n            \n            float lineDist = linePointLength( vec3(uv.x, uv.y, 0.0) , vec3(SpBc.x, SpBc.y, 0.0)  , vec3(SpFc.x, SpFc.y, 0.0)  );\n            \n            float linewid =  radius*0.05;\n            float linemid = abs((radius*0.45)-lineDist);\n            if(linemid<linewid){fgcol=Robs[rindex].colourB;}\n            if(linemid<linewid+pixel){\n                f = smoothstep(linewid,linewid+pixel, linemid);\n                fgcol = mix(Robs[rindex].colourB, fgcol, f);\n            }\n            if(rindex>5){\n                if(SpFD<radius*2.0){\n                    float linewid =  radius*0.05;\n                    float linemid = abs((radius*+0.45)-dist);\n                    if(linemid<linewid){fgcol=Robs[rindex].colourB;} else if(dist>(radius*+0.45)) {fgcol=Robs[rindex].colourA;}\n                    if(linemid<linewid+pixel){\n                        f = smoothstep(linewid,linewid+pixel, linemid);\n                        fgcol = mix(Robs[rindex].colourB, fgcol, f);\n                    }\n                }\n            } else {\n                if(SpFD>radius*2.5&&lineDist<(radius*0.5)+pixel){\n                    float linewid =  radius*0.05;\n                    float linemid = abs((radius*+0.75)-dist);\n                    if(linemid<linewid){fgcol=Robs[rindex].colourB;} else if(dist>(radius*+0.75)) {fgcol=Robs[rindex].colourA;}\n                    if(linemid<linewid+pixel){\n                        f = smoothstep(linewid,linewid+pixel, linemid);\n                        fgcol = mix(Robs[rindex].colourB, fgcol, f);\n                    }\n                }\n            }\n            \n            if(SpH>height){\n                float face = 0.7; \n                if(inTri<0.0&&dist<radius*0.9){\n                    if(dist<radius*0.7){\n                        f = smoothstep(0.0, pixel*5.0, SpH-height);\n                        height=mix(height, SpH,  f);\n                        normal=mix(normal,vec3( face * cos(rotation) , face * sin(rotation), 0.7), f);\n                    } else {\n                        f = smoothstep(radius*0.75, radius*0.95, dist);\n                        height=mix( SpH, height, f);\n                        normal=mix(vec3( face * cos(rotation) , face * sin(rotation), 0.7),normal, f);\n                    }\n                } \n            }\n            \n        }\n        normal = normal/length(normal);\n        /*    // ----  Objects casting shadows on other objects\n        for(int i=0;i<numrobs;i++){\n            if(i!=rindex&&Robs[i].ison){\n                for(int j=0;j<numlights;j++){\n                   if(lights[j].casts&&lights[j].ison){\n                     if(distance(Robs[i].position, lights[j].position) < distance(Robs[rindex].position, lights[j].position)){\n                        vec3 tempBall = Robs[i].position;\n                        tempBall.z*=1.2;\n                        float beam = linePointLength(tempBall, lights[j].position, vec3(uv.x, uv.y, height)); \n                        float cradius = Robs[i].radius*1.2; // cheating and making the ball bigger so shadow seen more easily\n                        float blur = distance(Robs[i].position, vec3(uv.x, uv.y, height))/5.0;\n                        float shadow = 0.0;\n                        if (beam<=(cradius-blur)){shadow = 1.0;} else {\n                            f = smoothstep(cradius-blur, cradius, beam);\n                            shadow = mix(1.0,0.0, f);\n                        }\n                            lights[j].shadow.y = max(shadow, lights[j].shadow.y);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // ----  Lots of GPU for small improvement, Uncomment to use\n        */ \n    }\n    \n    if(ZoneGround||ZoneWall){\n        float shadowheight = 0.0;\n        if(ZoneWall){shadowheight = height;};\n        for(int i=0;i<numrobs;i++){\n            if(Robs[i].ison){\n            for(int j=0;j<numlights;j++){\n            if(lights[j].casts&&lights[j].ison){\n                float beam = linePointLength(Robs[i].position, lights[j].position, vec3(uv.x, uv.y, shadowheight)); \n                float cradius = Robs[i].radius;\n                float blur = 0.;\n                blur=distance(Robs[i].position, vec3(uv.x, uv.y, shadowheight))/8.0;\n                float shadow = 0.0;\n                if (beam<=(cradius-blur)){shadow = 1.0;} else {\n                    f = smoothstep(cradius-blur, cradius, beam);\n                    shadow = mix(1.0,0.0, f);\n                }\n                lights[j].shadow.x = max(shadow, lights[j].shadow.x);\n            }\n            }\n            }\n        }\n    }\n\n    vec2 ambientmulti = vec2((min(0.5+(height*3.0), 1.0)),0.5);\n    float ambiA = 1.0;float ambiB = 1.0; float ambiC = 0.5;\n    ambientmulti *= sqrt((min(ambiC-(courtprox.w*ambiA), ambiB))*(min(ambiC-courtprox.z*ambiA, ambiB))*(min(ambiC-courtprox.y*ambiA, ambiB))*(min(ambiC-courtprox.x*ambiA, ambiB)));\n   \n    vec3 position = vec3(uv, height);\n    vec3 bgtot = vec3(0.0);\n    vec3 fgtot = vec3(0.0);\n    vec3 sptot = vec3(0.0);\n    for(int j=0;j<numlights;j++){\n   if(lights[j].ison){\n        lights[j].difference = lights[j].position - position;\n        lights[j].dist = length(lights[j].difference);\n        lights[j].difference = lights[j].difference/lights[j].dist;\n        lights[j].amount.x = max(0.0, dot(lights[j].difference, normal));\n        lights[j].amount.x = lights[j].amount.x/(lights[j].dist*lights[j].dist);\n        lights[j].amount.y = max(0.0, dot(lights[j].difference, bgnormal));\n        lights[j].amount.y = lights[j].amount.y/(lights[j].dist*lights[j].dist);\n        lights[j].amount.y *= lights[j].intensity * (1.0-lights[j].shadow.x);\n        lights[j].amount.x *= lights[j].intensity * (1.0-lights[j].shadow.y);\n        bgtot += lights[j].colour*lights[j].amount.y;\n        fgtot += lights[j].colour*lights[j].amount.x;\n        }\n    }\n\n    bgcol*=(robambient.y*ambientmulti.y)+bgtot;\n    if(ZoneRob){\n        vec3 incident = vec3(0.0, 0.0, -1.0);\n        vec3 reflection = reflect(incident, normal);\n        for(int j=0;j<numlights;j++){\n        if(lights[j].ison){\n            lights[j].amount.z = pow(max(0.0, dot(lights[j].difference, reflection)),32.0);\n            lights[j].amount.z = lights[j].amount.z/(lights[j].dist*lights[j].dist);\n            lights[j].amount.z *= lights[j].intensity * (1.0-lights[j].shadow.y);\n            sptot += lights[j].colour*lights[j].amount.z;\n            }\n        }\n\n        fgcol *= (robambient.x*ambientmulti.x)+fgtot;\n        fgcol += sptot;\n        \n        if(ZoneGround){\n            f = smoothstep(radius-pixel, radius, dist);\n            col = mix(fgcol,bgcol, f);\n        } else {\n            col = fgcol;\n        }\n    } else {\n       col = bgcol;\n    }\n    \n    if(tracting){\n        float tdist = dradius*0.5;\n        float tdistf = distance(Robs[tracter].position.xy, Robs[tractee].position.xy)/2.0;\n        float cosr = cos(Robs[tracter].rotation);\n        float sinr = sin(Robs[tracter].rotation);\n        vec2 tpA = vec2(Robs[tracter].position.x + (tdist * cosr), Robs[tracter].position.y + (tdist * sinr));\n        vec2 tpB = vec2(Robs[tracter].position.x + (tdistf * cosr), Robs[tracter].position.y + (tdistf * sinr));\n        float tpdist = distance(uv, Robs[tractee].position.xy);\n        float tqdist = distance(uv, tpA);\n        float tractor = sdBezier(uv, tpA, tpB, Robs[tractee].position.xy);\n        float lv = 0.01*tqdist;\n        float lw = (0.6*tqdist)+sin((mTime*80.0)+(tqdist*200.0))/80.0;\n        vec3 lcol = tcol/2.;\n        if(tractor<lw){f = smoothstep(lv, lw, tractor);col = mix(col+lcol,col, f);}\n    \n        if(rindex==tractee){\n            float llw = 0.4;\n            vec3 lnorm = vec3(sin(mTime*3.),cos(mTime*11.),cos(mTime*7.));\n            float ncola = sin(dot(normal, lnorm));\n            float ncolb = sin(dot(normal, lnorm.yzx));\n            float ncolc = sin(dot(normal, lnorm.zxy));\n            if(ncolc>sin(ncolc*5.) && ncolc<sin(ncolc*5.)+llw){col += tcol;}\n        }\n    }\n    \n    col = contrast(col, 1.2);\n    col = gammaCorrection(col, .95);\n    if(outputMode){col = outputColour;}\n    fragColor = vec4(col,1.0);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define numrobs 11\n#define numlights 4\n\n#define white vec3(1.)\n#define pink vec3(.95,.75,.75)\n#define pgreen vec3(.7,.9,.7)\n#define pblack vec3(.6,.6,.6)\n#define black vec3(.0)\n#define pgrey vec3(0.85)\n#define pred vec3(1., .5, .5)\n\nfloat pixel = 0.0;\nvec4 courtprox = vec4(0.0);\nvec2 uv = vec2(0.0);\nfloat ar = 0.0;\nfloat f = 0.0; \nfloat border = 0.05;\nfloat bar = 1.0;\n\nstruct light\n{\n    vec3 colour;\n    vec3 position;\n    vec3 difference;\n    vec3 amount;\n    vec2 shadow;\n    float dist;\n    float intensity;\n    bool casts;\n    bool ison;\n};\n\nstruct Rob\n{\n    vec3 position;\n    vec3 colourA;\n    vec3 colourB;\n    float rotation;\n    float radius;\n    bool ison;\n};\n\nvec3 getGroundColour(){\n    float linewidth = 0.01;\n    float hlinewidth = linewidth/2.0;\n    float rhlinewidth = hlinewidth + pixel/2.0;\n    vec3 rcol = pgrey;\n    if(courtprox.x>-linewidth&&courtprox.x<=0.0||abs(courtprox.y)<linewidth||courtprox.z>-linewidth&&courtprox.z<=0.0||abs(courtprox.w)<linewidth){\n        rcol = white;\n    }\n    float crad = 0.2;\n    float dfc = distance(uv, vec2(ar/2.0, 0.5));\n    float crdiff = dfc-crad;\n    if(crdiff<rhlinewidth ){\n        f = smoothstep(rhlinewidth-pixel,rhlinewidth , abs(crdiff));\n        rcol = mix(white, pgrey, f);\n    }\n\n    if(crdiff>=hlinewidth-pixel&&abs(uv.x - (ar/2.0))<=hlinewidth){\n        rcol = white;\n    }\n    dfc = distance(uv, vec2(border*bar, 0.5));\n    crdiff = dfc-crad;\n    if(crdiff<rhlinewidth ){\n        f = smoothstep(rhlinewidth-pixel,rhlinewidth , abs(crdiff));\n        rcol = mix(white, rcol, f);\n    }\n    dfc = distance(uv, vec2(ar-(border*bar), 0.5));\n    crdiff = dfc-crad;\n    if(abs(crdiff)<rhlinewidth ){\n        f = smoothstep(rhlinewidth-pixel,rhlinewidth , abs(crdiff));\n        rcol = mix(white, rcol, f);\n    }\n    return rcol;\n}\n\nbool outputMode = false; vec3 outputColour;\nvoid outputValue (in float value){\n    outputMode = true;\n    if ( value >= 0.0 && value <= 1.0 )\n        { outputColour = vec3(value, value, value); }\n        else if ( value < 0.0 && value > -1.0 )\n        { outputColour = vec3(0.0, 0.0, -value ); }\n        else if ( value > 1.0 )\n        { outputColour = vec3(1.0-(1.0/value), 1.0, 0.0); }\n        else if ( value < -1.0 )\n        { outputColour = vec3(1.0-(1.0/-value), 0.0, 1.0); }\n} \nvoid outputValue (in vec3 value){outputMode = true;outputColour = value;}\n\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 gammaCorrection (vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\n\nfloat linePointLength( in vec3 P, in vec3 A, in vec3 B ){\n    vec3 AB = B-A;\n    float lenAB = length(AB);\n    vec3 D = AB/lenAB;\n    vec3 AP = P-A;\n    float d = dot(D, AP);\n    vec3 X = A + D * dot(P-A, D);\n    if(X.z<0.0){return 10.0;} else {return length(X-P);}\n}\n\nvec3 linePoint( in vec3 P, in vec3 A, in vec3 B ){\n    vec3 AB = B-A;\n    float lenAB = length(AB);\n    vec3 D = AB/lenAB;\n    vec3 AP = P-A;\n    float d = dot(D, AP);\n    vec3 X = A + D * dot(P-A, D);\n    return X;\n}\n\n// SD Functions from https://iquilezles.org/articles/distfunctions2d/\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ){\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n    }\n    return sqrt( res );\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XXSyWD",
    "date": "0",
    "viewed": 0,
    "name": "Falling sand and liquid",
    "description": "First attempt at multiple materials",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "particles",
     "automata",
     "sand"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 color, in vec2 coord) {\n    color = texelFetch(iChannel0, ivec2(coord), 0);\n    color.a = 1.0;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define PX texture(iChannel0, vec2(uv.x\n#define PY , uv.y\n#define PZ ));\n#define BASE if(fragCoord.y < 3.)\n#define STILL_SAND else if(O.a >= ssand)\n#define FALLING_SAND else if(O.a >= fsand)\n#define WATER else if(O.a >= water)\n#define AIR else if(O.a >= air)\n#define SET_STILL_SAND if(colz){fc = vec4(0.4,0.3,0.,ssand);} else {fc.a=ssand;}\n#define SET_FALLING_SAND if(colz){fc = vec4(0.7,0.4,0.,fsand);} else {fc.a=fsand;}\n#define SET_GREEN_WATER if(colz){fc = vec4(0.,1.,0.,water);} else {fc.a=water;}\n#define SET_BLUE_WATER if(colz){fc = vec4(0.,0.,1.,water);} else {fc.a=water;}\n#define SET_WATER if(colz){fc = vec4(0.,1.,1.,water);} else {fc.a=water;}\n#define SET_AIR if(colz){fc = vec4(0.,0.,0.,air);} else {fc.a=air;}\n\nvoid mainImage( out vec4 fc, in vec2 fragCoord )\n{\n    bool colz = true;\n    vec2 uv = fragCoord/iResolution.xy;\n    float py = 1.0/iResolution.y;\n    float px = 1.0/iResolution.x;\n    float px2 = 2.*px;\n    float py2 = 2.*py;\n    float py3 = 3.*py;\n    float air = 0.2;\n    float water = 0.3;\n    float fsand = 0.4;\n    float ssand = 0.5;\n    vec4 O = PX PY PZ\n    if(O.a==0.){\n        fc = texture(iChannel1, vec2(uv.x, uv.y));\n        O = fc;\n        if(O.g>0.1&&O.g>O.b*1.1&&O.g>O.r*1.1){\n            SET_AIR\n        } else if(O.b>0.1&&O.b>O.g*1.001&&O.b>O.r*1.001){\n            SET_AIR\n        } else if(O.b+O.g+O.r<0.5){\n            SET_AIR\n        } else {\n            SET_FALLING_SAND\n        }\n        BASE {\n            SET_STILL_SAND\n        }\n \n    } else {\n        fc = O;\n        \n        // This is our 5 x 5 + 2 kernel -------------------------------------------------------------------------------------------\n                                                           vec4 y = PX PY+py3 PZ\n        vec4 a = PX-px2 PY+py2 PZ vec4 b = PX-px PY+py2 PZ vec4 c = PX PY+py2 PZ vec4 d = PX+px PY+py2 PZ vec4 e = PX+px2 PY+py2 PZ\n        vec4 f = PX-px2 PY+py PZ  vec4 g = PX-px PY+py PZ  vec4 h = PX PY+py PZ  vec4 i = PX+px PY+py PZ  vec4 j = PX+px2 PY+py PZ\n        vec4 k = PX-px2 PY PZ     vec4 l = PX-px PY PZ       /* O = PX PY PZ */  vec4 m = PX+px PY PZ     vec4 n = PX+px2 PY PZ\n        vec4 o = PX-px2 PY-py PZ  vec4 p = PX-px PY-py PZ  vec4 q = PX PY-py PZ  vec4 r = PX+px PY+py PZ  vec4 s = PX+px2 PY+py PZ\n        vec4 t = PX-px2 PY-py2 PZ vec4 u = PX-px PY-py2 PZ vec4 v = PX PY-py2 PZ vec4 w = PX+px PY+py2 PZ vec4 x = PX+px2 PY+py2 PZ\n                                                           vec4 z = PX PY-py3 PZ\n        // And these are the assigned pixels --------------------------------------------------------------------------------------\n        //\n        //      y\n        //  a b c d e\n        //  f g h i j\n        //  k l O m n\n        //  o p q r s\n        //  t u v w x\n        //      z\n\n        BASE {\n            \n            SET_STILL_SAND\n            \n        } STILL_SAND {\n        \n            \n        }\n        bool set = false;\n        \n        bvec3 bottom1 = bvec3(v.a >= water, q.a >= water,O.a >= water);\n        bvec4 bottom2 = bvec4(v.a >= water, q.a >= water, O.a >= water, h.a >= water);\n        bvec4 bottom3 = bvec4(z.a >= water, v.a >= water, q.a >= water, O.a >= water);\n        \n        bvec3 top1 = bvec3(q.a >= water, O.a >= water, h.a >= water);\n        bvec4 top2 = bvec4(q.a >= water, O.a >= water, h.a >= water, c.a >= water);\n        bvec4 top3 = bvec4(O.a >= water, h.a >= water, c.a >= water, y.a >= water);\n        \n        bvec3 fall1 = bvec3(true, false, true);\n        bvec4 fall2 = bvec4(true, false, false, true);\n        bvec4 fall3 = bvec4(false, false, false, true);\n        \n        if(bottom1 == fall1) { SET_AIR };\n        if(bottom2 == fall2) { SET_AIR };\n        if(bottom3 == fall3) { SET_AIR };\n        \n        if(top1 == fall1) { fc=h;}\n        if(top2 == fall2) { fc=c;}\n        if(top3 == fall3) { fc=y;}\n        \n\n        \n        \n        /*\n        int solid = 0;\n        bool sset = false;\n        bool fall = false;\n        vec4 fourth = vec4(0.);\n        if(z.a >= water){ solid+=1; }\n        if(v.a >= water){ solid+=1; }\n        if(q.a >= water){ solid+=1; }\n        if(O.a >= water){ solid+=1; }\n        if( solid == 4){ fourth=O; sset=true; } else { fall = true;}\n        if(h.a >= water){ solid+=1; }\n        if( solid == 4 && !sset){ fourth=h; sset=true; }\n        if(c.a >= water){ solid+=1; }\n        if( solid == 4 && !sset){ fourth=c; sset=true; }\n        if(y.a >= water){ solid+=1; }\n        if( solid == 4 && !sset){ fourth=y; sset=true; }\n        \n        if(sset){\n            fc=fourth;\n        } else if(y.a >= water){\n            fc=y;\n        } else {\n            SET_AIR\n        }\n        \n\n        \n        STILL_SAND {\n        \n            \n        } FALLING_SAND {\n\n            if(q.a == air){fc = q;} else if(q.a == water){fc = q;} else if(h.a == fsand && q.a == ssand){\n\n                SET_STILL_SAND\n            }\n            \n        } WATER {\n        \n            if(q.a == air){fc = q;}\n            if(h.a == fsand){fc = h;}\n            \n        } AIR {\n        \n            if(h.a == fsand){fc = h;} else if(h.a == water){fc = h;}\n            \n        }*/\n\n    }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "/*\n#define PX texture(iChannel0, vec2(uv.x\n#define PY , uv.y\n#define PZ ));\n\n// ....LATER...\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float py = 1.0/iResolution.y;\n    float px = 1.0/iResolution.x;\n    float px2 = 2.*px;\n    float py2 = 2.*py;\n    float py3 = 3.*py;\n    \n// ....LATER...\n        \n        // This is our 5 x 5 + 2 kernel -------------------------------------------------------------------------------------------\n                                                           vec4 y = PX PY+py3 PZ\n        vec4 a = PX-px2 PY+py2 PZ vec4 b = PX-px PY+py2 PZ vec4 c = PX PY+py2 PZ vec4 d = PX+px PY+py2 PZ vec4 e = PX+px2 PY+py2 PZ\n        vec4 f = PX-px2 PY+py PZ  vec4 g = PX-px PY+py PZ  vec4 h = PX PY+py PZ  vec4 i = PX+px PY+py PZ  vec4 j = PX+px2 PY+py PZ\n        vec4 k = PX-px2 PY PZ     vec4 l = PX-px PY PZ     vec4 O = PX PY PZ     vec4 m = PX+px PY PZ     vec4 n = PX+px2 PY PZ\n        vec4 o = PX-px2 PY-py PZ  vec4 p = PX-px PY-py PZ  vec4 q = PX PY-py PZ  vec4 r = PX+px PY+py PZ  vec4 s = PX+px2 PY+py PZ\n        vec4 t = PX-px2 PY-py2 PZ vec4 u = PX-px PY-py2 PZ vec4 v = PX PY-py2 PZ vec4 w = PX+px PY+py2 PZ vec4 x = PX+px2 PY+py2 PZ\n                                                           vec4 z = PX PY-py3 PZ\n        // And these are the assigned pixels --------------------------------------------------------------------------------------\n        //\n        //      y\n        //  a b c d e\n        //  f g h i j\n        //  k l O m n\n        //  o p q r s\n        //  t u v w x\n        //      z\n        \n*/",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MXsBDX",
    "date": "1729019113",
    "viewed": 158,
    "name": "8 Colour Dithering",
    "description": "I wanted to try converting to 3 bit/8 colour space.\nQuite easy in principle, you just round every r, g and b up to 1 or down to 0.\nthe dithering just varies the threshold for rounding.\n2 pixel dithering and 3 pixel use different criteria.",
    "likes": 3,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "dithering",
     "3bitcolour",
     "8color"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// 8 Colour Dithering, John Cotterell\n// Fork of \"Raymarching - Primitives\" by iq. https://shadertoy.com/view/Xds3zN\n// 2024-10-15 18:55:56\n// Dithering code is right at the bottom.....\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// The license is here only not because I want to (can one\n// license pieces of math?), but because people get upset\n// if I don't add one...\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations (such as cutting an infinite cylinder with two planes).\n\n// List of other 3D SDFs:\n//    https://www.shadertoy.com/playlist/43cXRl\n// and\n//    https://iquilezles.org/articles/distfunctions\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 1   // make this 2 or 3 for antialiasing\n#endif\n\n//------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdHorseshoe( in vec3 p, in vec2 c, in float r, in float le, vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p.xy);\n    p.xy = mat2(-c.x, c.y, \n              c.y, c.x)*p.xy;\n    p.xy = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n                (p.x>0.0)?p.y:l );\n    p.xy = vec2(p.x,abs(p.y-r))-vec2(le,0.0);\n    \n    vec2 q = vec2(length(max(p.xy,0.0)) + min(0.0,max(p.x,p.y)),p.z);\n    vec2 d = abs(q) - w;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdU( in vec3 p, in float r, in float le, vec2 w )\n{\n    p.x = (p.y>0.0) ? abs(p.x) : length(p.xy);\n    p.x = abs(p.x-r);\n    p.y = p.y - le;\n    float k = max(p.x,p.y);\n    vec2 q = vec2( (k<0.0) ? -k : length(max(p.xy,0.0)), abs(p.z) ) - w;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( pos.y, 0.0 );\n\n    // bounding box\n    if( sdBox( pos-vec3(-2.0,0.3,0.25),vec3(0.3,0.3,1.0) )<res.x )\n    {\n      res = opU( res, vec2( sdSphere(    pos-vec3(-2.0,0.25, 0.0), 0.25 ), 26.9 ) );\n\t  res = opU( res, vec2( sdRhombus(  (pos-vec3(-2.0,0.25, 1.0)).xzy, 0.15, 0.25, 0.04, 0.08 ),17.0 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(0.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )\n    {\n\tres = opU( res, vec2( sdCappedTorus((pos-vec3( 0.0,0.30, 1.0))*vec3(1,-1,1), vec2(0.866025,-0.5), 0.25, 0.05), 25.0) );\n    res = opU( res, vec2( sdBoxFrame(    pos-vec3( 0.0,0.25, 0.0), vec3(0.3,0.25,0.2), 0.025 ), 16.9 ) );\n\tres = opU( res, vec2( sdCone(        pos-vec3( 0.0,0.45,-1.0), vec2(0.6,0.8),0.45 ), 55.0 ) );\n    res = opU( res, vec2( sdCappedCone(  pos-vec3( 0.0,0.25,-2.0), 0.25, 0.25, 0.1 ), 13.67 ) );\n    res = opU( res, vec2( sdSolidAngle(  pos-vec3( 0.0,0.00,-3.0), vec2(3,4)/5.0, 0.4 ), 49.13 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(1.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )\n    {\n\tres = opU( res, vec2( sdTorus(      (pos-vec3( 1.0,0.30, 1.0)).xzy, vec2(0.25,0.05) ), 7.1 ) );\n    res = opU( res, vec2( sdBox(         pos-vec3( 1.0,0.25, 0.0), vec3(0.3,0.25,0.1) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(     pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(    pos-vec3( 1.0,0.25,-2.0), vec2(0.15,0.25) ), 8.0 ) );\n    res = opU( res, vec2( sdHexPrism(    pos-vec3( 1.0,0.2,-3.0), vec2(0.2,0.05) ), 18.4 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(-1.0,0.35,-1.0),vec3(0.35,0.35,2.5))<res.x )\n    {\n\tres = opU( res, vec2( sdPyramid(    pos-vec3(-1.0,-0.6,-3.0), 1.0 ), 13.56 ) );\n\tres = opU( res, vec2( sdOctahedron( pos-vec3(-1.0,0.15,-2.0), 0.35 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(   pos-vec3(-1.0,0.15,-1.0), vec2(0.3,0.05) ),43.5 ) );\n    res = opU( res, vec2( sdEllipsoid(  pos-vec3(-1.0,0.25, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    res = opU( res, vec2( sdHorseshoe(  pos-vec3(-1.0,0.25, 1.0), vec2(cos(1.3),sin(1.3)), 0.2, 0.3, vec2(0.03,0.08) ), 11.5 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(2.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )\n    {\n    res = opU( res, vec2( sdOctogonPrism(pos-vec3( 2.0,0.2,-3.0), 0.2, 0.05), 51.8 ) );\n    res = opU( res, vec2( sdCylinder(    pos-vec3( 2.0,0.14,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.2,0.35,0.1), 0.08), 31.2 ) );\n\tres = opU( res, vec2( sdCappedCone(  pos-vec3( 2.0,0.09,-1.0), vec3(0.1,0.0,0.0), vec3(-0.2,0.40,0.1), 0.15, 0.05), 46.1 ) );\n    res = opU( res, vec2( sdRoundCone(   pos-vec3( 2.0,0.15, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.35,0.1), 0.15, 0.05), 51.7 ) );\n    res = opU( res, vec2( sdRoundCone(   pos-vec3( 2.0,0.20, 1.0), 0.2, 0.1, 0.3 ), 37.0 ) );\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n                //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.25, -0.75, -0.75 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 2.2, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // focal length\n        const float fl = 2.5;\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n\n    // ----- Dithering added by Cotterzz 15-oct-2024\n    if(fragCoord.x/(iResolution.x/iResolution.y)>fragCoord.y){\n    \n    // 2 pixel dithering thresholds\n    float dthA = 0.3;\n    float dthB = 0.7;\n    float dthC = 0.9;\n    float dthD = 0.5;\n    // 3 pixel dithering thresholds\n    float dthRA = 0.15;\n    float dthRB = -0.15;\n    float dthGA = 0.15;\n    float dthGB = -0.15;\n    float dthBA = 0.15;\n    float dthBB = -0.15;\n    vec2 txc = fragCoord;\n    bool yodd = false;\n    bool xodd = false;\n    bool fodd = false;\n    float avcol = 0.;\n    float thresh = 0.;\n    if (mod(txc.x, 2.) < 1.){xodd = false;}else{xodd = true;}\n    if (mod(txc.y, 2.) < 1.){yodd = false;}else{yodd = true;}\n\n    if(yodd&&xodd){thresh = dthA;} else if (xodd){thresh = dthB;}else if (yodd){thresh = dthC;} else {thresh = dthD;}\n    \n    float threshr = thresh;\n    float threshg = thresh;\n    float threshb = thresh;\n    \n\n    if (mod(txc.x, 3.) < 1.){threshr+=dthRA;threshg+=dthGA;} else if (mod(txc.x, 3.) < 2.){threshr+=dthRB;threshg+=dthGB;}\n\n    if (mod(txc.y, 3.) < 1.){threshb+=dthBA;} else if (mod(txc.x, 3.) < 2.){threshb+=dthBB;}\n    \n    threshb*=1.1;\n    \n    if(tot.r>threshr){tot.r = 1.;} else {tot.r = 0.;}\n    if(tot.g>threshg){tot.g = 1.;} else {tot.g = 0.;}\n    if(tot.b>threshb){tot.b = 1.;} else {tot.b = 0.;}\n    \n    }\n    //---- Dithering finished\n    \n    fragColor = vec4( tot, 1.0 );\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XXSBzK",
    "date": "1729648162",
    "viewed": 142,
    "name": "8 Colour Noise-Time Dithering ",
    "description": "My random noise on the left, and IQ's blue noise suggestion, much better, on the right.\nDithering before gamma on the bottom",
    "likes": 3,
    "published": "Unlisted",
    "usePreview": 1,
    "tags": [
     "noise",
     "dithering",
     "3bitcolour",
     "8color"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsBSR3",
       "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// 8 Colour Dithering, John Cotterell\n// Fork of \"Raymarching - Primitives\" by iq. https://shadertoy.com/view/Xds3zN\n// 2024-10-15 18:55:56\n// Dithering code is right at the bottom.....\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// The license is here only not because I want to (can one\n// license pieces of math?), but because people get upset\n// if I don't add one...\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations (such as cutting an infinite cylinder with two planes).\n\n// List of other 3D SDFs:\n//    https://www.shadertoy.com/playlist/43cXRl\n// and\n//    https://iquilezles.org/articles/distfunctions\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 1   // make this 2 or 3 for antialiasing\n#endif\n\n//------------------------------------------------------------------\n\nfloat rand( in vec2 s ){\n    return fract(sin(dot(s, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdHorseshoe( in vec3 p, in vec2 c, in float r, in float le, vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p.xy);\n    p.xy = mat2(-c.x, c.y, \n              c.y, c.x)*p.xy;\n    p.xy = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n                (p.x>0.0)?p.y:l );\n    p.xy = vec2(p.x,abs(p.y-r))-vec2(le,0.0);\n    \n    vec2 q = vec2(length(max(p.xy,0.0)) + min(0.0,max(p.x,p.y)),p.z);\n    vec2 d = abs(q) - w;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdU( in vec3 p, in float r, in float le, vec2 w )\n{\n    p.x = (p.y>0.0) ? abs(p.x) : length(p.xy);\n    p.x = abs(p.x-r);\n    p.y = p.y - le;\n    float k = max(p.x,p.y);\n    vec2 q = vec2( (k<0.0) ? -k : length(max(p.xy,0.0)), abs(p.z) ) - w;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( pos.y, 0.0 );\n\n    // bounding box\n    if( sdBox( pos-vec3(-2.0,0.3,0.25),vec3(0.3,0.3,1.0) )<res.x )\n    {\n      res = opU( res, vec2( sdSphere(    pos-vec3(-2.0,0.25, 0.0), 0.25 ), 26.9 ) );\n\t  res = opU( res, vec2( sdRhombus(  (pos-vec3(-2.0,0.25, 1.0)).xzy, 0.15, 0.25, 0.04, 0.08 ),17.0 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(0.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )\n    {\n\tres = opU( res, vec2( sdCappedTorus((pos-vec3( 0.0,0.30, 1.0))*vec3(1,-1,1), vec2(0.866025,-0.5), 0.25, 0.05), 25.0) );\n    res = opU( res, vec2( sdBoxFrame(    pos-vec3( 0.0,0.25, 0.0), vec3(0.3,0.25,0.2), 0.025 ), 16.9 ) );\n\tres = opU( res, vec2( sdCone(        pos-vec3( 0.0,0.45,-1.0), vec2(0.6,0.8),0.45 ), 55.0 ) );\n    res = opU( res, vec2( sdCappedCone(  pos-vec3( 0.0,0.25,-2.0), 0.25, 0.25, 0.1 ), 13.67 ) );\n    res = opU( res, vec2( sdSolidAngle(  pos-vec3( 0.0,0.00,-3.0), vec2(3,4)/5.0, 0.4 ), 49.13 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(1.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )\n    {\n\tres = opU( res, vec2( sdTorus(      (pos-vec3( 1.0,0.30, 1.0)).xzy, vec2(0.25,0.05) ), 7.1 ) );\n    res = opU( res, vec2( sdBox(         pos-vec3( 1.0,0.25, 0.0), vec3(0.3,0.25,0.1) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(     pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(    pos-vec3( 1.0,0.25,-2.0), vec2(0.15,0.25) ), 8.0 ) );\n    res = opU( res, vec2( sdHexPrism(    pos-vec3( 1.0,0.2,-3.0), vec2(0.2,0.05) ), 18.4 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(-1.0,0.35,-1.0),vec3(0.35,0.35,2.5))<res.x )\n    {\n\tres = opU( res, vec2( sdPyramid(    pos-vec3(-1.0,-0.6,-3.0), 1.0 ), 13.56 ) );\n\tres = opU( res, vec2( sdOctahedron( pos-vec3(-1.0,0.15,-2.0), 0.35 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(   pos-vec3(-1.0,0.15,-1.0), vec2(0.3,0.05) ),43.5 ) );\n    res = opU( res, vec2( sdEllipsoid(  pos-vec3(-1.0,0.25, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    res = opU( res, vec2( sdHorseshoe(  pos-vec3(-1.0,0.25, 1.0), vec2(cos(1.3),sin(1.3)), 0.2, 0.3, vec2(0.03,0.08) ), 11.5 ) );\n    }\n\n    // bounding box\n    if( sdBox( pos-vec3(2.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )\n    {\n    res = opU( res, vec2( sdOctogonPrism(pos-vec3( 2.0,0.2,-3.0), 0.2, 0.05), 51.8 ) );\n    res = opU( res, vec2( sdCylinder(    pos-vec3( 2.0,0.14,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.2,0.35,0.1), 0.08), 31.2 ) );\n\tres = opU( res, vec2( sdCappedCone(  pos-vec3( 2.0,0.09,-1.0), vec3(0.1,0.0,0.0), vec3(-0.2,0.40,0.1), 0.15, 0.05), 46.1 ) );\n    res = opU( res, vec2( sdRoundCone(   pos-vec3( 2.0,0.15, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.35,0.1), 0.15, 0.05), 51.7 ) );\n    res = opU( res, vec2( sdRoundCone(   pos-vec3( 2.0,0.20, 1.0), 0.2, 0.1, 0.3 ), 37.0 ) );\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n                //spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.25, -0.75, -0.75 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 2.2, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // focal length\n        const float fl = 2.5;\n        \n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n         col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        if(fragCoord.y>iResolution.y*0.5) {col = pow( col, vec3(0.4545) );} \n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n\n    // Dithering\n    if(fragCoord.x>iResolution.x*0.65) {\n        // ----- added by iq\n        tot = step( texelFetch(iChannel0,(ivec2(fragCoord)+iFrame*ivec2(17,113))&1023,0).xyz, tot );\n    } else if(fragCoord.x<iResolution.x*0.35){\n        // ----- added by Cotterzz\n        float seed = 0.1 + fract(iTime);\n        tot.r = step( rand(seed*0.02*fragCoord), tot.r );\n        tot.g = step( rand(seed*0.03*fragCoord), tot.g );\n        tot.b = step( rand(seed*0.04*fragCoord), tot.b );\n    }\n    if(fragCoord.y<=iResolution.y*0.5) {tot = pow( tot, vec3(0.4545) );}\n    fragColor = vec4( tot, 1.0 );\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lftyzM",
    "date": "1730420168",
    "viewed": 97,
    "name": "8 to 36(27) colour dither.",
    "description": "Chequered dither that swaps each frame for almost imperceptible dithering.\nThere's only 27 distinct colours here though, red/white produces the same RGB as yellow/magenta, for example.\nBlack/white, red/cyan, green/magenta and blue/yellow - same gray!",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "dithering",
     "timedithering"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 txc = fragCoord;\n    bool yodd = false;\n    bool xodd = false;\n    bool fodd = false;\n    vec3 colours[8];\n    colours[0] = vec3(1.0, 0.0, 0.0);\n    colours[1] = vec3(0.0, 1.0, 0.0);\n    colours[2] = vec3(0.0, 0.0, 1.0);\n    colours[3] = vec3(1.0, 0.0, 1.0);\n    colours[4] = vec3(1.0, 1.0, 0.0);\n    colours[5] = vec3(0.0, 1.0, 1.0);\n    colours[6] = vec3(0.0, 0.0, 0.0);\n    colours[7] = vec3(1.0, 1.0, 1.0);\n    if (mod(txc.x, 2.) < 1.){xodd = false;}else{xodd = true;}\n    if (mod(txc.y, 2.) < 1.){yodd = false;}else{yodd = true;}\n    if (mod(float(iFrame), 2.) < 1.){fodd = false;}else{fodd = true;}\n    \n    int ca = int(floor(uv.x*7.));\n    int cb = int(floor(uv.y*8.));\n    \n    vec3 colA = colours[ca];\n    vec3 colB = colours[cb];\n    \n    vec3 col = colA;\n    //if(yodd){ col =colours[4];};\n    if(!(((yodd!=xodd)&&!fodd)||(yodd==xodd&&fodd))){\n        col=colB;\n        //if(yodd){ col =colours[1];}\n    }\n    if(ca>cb){ col = colours[7];}\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MfccW8",
    "date": "0",
    "viewed": 0,
    "name": "Four shades of light",
    "description": "Adapting another shader for a game jam",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "game",
     "lighting",
     "gamejam",
     "raylib",
     "8colourpalette"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsBSR3",
       "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Copyright (c) 2024 John Cotterell johnmdcotterell@gmail.com\n// You may view and edit this code (with this message intact) only on Shadertoy.\n// Anything else requires my permission.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // GEOMETRY SETTINGS\n    // General\n    uv = fragCoord/iResolution.y;      // Normalised resolution\n    float height = 0.0;                     // This is the z value to go with our uv's x and y\n    ar = iResolution.x/iResolution.y; // Aspect ratio or normalised width\n    pixel = 1.4/iResolution.y;        // Size of pixel, for AA\n    // Zones. Not exclusive. We can be on more than one for purposes of AA mixing\n    bool ZoneRob = false;                  // Are we on the curved fg objects\n    bool ZoneGround = false;                // Are we on the ground\n    Rob Robs[numrobs];\n    float border = 1./100.;\n    float dist = ar; // distance to nearest foreground object\n    int rindex = -1; // index of object\n    vec2 centre = vec2(ar/2.0, 0.5); // centre of current object\n    float radius = 0.0; // radius of current object\n    float cradius = 0.34; // radius of circle\n    vec2 centreL = vec2((ar/2.0)-(cradius),0.5); // centre of left circle\n    vec2 centreR = vec2((ar/2.0)+(cradius),0.5); // centre of right circle\n    float segment = 1.256637; // ( 3.1415926 * 2.0 ) / 5.0;\n    float rightAng = 1.5708; // ( 3.1415926 * 2.0 ) / 4.0;\n    float dradius = 0.03; // default object radius\n    float bradius = 0.02; // ball radius\n    vec2 distv; // vector from current position to centre\n    vec3 normal = vec3(0.0,0.0,1.0); // normal of surface, default is normal of ground\n    vec3 bgnormal = vec3(0.0,0.0,1.0); // normal of walls or ground, default is normal of ground\n    float theight = 0.0;\n    float angle = 0.0;\n    float speed = 1.0;\n    bool isLine = false;\n    \n    for(int i=1;i<numrobs;i++){\n        Robs[i].radius = dradius;\n        angle = float(i) * segment;\n        vec2 rcentre = centreL;\n        if(i>5){\n            angle += speed;\n            Robs[i].rotation = angle + rightAng;\n            rcentre = centreR;} else {\n                \n                angle -= speed;\n                Robs[i].rotation = angle - rightAng;\n            }\n        Robs[i].position = vec3( rcentre.x + (cradius * cos(angle)), rcentre.y + (cradius * sin(angle)), 0.0);\n        \n    }\n\n    Robs[1].colourA = red;\n    Robs[2].colourA = red;\n    Robs[3].colourA = blue;\n    Robs[4].colourA = blue;\n    Robs[5].colourA = purple;\n    Robs[6].colourA = purple;\n    Robs[7].colourA = green;\n    Robs[8].colourA = green;\n    Robs[9].colourA = cyan;\n    Robs[10].colourA = cyan;\n    \n    // COLOUR SETTINGS\n    vec3 bgcol; // final background colour\n    vec3 fgcol; // final foreground colour\n    vec3 col = white;   // final colour\n    vec2 robambient = vec2(1.0, 1.0); // the total Ambient effect of round objects. two vlaues for mixing foreground and bg\n    \n    light lights[numlights];\n    lights[0] = light(vec3(1.0,1.0,1.0),vec3(ar*0.5, 0.5 ,0.5),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.0);\n    lights[1] = light(vec3(1.0,0.4,0.4),vec3(ar*-0.04, 0.5 ,0.15),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.01);\n    lights[2] = light(vec3(0.4,1.0,0.4),vec3(ar*1.04, 0.5 ,0.15),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.01);\n    lights[3] = light(vec3(0.0,0.0,1.0),vec3(ar*1.04, 0.5 ,0.15),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.015);\n    lights[4] = light(vec3(1.0,0.0,1.0),vec3(ar*1.04, 0.5 ,0.15),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.01);\n    lights[5] = light(vec3(0.0,1.0,1.0),vec3(ar*1.04, 0.5 ,0.15),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.01);\n\n        ZoneGround = true;\n        bgcol = getGroundColour();\n        bgnormal = vec3(0.0,0.0,1.0);\n\n   \n    \n    \n    for(int i=1;i<numrobs;i++){\n        float bdist = distance(uv, Robs[i].position.xy);\n        if(bdist<dist){dist=bdist;}\n        \n        if(bdist<Robs[i].radius){\n            dist=bdist;\n            radius = Robs[i].radius;\n            height = sqrt((radius*radius)-(dist*dist));\n            ZoneRob = true;\n            rindex = i;\n\n            if(bdist<Robs[i].radius-pixel){ZoneGround = false;}\n        } else {\n            float edgedist = distance(uv, Robs[i].position.xy) + (Robs[i].position.z);\n            robambient *= 1.0 - (0.5 * pow(0.8/(edgedist/Robs[i].radius),3.0)); // ambient multiplier for outside of object\n        }\n        \n    }\n    \n    lights[1].position.xy = Robs[1].position.xy;\n    lights[2].position.xy = Robs[8].position.xy;\n    lights[3].position.xy = Robs[3].position.xy;\n    lights[4].position.xy = Robs[6].position.xy;\n    lights[5].position.xy = Robs[9].position.xy;\n    if(ZoneRob){\n        fgcol = Robs[rindex].colourA;\n        \n        \n        if(rindex==1||rindex==8){\n            \n            fgcol+=0.6;\n            fgcol*=1.7;\n        } else if(rindex==3||rindex==6||rindex==9){\n            \n            fgcol+=1.2;\n            fgcol*=1.2;\n        }\n        centre = vec2(Robs[rindex].position.x, Robs[rindex].position.y);\n        distv = uv - centre;\n        normal = vec3(distv.x, distv.y, height)/radius;\n        height+=Robs[rindex].position.z;\n        \n\n        \n        robambient *= (0.6 + normal.z/3.0);// ambient multiplier for inside of object\n        float rotation = Robs[rindex].rotation;\n\n        normal = normal/length(normal);\n    }\n    \n        \n    Join Joins[numjoins];\n    \n    Joins[0] = Join( 1, 2);\n    Joins[1] = Join( 2, 3);\n    Joins[2] = Join( 3, 4);\n    Joins[3] = Join( 4, 5);\n    \n    \n    if (ZoneGround) {\n        for(int j=0;j<numjoins;j++){\n            if(sqrt(sdLine(uv, Robs[Joins[j].a].position.xy, Robs[Joins[j].b].position.xy))<border){\n            //if(!(((yodd!=xodd)&&!fodd)||(yodd==xodd&&fodd))){\n                bgcol = vec3(0.7);\n            //}\n                isLine = true;\n            }\n        }\n    }\n    // calculate and multiply ambient\n\n    // these ambient calculations are an approximation based on proximity to walls, ground and objects\n    // it gives us a very rough but dynamic AO value\n    float ambientmulti = (min(0.7+(height*2.0), 1.0));// if you're on the ground, half of ambient light is removed\n    float ambiA = 1.0;float ambiB = 1.0; float ambiC = 0.5;\n    //ambientmulti *= sqrt((min(ambiC-(courtprox.w*ambiA), ambiB))*(min(ambiC-courtprox.z*ambiA, ambiB))*(min(ambiC-courtprox.y*ambiA, ambiB))*(min(ambiC-courtprox.x*ambiA, ambiB)));\n    // and again for each wall\n    ambientmulti = robambient.x*ambientmulti*ambientmulti;\n    \n    vec3 position = vec3(uv, height);\n    vec3 bgtot = vec3(0.0);\n    vec3 fgtot = vec3(0.0);\n    vec3 sptot = vec3(0.0);\n    for(int j=0;j<numlights;j++){\n        lights[j].difference = lights[j].position - position;\n        lights[j].dist = length(lights[j].difference);\n        lights[j].difference = lights[j].difference/lights[j].dist;\n        lights[j].amount.x = max(0.0, dot(lights[j].difference, normal));\n        lights[j].amount.x = lights[j].amount.x/(lights[j].dist*lights[j].dist);\n        lights[j].amount.y = max(0.0, dot(lights[j].difference, bgnormal));\n        lights[j].amount.y = lights[j].amount.y/(lights[j].dist*lights[j].dist);\n        lights[j].amount.y *= lights[j].intensity * (1.0-lights[j].shadow.x);\n        lights[j].amount.x *= lights[j].intensity * (1.0-lights[j].shadow.y);\n        bgtot += lights[j].colour*lights[j].amount.y;\n        fgtot += lights[j].colour*lights[j].amount.x;\n    }\n\n    bgcol*=ambientmulti+bgtot;\n    \n    if(ZoneRob){\n        // calculate and add specular\n        vec3 incident = vec3(0.0, 0.0, -1.0);\n        vec3 reflection = reflect(incident, normal);\n        for(int j=0;j<numlights;j++){\n            lights[j].amount.z = pow(max(0.0, dot(lights[j].difference, reflection)),8.0);\n            lights[j].amount.z = lights[j].amount.z/(lights[j].dist*lights[j].dist);\n            lights[j].amount.z *= lights[j].intensity * (1.0-lights[j].shadow.y);\n            sptot += lights[j].colour*lights[j].amount.z;\n        }\n    \n       fgcol *= ambientmulti+fgtot;\n        fgcol += sptot*2.; // Add specuialr highlight\n        \n\n    \n        // Assign forground or background colour or mix them if on AA border\n   \n        if(ZoneGround){\n            f = smoothstep(radius-pixel, radius, dist);\n            col = mix(fgcol,bgcol, f);\n        } else {\n            col = fgcol;\n        }\n    } else {\n        col = bgcol;\n\n    }\n    // Output to screen\n\n    f = smoothstep(0.0, iResolution.x, iMouse.x);\n    col = contrast(col, f+1.0);\n    if(iMouse.y!=0.0){\n        f = smoothstep(0.0, iResolution.y, iMouse.y);\n        col = gammaCorrection(col, 0.5 + f*2.0);\n    }\n    \n\n    if(outputMode){col = outputColour;}\n    col = step( texelFetch(iChannel0,(ivec2(fragCoord)+iFrame*ivec2(17,113))&1023,0).xyz, col );\n    fragColor = vec4(col,1.0);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define numrobs 11\n#define numlights 6\n#define numjoins 4\n#define black vec3(0.0,0.0,0.0)\n#define white vec3(1.0,1.0,1.0)\n#define grey vec3(0.5,0.5,0.5)\n#define blue vec3(0.0,0.0,1.0)\n#define red vec3(1.0,0.0,0.0)\n#define lime vec3(0.0,1.0,0.0)\n#define green vec3(0.0,0.7,0.0)\n#define cyan vec3(0.0,1.0,1.0)\n#define purple vec3(1.0,0.0,1.0)\n#define yellow vec3(1.0,1.0,0.0)\n#define orange vec3(1.0,0.6,0.0)\n\n#define porange vec3(1.0,0.8,0.6)\n#define pyellow vec3(0.87,0.87,0.7)\n#define pblue vec3(0.8,0.85,1.0)\n#define pgreen vec3(0.7,0.9,0.7)\n#define pink vec3(0.95,0.75,0.75)\n#define ppurple vec3(1.0,0.7,1.0)\n#define pgrey vec3(0.85,0.85,0.85)\n\n// declared here for use in functions\nfloat pixel = 0.0;\nvec4 courtprox = vec4(0.0);\nvec2 uv = vec2(0.0);\nfloat ar = 0.0;\nfloat f = 0.0; // AA mixing number\nfloat border = 0.05;\nfloat bar = 1.0;\n    struct Join\n    {\n        int a;\n        int b;\n    };\n    \n\nstruct light\n{\n    vec3 colour;\n    vec3 position;\n    vec3 difference;\n    vec3 amount;\n    vec2 shadow;\n    float dist;\n    float intensity;\n};\n\nstruct Rob // Round Object. (Players and Ball)\n{\n    vec3 position;\n    vec3 colourA;\n    vec3 colourB;\n    float rotation;\n    float radius;\n};\n\nvec3 getGroundColour(){\n\n    vec3 rcol = pgrey;\n\n    return rcol;\n}\n\nbool outputMode = false; vec3 outputColour; // Easy way to throw a value at the output for debugging\nvoid outputValue (in float value){\n    outputMode = true;\n    if ( value >= 0.0 && value <= 1.0 )\n        { outputColour = vec3(value, value, value); }\n        else if ( value < 0.0 && value > -1.0 )\n        { outputColour = vec3(0.0, 0.0, -value ); }\n        else if ( value > 1.0 )\n        { outputColour = vec3(1.0-(1.0/value), 1.0, 0.0); }\n        else if ( value < -1.0 )\n        { outputColour = vec3(1.0-(1.0/-value), 0.0, 1.0); }\n} // Call outputValue with a float and that value will override the pixel output\nvoid outputValue (in vec3 value){outputMode = true;outputColour = value;} // or directly with a vec3\n\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 gammaCorrection (vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\n\nfloat linePointLength( in vec3 P, in vec3 A, in vec3 B ){\n    vec3 AB = B-A;\n    float lenAB = length(AB);\n    vec3 D = AB/lenAB;\n    vec3 AP = P-A;\n    float d = dot(D, AP);\n    vec3 X = A + D * dot(P-A, D);\n    if(X.z<0.0){return 10.0;} else {return length(X-P);}\n}\n\nvec3 linePoint( in vec3 P, in vec3 A, in vec3 B ){\n    vec3 AB = B-A;\n    float lenAB = length(AB);\n    vec3 D = AB/lenAB;\n    vec3 AP = P-A;\n    float d = dot(D, AP);\n    vec3 X = A + D * dot(P-A, D);\n    return X;\n}\n\n// SD Functions from https://iquilezles.org/articles/distfunctions2d/\nfloat sdLine(in vec2 iPoint, in vec2 iLine0, in vec2 iLine1) {\n\tvec2 diff = iPoint - iLine0;\n\tvec2 dir = iLine1 - iLine0;\n\tfloat t = dot(diff, dir) / dot(dir,dir);\n\tt = clamp(t, 0.0, 1.0);\n\tvec2 oLinePoint = t * dir + iLine0;\n    vec2 diff2 = iPoint - oLinePoint;\n\treturn dot(diff2, diff2);\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ){\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n/* OLD SHADER\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 Tcolf;\n    vec3 Tcolb;\n    \n    float speed = iTime;\n    float dist = 20.0;\n    float angle;\n    vec3 bcol,col;\n    int currentBall = 10;\n    for(int i=0;i<numballs;i++){\n        angle = float(i) * segment;\n        vec2 rcentre = centreL;\n        if(i>4){\n            angle += speed;\n            rcentre = centreR;} else {\n                angle -= speed;\n            }\n        Balls[i]= vec4( rcentre.x + (cradius * cos(angle)), rcentre.y + (cradius * sin(angle)), 0.0, angle );\n\n        float bdist = distance(uv, Balls[i].xy);\n        if(bdist<radius){\n            dist=bdist;\n            if(bdist<(radius-pixel)){currentBall = i;}\n            centre = vec2(Balls[i].x, Balls[i].y);\n            vec3 TAbcol = vec3(0.9,1.0,0.9);\n            vec3 TAfcol = vec3(0.1,0.7,0.1);\n            vec3 TBbcol = vec3(0.1,0.0,0.0);\n            vec3 TBfcol = vec3(1.0,0.0,0.0);\n            \n            if(i<5){Tcolf=TAfcol;Tcolb=TAbcol;}else{Tcolf=TBfcol;Tcolb=TBbcol;}\n            float f;\n            float ringRadius=0.8;\n            float ringWidth = 0.1;\n            if(i>4){flatTop=true;ringRadius=0.45;}else{flatTop=false;ringRadius=0.8;}\n            if(bdist>radius*(ringRadius+ringWidth)){\n                f = smoothstep(radius*(ringRadius+ringWidth), (radius*(ringRadius+ringWidth))+pixel, bdist);\n                bcol = mix(Tcolf,Tcolb,  f);\n            } else if (bdist<radius*ringRadius){\n                \n                f = smoothstep(radius*ringRadius, (radius*ringRadius)-pixel, bdist);\n                bcol = mix(Tcolf,Tcolb,  f);\n            } else {\n                bcol = Tcolf;\n            }\n\n            \n        } else if(bdist<dist){ dist=bdist;}\n           \n        \n\n    }\n\n    float rotation;\n\n    if(currentBall>4){\n        rotation = Balls[currentBall].w + rightAng;\n    } else {rotation = Balls[currentBall].w - rightAng;}\n\n     //vec2 ball = vec2(Balls[0].x + (radius*1.3 * cos(Balls[0].w- rightAng)), Balls[0].y + (radius*1.3 * sin(Balls[0].w- rightAng)));\n     //if( distance(uv, ball)<radius*0.2){ centre = vec2(ball.x, ball.y); bcol = purple; currentBall=-1;}\n    // Spoiler flap\n    float SpFoffset = radius*3.0;// set distance from centre to front\n    float SpBoffset = radius/1.8;// set distance from centre to back\n    float SpFheight = radius*-1.5;// set front and back heights\n    float SpBheight = radius*1.2;\n    float SpWidth = radius/1.6;// set width, length, height of triangle\n    float SpLength = SpFoffset+SpBoffset;\n    float SpHeight = SpBheight-SpFheight;\n    vec3 SpFc = vec3(centre.x + SpFoffset * cos(rotation), 0.0, centre.y + SpFoffset * sin(rotation));// get front point F\n    vec3 SpFl = SpFc; SpFl.x += (SpWidth * sin(rotation)); SpFl.z -= (SpWidth * cos(rotation));// get front points L and R\n    vec3 SpFr = SpFc; SpFr.x -= (SpWidth * sin(rotation)); SpFr.z += (SpWidth * cos(rotation));\n    vec3 SpBc = vec3(centre.x - SpBoffset * cos(rotation), 0.0, centre.y - SpBoffset * sin(rotation));// get back point B\n    vec3 SpBl = SpBc; SpBl.x += (SpWidth * sin(rotation)); SpBl.z -= (SpWidth * cos(rotation));// get back points L and R\n    vec3 SpBr = SpBc; SpBr.x -= (SpWidth * sin(rotation)); SpBr.z += (SpWidth * cos(rotation));\n    float SpBD = linePointLength( vec3(uv.x, 0.0, uv.y), vec3(SpBl.x, 0.0, SpBl.z), vec3(SpBr.x, 0.0, SpBr.z) );// get distance from back\n    float SpFD = linePointLength( vec3(uv.x, 0.0, uv.y), vec3(SpFl.x, 0.0, SpFl.z), vec3(SpFr.x, 0.0, SpFr.z) );// get distance from front\n    float SpH = SpFheight + (SpHeight*(SpFD/SpLength));// get height of current point\n    float inTri = sdTriangle(uv, SpFc.xz, SpBr.xz, SpBl.xz);// is point in triangle\n    //if(inTri<0.0){outputValue(purple);} // uncomment to test where spoiler triangle is\n    \n    float lineDist = linePointLength( vec3(uv.x, 0.0, uv.y) , vec3(SpBc.x, 0.0, SpBc.z)  , vec3(SpFc.x, 0.0, SpFc.z)  );\n    if(currentBall<5){\n        float gfline = 2.7;\n        float gflinew = 0.011;\n        if(lineDist>radius/gfline&&lineDist<(radius/gfline)+gflinew&&dist<radius*0.9)\n            {\n            if(lineDist<(radius/gfline)+(gflinew/5.0)){\n                float p = smoothstep(radius/gfline, radius/gfline + (gflinew/5.0), lineDist);\n                bcol = mix(Tcolb,Tcolf,  p);} else {\n                    float p = smoothstep((radius/gfline)+gflinew, (radius/gfline)+gflinew - (gflinew/5.0), lineDist);\n                    bcol = mix(bcol,Tcolf,  p);\n                }\n            } else if (lineDist<(radius/gfline)+gflinew ){bcol = Tcolb;}\n    }\n    \n    float power = 32.0;\n    float power2 = 32.0;\n\n    float height = sqrt((radius*radius)-(dist*dist));\n    vec2 distv = uv - centre;\n    vec3 normal = vec3(distv.x, height, distv.y)/radius;\n        \n    if(flatTop){\n        if(height>theight){\n            height=theight;\n            normal = vec3(0.0, 1.0, 0.0);\n            power = power2;\n        }\n        float p = smoothstep(theight-0.01, theight, height);\n        normal = mix(normal,vec3(0.0, 1.0, 0.0),  p);\n        height = mix(height,theight,  p);\n    }\n    if(SpH>height&&currentBall<10){// is spoiler higher than dome\n        float face = 0.7;  \n        if(inTri<0.0){\n        power = power2;\n        float s = smoothstep(0.0, -0.002, inTri);\n        bcol=mix(Tcolb, Tcolf, s);\n        if(inTri<-0.005){\n            s = smoothstep(-0.01, -0.008, inTri);\n            bcol=mix(Tcolb, Tcolf, s);\n        }\n            s = smoothstep(0.0, pixel*6.0, SpH-height);\n            height=mix(height, SpH, s);\n            normal=mix(normal,vec3( face * cos(rotation), 0.9 , face * sin(rotation)), s);\n        } \n        if (inTri<radius/10.0&&inTri>0.0) {\n            power = power2;\n            bcol=Tcolb;\n            float s = smoothstep(0.0, radius/6.0, inTri);\n            height=mix(SpH,height,  s);\n            normal=mix(vec3( face * cos(rotation), 0.9 , face * sin(rotation)),normal, s);\n        }\n    }\n    \n    normal = normal/length(normal);\n\n    vec3 position = vec3(uv.x, height, uv.y);\n        \n    vec3 incident = vec3(0.0, -1.0, 0.0);\n    vec3 reflection = reflect(incident, normal);\n\n    vec3 lcolA = vec3(0.0,0.4,0.0);\n    vec3 lcolB = vec3(0.5,0.0,0.0);\n    vec3 lcolC = vec3(0.4,0.4,0.5);\n\n    vec3 lcolAmbient = (lcolA+lcolB+lcolC+lcolC+lcolC)/(7.0);\n        \n    gcol *= lcolAmbient;\n\n    vec3 lightA = vec3(0.0-0.3, 0.1, 0.5);\n    vec3 lightB = vec3(ar+0.3, 0.1, 0.5);\n    vec3 lightC = vec3(0.5*ar,0.2, 0.5);\n        \n    float f;\n    \n    vec3 goalRT = vec3(ar-0.1, 0.2, 0.65);\n    vec3 goalRB = vec3(ar-0.1, 0.2, 0.35);\n\n    float lightBTG = (goalRT.z-lightB.z)/(lightB.x-goalRT.x);\n    float lightBTGdist = ( (lightB.x - uv.x) * lightBTG) -  (uv.y-lightB.z);\n    float lightBBG = (goalRB.z-lightB.z)/(lightB.x-goalRB.x);\n    float lightBBGdist =    (uv.y-lightB.z)-( (lightB.x - uv.x) * lightBBG);\n    float lightBdist = lightBBGdist*lightBTGdist;\n    \n    vec3 goalLT = vec3(0.1, 0.2, 0.65);\n    vec3 goalLB = vec3(0.1, 0.2, 0.35);\n\n    float lightATG = (goalLT.z-lightA.z)/(lightA.x-goalLT.x);\n    float lightATGdist = ( (lightA.x - uv.x) * lightATG) -  (uv.y-lightA.z);\n    float lightABG = (goalLB.z-lightA.z)/(lightA.x-goalLB.x);\n    float lightABGdist =    (uv.y-lightA.z)-( (lightA.x - uv.x) * lightABG);\n    float lightAdist = lightABGdist*lightATGdist;\n\n    vec3 tolightA = lightA - position;\n    vec3 tolightB = lightB - position;\n    vec3 tolightC = lightC - position;\n\n    float distlA = length(tolightA);\n    float distlB = length(tolightB);\n    float distlC = length(tolightC);\n\n    tolightA = tolightA/distlA;\n    tolightB = tolightB/distlB;\n    tolightC = tolightC/distlC;\n    \n    float lamntA = max(0.0, dot(tolightA, normal));\n    float lamntB = max(0.0, dot(tolightB, normal));\n    float lamntC = max(0.0, dot(tolightC, normal));\n\n    float specamntA = pow(max(0.0, dot(tolightA, reflection)), power);\n    float specamntB = pow(max(0.0, dot(tolightB, reflection)), power);\n    float specamntC = pow(max(0.0, dot(tolightC, reflection)), power);\n    if( dist > radius ){ height = 0.0;}\n    \n    vec3 tlightA = (lcolA*specamntA)+(lcolA*lamntA);\n    vec3 tlightB = (lcolB*specamntB)+(lcolB*lamntB);\n    vec3 tlightC = (lcolC*specamntC)+(lcolC*lamntC);\n    \n    tlightA*=2.0;\n    tlightB*=2.0;\n    tlightC*=3.0;\n    \n    int Btotal;\n    int Atotal;\n    int Ctotal;\n    float Bmost=0.0;\n    float Amost=0.0;\n    float Cmost=0.0;\n        \n    bool Bcast = false;\n    float BcastDepth;\n    bool Acast = false;\n    float AcastDepth;\n    for(int i=0;i<numballs;i++){\n        if(i!=currentBall){\n            vec3 ballcast = Balls[i].xzy;\n            float beamA = linePointLength(ballcast, lightA, vec3(uv.x, height, uv.y));\n            float beamB = linePointLength(ballcast, lightB, vec3(uv.x, height, uv.y));\n            float beamC = linePointLength(ballcast, lightC, vec3(uv.x, height, uv.y)); \n               \n            if (beamC>(radius)){Ctotal+=1;} else if ((radius-beamC) > Cmost) {Cmost = radius-beamC;}\n\n            if (beamA>(radius)){ Atotal+=1;} else {\n                if ((radius-beamA) > Amost) {Amost = radius-beamA;}\n                if (height>0.0  && (uv.x>Balls[i].x) ){ Acast = true; AcastDepth=radius-beamA;}\n            }\n\n            if (beamB>(radius)){\n                Btotal+=1;\n            } else {\n                if ((radius-beamB) > Bmost) {Bmost = radius-beamB;}\n                if(height>0.0  && (uv.x<Balls[i].x) ){Bcast = true;BcastDepth=radius-beamB;}\n            }\n\n            }\n        }\n        float lcolAinc = lightA.y/(lightA.x-uv.x);\n        f = smoothstep(0.0, uv.x/40.0, lightAdist);\n        vec3 gacol = mix(gcol,gcol+(lcolA*-lcolAinc*1.2),  f);\n        tlightA = mix(vec3(0.0,0.0,0.0),tlightA,  f);\n        if(Atotal==10){\n            \n            gcol = gacol;\n        }  else {\n            Amost *=100.0;\n            f = smoothstep(0.2 + (dist-radius)*10.0, 0.0, Amost);\n            gcol = mix(gcol,gacol,  f);\n            if(Acast){\n                f = smoothstep(0.0, 0.01, AcastDepth);\n                tlightA = mix(tlightA,vec3(0.0,0.0,0.0),  f);\n            }\n        }\n        \n        float lcolBinc = lightB.y/(lightB.x-uv.x);\n        f = smoothstep(0.0, (ar-uv.x)/40.0, lightBdist);\n        vec3 gbcol = mix(gcol,gcol+(lcolB*lcolBinc*1.2),  f);\n        tlightB = mix(vec3(0.0,0.0,0.0),tlightB,  f);\n        if(Btotal==10){\n            \n            gcol = gbcol;\n        }  else {\n            Bmost *=100.0;\n            f = smoothstep(0.2 + (dist-radius)*10.0, 0.0, Bmost);\n            gcol = mix(gcol,gbcol,  f);\n            if(Bcast){\n                f = smoothstep(0.0, 0.01, BcastDepth);\n                tlightB = mix(tlightB,vec3(0.0,0.0,0.0),  f);\n            }\n        }\n        \n    vec3 VA = vec3(lightC.x-uv.x, lightC.y, lightC.z-uv.y);\n    vec3 VB = vec3(0.0, 1.0, 0.0);\n    VA = VA/length(VA);\n    float lcolCinc = dot(VB,VA );\n    if(Ctotal==10 ||  dist < (radius-pixel)){    \n        gcol = gcol+(lcolC*lcolCinc*1.2);\n    }  else if(dist > (radius-pixel)) {\n        Cmost *=80.0;\n        f = smoothstep(0.4 + (dist-radius)*5.0, 0.0, Cmost);\n        gcol = mix(gcol, gcol+(lcolC*lcolCinc*1.2), f);\n    }\n\n}\n\n// OLDER SHADER\n\nvec3 colourGround = vec3(0.820,0.820,0.820);\nvec3 colourPaint  = vec3(0.420,0.420,0.420);\nvec3 colourTeamA  = vec3(0.839,0.000,0.000);\nvec3 colourTeamB  = vec3(0.212,0.800,0.000);\nvec3 colourLight = vec3(1.000,1.000,1.000);\nvec3 colourAmbient = vec3(0.188,0.188,0.188);\nvec2 centre;\nfloat radius;\nfloat pixel;\n\nvec2 tanLineDist( in vec2 C, in float r, in vec2 P, in vec2 F){\n    C.y = -C.y;\n    vec2 d = P-C;\n    vec2 dr = vec2(-d.y, d.x);\n    float dl = length(d);\n    //if(dl>=r){\n        float rho = r/dl;\n        float ad = rho*rho;\n        float bd = rho*sqrt(1.0-ad);//*(1.0-rho)); // (1-rho)*(1-rho) ?\n        vec2 T1 = vec2(C.x + ad*d.x + bd*dr.x, C.y + ad*d.y + bd*dr.y);\n        vec2 T2 = vec2(C.x + ad*d.x - bd*dr.x, C.y + ad*d.y - bd*dr.y);\n\n    //}\n    float ax = T1.x-P.x;\n    float by = P.y-T1.y;\n    float c = (T1.y*P.x)-(T1.x*P.y);\n\n    float ax2 = T2.x-P.x;\n    float by2 = P.y-T2.y;\n    float c2 = (T2.y*P.x)-(T2.x*P.y);\n\n    return  vec2((F.x*-ax)- (F.y*-by)-c, (F.x*-ax2)- (F.y*-by2)-c2);\n}\n\nvec3 getGroundTexture( in vec2 p, in float ar , in float pmult)\n{\n    float gpixel = pixel*pmult*1.2;\n    float lineWidth = 1.0/180.0;\n    float f ;\n    vec2 pn = vec2((p.x-(0.5*ar)), p.y-0.5);\n    vec3 gcol = colourGround;\n    \n    float lpn = length(pn);\n    float bdist = sdBox(pn, vec2(ar/2.0, 0.5));\n    if(bdist<=0.0-lineWidth){\n        if(bdist >= -lineWidth*2.0){\n            gcol = colourPaint;\n        }\n        \n        if(lpn>(0.2-gpixel)-lineWidth){\n            if(lpn<0.2){\n                f = smoothstep((0.2-gpixel), .2 , lpn);\n                gcol = mix(colourPaint,colourGround,  f);\n                f = smoothstep(0.2-lineWidth, (0.2-gpixel)-lineWidth , lpn);\n                gcol = mix(gcol,colourGround,  f);\n            }\n        if(abs(pn.x)<=lineWidth/2.0 && lpn>=0.19){\n                gcol = colourPaint;\n            }\n        }\n        \n    }\n    \n    gcol = gcol*colourAmbient;\n    float TAdist = sdBox(vec2(pn.x+(0.5*ar), pn.y), vec2(0.0, 0.15));\n    gcol = gcol*(1.0+(colourTeamA/sqrt(TAdist*50.0)));\n\n    float modRadius = radius;//*(1.0/pow((pn.x+(0.5*ar)), 2.0));\n\n    vec2 isInLight = tanLineDist(centre, modRadius, vec2(ar, -0.65), -p.yx);\n    vec2 isInLight2 = tanLineDist(centre, modRadius, vec2(ar, -0.35), -p.yx);\n    \n    float TBdist = sdBox(vec2(pn.x-(0.5*ar), pn.y), vec2(0.0, 0.15));\n    float inLight= 0.0;\n    \n    if(isInLight.y>=0.0 || isInLight2.y<=0.0){\n        inLight=1.0;} else {\n            inLight= 1.0/(abs(isInLight2.y)/abs(isInLight.y) +1.0);\n        }\n\n    float inLight2= 0.0;\n    \n    if(isInLight.x>=0.0 || isInLight2.x<=0.0){\n        inLight2=1.0;} else {\n            inLight2= 1.0/(abs(isInLight.x)/abs(isInLight2.x) +1.0);\n        } \n\n    if(isInLight.y>=0.0 && isInLight2.x<=0.0){ inLight=0.0;}\n    if(isInLight.y<=0.0 && isInLight2.x>=0.0){ \n        float inLightCross = (inLight+inLight2);\n        inLight=inLight2 = inLightCross;\n\n        \n\n    }\n\n    inLight = min(inLight, inLight2);\n    if(isInLight.y>0.0 && isInLight2.x<=0.0  && (isInLight.x>0.0 || isInLight2.y<0.0)){inLight=1.0;}\n    f = smoothstep(0.0, 1.0,inLight);\n    gcol = mix(gcol,gcol*( 1.0+(colourTeamB/sqrt(TBdist*50.0))),  f);\n\n\n    if(p.x<0.0||p.y<0.0||p.x>1.0*ar||p.y>1.0){gcol = vec3(0.0,0.0,0.0);}\n    gcol = gcol*(2.0+(colourLight/(sqrt(lpn+0.2)/1.2)));\n    //gcol.b *= pn.x*ar;\n    return gcol;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    float border = 0.1;\n    vec2 guv = uv * (1.0 + border*2.0);\n    guv.x -= border*ar;\n    guv.y -= border;\n    vec3 col = vec3(0.0,0.0,0.0);\n    col = getGroundTexture(guv, ar, 1.0);\n    pixel = 1.0/iResolution.y;\n    \n    radius = 0.06;// + (iMouse.y/iResolution.y)/10.0;\n    \n    vec2 guv2 = guv + pixel;\n    centre = vec2((iMouse.x/iResolution.y),iMouse.y/iResolution.y);\n    centre = centre * (1.0 + border*2.0); centre.x -= border*ar; centre.y -= border;\n    vec2 distv = guv.xy - centre;\n    vec2 distv2 = guv2.xy - centre;\n    float dist = length(distv);\n    float dist2 = length(distv2);\n    float height = sqrt((radius*radius)-(dist*dist));\n    float height2 = sqrt((radius*radius)-(dist2*dist2));\n    vec3 position = vec3(guv.x, height, guv.y);\n    vec3 position2 = vec3(guv2.x, height2, guv2.y);\n    vec3 normal = vec3(distv.x, height, distv.y)/radius;\n    vec3 normal2 = vec3(distv2.x, height2, distv2.y)/radius;\n    vec3 incident = vec3(0.0, -1.0, 0.0);\n    vec3 reflection = reflect(incident, normal);\n    vec3 reflection2 = reflect(incident, normal2);\n    vec3 q = position + reflection * 100.0;\n    vec3 q2 = position2 + reflection2 * 100.0;\n\n    float a = 0.0;\n    float b = -1.0;\n    float c = 0.0;\n    float d = 0.0;\n    bool intersects;\n    bool intersects2;\n    vec3 intersection;\n    vec3 intersection2;\n    float t;\n    float f;\n    vec2 box;\n    vec2 boxposition;\n    float boxdist;\n    float bdist;\n    float tDenom = a*(q.x-position.x) + b*(q.y-position.y) + c*(q.z-position.z);\n    if (tDenom < 0.1) {\n        intersects = false;\n    } else {\n        t = - ( a*position.x + b*position.y + c*position.z - d ) / tDenom;\n        intersects = true;\n        intersection = vec3((position.x+t*(q.x-position.x)),(position.y+t*(q.y-position.y)),(position.z+t*(q.z-position.z)));\n    }\n    if(dist<radius){\n    col = vec3(0.6,0.6,0.8);\n    box = vec2(0.5*ar,0.5);\n    boxposition = vec2(0.5*ar, 0.5);\n    boxdist = sdBox(boxposition-intersection.xz, box);\n    vec2 intersectionoffset = vec2(boxposition.x - box.x/2.0, boxposition.y - box.y/2.0);\n    bdist = distance(position, intersection);\n    float bdistpix = iResolution.y * bdist;\n    if(intersects){\n        f = smoothstep(-pixel*4.0*sqrt(bdistpix), pixel*4.0*sqrt(bdistpix) , boxdist);\n        \n        vec3 greflection = vec3(reflection.x, 0.0, reflection.z);\n        float gangle = dot(reflection, greflection);\n        vec3 groundcol = getGroundTexture(vec2(intersection.x,intersection.z), ar, 1.5*gangle*(5.0+bdist));//texture(iChannel1, vec2(intersection.x,intersection.z)).rgb;\n        \n        col = mix((groundcol+col)/2.0,col,  f);\n\n       \n    }\n}\n\n    a = 1.0;\n    b = 0.0;\n    c = 0.0;\n    d = ar;\n    tDenom = a*(q.x-position.x) + b*(q.y-position.y) + c*(q.z-position.z);\n    float tDenom2 = a*(q2.x-position2.x) + b*(q2.y-position2.y) + c*(q2.z-position2.z);\n\n    \n    if (tDenom < 0.01) {\n        intersects = false;\n    } else {\n        t = - ( a*position.x + b*position.y + c*position.z - d ) / tDenom;\n        intersects = true;\n        intersection = vec3((position.x+t*(q.x-position.x)),(position.y+t*(q.y-position.y)),(position.z+t*(q.z-position.z)));\n        if (tDenom2 < 0.01) {\n            intersects2 = false;\n        } else {\n            intersects2 = true;\n            t = - ( a*position2.x + b*position2.y + c*position2.z - d ) / tDenom2;\n            intersection2 = vec3((position2.x+t*(q2.x-position2.x)),(position2.y+t*(q2.y-position2.y)),(position2.z+t*(q2.z-position2.z)));\n        }\n    }\n    box = vec2(0.15,0.15);\n    boxposition = vec2(0.15, 0.5);\n    \n    boxdist = sdBox(boxposition-intersection.yz, box);\n    bdist = distance(intersection2, intersection);\n\n\n    if(intersects && boxdist<bdist){\n        f = smoothstep(0.0, bdist , boxdist);\n\n        col = mix((colourTeamB+col),col,  f);\n    }\n\n\n    vec3 ground = getGroundTexture(guv, ar, 1.0);\n\t//Smoothes the edge of the sphere\n\tfloat g = smoothstep(radius-pixel*3.0, radius-pixel, dist);\n\tvec3 fcol = mix( col,ground, g);\n\n    \n    fcol *= fcol;\nfcol = contrast(fcol);\n\n    \n    fragColor = vec4(fcol,1.0);\n}\n*/",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lc3yD8",
    "date": "0",
    "viewed": 0,
    "name": "Four shades of light 2",
    "description": "first attempt at shader for game jam",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "game",
     "gamejam",
     "raylib",
     "8colourpalette"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsBSR3",
       "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define numnodes 12\n#define numjoins 4\nfloat sdLine(in vec2 iPoint, in vec2 iLine0, in vec2 iLine1) {\n\tvec2 diff = iPoint - iLine0;\n\tvec2 dir = iLine1 - iLine0;\n\tfloat t = dot(diff, dir) / dot(dir,dir);\n\tt = clamp(t, 0.0, 1.0);\n\tvec2 oLinePoint = t * dir + iLine0;\n    vec2 diff2 = iPoint - oLinePoint;\n\treturn dot(diff2, diff2);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    \n    float size = 1./40.;\n    float border = 1./100.;\n    \n    vec3 light = vec3 (0.0);\n    \n    vec4 rand = texelFetch(iChannel0,(ivec2(fragCoord)+iFrame*ivec2(17,113))&1023,0);\n    \n    vec3 colours[8];\n    colours[0] = vec3(1.0, 0.0, 0.0);\n    colours[1] = vec3(0.0, 1.0, 0.0);\n    colours[2] = vec3(0.0, 1.0, 1.0);\n    colours[3] = vec3(1.0, 0.0, 1.0);\n    colours[4] = vec3(1.0, 1.0, 0.0);\n    colours[5] = vec3(0.0, 0.0, 1.0);\n    colours[6] = vec3(0.0, 0.0, 0.0);\n    colours[7] = vec3(1.0, 1.0, 1.0);\n    \n    int coloursint[8] = int[8](7,4,2,1,3,0,5,6);\n    \n    struct Node\n    {\n        int col;\n        int col2;\n        vec2 pos;\n        bool ison;\n    };\n    \n    \n    struct Join\n    {\n        int a;\n        int b;\n    };\n    \n    Join Joins[numjoins];\n    \n    Joins[0] = Join( 10, 4);\n    Joins[1] = Join( 4, 5);\n    Joins[2] = Join( 5, 0);\n    Joins[3] = Join( 1, 6);\n    \n    Node Nodes[numnodes];\n    \n    Nodes[0] = Node( 0, 4, vec2(0.45, 0.35), true);\n    Nodes[1] = Node( 1, 4, vec2(0.6, 0.4), true);\n    Nodes[2] = Node( 5, 2, vec2(0.8, 0.3), true);\n    Nodes[3] = Node( 3, 5, vec2(0.7, 0.4), true);\n    Nodes[4] = Node( 1, 4, vec2(0.2, 0.35), true);\n    Nodes[5] = Node( 5, 2, vec2(0.35, 0.3), true);\n    Nodes[6] = Node( 0, 4, vec2(0.5, 0.65), false);\n    Nodes[7] = Node( 1, 4, vec2(0.6, 0.75), false);\n    Nodes[8] = Node( 5, 2, vec2(0.8, 0.65), false);\n    Nodes[9] = Node( 3, 5, vec2(0.7, 0.75), false);\n    Nodes[10] = Node( 1, 4, vec2(0.25, 0.85), false);\n    Nodes[11] = Node( 5, 2, vec2(0.35, 0.65), false);   \n    \n    bool isnode = false;\n    bool isborder = false;\n    bool isline = false;\n    int thisnode = -1;\n    int nearest = -1;\n    float dist = 1.;\n    vec2 txc = fragCoord;\n    bool yodd = false;\n    bool xodd = false;\n    bool fodd = false;\n    if (mod(txc.x, 2.) < 1.){xodd = false;}else{xodd = true;}\n    if (mod(txc.y, 2.) < 1.){yodd = false;}else{yodd = true;}\n    if (mod(float(iFrame), 2.) < 1.){fodd = false;}else{fodd = true;}\n    \n    for(int i=0;i<numnodes;i++){\n        Nodes[i].pos.x*=ar;\n        float tdist = distance(uv, Nodes[i].pos);\n        if(tdist<dist){\n            dist=tdist;\n            nearest=i;\n            if (tdist<size+border) {\n                isnode=true;\n                thisnode=i;\n                if((tdist)>size){isborder=true;}\n            }\n        }\n        vec3 primary = colours[Nodes[i].col];\n        vec3 secondary = colours[coloursint[int(floor((tdist*tdist*150.)+0.5))]];\n        vec3 tertiary = colours[Nodes[i].col2];\n        // Add light value\n        if(Nodes[i].ison&&tdist<0.25){\n            if(((yodd!=xodd)&&!fodd)||(yodd==xodd&&fodd)){\n                if(rand.x +rand.y+rand.z>sqrt(tdist*60.)){\n                    light += primary;\n                } else if(rand.x +rand.y+rand.z>sqrt(tdist*55.)){\n                    light += secondary;\n                } else if(rand.x +rand.y+rand.z>sqrt(tdist*50.)){\n                    light += tertiary;\n                }\n            }\n        }\n\n    }\n    \n\n    vec3 ncol = colours[Nodes[nearest].col];\n    vec3 col = vec3(0.);\n    \n    for(int j=0;j<numjoins;j++){\n        if(sqrt(sdLine(uv, Nodes[Joins[j].a].pos, Nodes[Joins[j].b].pos))<border){\n            if(!(((yodd!=xodd)&&!fodd)||(yodd==xodd&&fodd))){\n                col = vec3(1.);\n            }\n            isline = true;\n        }\n    }\n    if(isnode){\n        col = vec3(1.);\n        if(((yodd!=xodd)&&!fodd)||(yodd==xodd&&fodd)){\n            if(dist>size-border){\n            col=ncol;\n            \n            }\n        }\n        \n        if(isborder||!Nodes[thisnode].ison){\n        col=ncol;\n\n        }\n        if((!Nodes[thisnode].ison)&&(((yodd!=xodd)&&!fodd)||(yodd==xodd&&fodd))){\n            col=vec3(0.);\n        }\n    } else {\n        \n\n            col = col+light;\n\n    }\n    \n\n    \n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4ftyDN",
    "date": "1730675155",
    "viewed": 113,
    "name": "Temporal pixel dither v1",
    "description": "Tracks the RGB channels of each pixel over time and assign one of the limited palette colours, so the average RGB output is the same\nLeft is temporal only, right is spatial and temporal\nClick to round up and prevent near white/black flashing.",
    "likes": 0,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "dithering",
     "8colourpalette"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dfGRn",
       "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainB1(out vec4 color, in vec2 coord) {\n    vec4 colA = texture(iChannel0, coord/iResolution.xy);\n    vec4 colB = texelFetch(iChannel1, ivec2(coord), 0);\n    if(iMouse.z>0.){\n        colA = thresh(colA);\n    }\n    vec3 colx = colA.rgb+colB.rgb;\n    if(colx.r>=1.){color.r = 1.0;} else {color.r = 0.;}\n    if(colx.g>=1.){color.g = 1.0;} else {color.g = 0.;}\n    if(colx.b>=1.){color.b = 1.0;} else {color.b = 0.;}\n}\n\nvoid mainB2(out vec4 color, in vec2 coord) {\n    bool xodd = true; if (mod(coord.x, 2.) < 1.){xodd = false;}\n    bool yodd = true; if (mod(coord.y, 2.) < 1.){yodd = false;}\n    vec2 coords[4];\n    int current = 0;\n    coords[0] = coord;\n    coords[1] = coord;\n    coords[2] = coord;\n    coords[3] = coord;\n    if(yodd&&xodd){\n        coords[1].x += 1.;\n        coords[2].x += 1.;\n        coords[2].y += 1.;\n        coords[3].y += 1.;\n    } else if(yodd){\n        current = 1;\n        coords[0].x -= 1.;\n        coords[2].y += 1.;\n        coords[3].y += 1.;\n        coords[3].x -= 1.;\n    } else if(xodd){\n        current = 3;\n        coords[0].y -= 1.;\n        coords[1].y -= 1.;\n        coords[1].x += 1.;\n        coords[2].x += 1.;\n    } else {\n        current = 2;\n        coords[0].y -= 1.;\n        coords[0].x -= 1.;\n        coords[1].y -= 1.;\n        coords[3].x -= 1.;\n    }\n    vec4 cols[4];\n    cols[0] = texture(iChannel0, coords[0]/iResolution.xy);\n    cols[1] = texture(iChannel0, coords[1]/iResolution.xy);\n    cols[2] = texture(iChannel0, coords[2]/iResolution.xy);\n    cols[3] = texture(iChannel0, coords[3]/iResolution.xy);\n    \n    if(iMouse.z>0.){\n        cols[0] = thresh(cols[0]);\n        cols[1] = thresh(cols[1]);\n        cols[2] = thresh(cols[2]);\n        cols[3] = thresh(cols[3]);\n    }\n\n    vec4 colB = texelFetch(iChannel1, ivec2(coords[current]), 0);\n    \n    vec4 outputs[4];\n    \n    outputs[0] = getunits(cols[0]+colB);\n    outputs[1] = getunits(cols[1]+getrem(cols[0]+colB));\n    outputs[2] = getunits(cols[2]+getrem(cols[1]+getrem(cols[0]+colB)));\n    outputs[3] = getunits(cols[3]+getrem(cols[2]+getrem(cols[1]+getrem(cols[0]+colB))));\n    \n    color = outputs[current];\n    color.a = 1.;\n\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n    if(coord.x<iResolution.x/2.){\n        mainB1(color, coord);\n    }else{\n        mainB2(color, coord);\n    }\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dfGRn",
       "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainA1(out vec4 color, in vec2 coord) {    \n    vec4 colA = texture(iChannel0, coord/iResolution.xy);\n    vec4 colB = texelFetch(iChannel1, ivec2(coord), 0);\n    if(iMouse.z>0.){\n        colA = thresh(colA);\n    }\n    vec3 colx = colA.rgb+colB.rgb;\n    color.r = mod(colx.r, 1.);\n    color.b = mod(colx.b, 1.);\n    color.g = mod(colx.g, 1.);\n}\n\nvoid mainA2(out vec4 color, in vec2 coord) {\n    bool xodd = true; if (mod(coord.x, 2.) < 1.){xodd = false;}\n    bool yodd = true; if (mod(coord.y, 2.) < 1.){yodd = false;}\n    vec2 coords[4];\n    int current = 0;\n    coords[0] = coord;\n    coords[1] = coord;\n    coords[2] = coord;\n    coords[3] = coord;\n    if(yodd&&xodd){\n        coords[1].x += 1.;\n        coords[2].x += 1.;\n        coords[2].y += 1.;\n        coords[3].y += 1.;\n    } else if(yodd){\n        current = 1;\n        coords[0].x -= 1.;\n        coords[2].y += 1.;\n        coords[3].y += 1.;\n        coords[3].x -= 1.;\n    } else if(xodd){\n        current = 3;\n        coords[0].y -= 1.;\n        coords[1].y -= 1.;\n        coords[1].x += 1.;\n        coords[2].x += 1.;\n    } else {\n        current = 2;\n        coords[0].y -= 1.;\n        coords[0].x -= 1.;\n        coords[1].y -= 1.;\n        coords[3].x -= 1.;\n    }\n    vec4 cols[4];\n    cols[0] = texture(iChannel0, coords[0]/iResolution.xy);\n    cols[1] = texture(iChannel0, coords[1]/iResolution.xy);\n    cols[2] = texture(iChannel0, coords[2]/iResolution.xy);\n    cols[3] = texture(iChannel0, coords[3]/iResolution.xy);\n    \n    if(iMouse.z>0.){\n        cols[0] = thresh(cols[0]);\n        cols[1] = thresh(cols[1]);\n        cols[2] = thresh(cols[2]);\n        cols[3] = thresh(cols[3]);\n    }\n    \n    vec4 colB = texelFetch(iChannel1, ivec2(coords[current]), 0);\n    \n    vec4 outputs[4];\n    \n    outputs[0] = getunits(cols[0]+colB);\n    outputs[1] = getunits(cols[1]+getrem(cols[0]+colB));\n    outputs[2] = getunits(cols[2]+getrem(cols[1]+getrem(cols[0]+colB)));\n    outputs[3] = getunits(cols[3]+getrem(cols[2]+getrem(cols[1]+getrem(cols[0]+colB))));\n    \n    color = getrem(cols[3]+getrem(cols[2]+getrem(cols[1]+getrem(cols[0]+colB))));\n\n    color.a=1.;\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n    if(coord.x<iResolution.x/2.){\n        mainA1(color, coord);\n    }else{\n        mainA2(color, coord);\n    }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec4 thresh(in vec4 col){\n        float t = 0.07;\n        float tu = 0.92;\n        if(col.r<t&&col.g<t&&col.b<t){col=vec4(0.,0.,0.,1.);}\n        if(col.r>tu&&col.g>tu&&col.b>tu){col=vec4(1.,1.,1.,1.);}\n        return col;\n}\n\nvec4 getunits(in vec4 col){\n    vec4 ocol = vec4(1.);\n    if(col.r>=1.){ocol.r = 1.0;} else {ocol.r = 0.;}\n    if(col.g>=1.){ocol.g = 1.0;} else {ocol.g = 0.;}\n    if(col.b>=1.){ocol.b = 1.0;} else {ocol.b = 0.;}\n    return ocol;\n}\n\nvec4 getrem(in vec4 col){\n    vec4 ocol = vec4(1.);\n    ocol.r = mod(col.r, 1.);\n    ocol.b = mod(col.b, 1.);\n    ocol.g = mod(col.g, 1.);\n    return ocol;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lctyRB",
    "date": "0",
    "viewed": 0,
    "name": "Temporal pixel dither v2",
    "description": "Tracks the RGB channels of each pixel over time and assign one of the limited palette colours, so the average RGB output is the same\nLeft is temporal only, right is spatial and temporal\nClick to round up and prevent near white/black flashing.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "dithering",
     "8colourpalette"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dfGRn",
       "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
       "type": "texture",
       "channel": 3,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainB1(out vec4 color, in vec2 coord) {\n    vec4 colA = texture(source, coord/iResolution.xy);\n    vec4 colB = texelFetch(iChannel2, ivec2(coord), 0);\n    colA = thresh(colA);\n    vec3 colx = colA.rgb+colB.rgb;\n    if(colx.r>=1.){color.r = 1.0;} else {color.r = 0.;}\n    if(colx.g>=1.){color.g = 1.0;} else {color.g = 0.;}\n    if(colx.b>=1.){color.b = 1.0;} else {color.b = 0.;}\n}\n\nvoid mainB2(out vec4 color, in vec2 coord) {\n    bool xodd = true; if (mod(coord.x, 2.) < 1.){xodd = false;}\n    bool yodd = true; if (mod(coord.y, 2.) < 1.){yodd = false;}\n    vec2 coords[4];\n    int current = 0;\n    coords[0] = coord;\n    coords[1] = coord;\n    coords[2] = coord;\n    coords[3] = coord;\n    if(yodd&&xodd){\n        coords[1].x += 1.;\n        coords[2].x += 1.;\n        coords[2].y += 1.;\n        coords[3].y += 1.;\n    } else if(yodd){\n        current = 1;\n        coords[0].x -= 1.;\n        coords[2].y += 1.;\n        coords[3].y += 1.;\n        coords[3].x -= 1.;\n    } else if(xodd){\n        current = 3;\n        coords[0].y -= 1.;\n        coords[1].y -= 1.;\n        coords[1].x += 1.;\n        coords[2].x += 1.;\n    } else {\n        current = 2;\n        coords[0].y -= 1.;\n        coords[0].x -= 1.;\n        coords[1].y -= 1.;\n        coords[3].x -= 1.;\n    }\n    vec4 cols[4];\n    cols[0] = texture(source, coords[0]/iResolution.xy);\n    cols[1] = texture(source, coords[1]/iResolution.xy);\n    cols[2] = texture(source, coords[2]/iResolution.xy);\n    cols[3] = texture(source, coords[3]/iResolution.xy);\n        cols[0] = thresh(cols[0]);\n        cols[1] = thresh(cols[1]);\n        cols[2] = thresh(cols[2]);\n        cols[3] = thresh(cols[3]);\n\n    vec4 colB = texelFetch(iChannel1, ivec2(coords[current]), 0);\n    \n    vec4 outputs[4];\n    \n    outputs[0] = getunits(cols[0]+colB);\n    outputs[1] = getunits(cols[1]+getrem(cols[0]+colB));\n    outputs[2] = getunits(cols[2]+getrem(cols[1]+getrem(cols[0]+colB)));\n    outputs[3] = getunits(cols[3]+getrem(cols[2]+getrem(cols[1]+getrem(cols[0]+colB))));\n    \n    color = outputs[current];\n\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n    //color = texelFetch(iChannel1, ivec2(coord), 0);\n    bool xodd = true; if (mod(coord.x, 2.) < 1.){xodd = false;}\n    bool yodd = true; if (mod(coord.y, 2.) < 1.){yodd = false;}\n    bool fodd = true; if (mod(float(iFrame), 2.) < 1.){fodd = false;}\n    if((xodd&&yodd)||(!xodd&&!yodd)){\n        if(fodd){mainB1(color, coord);}else{mainB2(color, coord);}\n    }else{\n        if(fodd){mainB2(color, coord);}else{mainB1(color, coord);}\n    }\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dfGRn",
       "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
       "type": "texture",
       "channel": 3,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainA2(out vec4 color, in vec2 coord) {\n    bool xodd = true; if (mod(coord.x, 2.) < 1.){xodd = false;}\n    bool yodd = true; if (mod(coord.y, 2.) < 1.){yodd = false;}\n    vec2 coords[4];\n    int current = 0;\n    coords[0] = coord;\n    coords[1] = coord;\n    coords[2] = coord;\n    coords[3] = coord;\n    if(yodd&&xodd){\n        coords[1].x += 1.;\n        coords[2].x += 1.;\n        coords[2].y += 1.;\n        coords[3].y += 1.;\n    } else if(yodd){\n        current = 1;\n        coords[0].x -= 1.;\n        coords[2].y += 1.;\n        coords[3].y += 1.;\n        coords[3].x -= 1.;\n    } else if(xodd){\n        current = 3;\n        coords[0].y -= 1.;\n        coords[1].y -= 1.;\n        coords[1].x += 1.;\n        coords[2].x += 1.;\n    } else {\n        current = 2;\n        coords[0].y -= 1.;\n        coords[0].x -= 1.;\n        coords[1].y -= 1.;\n        coords[3].x -= 1.;\n    }\n    vec4 cols[4];\n    cols[0] = texture(source, coords[0]/iResolution.xy);\n    cols[1] = texture(source, coords[1]/iResolution.xy);\n    cols[2] = texture(source, coords[2]/iResolution.xy);\n    cols[3] = texture(source, coords[3]/iResolution.xy);\n    \n    cols[0] = thresh(cols[0]);\n    cols[1] = thresh(cols[1]);\n    cols[2] = thresh(cols[2]);\n    cols[3] = thresh(cols[3]);\n    \n    vec4 colB = texelFetch(iChannel1, ivec2(coords[current]), 0);\n    \n    vec4 outputs[4];\n    \n    outputs[0] = getunits(cols[0]+colB);\n    outputs[1] = getunits(cols[1]+getrem(cols[0]+colB));\n    outputs[2] = getunits(cols[2]+getrem(cols[1]+getrem(cols[0]+colB)));\n    outputs[3] = getunits(cols[3]+getrem(cols[2]+getrem(cols[1]+getrem(cols[0]+colB))));\n    \n    color = getrem(cols[3]+getrem(cols[2]+getrem(cols[1]+getrem(cols[0]+colB))));\n    \n\n\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n\n    mainA2(color, coord);\n\n    if(color.g<0.){color.g=0.;}\n    if(color.r<0.){color.r=0.;}\n    if(color.b<0.){color.b=0.;}\n        color.a=1.;\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define source iChannel0\nvec4 thresh(in vec4 col){\n        float t = 0.07;\n        float tu = 0.92;\n        if(col.r<t&&col.g<t&&col.b<t){col=vec4(0.,0.,0.,1.);}\n        if(col.r>tu&&col.g>tu&&col.b>tu){col=vec4(1.,1.,1.,1.);}\n        return col;\n}\n\nvec4 getunits(in vec4 col){\n    vec4 ocol = vec4(1.);\n    if(col.r>=1.){ocol.r = 1.0;} else {ocol.r = 0.;}\n    if(col.g>=1.){ocol.g = 1.0;} else {ocol.g = 0.;}\n    if(col.b>=1.){ocol.b = 1.0;} else {ocol.b = 0.;}\n    return ocol;\n}\n\nvec4 getrem(in vec4 col){\n    vec4 ocol = vec4(1.);\n    ocol.r = mod(col.r, 1.);\n    ocol.b = mod(col.b, 1.);\n    ocol.g = mod(col.g, 1.);\n    return ocol;\n}\n#define numrobs 11\n#define numlights 6\n#define numjoins 4\n#define black vec3(0.0,0.0,0.0)\n#define white vec3(1.0,1.0,1.0)\n#define grey vec3(0.5,0.5,0.5)\n#define blue vec3(0.0,0.0,1.0)\n#define red vec3(1.0,0.0,0.0)\n#define lime vec3(0.0,1.0,0.0)\n#define green vec3(0.0,0.7,0.0)\n#define cyan vec3(0.0,1.0,1.0)\n#define purple vec3(1.0,0.0,1.0)\n#define yellow vec3(1.0,1.0,0.0)\n#define orange vec3(1.0,0.6,0.0)\n\n#define porange vec3(1.0,0.8,0.6)\n#define pyellow vec3(0.87,0.87,0.7)\n#define pblue vec3(0.8,0.85,1.0)\n#define pgreen vec3(0.7,0.9,0.7)\n#define pink vec3(0.95,0.75,0.75)\n#define ppurple vec3(1.0,0.7,1.0)\n#define pgrey vec3(0.85,0.85,0.85)\n\n// declared here for use in functions\nfloat pixel = 0.0;\nvec4 courtprox = vec4(0.0);\nvec2 uv = vec2(0.0);\nfloat ar = 0.0;\nfloat f = 0.0; // AA mixing number\nfloat border = 0.05;\nfloat bar = 1.0;\n    struct Join\n    {\n        int a;\n        int b;\n    };\n    \n\nstruct light\n{\n    vec3 colour;\n    vec3 position;\n    vec3 difference;\n    vec3 amount;\n    vec2 shadow;\n    float dist;\n    float intensity;\n};\n\nstruct Rob // Round Object. (Players and Ball)\n{\n    vec3 position;\n    vec3 colourA;\n    vec3 colourB;\n    float rotation;\n    float radius;\n};\n\nvec3 getGroundColour(){\n\n    vec3 rcol = pgrey;\n\n    return rcol;\n}\n\nbool outputMode = false; vec3 outputColour; // Easy way to throw a value at the output for debugging\nvoid outputValue (in float value){\n    outputMode = true;\n    if ( value >= 0.0 && value <= 1.0 )\n        { outputColour = vec3(value, value, value); }\n        else if ( value < 0.0 && value > -1.0 )\n        { outputColour = vec3(0.0, 0.0, -value ); }\n        else if ( value > 1.0 )\n        { outputColour = vec3(1.0-(1.0/value), 1.0, 0.0); }\n        else if ( value < -1.0 )\n        { outputColour = vec3(1.0-(1.0/-value), 0.0, 1.0); }\n} // Call outputValue with a float and that value will override the pixel output\nvoid outputValue (in vec3 value){outputMode = true;outputColour = value;} // or directly with a vec3\n\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 gammaCorrection (vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\n\nfloat linePointLength( in vec3 P, in vec3 A, in vec3 B ){\n    vec3 AB = B-A;\n    float lenAB = length(AB);\n    vec3 D = AB/lenAB;\n    vec3 AP = P-A;\n    float d = dot(D, AP);\n    vec3 X = A + D * dot(P-A, D);\n    if(X.z<0.0){return 10.0;} else {return length(X-P);}\n}\n\nvec3 linePoint( in vec3 P, in vec3 A, in vec3 B ){\n    vec3 AB = B-A;\n    float lenAB = length(AB);\n    vec3 D = AB/lenAB;\n    vec3 AP = P-A;\n    float d = dot(D, AP);\n    vec3 X = A + D * dot(P-A, D);\n    return X;\n}\n\n// SD Functions from https://iquilezles.org/articles/distfunctions2d/\nfloat sdLine(in vec2 iPoint, in vec2 iLine0, in vec2 iLine1) {\n\tvec2 diff = iPoint - iLine0;\n\tvec2 dir = iLine1 - iLine0;\n\tfloat t = dot(diff, dir) / dot(dir,dir);\n\tt = clamp(t, 0.0, 1.0);\n\tvec2 oLinePoint = t * dir + iLine0;\n    vec2 diff2 = iPoint - oLinePoint;\n\treturn dot(diff2, diff2);\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ){\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Copyright (c) 2024 John Cotterell johnmdcotterell@gmail.com\n// You may view and edit this code (with this message intact) only on Shadertoy.\n// Anything else requires my permission.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // GEOMETRY SETTINGS\n    // General\n    uv = fragCoord/iResolution.y;      // Normalised resolution\n    float height = 0.0;                     // This is the z value to go with our uv's x and y\n    ar = iResolution.x/iResolution.y; // Aspect ratio or normalised width\n    pixel = 1.4/iResolution.y;        // Size of pixel, for AA\n    // Zones. Not exclusive. We can be on more than one for purposes of AA mixing\n    bool ZoneRob = false;                  // Are we on the curved fg objects\n    bool ZoneGround = false;                // Are we on the ground\n    Rob Robs[numrobs];\n    float border = 1./100.;\n    float dist = ar; // distance to nearest foreground object\n    int rindex = -1; // index of object\n    vec2 centre = vec2(ar/2.0, 0.5); // centre of current object\n    float radius = 0.0; // radius of current object\n    float cradius = 0.34; // radius of circle\n    vec2 centreL = vec2((ar/2.0)-(cradius),0.5); // centre of left circle\n    vec2 centreR = vec2((ar/2.0)+(cradius),0.5); // centre of right circle\n    float segment = 1.256637; // ( 3.1415926 * 2.0 ) / 5.0;\n    float rightAng = 1.5708; // ( 3.1415926 * 2.0 ) / 4.0;\n    float dradius = 0.03; // default object radius\n    float bradius = 0.02; // ball radius\n    vec2 distv; // vector from current position to centre\n    vec3 normal = vec3(0.0,0.0,1.0); // normal of surface, default is normal of ground\n    vec3 bgnormal = vec3(0.0,0.0,1.0); // normal of walls or ground, default is normal of ground\n    float theight = 0.0;\n    float angle = 0.0;\n    float speed = iTime;\n    bool isLine = false;\n    \n    for(int i=1;i<numrobs;i++){\n        Robs[i].radius = dradius;\n        angle = float(i) * segment;\n        vec2 rcentre = centreL;\n        if(i>5){\n            angle += speed;\n            Robs[i].rotation = angle + rightAng;\n            rcentre = centreR;} else {\n                \n                angle -= speed;\n                Robs[i].rotation = angle - rightAng;\n            }\n        Robs[i].position = vec3( rcentre.x + (cradius * cos(angle)), rcentre.y + (cradius * sin(angle)), 0.0);\n        \n    }\n\n    Robs[1].colourA = red;\n    Robs[2].colourA = red;\n    Robs[3].colourA = blue;\n    Robs[4].colourA = blue;\n    Robs[5].colourA = purple;\n    Robs[6].colourA = purple;\n    Robs[7].colourA = green;\n    Robs[8].colourA = green;\n    Robs[9].colourA = cyan;\n    Robs[10].colourA = cyan;\n    \n    // COLOUR SETTINGS\n    vec3 bgcol; // final background colour\n    vec3 fgcol; // final foreground colour\n    vec3 col = white;   // final colour\n    vec2 robambient = vec2(1.0, 1.0); // the total Ambient effect of round objects. two vlaues for mixing foreground and bg\n    \n    light lights[numlights];\n    lights[0] = light(vec3(1.0,1.0,1.0),vec3(ar*0.5, 0.5 ,0.5),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.0);\n    lights[1] = light(vec3(1.0,0.4,0.4),vec3(ar*-0.04, 0.5 ,0.15),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.01);\n    lights[2] = light(vec3(0.4,1.0,0.4),vec3(ar*1.04, 0.5 ,0.15),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.01);\n    lights[3] = light(vec3(0.0,0.0,1.0),vec3(ar*1.04, 0.5 ,0.15),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.015);\n    lights[4] = light(vec3(1.0,0.0,1.0),vec3(ar*1.04, 0.5 ,0.15),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.01);\n    lights[5] = light(vec3(0.0,1.0,1.0),vec3(ar*1.04, 0.5 ,0.15),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.01);\n\n        ZoneGround = true;\n        bgcol = getGroundColour();\n        bgnormal = vec3(0.0,0.0,1.0);\n\n   \n    \n    \n    for(int i=1;i<numrobs;i++){\n        float bdist = distance(uv, Robs[i].position.xy);\n        if(bdist<dist){dist=bdist;}\n        \n        if(bdist<Robs[i].radius){\n            dist=bdist;\n            radius = Robs[i].radius;\n            height = sqrt((radius*radius)-(dist*dist));\n            ZoneRob = true;\n            rindex = i;\n\n            if(bdist<Robs[i].radius-pixel){ZoneGround = false;}\n        } else {\n            float edgedist = distance(uv, Robs[i].position.xy) + (Robs[i].position.z);\n            robambient *= 1.0 - (0.5 * pow(0.8/(edgedist/Robs[i].radius),3.0)); // ambient multiplier for outside of object\n        }\n        \n    }\n    \n    lights[1].position.xy = Robs[1].position.xy;\n    lights[2].position.xy = Robs[8].position.xy;\n    lights[3].position.xy = Robs[3].position.xy;\n    lights[4].position.xy = Robs[6].position.xy;\n    lights[5].position.xy = Robs[9].position.xy;\n    if(ZoneRob){\n        fgcol = Robs[rindex].colourA;\n        \n        \n        if(rindex==1||rindex==8){\n            \n            fgcol+=0.6;\n            fgcol*=1.7;\n        } else if(rindex==3||rindex==6||rindex==9){\n            \n            fgcol+=1.2;\n            fgcol*=1.2;\n        }\n        centre = vec2(Robs[rindex].position.x, Robs[rindex].position.y);\n        distv = uv - centre;\n        normal = vec3(distv.x, distv.y, height)/radius;\n        height+=Robs[rindex].position.z;\n        \n\n        \n        robambient *= (0.6 + normal.z/3.0);// ambient multiplier for inside of object\n        float rotation = Robs[rindex].rotation;\n\n        normal = normal/length(normal);\n    }\n    \n        \n    Join Joins[numjoins];\n    \n    Joins[0] = Join( 1, 2);\n    Joins[1] = Join( 2, 3);\n    Joins[2] = Join( 3, 4);\n    Joins[3] = Join( 4, 5);\n    \n    \n    if (ZoneGround) {\n        for(int j=0;j<numjoins;j++){\n            if(sqrt(sdLine(uv, Robs[Joins[j].a].position.xy, Robs[Joins[j].b].position.xy))<border){\n            //if(!(((yodd!=xodd)&&!fodd)||(yodd==xodd&&fodd))){\n                bgcol = vec3(0.7);\n            //}\n                isLine = true;\n            }\n        }\n    }\n    // calculate and multiply ambient\n\n    // these ambient calculations are an approximation based on proximity to walls, ground and objects\n    // it gives us a very rough but dynamic AO value\n    float ambientmulti = (min(0.7+(height*2.0), 1.0));// if you're on the ground, half of ambient light is removed\n    float ambiA = 1.0;float ambiB = 1.0; float ambiC = 0.5;\n    //ambientmulti *= sqrt((min(ambiC-(courtprox.w*ambiA), ambiB))*(min(ambiC-courtprox.z*ambiA, ambiB))*(min(ambiC-courtprox.y*ambiA, ambiB))*(min(ambiC-courtprox.x*ambiA, ambiB)));\n    // and again for each wall\n    ambientmulti = robambient.x*ambientmulti*ambientmulti;\n    \n    vec3 position = vec3(uv, height);\n    vec3 bgtot = vec3(0.0);\n    vec3 fgtot = vec3(0.0);\n    vec3 sptot = vec3(0.0);\n    for(int j=0;j<numlights;j++){\n        lights[j].difference = lights[j].position - position;\n        lights[j].dist = length(lights[j].difference);\n        lights[j].difference = lights[j].difference/lights[j].dist;\n        lights[j].amount.x = max(0.0, dot(lights[j].difference, normal));\n        lights[j].amount.x = lights[j].amount.x/(lights[j].dist*lights[j].dist);\n        lights[j].amount.y = max(0.0, dot(lights[j].difference, bgnormal));\n        lights[j].amount.y = lights[j].amount.y/(lights[j].dist*lights[j].dist);\n        lights[j].amount.y *= lights[j].intensity * (1.0-lights[j].shadow.x);\n        lights[j].amount.x *= lights[j].intensity * (1.0-lights[j].shadow.y);\n        bgtot += lights[j].colour*lights[j].amount.y;\n        fgtot += lights[j].colour*lights[j].amount.x;\n    }\n\n    bgcol*=ambientmulti+bgtot;\n    \n    if(ZoneRob){\n        // calculate and add specular\n        vec3 incident = vec3(0.0, 0.0, -1.0);\n        vec3 reflection = reflect(incident, normal);\n        for(int j=0;j<numlights;j++){\n            lights[j].amount.z = pow(max(0.0, dot(lights[j].difference, reflection)),8.0);\n            lights[j].amount.z = lights[j].amount.z/(lights[j].dist*lights[j].dist);\n            lights[j].amount.z *= lights[j].intensity * (1.0-lights[j].shadow.y);\n            sptot += lights[j].colour*lights[j].amount.z;\n        }\n    \n       fgcol *= ambientmulti+fgtot;\n        fgcol += sptot*2.; // Add specuialr highlight\n        \n\n    \n        // Assign forground or background colour or mix them if on AA border\n   \n        if(ZoneGround){\n            f = smoothstep(radius-pixel, radius, dist);\n            col = mix(fgcol,bgcol, f);\n        } else {\n            col = fgcol;\n        }\n    } else {\n        col = bgcol;\n\n    }\n    // Output to screen\n\n    f = smoothstep(0.0, iResolution.x, iMouse.x);\n    col = contrast(col, f+1.0);\n    if(iMouse.y!=0.0){\n        f = smoothstep(0.0, iResolution.y, iMouse.y);\n        col = gammaCorrection(col, 0.5 + f*2.0);\n    }\n    \n\n    if(outputMode){col = outputColour;}\n   \n    fragColor = vec4(col,1.0);\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dfGRn",
       "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
       "type": "texture",
       "channel": 3,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "void mainA1(out vec4 color, in vec2 coord) {    \n    vec4 colA = texture(source, coord/iResolution.xy);\n    vec4 colB = texelFetch(iChannel1, ivec2(coord), 0);\n    colA = thresh(colA);\n    vec3 colx = colA.rgb+colB.rgb;\n    color.r = mod(colx.r, 1.);\n    color.b = mod(colx.b, 1.);\n    color.g = mod(colx.g, 1.);\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n\n    mainA1(color, coord);\n\n    if(color.g<0.){color.g=0.;}\n    if(color.r<0.){color.r=0.;}\n    if(color.b<0.){color.b=0.;}\n        color.a=1.;\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lccczX",
    "date": "1730947028",
    "viewed": 71,
    "name": "Color Map 4096",
    "description": "Mapping all the colours to 2D coordinates, 16 levels of each colour for 4096 total colors.\nUseful for testing dithering",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "color",
     "rgb",
     "colormap",
     "colour",
     "dithering",
     "colourmap"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsBSR3",
       "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/*\n this code is for use (reading, review, execution, forking, modifying, copy, paste or re-use)\n on shadertoy only, unless explicit permission is granted by it's author\n and/or a commercial license is agreed with it's author\n use of the code for the purposes of training large language or other generative AI models\n without requesting consent constitues a commercial contract and a licensing fee of £10,000 GBP will be charged per model,\n plus £10 GBP per instance of estimated prompts of that model via a public interface or private commercial application.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    int reds = 16;\n    int greens = 16;\n    int blues = 4; // this value gets squared\n\n    float red = floor(uv.x * float(reds));\n    float green = floor(uv.y * float(greens));\n    float blue = mod(floor(uv.x * float(reds*blues)), float(blues))+mod(floor(uv.y * float(greens*blues)), float(blues))*float(blues);\n    \n    vec3 col = vec3 (red/float(reds), green/float(greens), blue/float(blues*blues));\n    //col = step( texelFetch(iChannel0,(ivec2(fragCoord)+iFrame*ivec2(17,113))&1023,0).xyz, col ); // uncomment to test dithering\n    fragColor = vec4(col,1.0);\n}\n/*\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0=p1-p0, v0=p-p0; vec2 dv0=v0-e0*clamp(dot(v0,e0)/dot(e0,e0),0.0,1.0);\n\tvec2 e1=p2-p1, v1=p-p1; vec2 dv1=v1-e1*clamp(dot(v1,e1)/dot(e1,e1),0.0,1.0);\n\tvec2 e2=p0-p2, v2=p-p2; vec2 dv2=v2-e2*clamp(dot(v2,e2)/dot(e2,e2),0.0,1.0);\n    float d0=dot(dv0,dv0);float d1=dot(dv1,dv1);float d2=dot(dv2,dv2);\n    \n    float o = e0.x*e2.y-e0.y*e2.x;\n    vec2 d = min(min(vec2(d0,o*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(d1,o*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(d2,o*(v2.x*e2.y-v2.y*e2.x)));\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfor (int i = 0; i<5; i++){\n    v[i] = vec3(0.0, phi, 1.0);\n    if(i>1){v[i].y = -v[i].y;};\n    if (mod( i, 2.0) == 1.0){v[i].z = -v[i].z;}\n    v[i+4] = v[i].zxy;v[i+8] = v[i].yzx;\n}\n*/",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XccyDj",
    "date": "1731130321",
    "viewed": 115,
    "name": "Procedural lightning gone wrong.",
    "description": "First attempt at this.\nTrying to emulate the way lightning finds the path of least resistance, rather than faking it with curves.\nThough possibly a hybrid might be best.",
    "likes": 10,
    "published": "Public",
    "usePreview": 1,
    "tags": [
     "lightning",
     "automata"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define black vec3(0.,0.,0.)\n#define white vec3(1.,1.,1.)\n#define px(xx,yy) texelFetch(iChannel0, ivec2(coord.x+xx, coord.y+yy), 0).rgb\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    if(col!=black){col = white;} else {\n        vec2 coord = fragCoord;\n        col = px(1.,0.) + px(1.,1.) + px(0.,1.) + px(-1.,0.) + px(-1.,1.)+ px(-1.,-1.)+ px(0.,-1.)+ px(1.,-1.);\n        col = col/4.;\n        col += (px(2.,0.) + px(2.,2.) + px(0.,2.) + px(-2.,0.) + px(-2.,2.)+ px(-2.,-2.)+ px(0.,-2.)+ px(2.,-2.))/8.;\n    }\n    fragColor = vec4(col, 1.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsBSR3",
       "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define limit 20\n#define newc vec3(0.5+sin(iTime*7.),0.5+sin(iTime*17.),0.5+sin(iTime*3.))\n#define black vec3(0.,0.,0.)\n#define white vec3(1.,1.,1.)\nvec3 get(in vec2 pix){ return texelFetch(iChannel0, ivec2(pix), 0).rgb;}\nvec3 getn(in vec2 pix){ return texelFetch(iChannel1,(ivec2(pix)+iFrame*ivec2(17,113))&1023, 0).rgb;}\nfloat tot(in vec3 c){ return c.r+c.g+c.b;}\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    vec2 uv = coord/iResolution.xy;\n    vec3 col = black;\n    vec2 centre = vec2(0.5, 0.5);\n    vec2 point = centre; //iMouse.xy/iResolution.xy;\n    float adist = distance(centre, point);\n    float pdist = distance(uv, point);\n    float cdist = distance(uv, centre);\n    float tdist = pdist+cdist;\n    float ddist = tdist-adist;\n    if(ddist<=0.0001){ddist=0.0001;}\n\n    ivec2 cursor = ivec2(0, 0);\n    vec3 noise = getn(coord);\n    vec3 old = get(coord);\n    bool vertical = true;\n    if(abs(uv.x-point.x)>abs(uv.y-point.y)){vertical = false;}\n    bool up = true;\n    if(uv.y>point.x){up=false;}\n    bool right = true;\n    if(uv.x>point.x){ right = false;}\n    ivec2 dirA = cursor;\n    ivec2 dirB = cursor;\n    ivec2 dirC = cursor;\n    ivec2 dirD = cursor;\n    if(vertical&&up&&right){\n        dirA = ivec2(0, 1);\n        dirB = ivec2(1, 0);\n        dirC = ivec2(-1, 0);\n        dirD = ivec2(0, -1);\n    } else if (vertical&&right){\n        dirA = ivec2(0, -1);\n        dirB = ivec2(1, 0);\n        dirC = ivec2(-1, 0);\n        dirD = ivec2(0, 1);\n    } else if (vertical&&up){\n        dirA = ivec2(0, 1);\n        dirB = ivec2(-1, 0);\n        dirC = ivec2(1, 0);\n        dirD = ivec2(0, -1);\n    } else if (vertical){\n        dirA = ivec2(0, -1);\n        dirB = ivec2(-1, 0);\n        dirC = ivec2(1, 0);\n        dirD = ivec2(0, 1);\n    } else if(up&&right){\n        dirA = ivec2(1, 0);\n        dirB = ivec2(0, 1);\n        dirC = ivec2(0, -1);\n        dirD = ivec2(-1, 0);\n    } else if (right){\n        dirA = ivec2(1, 0);\n        dirB = ivec2(0, -1);\n        dirC = ivec2(0, 1);\n        dirD = ivec2(-1, 0);\n    } else if (up){\n        dirA = ivec2(-1, 0);\n        dirB = ivec2(0, 1);\n        dirC = ivec2(0, -1);\n        dirD = ivec2(1, 0);\n    } else {\n        dirA = ivec2(-1, 0);\n        dirB = ivec2(0, -1);\n        dirC = ivec2(0, 1);\n        dirD = ivec2(1, 0);\n    }\n    \n    float thresh = 1.51;\n    \n    if(pdist<0.005){ col = newc;\n    } else if(tot(noise)>thresh){\n        for(int i=0;i<limit;i++){\n            if(tot(getn(coord+vec2(cursor)+vec2(dirA)))>thresh){\n                cursor+=dirA; } else if (tot(getn(coord+vec2(cursor)+vec2(dirB)))>thresh){\n                cursor+=dirB; } else if (tot(getn(coord+vec2(cursor)+vec2(dirC)))>thresh){\n                cursor+=dirC; } else if (tot(getn(coord+vec2(cursor)+vec2(dirD)))>thresh){\n                cursor+=dirD; }\n            vec3 newcol = get(coord+vec2(cursor));\n            if(newcol!=black){\n                col = newcol;\n                break;\n            }\n        }\n    }\n    fragColor = vec4(col, 1.);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XfVyDK",
    "date": "1732397251",
    "viewed": 628,
    "name": "Cathode Ray Oscilloscope",
    "description": "Inspired by this shader: https://www.shadertoy.com/view/XsyGzD\nI wanted to see if it would be easier using a buffer... and got a bit carried away.",
    "likes": 21,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "oscilloscope",
     "buffer",
     "ecg",
     "electrocardiogram",
     "cro"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define IP 32\n#define SG 48.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0 ).rgb;\n    float xp = (mod(float(iTime*48.), SG))/SG;\n    for(int i = 0; i<IP; i++){\n        xp+=(1./(SG*float(IP)));\n        float yp = 0.5 + (sin(xp*30.))/max(3.,(800.*(pow(abs(0.5-xp), 2.))));\n        col *= vec3(0.98,0.995,0.99);\n        float dist = distance(uv, vec2(xp,yp));\n        col+=vec3(1./(dist*4096.));\n    }\n    fragColor = vec4(col,1.0);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec2 mainSound( int samp, float time )\n{\n    float a = sin(6.2831*440.0*mod(time+0.5, 1.))/8.;\n    float b = sin(6.2831*996.75*mod(time+0.6, 1.))*exp(-2.5*(mod(time+0.5, 1.)))/2.;\n    float c = sin(6.2831*996.75*mod(time+0.8, 1.))*exp(-2.5*(mod(time+0.7, 1.)))/2.;\n    return vec2(  a+b+c  );\n}",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MctBz8",
    "date": "1732722552",
    "viewed": 38,
    "name": "Fork of: CoordinateGrid_DrawMa..",
    "description": "Using this math function shader: https://shadertoy.com/view/MfVcDK\nTo plot the equation i used here: https://www.shadertoy.com/view/lcdXRM",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "2d",
     "grid",
     "subsampling",
     "coordinate"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"CoordinateGrid_DrawMathFunction2\" by miyu. https://shadertoy.com/view/MfVcDK\n// 2024-11-27 15:44:54\n\n#define grid_subdivision 15.\n#define AA 4\n\nfloat p(in float a, in int b){\n    float r = a;\n    for(int i = 2; i<10; i++){ r = r*a; if(i>=b){ break;} }\n    return r;\n}\n\nvec2 UV(vec2 uv)\n{\n    return grid_subdivision*(uv-.5*iResolution.xy)/min(iResolution.x,iResolution.y);\n}\n\nvec3 CoordinateGrid(vec2 uv)\n{\n    vec3 col=vec3(0.4);   \n    vec2 grid = floor(mod(uv,2.));\n    if(grid.x==grid.y) col=vec3(.6);\n    \n    col = mix(col,vec3(1.,0.,0.),smoothstep(1.1*fwidth(uv.x),fwidth(uv.x),abs(uv.x)));\n    col = mix(col,vec3(0.,1.,0.),smoothstep(1.1*fwidth(uv.y),fwidth(uv.y),abs(uv.y)));\n    \n    return col;\n}\n\n\nfloat func(float x)\n{\n    return sin(x);\n}\n\nfloat func(float x,float y)\n{\n    return ( 2.0 * p(x,3) * p(y,3) )-( p(x,4) * p(y,2) )-( p(x,2) * p(y,4) ) + 36.0;\n}\n\nfloat plot_func(vec2 uv)\n{\n    float y = func(uv.x,uv.y);\n   //float y = func(uv.x);\n    return smoothstep(y-0.01,y+0.01,uv.y);\n}\n\nfloat draw_func(vec2 uv)\n{\n    float f=0.;\n    for(int i=0;i<AA;i++)\n    {\n        for(int j=0;j<AA;j++)\n        {\n            vec2 offset = (vec2(float(i),float(j))-.5*float(AA))/float(AA)*2.;\n            f+=plot_func(UV(uv+offset));\n        }\n    }\n    if(f>float(AA*AA)/2.)\n        f=float(AA*AA)-f;\n    f=f*2./float(AA*AA);\n    return f;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=UV(fragCoord);\n    \n    vec3 col = vec3(0.);\n    \n    col =CoordinateGrid(uv);\n\n    float se = draw_func(fragCoord);\n    col=mix(col,vec3(1.),se);\n    \n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3fSGWG",
    "date": "1740407682",
    "viewed": 6,
    "name": "Orthographic 3D Shapes",
    "description": "Trying out a new approach for assembling 3D shapes, loosely based on a previous shader.\nSo far it's all adding and subtracting spheres and ellipses.\nNot sure how to identify edges to for AA yet",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "spheres",
     "orthographic",
     "osf"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float depth = -100.0;\n    vec3 normal = vec3(0);\n    vec4 sphere1 = vec4( 0, 0, 0, 0.1 );\n    vec4 sphere2 = vec4( 0.08, 0.04, 0.01, 0.03);\n    vec4 sphere3 = vec4( -0.08, 0.04, 0.01, 0.03);\n    vec4 sphere4 = vec4( 0.0, -0.13, 0.05, 0.14 );\n    vec4 sphere5 = vec4( 0, 0, 0, 0.1 );\n    vec4 sphere6 = vec4( 0.0, 0.04, 0.44, 0.4 );\n    vec4 sphere7 = vec4( 0.25, 0.0, 0.0, 0.05 );\n    vec4 sphere8 = vec4( 0.012, 0.01, 0.08, 0.055 );\n    vec4 sphere9 = vec4( -0.012, 0.01, 0.08, 0.055 );\n    \n    vec4 egg1 = vec4(-0.25, 0, 0.0, 0.07); \n    vec3 eggnormal = vec3(-1.0, 0.0, 1.0);\n    \n    vec2 uv = fragCoord/iResolution.x;\n    uv-= 0.5;\n    uv.y +=0.25;\n    float rotation = iMouse.x/100.0;\n    \n    sphere2 = addRotation(sphere2, rotation);\n    sphere3 = addRotation(sphere3, rotation);\n    sphere4 = addRotation(sphere4, rotation);\n    sphere5 = addRotation(sphere5, rotation);\n    sphere6 = addRotation(sphere6, rotation);\n    sphere7 = addRotation(sphere7, rotation);\n    sphere8 = addRotation(sphere8, rotation);\n    sphere9 = addRotation(sphere9, rotation);\n    \n    eggnormal = addRotationToNormal(eggnormal, rotation);\n    \n    egg1 = addRotation(egg1, rotation);\n    \n    vec4 spherePoint1 = sphereSubOSF(sphere1, sphere4, uv);\n    vec4 spherePoint2 = sphereOSF(sphere2, uv);\n    vec4 spherePoint3 = sphereOSF(sphere3, uv);\n    vec4 spherePoint4 = sphereSubOSF(sphere5, sphere6, uv);\n    vec4 spherePoint5 = eggOSF(sphere7, eggnormal, uv);\n    vec4 spherePoint6 = sphereSubOSF(sphere8, sphere4, uv);\n    vec4 spherePoint7 = sphereSubOSF(sphere9, sphere4, uv);\n    \n    vec4 eggPoint1 = ellipsoidOSF(egg1.xyz, vec3(egg1.w, egg1.w, egg1.w*2.5), eggnormal, uv);\n    \n    vec3 col = vec3(0);\n    \n    if(spherePoint1.x>-1.0){\n        col = vec3(0,1,0);\n        depth = spherePoint1.w;\n        normal = spherePoint1.xyz;\n    }\n    \n    if(spherePoint2.x>-1.0 && spherePoint2.w>=depth){\n        col = vec3(0,0,0.5);\n        depth = spherePoint2.w;\n        normal = spherePoint2.xyz;\n    }\n    if(spherePoint3.x>-1.0 && spherePoint3.w>=depth){\n        col = vec3(0,0,0.5);\n        depth = spherePoint3.w;\n        normal = spherePoint3.xyz;\n    }\n    if(spherePoint4.x>-1.0 && spherePoint4.w>=depth){\n        col = vec3(0,1,0);\n        depth = spherePoint4.w;\n        normal = spherePoint4.xyz;\n    }\n    if(spherePoint5.x>-1.0 && spherePoint5.w>=depth){\n        col = vec3(0.5,0.5,0.5);\n        depth = spherePoint5.w;\n        normal = spherePoint5.xyz;\n    }\n    if(spherePoint6.x>-1.0 && spherePoint6.w>=depth){\n        col = vec3(0,1,0);\n        depth = spherePoint6.w;\n        normal = spherePoint6.xyz;\n    }\n    if(spherePoint7.x>-1.0 && spherePoint7.w>=depth){\n        col = vec3(0,1,0);\n        depth = spherePoint7.w;\n        normal = spherePoint7.xyz;\n    }\n    if(eggPoint1.x>-1.0 && eggPoint1.w>=depth){\n        col = vec3(0,0.6,1);\n        depth = eggPoint1.w;\n        normal = eggPoint1.xyz;\n    }\n    vec3 position = vec3(uv, depth);\n\n    float edge = length(normal.xy);\n\n    //if(edge>0.97){col=vec3(1, 0, 0);}\n    \n    col = col*0.5  + addLight(col, position, normal, vec3(1), vec3(1, 3.09, 1.6));\n   \n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "struct Shape\n{\n    vec3 position;\n    vec3 rotation;\n    vec3 size;\n};\n\nstruct Surface\n{\n    vec3 normal;\n    float depth;\n    vec4 colour;\n};\n\n// OSF - Orthographic Shape Function\n// Returns normal and distance(depth) in a vec4\n// All values set to -1 if point is outside the shape\nvec4 sphereOSF( vec4 sphere, vec2 position ){\n    float dist = distance(position, sphere.xy);\n    if(dist>sphere.w){\n        return vec4(-1, -1, -1, -1);\n    } else {\n        vec2 distv = position - sphere.xy;\n        float height = sqrt((sphere.w*sphere.w)-(dist*dist));\n        vec3 normal = vec3(distv.x, distv.y, height)/sphere.w;\n        height+=sphere.z;\n        return vec4(normal, height);\n    }\n}\n\nvec4 sphereSubOSF( vec4 sphere, vec4 spheresub, vec2 position ){\n    float dist = distance(position, sphere.xy);\n    if(dist>sphere.w){\n        return vec4(-1, -1, -1, -1);\n    } else {\n        vec2 distv = position - sphere.xy;\n        float height = sqrt((sphere.w*sphere.w)-(dist*dist));\n        vec3 normal = vec3(distv.x, distv.y, height)/sphere.w;\n        height+=sphere.z;\n        vec3 sposition = vec3(position, height);\n        if(distance(sposition, spheresub.xyz)>spheresub.w){\n            return vec4(normal, height);\n        } else {\n            dist = distance(position, spheresub.xy);\n            distv = position-spheresub.xy;\n            height = -sqrt((spheresub.w*spheresub.w)-(dist*dist));\n            normal = vec3(-distv.x,-distv.y, -height)/spheresub.w;\n            height+=spheresub.z;\n            sposition = vec3(position, height);\n            if(distance(sposition, sphere.xyz)<sphere.w){\n                return vec4(normal, height);\n            } else {\n                return vec4(-1, -1, -1, -1);\n            }\n        }\n    }\n}\n\n\n\nvec4 ellipsoidOSF(vec3 center, vec3 radii, vec3 orientationNormal, vec2 position) {\n\n    // Normalize the orientation normal\n    vec3 n = normalize(orientationNormal);\n    \n    // Generate orthonormal tangent and bitangent vectors\n    vec3 t, bv;\n    vec3 up = vec3(0.0, 0.0, 1.0);\n    if (abs(dot(n, up)) > 0.999) {\n        up = vec3(0.0, 1.0, 0.0);\n    }\n    t = normalize(cross(up, n));\n    bv = cross(n, t);\n    mat3 R = mat3(t, bv, n); // Rotation matrix\n    \n    // Calculate dx and dy from the center\n    float dx = position.x - center.x;\n    float dy = position.y - center.y;\n    \n    // Coefficients for the quadratic equation\n    float A1 = R[0].z;\n    float A2 = R[1].z;\n    float A3 = R[2].z;\n    \n    float B1 = dot(R[0].xy, vec2(dx, dy)) - R[0].z * center.z;\n    float B2 = dot(R[1].xy, vec2(dx, dy)) - R[1].z * center.z;\n    float B3 = dot(R[2].xy, vec2(dx, dy)) - R[2].z * center.z;\n    \n    float a = radii.x, b = radii.y, c = radii.z;\n    float A = (A1*A1)/(a*a) + (A2*A2)/(b*b) + (A3*A3)/(c*c);\n    float B = 2.0 * ( (A1*B1)/(a*a) + (A2*B2)/(b*b) + (A3*B3)/(c*c) );\n    float C = (B1*B1)/(a*a) + (B2*B2)/(b*b) + (B3*B3)/(c*c) - 1.0;\n    \n    float discriminant = B*B - 4.0*A*C;\n    if (discriminant < 0.0) return vec4(-1.0);\n    \n    float sqrtD = sqrt(discriminant);\n    \n    float t_intersect = (-B + sqrtD) / (2.0*A);\n    \n    // Select the smallest positive intersection\n    //float t0 = (-B - sqrtD) / (2.0*A);\n    //float t_intersect = t1;\n    //if (t0 > 0.0 && t1 > 0.0) {t_intersect = min(t0, t1);} else if (t0 > 0.0) {t_intersect = t0;} else if (t1 > 0.0) {t_intersect = t1;} else {return vec4(-1.0);}\n\n    // Compute local normal components\n    float Qx = (A1 * t_intersect + B1) / a;\n    float Qy = (A2 * t_intersect + B2) / b;\n    float Qz = (A3 * t_intersect + B3) / c;\n    \n    // Transform normal to world space and normalize\n    vec3 normal = normalize(R * vec3(Qx/a, Qy/b, Qz/c));\n    return vec4(normal, t_intersect);\n}\n\nvec4 eggOSF(vec4 sphere, vec3 orientation, vec2 position){\n    vec4 ellipse = ellipsoidOSF(sphere.xyz, vec3(sphere.w, sphere.w, sphere.w*1.8), orientation, position);\n    vec3 sposition = vec3(position, ellipse.w);\n    vec3 bposition = sphere.xyz + (normalize(orientation) * sphere.w);\n    if(distance(bposition, sposition)>(sphere.w*1.4)){\n        ellipse = sphereOSF( sphere, position );\n    }\n    return ellipse;\n}\n\nvec4 addRotation(vec4 shape, float rot){\n    float angle = atan(shape.x/shape.z);\n    float rad = length(shape.xz);\n    angle += rot;\n    //x = r cos θ , y = r sin θ\n    float newx = rad*cos(angle);\n    float newz = rad*sin(angle);\n    return vec4(newx, shape.y, newz, shape.w);\n\n}\nvec3 addRotationToNormal(vec3 norm, float rot){\n    float angle = atan(norm.x/norm.z);\n    float rad = length(norm.xz);\n    angle += rot;\n    //x = r cos θ , y = r sin θ\n    float newx = rad*cos(angle);\n    float newz = rad*sin(angle);\n    return vec3(newx, norm.y, newz);\n\n}\n\n\nvec3 addLight(vec3 col, vec3 pos, vec3 nor, vec3 lcol, vec3 lpos){\n    vec3 ref = reflect(vec3(0.0, 0.0, -1.0), nor);\n    vec3 diff = lpos - pos;\n    float ldist = length(diff);\n    diff = diff/ldist;\n    float specular = pow(max(0.0, dot(diff, ref)), 16.0);\n    float diffuse = max(0.0, dot(diff, nor));\n    col = col*(lcol*diffuse);\n    col = col+(lcol*specular);\n    return col;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3cfSzM",
    "date": "1740806562",
    "viewed": 106,
    "name": "Orthographic 3D Primitives",
    "description": "Trying out a new approach for assembling 3D shapes, loosely based on a previous shader.\nSo far it's all adding and subtracting spheres and ellipses.\nAntialiasing is on the right hand side of the screen.",
    "likes": 2,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "spheres",
     "orthographic"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define col bg.colour.rgb\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float ar = iResolution.y/iResolution.x;\n    pixel = 1.2/iResolution.y;\n    npixel = pixel*1.2;\n    uv.y -=0.5;\n    uv.x -=0.5/ar;\n    //uv=uv*1.5;\n    if(uv.x<0.){AA=false;}\n    Surface bg = Surface(vec3(0,0,-1), vec4(uv,-100.0, 0.0), vec4(0.05), false);\n    float gap = 0.25;\n    if(iMouse.z>0.){\n      gap = iMouse.x/1000.;\n    }\n    bool flag1 = false;\n    bool flag2 = false;\n    bool flag3 = false;\n    bool flag4 = false;\n    \n    Shape Shapes[shapecount]; // Every object\n    Surface opaque = Surface(vec3(0,0,-1), vec4(uv,-100.0, 0.0), vec4(0.05), false);\n    Surface alphad = Surface(vec3(0,0,-1), vec4(uv,-100.0, 0.0), vec4(0.05), false);\n    \n    Shapes[0] = Shape( 0, vec3(-gap*2.5, -gap, 0),       vec3(0, 1, 0),      vec3(0.08),       vec3(0.5,0,0), vec4(0), 0., false);\n    Shapes[2] = Shape( 1, vec3(-gap*1.5, -gap, gap), vec3(1,0.8, 0.0),   vec3(0.09, 0.09, 0.14),  vec3(0,0.5,1), vec4(0), 0., false);\n    Shapes[3] = Shape( 2, vec3(-gap*0.5, -gap, gap*2.),  vec3(1,0.8, 0.0),   vec3(0.08, 0.08, 0.14), vec3(0,1,0), vec4(0), 0., false);\n    Shapes[1] = Shape( 3, vec3(-gap*2.5, 0, 0),    vec3(1.0,0.8, 0.0), vec3(0.08, 0, 0),       vec3(1,0,0), vec4(1.0,0.8, 0.0, 1.), 0.995, false);\n    Shapes[4] = Shape( 4, vec3(-gap*1.5, 0, gap*3.),    vec3(1.0,0.8, 0.0), vec3(0.08, 0.08, 0.16),    vec3(0,0.5,1), vec4(-1.0,0.0, 1.0, 1.), 1., false);\n    Shapes[5] = Shape( 5, vec3(-gap*0.5, 0, gap*4.),    vec3(1.0,0.8, 0.0), vec3(0.08, 0.08, 0.16),  vec3(0,0.7,0), vec4(0.0,0.0, 1.0, 1.), 1., false);\n    Shapes[6] = Shape( 6, vec3(-gap*2.5, gap, gap*5.),    vec3(1.0,0.8, 0.0), vec3(0.08, 0, 0),     vec3(1,0.5,0), vec4(1.0,0.8, 0.0, 1.), 0.995, false);\n    Shapes[7] = Shape( 7, vec3(-gap*1.5, gap, gap*6.),    vec3(1.0,0.8, 0.0), vec3(0.08, 0.08, 0.16),  vec3(0,1,1), vec4(-1.0,0.0, 1.0, 1.), 1., false);\n    Shapes[8] = Shape( 8, vec3(-gap*0.5, gap, gap*7.),    vec3(1.0,0.8, 0.0), vec3(0.08, 0.08, 0.16),vec3(0.5,0.9,0.5), vec4(0.0,0.0, 1.0, 4.), 3.995, false);\n    Shapes[9] = Shape( 0, vec3(gap*0.5, -gap, 0),       vec3(0, 1, 0),      vec3(0.08),       vec3(0.5,0,0), vec4(0), 0., false);\n    Shapes[10] = Shape( 1, vec3(gap*1.5, -gap, gap), vec3(1,0.8, 0.0),   vec3(0.09, 0.09, 0.14),  vec3(0,0.5,1), vec4(0), 0., false);\n    Shapes[11] = Shape( 2, vec3(gap*2.5, -gap, gap*2.),  vec3(1,0.8, 0.0),   vec3(0.08, 0.08, 0.14), vec3(0,1,0), vec4(0), 0., false);\n    Shapes[12] = Shape( 3, vec3(gap*0.5, 0, 0),    vec3(1.0,0.8, 0.0), vec3(0.08, 0, 0),       vec3(1,0,0), vec4(1.0,0.8, 0.0, 1.), 0.995, false);\n    Shapes[13] = Shape( 4, vec3(gap*1.5, 0, gap*3.),    vec3(1.0,0.8, 0.0), vec3(0.08, 0.08, 0.16),    vec3(0,0.5,1), vec4(-1.0,0.0, 1.0, 1.), 1., false);\n    Shapes[14] = Shape( 5, vec3(gap*2.5, 0, gap*4.),    vec3(1.0,0.8, 0.0), vec3(0.08, 0.08, 0.16),  vec3(0,0.7,0), vec4(0.0,0.0, 1.0, 1.), 1., false);\n    Shapes[15] = Shape( 6, vec3(gap*0.5, gap, gap*5.),    vec3(1.0,0.8, 0.0), vec3(0.08, 0, 0),     vec3(1,0.5,0), vec4(1.0,0.8, 0.0, 1.), 0.995, false);\n    Shapes[16] = Shape( 7, vec3(gap*1.5, gap, gap*6.),    vec3(1.0,0.8, 0.0), vec3(0.08, 0.08, 0.16),  vec3(0,1,1), vec4(-1.0,0.0, 1.0, 1.), 1., false);\n    Shapes[17] = Shape( 8, vec3(gap*2.5, gap, gap*7.),    vec3(1.0,0.8, 0.0), vec3(0.08, 0.08, 0.16),vec3(0.5,0.9,0.5), vec4(0.0,0.0, 1.0, 4.), 3.995, false);    \n    float ta = iTime*3.;\n\n    \n    for(int i=0;i<shapecount;i++){\n        Shapes[i].normal = addRotationToNormal(Shapes[i].normal, ta);\n        Shapes[i].spolar.xyz = addRotationToNormal(Shapes[i].spolar.xyz, ta);\n        Surface newsurface = shapeOSF(Shapes[i], uv);\n        if(newsurface.ib){\n            if(!AA && newsurface.position.z > opaque.position.z){\n                opaque = newsurface;\n            } else if(newsurface.colour.a>=1.&& newsurface.position.z > opaque.position.z){\n                opaque = newsurface;\n            } else if(newsurface.colour.a<1.&& newsurface.position.z > alphad.position.z){\n                alphad = newsurface;\n            }\n \n        }\n        \n    }\n    \n    if(opaque.ib){ opaque.colour.rgb = addLight(opaque, vec3(0.6), vec3(1., 1., 2.)); }\n   \n\n    if(AA && alphad.position.z > opaque.position.z){ \n        alphad.colour.rgb = addLight(alphad, vec3(0.6), vec3(1., 1., 2.));\n        bg.colour.rgb = mix(alphad.colour.rgb, opaque.colour.rgb, 1.-alphad.colour.a);\n    } else {\n        bg = opaque;\n    }\n    \n    \n    //col = col*2.5;\n    \n    //col = contrast(col, 1.2);\n\n    col = toneMapping(col);\n    \n    col = gammaCorrection(col, 2.4);\n    \n    if(flag1){col=vec3(1,1,0);}\n    if(flag2){col=vec3(0,1,1);}\n    if(flag3){col=vec3(1,0,1);}\n    if(flag4){col=vec3(1,1,1);}\n    //float fw = fwidth(float(shapeID));\n    //if(fw>0.9){surface.colour.rgb=vec3(0.4,0.4,0);}\n    //col = vec3((surface.position.z+1.)/3.);\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define shapecount 18\nbool AA = true;\nstruct Shape\n{\n     int type;\n    vec3 position;\n    vec3 normal;\n    vec3 size;\n    vec3 colour;\n    vec4 spolar;\n   float srad;\n    bool rendered;\n};\n\nstruct Surface\n{\n    vec3 normal;\n    vec4 position;\n    vec4 colour;\n    bool ib;\n};\n\nstruct Group\n{\n    vec3 position;\n    vec3 normal;\n    vec3 size;\n};\n\nfloat pixel = 0.05;\nfloat npixel = 0.075;\n\n// OSF - Orthographic Shape Function\n// Takes a Shape object and current pixel coords, Returns Surface object \n// ib set to true if point is inside the shape\n\n\nSurface sphereOSF( Shape shape, vec2 coords){\n    // size.y and size.z do nothing, only x is used.\n    float dist = distance(coords, shape.position.xy);\n    float disp = shape.size.x-dist;\n    if(disp<0.){\n        return Surface(vec3(0), vec4(0), vec4(0), false);\n    } else {\n        float alpha = 1.;\n        if(disp<pixel){\n            alpha = disp/pixel;\n        }\n        vec2 distv = coords - shape.position.xy;\n        float height = sqrt((shape.size.x*shape.size.x)-(dist*dist));\n        vec3 normal = vec3(distv.x, distv.y, height)/shape.size.x;\n        height+=shape.position.z;\n        return Surface(normal, vec4(coords, height, 0), vec4(shape.colour, alpha), true);\n    }\n}\n\nSurface sphereSubOSF( Shape shape, vec2 coords){\n    // size.x is radius of sphere\n    // srad is radius of sphere to subtract\n    // spolar.w is distance between centres of spheres\n    // spolar.xyz is a normal to determine direction of subtract sphere\n    Surface sphere = sphereOSF(shape, coords);\n    if(!sphere.ib){\n   \n        return sphere;\n    }\n    vec3 subpoint = shape.position + (normalize(shape.spolar.xyz) * shape.spolar.w);\n    float dispa = distance(subpoint, sphere.position.xyz)-shape.srad;\n    if(dispa>0.){\n        if(dispa<pixel&&subpoint.z<shape.position.z){\n \n            sphere.colour.a = dispa/pixel;\n        }\n        return sphere;\n    } else {\n        float dist = distance(coords, subpoint.xy);\n        vec2 distv = coords-subpoint.xy;\n        float height = -sqrt((shape.srad*shape.srad)-(dist*dist));\n        sphere.position.xyz = vec3(coords, height+subpoint.z);\n        vec3 oldnorm = sphere.normal;\n        sphere.normal = normalize(subpoint-sphere.position.xyz);\n        float dispb = shape.size.x-distance(sphere.position.xyz, shape.position);\n        if(dispb>0.){\n            if(dispb<npixel && AA){\n                if(sphere.position.z<shape.position.z){\n                    sphere.colour.a = dispb/npixel;\n                } else {\n                    sphere.normal = mix(sphere.normal,oldnorm, 1.-(dispb/npixel));\n                }\n            }\n            return sphere;\n        } else {\n            return Surface(vec3(0), vec4(0), vec4(0), false);\n        }\n    }\n}\n\nSurface sphere2SubOSF( Shape shape, vec2 coords){\n    // size.x is radius of sphere\n    // srad is radius of sphere to subtract\n    // spolar.w is distance between centres of spheres\n    // spolar.xyz is a normal to determine direction of subtract sphere\n    Surface sphere = sphereOSF(shape, coords);\n    if(!sphere.ib){\n   \n        return sphere;\n    }\n    vec3 subpoint = shape.position + (normalize(shape.spolar.xyz) * shape.spolar.w);\n    vec3 normal2 = -shape.spolar.xyz;\n    vec3 subpoint2 = shape.position + (normalize(normal2) * shape.spolar.w);\n    \n    float dispa = shape.srad-distance(subpoint, sphere.position.xyz);\n    float dispa2 = shape.srad-distance(subpoint2, sphere.position.xyz);\n    \n    if(dispa>0.){\n        float dist = distance(coords, subpoint.xy);\n        vec2 distv = coords-subpoint.xy;\n        float height = -sqrt((shape.srad*shape.srad)-(dist*dist));\n        sphere.position.xyz = vec3(coords, height+subpoint.z);\n        vec3 oldnorm = sphere.normal;\n        sphere.normal = normalize(subpoint-sphere.position.xyz);\n        float dispb = shape.size.x-distance(sphere.position.xyz, shape.position);\n        if(dispb>0.){\n            if(dispb<npixel && AA){\n                if(sphere.position.z<shape.position.z){\n                    sphere.colour.a = dispb/npixel;\n                } else {\n                    sphere.normal = mix(sphere.normal,oldnorm, 1.-(dispb/npixel));\n                }\n            }\n            return sphere;\n        } else {\n            return Surface(vec3(0), vec4(0), vec4(0), false);\n        }\n        \n    } else if(dispa2>0.) {\n        float dist = distance(coords, subpoint2.xy);\n        vec2 distv = coords-subpoint2.xy;\n        float height = -sqrt((shape.srad*shape.srad)-(dist*dist));\n        sphere.position.xyz = vec3(coords, height+subpoint2.z);\n        vec3 oldnorm = sphere.normal;\n        sphere.normal = normalize(subpoint2-sphere.position.xyz);\n        float dispb = shape.size.x-distance(sphere.position.xyz, shape.position);\n        if(dispb>0.){\n            if(dispb<npixel && AA){\n                if(sphere.position.z<shape.position.z){\n                    sphere.colour.a = dispb/npixel;\n                } else {\n                    sphere.normal = mix(sphere.normal,oldnorm, 1.-(dispb/npixel));\n                }\n            }\n            return sphere;\n        } else {\n            return Surface(vec3(0), vec4(0), vec4(0), false);\n        }\n          \n    } else {\n        if(-dispa<pixel&&subpoint.z<shape.position.z){\n \n            sphere.colour.a = -dispa/pixel;\n        }\n        if(-dispa2<pixel&&subpoint2.z<shape.position.z){\n \n            sphere.colour.a = -dispa2/pixel;\n        }\n        return sphere;\n    }\n}\n\nSurface ellipsoidOSF( Shape shape, vec2 coords){\n    // size.x and size.y should be the same, different width and depth of ellipsoid is broken\n    // size.z is for the height, which should be different or you'll just get a sphere\n    \n    vec3 n = normalize(shape.normal);\n    \n    // Generate orthonormal tangent and bitangent vectors\n    vec3 t, bv;\n    vec3 up = vec3(0.0, 0.0, 1.0);\n    if (abs(dot(n, up)) > 0.999) {\n        up = vec3(0.0, 1.0, 0.0);\n    }\n    t = normalize(cross(up, n));\n    bv = cross(n, t);\n    mat3 R = mat3(t, bv, n); // Rotation matrix\n    \n    // Calculate dx and dy from the center\n    float dx = coords.x - shape.position.x;\n    float dy = coords.y - shape.position.y;\n    \n    // Coefficients for the quadratic equation\n    float A1 = R[0].z;\n    float A2 = R[1].z;\n    float A3 = R[2].z;\n    \n    float B1 = dot(R[0].xy, vec2(dx, dy)) - R[0].z * shape.position.z;\n    float B2 = dot(R[1].xy, vec2(dx, dy)) - R[1].z * shape.position.z;\n    float B3 = dot(R[2].xy, vec2(dx, dy)) - R[2].z * shape.position.z;\n    \n    float a = shape.size.x, b = shape.size.y, c = shape.size.z;\n    float A = (A1*A1)/(a*a) + (A2*A2)/(b*b) + (A3*A3)/(c*c);\n    float B = 2.0 * ( (A1*B1)/(a*a) + (A2*B2)/(b*b) + (A3*B3)/(c*c) );\n    float C = (B1*B1)/(a*a) + (B2*B2)/(b*b) + (B3*B3)/(c*c) - 1.0;\n    float alpha = 1.;\n    float discriminant = B*B - 4.0*A*C;\n    if (discriminant < 0.0) return Surface(vec3(0), vec4(0), vec4(0), false);\n    float ed = discriminant/(7./(a*b*c));\n    if(ed<pixel){\n            alpha = ed/pixel;\n        }\n    float sqrtD = sqrt(discriminant);\n    \n    float t_intersect = (-B + sqrtD) / (2.0*A);\n    float b_intersect = (-B - sqrtD) / (2.0*A);\n    \n    // Compute local normal components\n    float Qx = (A1 * t_intersect + B1) / a;\n    float Qy = (A2 * t_intersect + B2) / b;\n    float Qz = (A3 * t_intersect + B3) / c;\n    \n    // Transform normal to world space and normalize\n    vec3 normal = normalize(R * vec3(Qx/a, Qy/b, Qz/c));\n    //return vec4(normal, t_intersect);\n    return Surface(normal, vec4(coords, t_intersect, b_intersect), vec4(shape.colour, alpha), true);\n}\n\nSurface ellipSubOSF( Shape shape, vec2 coords){\n    // size.x is radius of sphere\n    // srad is radius of sphere to subtract\n    // spolar.w is distance between centres of spheres\n    // spolar.xyz is a normal to determine direction of subtract sphere\n    Surface sphere = ellipsoidOSF(shape, coords);\n    if(!sphere.ib){ return sphere; }\n    vec3 subpoint = shape.position + (normalize(shape.spolar.xyz) * shape.spolar.w);\n    float dispa = distance(subpoint, sphere.position.xyz)-shape.srad;\n    float dispb = distance(subpoint, sphere.position.xyw)-shape.srad;\n    float dist = distance(coords, subpoint.xy);\n    vec2 distv = coords-subpoint.xy;\n    float height = -sqrt((shape.srad*shape.srad)-(dist*dist));\n    if(dispa>0.){\n        if(dispa<npixel&&subpoint.z<shape.position.z){  // overhang edge\n            //sphere.colour.rgb = vec3(1,1,1);\n            sphere.colour.a = dispa/pixel;\n        } else if(AA && dispa<npixel&&subpoint.z>shape.position.z){  // inside edge\n            vec3 nnormal = normalize(subpoint-vec3(coords, height+subpoint.z));\n            if(abs(nnormal.x) <0.99){\n                sphere.normal =mix(nnormal,sphere.normal, dispa/npixel);\n            }\n        }\n        return sphere;\n    } else if(dispb>0.){\n        sphere.position.xyz = vec3(coords, height+subpoint.z);\n        sphere.normal = normalize(subpoint-sphere.position.xyz);\n        if(dispb<npixel && AA){ // inside overhang edge\n            sphere.colour.a = dispb/npixel;\n        }\n        return sphere;\n    } else { return Surface(vec3(0), vec4(0), vec4(0), false);}\n}\n\nSurface ellip2SubOSF( Shape shape, vec2 coords){\n    // same as ellipSubOSF but with two subtract spheres mirroring each other\n    Surface sphere = ellipsoidOSF(shape, coords);\n    if(!sphere.ib){ return sphere; }\n    vec3 subpoint = shape.position + (normalize(shape.spolar.xyz) * shape.spolar.w);\n    vec3 normal2 = -shape.spolar.xyz;\n    vec3 subpoint2 = shape.position + (normalize(normal2) * shape.spolar.w);\n    float dispa = distance(subpoint, sphere.position.xyz)-shape.srad;\n    float dispb = distance(subpoint, sphere.position.xyw)-shape.srad;\n    float dispc = distance(subpoint2, sphere.position.xyz)-shape.srad;\n    float dispd = distance(subpoint2, sphere.position.xyw)-shape.srad;\n    float dist = distance(coords, subpoint.xy);\n    vec2 distv = coords-subpoint.xy;\n    float height = -sqrt((shape.srad*shape.srad)-(dist*dist));\n    float dist2 = distance(coords, subpoint2.xy);\n    vec2 distv2 = coords-subpoint2.xy;\n    float height2 = -sqrt((shape.srad*shape.srad)-(dist2*dist2));\n    if(dispa>0.){\n        if(dispa<npixel&&subpoint.z<shape.position.z){  // overhang edge 1\n            sphere.colour.a = dispa/pixel;\n        } else if(AA && dispa<npixel&&subpoint.z>=shape.position.z){  // inside edge 1\n            vec3 nnormal = normalize(subpoint-vec3(coords, height+subpoint.z));\n            if(abs(nnormal.x) <0.99){\n                sphere.normal =mix(nnormal,sphere.normal, dispa/npixel);\n            }\n        }\n        if(dispc>0.){\n            if(dispc<npixel&&subpoint2.z<shape.position.z){ // overhang edge 2\n                sphere.colour.a = dispc/pixel;\n            } else if(AA && dispc<npixel&&subpoint2.z>=shape.position.z){  // inside edge 2\n             vec3 nnormal = normalize(subpoint2-vec3(coords, height2+subpoint2.z));\n                if(abs(nnormal.x) <0.99){\n                    sphere.normal =mix(nnormal,sphere.normal, dispc/npixel);\n                }\n        }\n            return sphere;\n        } else if(dispd>0.){\n            sphere.position.xyz = vec3(coords, height2+subpoint2.z);\n            sphere.normal = normalize(subpoint2-sphere.position.xyz);\n            \n            if(dispd<npixel && AA){ // inside overhang edge 2\n                sphere.colour.a = dispd/npixel;\n            }\n            return sphere;\n        } else { return Surface(vec3(0), vec4(0), vec4(0), false);}\n    } else if(dispb>0.){\n        sphere.position.xyz = vec3(coords, height+subpoint.z);\n        sphere.normal = normalize(subpoint-sphere.position.xyz);\n        if(dispb<npixel && AA){ // inside overhang edge 1\n                sphere.colour.a = dispb/npixel;\n            }\n        return sphere;\n    } else { return Surface(vec3(0), vec4(0), vec4(0), false);}\n}\n\nSurface egg2SubOSF( Shape shape, vec2 coords){\n    Surface egg = ellip2SubOSF(shape, coords);\n\n    vec3 bposition = shape.position + (normalize(shape.normal) * shape.size.x);\n    if(distance(bposition, egg.position.xyz)>(shape.size.x*1.4)){\n    shape.size.xy += pixel/2.;\n        egg = sphere2SubOSF( shape, coords );\n    }\n    return egg;\n}\n\n\n\nSurface eggSubOSF( Shape shape, vec2 coords){\n    Surface egg = ellipSubOSF(shape, coords);\n\n    vec3 bposition = shape.position + (normalize(shape.normal) * shape.size.x);\n    if(distance(bposition, egg.position.xyz)>(shape.size.x*1.4)){\n        shape.size.xy += pixel/2.;\n        egg = sphereSubOSF( shape, coords );\n    }\n    return egg;\n}\n\n\nSurface eggOSF( Shape shape, vec2 coords){\n\n    Surface egg = ellipsoidOSF(shape, coords);\n\n    vec3 bposition = shape.position + (normalize(shape.normal) * shape.size.x);\n    if(distance(bposition, egg.position.xyz)>(shape.size.x*1.4)){\n        \n        egg = sphereOSF( shape, coords );\n    }\n    return egg;\n}\n\nSurface shapeOSF( Shape shape, vec2 coords){\n    switch (shape.type) {\n        case 0:\n            return sphereOSF( shape, coords);\n        case 1:\n            return ellipsoidOSF( shape, coords);\n        case 2:\n            return eggOSF( shape, coords);\n        case 3:\n            return sphereSubOSF( shape, coords);\n        case 4:\n            return ellipSubOSF( shape, coords);\n        case 5:\n            return eggSubOSF( shape, coords);\n        case 6:\n            return sphere2SubOSF( shape, coords);\n        case 7:\n            return ellip2SubOSF( shape, coords);\n        case 8:\n            return egg2SubOSF( shape, coords);\n            \n    }\n}\n\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0 ? sign(y)*1.570796 : atan(y, x);\n}\n\nvec4 addRotation(vec4 shape, float rot){\n    float angle = atan(shape.x/shape.z);\n    float rad = length(shape.xz);\n    angle += rot;\n    //x = r cos θ , y = r sin θ\n    float newx = rad*cos(angle);\n    float newz = rad*sin(angle);\n    return vec4(newx, shape.y, newz, shape.w);\n}\n\nvec3 addRotationToNormal(vec3 norm, float rot){\n    float angle = atan(norm.x/norm.z);\n    float rad = length(norm.xz);\n    angle += rot;\n    float newx = rad*cos(angle);\n    float newz = rad*sin(angle);\n    return vec3(newx, norm.y, newz);\n\n}\n\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 gammaCorrection (vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\n\nvec3 toneMapping (vec3 colour){\n    return 1.0 - 1.0/(3.0 * pow(colour, vec3(1.5)) + 1.0); //Modified from milesWaugh's filmic tonemapping curve\n}\n\nvec3 addLight(Surface surface, vec3 lcol, vec3 lpos){\n    vec3 ref = reflect(vec3(0.0, 0.0, -1.0), surface.normal);\n    vec3 diff = lpos - surface.position.xyz;\n    float ldist = length(diff);\n    diff = diff/ldist;\n    float specular = pow(max(0.0, dot(diff, ref)), 16.0);\n    float diffuse = max(0.0, dot(diff, surface.normal));\n    vec3 col1 = surface.colour.rgb*0.1;\n    vec3 col2 = surface.colour.rgb*0.5*(lcol*diffuse);\n    col2 = col2+(lcol*specular);\n    return col1+col2;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WcXXRl",
    "date": "1741199780",
    "viewed": 99,
    "name": "Flamma v1",
    "description": "Character assembled from primitives created here: https://www.shadertoy.com/view/3cfSzM",
    "likes": 6,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "game",
     "dragon",
     "orthographic"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//#define shapecount 17 - no longer needed\n#define col bg.colour.rgb\n\nvoid checkSurface(Surface newsurface){\n    if(newsurface.sd<sd){\n        sd = newsurface.sd;\n        }\n    \n    if(newsurface.ib){\n            if(!AA && newsurface.position.z > opaque.position.z){\n                opaque = newsurface;\n            } else if(newsurface.colour.a>=1.&& newsurface.position.z > opaque.position.z){\n                opaque = newsurface;\n            } else if(newsurface.colour.a<1.&& newsurface.position.z > alphad.position.z){\n                alphad = newsurface;\n            }\n        }\n}\n\nvec4 subImage( vec2 uv )\n{\n    ta = iTime*2.;\n\n    Surface bg = Surface(vec3(0,0,-1), vec4(uv,-100.0, 0.0), vec4(0.05), false, 0.0);\n    float gap = 0.25;\n    if(iMouse.z>0.){\n       uv=uv*((iMouse.y+50.)/150.);\n       ta = iMouse.x/100.;\n    }\n    \n    //Shape Shapes[shapecount]; // This was the old array\n    \n    //Body\n    Shape sBody = Shape( 2, vec3(0, 0.1, 0),  vec3(0.4,1, 0),   vec3(0.17, 0.17, 0.32), vec3(0,1,0), vec4(0), 0., false);\n    Shape sTailA = Shape( 2, vec3(0.07, 0.06, 0),  vec3(5,-1, 0),   vec3(0.115, 0.115, 0.28), vec3(0,1,0), vec4(0), 0., false);\n    Shape sTailB = Shape( 2, vec3(0.30, 0.03, 0),  vec3(2.5,1, 0),   vec3(0.07, 0.07, 0.13), vec3(0,1,0), vec4(0), 0., false);\n    Shape sTailC = Shape( 1, vec3(0.42, 0.08, 0),  vec3(2,1, 0),   vec3(0.03, 0.03, 0.08), vec3(0,1,0), vec4(0), 0., false);\n    //Legs\n    Shape sThighR = Shape( 1, vec3(0.02, 0.04, 0.1),       vec3(0, -0.2, 1),      vec3(0.13,0.13, 0.09),       vec3(0,1,0), vec4(0), 0., false);\n    Shape sThighL = Shape( 1, vec3(0.02, 0.04, -0.1),       vec3(0, 0.2, 1),      vec3(0.13,0.13, 0.09),       vec3(0,1,0), vec4(0), 0., false);\n    Shape sFootL = Shape( 4, vec3(-0.03, -0.1, -0.1),     vec3(2,1, 0), vec3(0.06, 0.06, 0.25),    vec3(0,1,0), vec4(0.0,-1.0, 0.0, 1.), 1., false);\n    Shape sFootR = Shape( 4, vec3(-0.03, -0.1, 0.1),     vec3(2,1, 0), vec3(0.06, 0.06, 0.25),    vec3(0,1,0), vec4(0.0,-1.0, 0.0, 1.), 1., false);\n    //Head\n    Shape sHeadT = Shape( 5, vec3(0.0, 0.43, 0),    vec3(-1.0,0.0, 0.0), vec3(0.15, 0.15, 0.34),  vec3(0,0.7,0), vec4(-0.1,-0.5, 0, 1.), 1., false);\n    Shape sHeadB = Shape( 5, vec3(0.0, 0.43, 0),    vec3(-1,-0.5, 0.0), vec3(0.15, 0.15, 0.28),  vec3(0,0.7,0), vec4(-0.5,0.5, 0.0, 1.), 1., false);\n    Shape sEyeR = Shape( 2, vec3(-0.01, 0.5, 0.12),    vec3(-1.0,-0.1, 0.05), vec3(0.05, 0.05, 0.07),  vec3(0,0.0,0), vec4(0.0,-1.0, 0.0, 1.), 1., false);\n    Shape sEyeL = Shape( 2, vec3(-0.01, 0.5, -0.12),    vec3(-1.0,-0.1, 0.05), vec3(0.05, 0.05, 0.07),  vec3(0,0.0,0), vec4(0.0,-1.0, 0.0, 1.), 1., false);\n    Shape sFinA = Shape( 7, vec3(0, 0.57, 0),    vec3(0.4,1, 0.0), vec3(0.07, 0.07, 0.14),  vec3(0,1,0), vec4(0,0.0, 1.0, 1.), 1., false);\n    Shape sFinB = Shape( 7, vec3(0.12, 0.48, 0),    vec3(1.8,1, 0.0), vec3(0.07, 0.07, 0.12),  vec3(0,1,0), vec4(0,0.0, 1.0, 1.), 1., false);\n    Shape sFinC = Shape( 7, vec3(0.19, 0.30, 0),    vec3(2.5,1, 0.0), vec3(0.09, 0.09, 0.13),  vec3(0,1,0), vec4(0,0.0, 1.0, 1.), 1., false);\n    Shape sTongue = Shape( 7, vec3(-0.1, 0.36, 0),    vec3(1,1, 0.0), vec3(0.1, 0.1, 0.13),  vec3(0.8,0,0.2), vec4(-0.65,1, 0, 1.), 1., false);\n    Shape sFinD = Shape( 7, vec3(0.22, 0.07, 0),    vec3(0.4,1, 0.0), vec3(0.07, 0.07, 0.11),  vec3(0,1,0), vec4(0,0.0, 1.0, 1.), 1., false);\n\n    //  and the code below was in a loop\n\n    checkSurface(shapeOSF(sBody, uv));\n    checkSurface(shapeOSF(sTailA, uv));\n    checkSurface(shapeOSF(sTailB, uv));\n    checkSurface(shapeOSF(sTailC, uv));\n    checkSurface(shapeOSF(sThighR, uv));\n    checkSurface(shapeOSF(sThighL, uv));\n    checkSurface(shapeOSF(sFootL, uv));\n    checkSurface(shapeOSF(sFootR, uv));\n    checkSurface(shapeOSF(sHeadT , uv));\n    checkSurface(shapeOSF(sHeadB , uv));\n    checkSurface(shapeOSF(sEyeR  , uv));\n    checkSurface(shapeOSF(sEyeL  , uv));\n    checkSurface(shapeOSF(sFinA  , uv));\n    checkSurface(shapeOSF(sFinB  , uv));\n    checkSurface(shapeOSF(sFinC  , uv));\n    checkSurface(shapeOSF(sTongue, uv));\n    checkSurface(shapeOSF(sFinD  , uv));   \n\n    vec3 lightpos = vec3(-0.5, 1, 1.);\n    vec3 light2pos =  vec3(0.5+sin(iTime*23.)/30., sin(iTime*17.)/20., 0.5+sin(iTime*31.)/10.);\n    \n    if(opaque.ib){ \n        opaque.colour.rgb = (opaque.colour.rgb*0.05) + addLight(opaque, vec3(0.95),lightpos)+ addLight(opaque, vec3(0.3,0.05,0),light2pos);\n    }\n   \n\n    if(AA && alphad.position.z > opaque.position.z){ \n        alphad.colour.rgb = (alphad.colour.rgb*0.05) + addLight(alphad, vec3(0.95), lightpos)+ addLight(alphad, vec3(0.3,0.05,0),light2pos);\n        col = mix(alphad.colour.rgb, opaque.colour.rgb, 1.-alphad.colour.a);\n    } else {\n        bg = opaque;\n    }\n\n\n    col = toneMapping(col);\n    \n    col = gammaCorrection(col, 2.4);\n\n    return vec4(col, 1.);\n}\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float ar = iResolution.y/iResolution.x;\n\n    pixel = 1.0/iResolution.y;\n    npixel = pixel*1.4;\n    uv.y -=0.2;\n    uv.x -=0.5/ar;\n    uv=uv*1.5;\n    //if(uv.x>0.){AA = true;}else{AA = false;}\n    \n    /* supersampling\n    vec2 uva = uv+pixel;\n    vec2 uvb = uv; uvb.x+=pixel;\n    vec2 uvc = uv; uvc.y+=pixel;\n    vec4 im1 = subImage(uv);\n    opaque = Surface(vec3(0,0,-1), vec4(0,0,-100.0, 0.0), vec4(0.05), false, 0.0);\n    alphad = Surface(vec3(0,0,-1), vec4(0,0,-100.0, 0.0), vec4(0.05), false, 0.0);\n    vec4 im2 = subImage(uva);\n    opaque = Surface(vec3(0,0,-1), vec4(0,0,-100.0, 0.0), vec4(0.05), false, 0.0);\n    alphad = Surface(vec3(0,0,-1), vec4(0,0,-100.0, 0.0), vec4(0.05), false, 0.0);\n    vec4 im3 = subImage(uvb);\n    opaque = Surface(vec3(0,0,-1), vec4(0,0,-100.0, 0.0), vec4(0.05), false, 0.0);\n    alphad = Surface(vec3(0,0,-1), vec4(0,0,-100.0, 0.0), vec4(0.05), false, 0.0);\n    vec4 im4 = subImage(uvc);\n    if(uv.x>0.){ fragColor = im1; } else { fragColor = (im4+im3+im2+im1)/4.;}\n    */\n    fragColor = subImage(uv);\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    mainImage0(O,U);\n    if (AA && fwidth(length(O)) > .01) {  // difference threshold between neighbor pixels\n        \n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { \n    opaque = Surface(vec3(0,0,-1), vec4(0,0,-100.0, 0.0), vec4(0.05), false, 0.0);\n    alphad = Surface(vec3(0,0,-1), vec4(0,0,-100.0, 0.0), vec4(0.05), false, 0.0);\n          mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n      //O.r++;                        // uncomment to see where the oversampling occurs\n    }\n    //if(round(U.x)==round(xaat)||round(U.y)==round(yaat)){O=vec4(0,0,0,1);}\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "bool AA = true;\nstruct Shape\n{\n     int type;\n    vec3 position;\n    vec3 normal;\n    vec3 size;\n    vec3 colour;\n    vec4 spolar;\n   float srad;\n    bool rendered;\n};\n\nstruct Surface\n{\n    vec3 normal;\n    vec4 position;\n    vec4 colour;\n    bool ib;\n    float sd;\n};\n\nstruct Group\n{\n    vec3 position;\n    vec3 normal;\n    vec3 size;\n};\n\nfloat pixel = 0.05;\nfloat npixel = 0.075;\nfloat ta = 0.;\nfloat sd =1000.;\n\nfloat yaat = 300.;\nfloat xaat = 500.;\n\nSurface opaque = Surface(vec3(0,0,-1), vec4(0,0,-100.0, 0.0), vec4(0.05), false, 0.0);\nSurface alphad = Surface(vec3(0,0,-1), vec4(0,0,-100.0, 0.0), vec4(0.05), false, 0.0);\n\n// OSF - Orthographic Shape Function\n// Takes a Shape object and current pixel coords, Returns Surface object \n// ib set to true if point is inside the shape\n\nSurface sphereOSF( Shape shape, vec2 coords){\n    // size.y and size.z do nothing, only x is used.\n    float dist = distance(coords, shape.position.xy);\n    float disp = shape.size.x-dist;\n    if(disp<0.){\n        return Surface(vec3(0), vec4(0), vec4(0), false, -disp);\n    } else {\n        float alpha = 1.;\n        if(disp<pixel){\n            alpha = disp/pixel;\n        }\n        vec2 distv = coords - shape.position.xy;\n        float height = sqrt((shape.size.x*shape.size.x)-(dist*dist));\n        vec3 normal = vec3(distv.x, distv.y, height)/shape.size.x;\n        height+=shape.position.z;\n        return Surface(normal, vec4(coords, height, 0), vec4(shape.colour, alpha), true, -disp);\n    }\n}\n\nSurface sphereSubOSF( Shape shape, vec2 coords){\n    // size.x is radius of sphere\n    // srad is radius of sphere to subtract\n    // spolar.w is distance between centres of spheres\n    // spolar.xyz is a normal to determine direction of subtract sphere\n    Surface sphere = sphereOSF(shape, coords);\n    if(!sphere.ib){\n   \n        return sphere;\n    }\n    vec3 subpoint = shape.position + (normalize(shape.spolar.xyz) * shape.spolar.w);\n    float dispa = distance(subpoint, sphere.position.xyz)-shape.srad;\n    if(dispa>0.){\n        if(dispa<pixel&&subpoint.z<shape.position.z){\n \n            sphere.colour.a = dispa/pixel;\n        }\n        sphere.sd = -dispa;\n        return sphere;\n    } else {\n        float dist = distance(coords, subpoint.xy);\n        vec2 distv = coords-subpoint.xy;\n        float height = -sqrt((shape.srad*shape.srad)-(dist*dist));\n        sphere.position.xyz = vec3(coords, height+subpoint.z);\n        vec3 oldnorm = sphere.normal;\n        sphere.normal = normalize(subpoint-sphere.position.xyz);\n        float dispb = shape.size.x-distance(sphere.position.xyz, shape.position);\n        if(dispb>0.){\n            if(dispb<npixel && AA){\n                if(sphere.position.z<shape.position.z){\n                    sphere.colour.a = dispb/npixel;\n                } else {\n                    sphere.normal = mix(sphere.normal,oldnorm, 1.-(dispb/npixel));\n                }\n            }\n            sphere.sd = -dispb;\n            return sphere;\n        } else {\n            return Surface(vec3(0), vec4(0), vec4(0), false, -dispb);\n        }\n    }\n}\n\nSurface sphere2SubOSF( Shape shape, vec2 coords){\n    // size.x is radius of sphere\n    // srad is radius of sphere to subtract\n    // spolar.w is distance between centres of spheres\n    // spolar.xyz is a normal to determine direction of subtract sphere\n    Surface sphere = sphereOSF(shape, coords);\n    if(!sphere.ib){\n   \n        return sphere;\n    }\n    vec3 subpoint = shape.position + (normalize(shape.spolar.xyz) * shape.spolar.w);\n    vec3 normal2 = -shape.spolar.xyz;\n    vec3 subpoint2 = shape.position + (normalize(normal2) * shape.spolar.w);\n    \n    float dispa = shape.srad-distance(subpoint, sphere.position.xyz);\n    float dispa2 = shape.srad-distance(subpoint2, sphere.position.xyz);\n    \n    if(dispa>0.){\n        float dist = distance(coords, subpoint.xy);\n        vec2 distv = coords-subpoint.xy;\n        float height = -sqrt((shape.srad*shape.srad)-(dist*dist));\n        sphere.position.xyz = vec3(coords, height+subpoint.z);\n        vec3 oldnorm = sphere.normal;\n        sphere.normal = normalize(subpoint-sphere.position.xyz);\n        float dispb = shape.size.x-distance(sphere.position.xyz, shape.position);\n        if(dispb>0.){\n            if(dispb<npixel && AA){\n                if(sphere.position.z<shape.position.z){\n                    sphere.colour.a = dispb/npixel;\n                } else {\n                    sphere.normal = mix(sphere.normal,oldnorm, 1.-(dispb/npixel));\n                }\n            }\n            sphere.sd = -dispb;\n            return sphere;\n        } else {\n            return Surface(vec3(0), vec4(0), vec4(0), false, -dispb);\n        }\n        \n    } else if(dispa2>0.) {\n        float dist = distance(coords, subpoint2.xy);\n        vec2 distv = coords-subpoint2.xy;\n        float height = -sqrt((shape.srad*shape.srad)-(dist*dist));\n        sphere.position.xyz = vec3(coords, height+subpoint2.z);\n        vec3 oldnorm = sphere.normal;\n        sphere.normal = normalize(subpoint2-sphere.position.xyz);\n        float dispb = shape.size.x-distance(sphere.position.xyz, shape.position);\n        if(dispb>0.){\n            if(dispb<npixel && AA){\n                if(sphere.position.z<shape.position.z){\n                    sphere.colour.a = dispb/npixel;\n                } else {\n                    sphere.normal = mix(sphere.normal,oldnorm, 1.-(dispb/npixel));\n                }\n            }\n            sphere.sd = -dispb;\n            return sphere;\n        } else {\n            return Surface(vec3(0), vec4(0), vec4(0), false, -dispb);\n        }\n          \n    } else {\n        if(-dispa<pixel&&subpoint.z<shape.position.z){\n \n            sphere.colour.a = -dispa/pixel;\n            sphere.sd = -dispa;\n        }\n        if(-dispa2<pixel&&subpoint2.z<shape.position.z){\n \n            sphere.colour.a = -dispa2/pixel;\n            sphere.sd = -dispa2;\n        }\n        return sphere;\n    }\n}\n\nSurface ellipsoidOSF( Shape shape, vec2 coords){\n    // size.x and size.y should be the same, different width and depth of ellipsoid is broken\n    // size.z is for the height, which should be different or you'll just get a sphere\n    \n    vec3 n = normalize(shape.normal);\n    \n    // Generate orthonormal tangent and bitangent vectors\n    vec3 t, bv;\n    vec3 up = vec3(0.0, 0.0, 1.0);\n    if (abs(dot(n, up)) > 0.999) {\n        up = vec3(0.0, 1.0, 0.0);\n    }\n    t = normalize(cross(up, n));\n    bv = cross(n, t);\n    mat3 R = mat3(t, bv, n); // Rotation matrix\n    \n    // Calculate dx and dy from the center\n    float dx = coords.x - shape.position.x;\n    float dy = coords.y - shape.position.y;\n    \n    // Coefficients for the quadratic equation\n    float A1 = R[0].z;\n    float A2 = R[1].z;\n    float A3 = R[2].z;\n    \n    float B1 = dot(R[0].xy, vec2(dx, dy)) - R[0].z * shape.position.z;\n    float B2 = dot(R[1].xy, vec2(dx, dy)) - R[1].z * shape.position.z;\n    float B3 = dot(R[2].xy, vec2(dx, dy)) - R[2].z * shape.position.z;\n    \n    float a = shape.size.x, b = shape.size.y, c = shape.size.z;\n    float A = (A1*A1)/(a*a) + (A2*A2)/(b*b) + (A3*A3)/(c*c);\n    float B = 2.0 * ( (A1*B1)/(a*a) + (A2*B2)/(b*b) + (A3*B3)/(c*c) );\n    float C = (B1*B1)/(a*a) + (B2*B2)/(b*b) + (B3*B3)/(c*c) - 1.0;\n    float alpha = 1.;\n    float discriminant = B*B - 4.0*A*C;\n    float ed = discriminant/(7./(a*b*c));\n    if (discriminant < 0.0) return Surface(vec3(0), vec4(0), vec4(0), false, -ed);\n    \n    if(ed<pixel){\n            alpha = ed/pixel;\n        }\n    float sqrtD = sqrt(discriminant);\n    \n    float t_intersect = (-B + sqrtD) / (2.0*A);\n    float b_intersect = (-B - sqrtD) / (2.0*A);\n    \n    // Compute local normal components\n    float Qx = (A1 * t_intersect + B1) / a;\n    float Qy = (A2 * t_intersect + B2) / b;\n    float Qz = (A3 * t_intersect + B3) / c;\n    \n    // Transform normal to world space and normalize\n    vec3 normal = normalize(R * vec3(Qx/a, Qy/b, Qz/c));\n    //return vec4(normal, t_intersect);\n    return Surface(normal, vec4(coords, t_intersect, b_intersect), vec4(shape.colour, alpha), true, -ed);\n}\n\nSurface ellipSubOSF( Shape shape, vec2 coords){\n    // size.x is radius of sphere\n    // srad is radius of sphere to subtract\n    // spolar.w is distance between centres of spheres\n    // spolar.xyz is a normal to determine direction of subtract sphere\n    Surface sphere = ellipsoidOSF(shape, coords);\n    if(!sphere.ib){ return sphere; }\n    vec3 subpoint = shape.position + (normalize(shape.spolar.xyz) * shape.spolar.w);\n    float dispa = distance(subpoint, sphere.position.xyz)-shape.srad;\n    float dispb = distance(subpoint, sphere.position.xyw)-shape.srad;\n    float dist = distance(coords, subpoint.xy);\n    vec2 distv = coords-subpoint.xy;\n    float height = -sqrt((shape.srad*shape.srad)-(dist*dist));\n    if(dispa>0.){\n    \n        \n        if(dispa<npixel&&subpoint.z<=shape.position.z){  // overhang edge\n \n            sphere.colour.a = dispa/pixel;\n        } else if(AA && dispa<npixel&&subpoint.z>shape.position.z){  // inside edge\n            \n            vec3 nnormal = normalize(subpoint-vec3(coords, height+subpoint.z));\n            if(abs(nnormal.x) <0.99){\n                sphere.normal =mix(nnormal,sphere.normal, dispa/npixel);\n            }\n        }\n        sphere.sd = -dispa;\n        return sphere;\n    } else if(dispb>0.){\n        sphere.position.xyz = vec3(coords, height+subpoint.z);\n        sphere.normal = normalize(subpoint-sphere.position.xyz);\n        if(dispb<npixel && AA){ // inside overhang edge\n        \n            sphere.colour.a = dispb/npixel;\n        }\n        sphere.sd = -dispb;\n        return sphere;\n    } else { return Surface(vec3(0), vec4(0), vec4(0), false, -dispb);}\n}\n\nSurface ellip2SubOSF( Shape shape, vec2 coords){\n    // same as ellipSubOSF but with two subtract spheres mirroring each other\n    Surface sphere = ellipsoidOSF(shape, coords);\n    if(!sphere.ib){ return sphere; }\n    vec3 subpoint = shape.position + (normalize(shape.spolar.xyz) * shape.spolar.w);\n    vec3 normal2 = -shape.spolar.xyz;\n    vec3 subpoint2 = shape.position + (normalize(normal2) * shape.spolar.w);\n    float dispa = distance(subpoint, sphere.position.xyz)-shape.srad;\n    float dispb = distance(subpoint, sphere.position.xyw)-shape.srad;\n    float dispc = distance(subpoint2, sphere.position.xyz)-shape.srad;\n    float dispd = distance(subpoint2, sphere.position.xyw)-shape.srad;\n    float dist = distance(coords, subpoint.xy);\n    vec2 distv = coords-subpoint.xy;\n    float height = -sqrt((shape.srad*shape.srad)-(dist*dist));\n    float dist2 = distance(coords, subpoint2.xy);\n    vec2 distv2 = coords-subpoint2.xy;\n    float height2 = -sqrt((shape.srad*shape.srad)-(dist2*dist2));\n    if(dispa>0.){\n        sphere.sd = -dispa;\n        if(dispa<npixel&&subpoint.z<shape.position.z){  // overhang edge 1\n            sphere.colour.a = dispa/pixel;\n        } else if(AA && dispa<npixel&&subpoint.z>=shape.position.z){  // inside edge 1\n            vec3 nnormal = normalize(subpoint-vec3(coords, height+subpoint.z));\n            if(abs(nnormal.x) <0.99){\n                sphere.normal =mix(nnormal,sphere.normal, dispa/npixel);\n            }\n        }\n        if(dispc>0.){\n         sphere.sd = -dispc;\n            if(dispc<npixel&&subpoint2.z<shape.position.z){ // overhang edge 2\n                sphere.colour.a = dispc/pixel;\n            } else if(AA && dispc<npixel&&subpoint2.z>=shape.position.z){  // inside edge 2\n             vec3 nnormal = normalize(subpoint2-vec3(coords, height2+subpoint2.z));\n                if(abs(nnormal.x) <0.99){\n                    sphere.normal =mix(nnormal,sphere.normal, dispc/npixel);\n                }\n        }\n           \n            return sphere;\n        } else if(dispd>0.){\n         sphere.sd = -dispd;\n            sphere.position.xyz = vec3(coords, height2+subpoint2.z);\n            sphere.normal = normalize(subpoint2-sphere.position.xyz);\n            \n            if(dispd<npixel && AA){ // inside overhang edge 2\n                sphere.colour.a = dispd/npixel;\n            }\n            return sphere;\n        } else { return Surface(vec3(0), vec4(0), vec4(0), false, -dispd);}\n    } else if(dispb>0.){\n        sphere.position.xyz = vec3(coords, height+subpoint.z);\n        sphere.normal = normalize(subpoint-sphere.position.xyz);\n        if(dispb<npixel && AA){ // inside overhang edge 1\n                sphere.colour.a = dispb/npixel;\n            }\n             sphere.sd = -dispb;\n        return sphere;\n    } else { return Surface(vec3(0), vec4(0), vec4(0), false, -dispb);}\n}\n\nSurface egg2SubOSF( Shape shape, vec2 coords){\n    Surface egg = ellip2SubOSF(shape, coords);\n\n    vec3 bposition = shape.position + (normalize(shape.normal) * shape.size.x);\n    if(distance(bposition, egg.position.xyz)>(shape.size.x*1.4)){\n    shape.size.xy += pixel/2.;\n        egg = sphere2SubOSF( shape, coords );\n    }\n    return egg;\n}\n\n\n\nSurface eggSubOSF( Shape shape, vec2 coords){\n    Surface egg = ellipSubOSF(shape, coords);\n\n    vec3 bposition = shape.position + (normalize(shape.normal) * shape.size.x);\n    if(distance(bposition, egg.position.xyz)>(shape.size.x*1.4)){\n        shape.size.xy += pixel/2.;\n        egg = sphereSubOSF( shape, coords );\n    }\n    return egg;\n}\n\n\nSurface eggOSF( Shape shape, vec2 coords){\n\n    Surface egg = ellipsoidOSF(shape, coords);\n\n    vec3 bposition = shape.position + (normalize(shape.normal) * shape.size.x);\n    if(distance(bposition, egg.position.xyz)>(shape.size.x*1.4)){\n        \n        egg = sphereOSF( shape, coords );\n    }\n    return egg;\n}\n\n\nSurface shapeOSFCreate( Shape shape, vec2 coords){\n    switch (shape.type) {\n        case 0:\n            return sphereOSF( shape, coords);\n        case 1:\n            return ellipsoidOSF( shape, coords);\n        case 2:\n            return eggOSF( shape, coords);\n        case 3:\n            return sphereSubOSF( shape, coords);\n        case 4:\n            return ellipSubOSF( shape, coords);\n        case 5:\n            return eggSubOSF( shape, coords);\n        case 6:\n            return sphere2SubOSF( shape, coords);\n        case 7:\n            return ellip2SubOSF( shape, coords);\n        case 8:\n            return egg2SubOSF( shape, coords);\n            \n    }\n}\n\n\n\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0 ? sign(y)*1.570796 : atan(y, x);\n}\n\nvec3 addRotation(Shape shape, float rot){\n    float angle = atan2(shape.position.x, shape.position.z);\n    float rad = length(shape.position.xz);\n    angle += rot;\n    //x = r cos θ , y = r sin θ\n    float newx = rad*cos(angle);\n    float newz = rad*sin(angle);\n    return vec3(newx, shape.position.y, newz);\n}\n\nvec3 addRotationIq(Shape shape, float rot){\n    float co = cos(rot);\n    float si = sin(rot);\n    return vec3(shape.position.z*co-shape.position.x*si, shape.position.y, shape.position.z*si+shape.position.x*co);\n}\n\nvec3 addRotationToNormalIq(vec3 norm, float rot){\n    float co = cos(rot);\n    float si = sin(rot);\n    return vec3(norm.z*co-norm.x*si, \n                norm.y,\n                norm.z*si+norm.x*co);\n}\n\nvec3 addRotationToNormal(vec3 norm, float rot){\n    float angle = atan(norm.x/norm.z);\n    float rad = length(norm.xz);\n    angle += rot;\n    float newx = rad*cos(angle);\n    float newz = rad*sin(angle);\n    return vec3(newx, norm.y, newz);\n\n}\n\nShape rotateShape(Shape shape, float rt){\n        shape.normal = addRotationToNormalIq(shape.normal, rt);\n        shape.spolar.xyz = addRotationToNormalIq(shape.spolar.xyz, rt);\n        shape.position = addRotationIq(shape, rt);\n    return shape;\n}\n\nSurface shapeOSF( Shape shape, vec2 coords){\n\n    return shapeOSFCreate(rotateShape(shape, ta), coords);\n}\n\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 gammaCorrection (vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\n\nvec3 toneMapping (vec3 colour){\n    return 1.0 - 1.0/(3.0 * pow(colour, vec3(1.5)) + 1.0); //Modified from milesWaugh's filmic tonemapping curve\n}\n\nvec3 addLight(Surface surface, vec3 lcol, vec3 lpos){\n    vec3 ref = reflect(vec3(0.0, 0.0, -1.0), surface.normal);\n    vec3 diff = lpos - surface.position.xyz;\n    float ldist = length(diff);\n    diff = diff/ldist;\n    float specular = pow(max(0.0, dot(diff, ref)), 16.0);\n    float diffuse = max(0.0, dot(diff, surface.normal));\n    //vec3 col1 = surface.colour.rgb*0.1;\n    vec3 col2 = surface.colour.rgb*0.5*(lcol*diffuse);\n    vec3 col1 = (lcol*specular);\n    return col1+col2;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WclSDX",
    "date": "0",
    "viewed": 0,
    "name": "Wooden sphere",
    "description": "trying out some orthographic texture bump mapping ",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "uv",
     "sphere",
     "orthographic",
     "bumpmap"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGRn",
       "filepath": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define PI 3.1416\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0 ? sign(y)*1.570796 : atan(y, x);\n}\nstruct Surface {\n    vec3 normal;\n    float depth;\n    vec2 uv; // Added UV coordinates\n};\n\nstruct Sphere {\n    vec3 position;\n    float radius;\n    vec4 orientation; // Added quaternion for rotation\n};\n\n\n// Helper function to rotate a vector by a quaternion\nvec3 QuaternionRotateVector(vec4 q, vec3 v) {\n    vec3 result;\n    float x = q.x, y = q.y, z = q.z, w = q.w;\n    float vx = v.x, vy = v.y, vz = v.z;\n\n    result.x = vx*(w*w + x*x - y*y - z*z) + 2.*vy*(x*y - w*z) + 2.*vz*(x*z + w*y);\n    result.y = 2.*vx*(x*y + w*z) + vy*(w*w - x*x + y*y - z*z) + 2.*vz*(y*z - w*x);\n    result.z = 2.*vx*(x*z - w*y) + 2.*vy*(y*z + w*x) + vz*(w*w - x*x - y*y + z*z);\n    \n    return result;\n}\n\nvec2 RotateUV(vec2 uv, vec3 normal) {\n    // Calculate the rotation angle around the y-axis (latitude)\n    float lat_angle = acos(normal.y);\n\n    // Calculate the rotation angle around the x-axis (longitude)\n    float long_angle = atan(normal.x, normal.z);\n\n    // Apply the rotations to the UV coordinates\n    float u = uv.x + long_angle / (2. * PI);\n    float v = uv.y + lat_angle / PI;\n\n    // Ensure UV coordinates are within [0, 1] range\n    u = mod(u, 1.0);\n    //v = clamp(v, 0.0, 1.0);\n    v = mod(v, 1.0);\n    u = clamp(u , 0.0, 1.0);\n    return vec2(u, v);\n}\nvec3 Normalize(vec3 v) {\n    float length = sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\n    return vec3(v.x / length, v.y / length, v.z / length);\n}\nSurface GetSphereSurface(Sphere sphere, vec2 coords, vec3 normal) {\n    vec2 diff = vec2( coords.x - sphere.position.x, coords.y - sphere.position.y );\n    float dist = sqrt(diff.x * diff.x + diff.y * diff.y);\n    float disp = sphere.radius - dist;\n    Surface newsurface;\n\n    if (disp < 0.0f) {\n        newsurface.normal = vec3( 0.0f, 0.0f, 0.0f );\n        newsurface.depth = 0.0f;\n        newsurface.uv = vec2( 0.0f, 0.0f );\n        return newsurface;\n    } else {\n        float depth = sqrt(sphere.radius * sphere.radius - dist * dist);\n        // Assuming projection along Z-axis: correct depth to Z position\n        newsurface.depth = depth + sphere.position.z; // Corrected to sphere.position.z\n\n        // Compute normal (diff.x, diff.y, depth) normalized\n        newsurface.normal = vec3(\n            diff.x / sphere.radius,\n            diff.y / sphere.radius,\n            depth / sphere.radius\n        );\n\n        // World space point (assuming projection along Z-axis)\n        vec3 world_point = vec3(\n            coords.x,\n            coords.y,\n            sphere.position.z + depth\n        );\n\n        // Translate to sphere's local position\n        vec3 relative_point =  vec3(\n            world_point.x - sphere.position.x,\n            world_point.y - sphere.position.y,\n            world_point.z - sphere.position.z\n        );\n\n        // Invert orientation (conjugate quaternion)\n        vec4 inv_orient = vec4( \n            -sphere.orientation.x, \n            -sphere.orientation.y, \n            -sphere.orientation.z, \n            sphere.orientation.w \n        );\n\n        // Rotate to local space\n        vec3 local_point = QuaternionRotateVector(inv_orient, relative_point);\n\n        // Normalize to get surface point on unit sphere\n        float len = sqrt(local_point.x*local_point.x + local_point.y*local_point.y + local_point.z*local_point.z);\n        if (len == 0.0f) {\n            newsurface.uv = vec2( 0.5f, 0.5f );\n            return newsurface;\n        }\n        vec3 norm_local = vec3(\n            local_point.x / len,\n            local_point.y / len,\n            local_point.z / len\n        );\n\n        // Calculate UV coordinates\n        float phi = atan(norm_local.z, norm_local.x); // Azimuthal angle\n        float theta = asin(norm_local.y); // Polar angle (latitude)\n        \n\n        float u = (phi + PI) / (2. * PI); // Map to [0, 1]\n        float v = 0.5f - theta / PI;     // Map north pole to 0, south to 1\n\n        newsurface.uv = vec2( u, v );\n\n\n        return newsurface;\n    }\n}\n\nvec4 ApplyInitialOrientation(vec4 initial_orientation, vec4 axis_angle_quaternion) {\n    // Quaternion composition: q1 * q2\n    float w = initial_orientation.w * axis_angle_quaternion.w - (initial_orientation.x * axis_angle_quaternion.x + initial_orientation.y * axis_angle_quaternion.y + initial_orientation.z * axis_angle_quaternion.z);\n    float x = initial_orientation.w * axis_angle_quaternion.x + initial_orientation.x * axis_angle_quaternion.w + initial_orientation.y * axis_angle_quaternion.z - initial_orientation.z * axis_angle_quaternion.y;\n    float y = initial_orientation.w * axis_angle_quaternion.y + initial_orientation.y * axis_angle_quaternion.w + initial_orientation.z * axis_angle_quaternion.x - initial_orientation.x * axis_angle_quaternion.z;\n    float z = initial_orientation.w * axis_angle_quaternion.z + initial_orientation.z * axis_angle_quaternion.w + initial_orientation.x * axis_angle_quaternion.y - initial_orientation.y * axis_angle_quaternion.x;\n\n    return vec4(x, y, z, w);\n}\n\nvec4 QuaternionFromAxisAngle(vec3 axis, float angle) {\n    vec3 norm_axis = Normalize(axis);\n    float sin_half_angle = sin(angle / 2.0);\n    vec4 q = vec4(\n        norm_axis.x * sin_half_angle,\n        norm_axis.y * sin_half_angle,\n        norm_axis.z * sin_half_angle,\n        cos(angle / 2.0)\n    );\n    return q;\n}\n\nvec4 QuaternionFromAxisAngle2(vec3 axis, float angle) {\n    vec4 q;\n    float halfAngle = angle / 2.;\n    float sinHalfAngle = sin(halfAngle);\n    float cosHalfAngle = cos(halfAngle);\n\n    q.x = sinHalfAngle * axis.x;\n    q.y = sinHalfAngle * axis.y;\n    q.z = sinHalfAngle * axis.z;\n    q.w = cosHalfAngle;\n\n    return q;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 snorm = vec3(0,1,0);\n    vec4 initial_orientation = QuaternionFromAxisAngle2(snorm,iMouse.x/100.);\n    //vec4 initial_orientation = vec4(0.0, 1.0, 0.9, 0.707); // Initial orientation (e.g., 45 degrees around Y axis)\n    vec3 earth_axis = vec3(0, 1, 0); // Earth's axis (approximately)\n    float earth_rotation = iTime; // Initial rotation (e.g., 0 radians)\n    vec4 axis_angle_quaternion = QuaternionFromAxisAngle(earth_axis, earth_rotation);\n    vec4 earth_orientation = ApplyInitialOrientation(initial_orientation, axis_angle_quaternion);\n\n    \n    \n    //quat = ApplyInitialOrientation(snorm, quat);\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    \n    Sphere sphere = Sphere( vec3( 0.5*ar,0.5,1), 0.2, earth_orientation);\n    float depth = -100.;\n    float pixel = uv.y/iResolution.y;\n    //pixel *=3.;\n    vec3 col = vec3(1);\n    float bh = 0.;\n    //bool done = false;\n    Surface surface = GetSphereSurface( sphere, uv, snorm);\n    for(int i = 0; i<21; i++){\n  \n        surface = GetSphereSurface( sphere, uv, snorm);\n        sphere.radius += pixel;\n        //sphere.position.x+= pixel/2.;\n        sphere.position.y-= pixel/2.2;\n            vec3 ncol = texelFetch(iChannel0, ivec2(surface.uv*1024.), 0).rgb;\n            if(ncol.r+ncol.g+ncol.b > float(i)/7.){\n                \n                \n                bh+=0.1;col=ncol;\n                \n            }\n            if(surface.depth > depth){\n                \n                depth = surface.depth;\n            }\n        \n    }\n    \n    //col = vec3(bh);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wcBSzm",
    "date": "0",
    "viewed": 0,
    "name": "Reverse FFT/Audio Visualisation",
    "description": "Drawing with mouse version.\nI want to make sound with it but it's not possible.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "fft",
     "audio",
     "drawing"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Cathode Ray Oscilloscope\" by Cotterzz. https://shadertoy.com/view/XfVyDK\n// 2025-03-11 08:55:27\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define IP 32\n#define SG 48.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0 ).rgb;\n    float xp = iMouse.x/iResolution.x;\n    //for(int i = 0; i<IP; i++){\n        \n        float yp = iMouse.y/iResolution.y;\n        col *= vec3(0.98,0.995,0.99);\n        float dist = distance(uv, vec2(xp,yp));\n        col=col+vec3(100./(dist*565536.));\n         //col=col*0.99;\n    //}\n    someFunction(yp*100.);\n    fragColor = vec4(col,1.0);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec2 mainSound( int samp, float time )\n{\n   \n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*getvar()*time));\n}",
     "name": "Sound",
     "description": "",
     "type": "sound"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "float num = 0.;\n\nvoid someFunction( float a )\n{\n    num = a;\n}\n\nfloat getvar(  )\n{\n    return num;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3fSXWw",
    "date": "1741959631",
    "viewed": 85,
    "name": "Orthographic Icosahedron",
    "description": "I was aiming for truncated icosahedron in less than 1000 chars.\nBest I could do was regular icosahedron in under 1150",
    "likes": 7,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "icosahedron",
     "orthographic",
     "analytic"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// see the comments for some much shorter ways to do this!\n\n#define I iResolution\n#define F float\n#define q ivec3\n#define j vec3\n#define k vec4\n#define R return\nF gp(j A, j B, j C, vec2 D){\n    F d = (A.x - C.x) * (B.y - C.y) - (B.x - C.x) * (A.y - C.y); if (d == 0.){ R -1.; }\n    F s = (D.x - C.x) * (B.y - C.y) - (B.x - C.x) * (D.y - C.y); F u = s / d;\n    F t = (A.x - C.x) * (D.y - C.y) - (D.x - C.x) * (A.y - C.y); F v = t / d;\n    if (u >= 0. && v >= 0. && u + v <= 1.){ F w = 1. - u - v; R u * A.z + v * B.z + w * C.z; } else { R -1.; }\n}\n\nj ar(j p, j a, F r){F c = cos(r);F s = sin(r); p = p-a;R j(p.z*c-p.x*s, p.y, p.z*s+p.x*c)+a;}\n\nvoid mainImage( out k fC, in vec2 fc ) {\n    vec2 uv = fc/I.y; j v[12]; j w[12]; F p = (1.+ sqrt(5.))/2.;\n    int t[26] = int[26](10,0,1,8,6,9,3,2,11,5,10,0,4,0,5,2,9,8,0,7,11,3,6,1,10,11);\n    k m = k(I.x/I.y/2., .5, 0., .2); j c = j(0.); F z = -1.;\n    for (int i = 0; i<4; i++){\n        v[i] = j(0., p, 1.0);\n        if(i>1){v[i].y = -v[i].y;};\n        if (i%2==1){v[i].z = -v[i].z;}\n        v[i+4] = v[i].zxy;v[i+8] = v[i].yzx;\n    }\n    for (int i = 0; i<12; i++){\n        normalize(v[i]);\n        w[i] = v[i]; v[i] *= m.w; v[i] += m.xyz;\n        v[i].yxz = ar(v[i].yxz, m.yxz, iMouse.y/-100.);\n        v[i] = ar(v[i], m.xyz, iMouse.x/-100.);\n    }\n    for (int i = 0; i<20; i++){\n        q T = q(t[i],t[i+1],t[i+2]);\n        if(i>9){ T = q(t[12],t[i+3],t[i+4]);}\n        if(i>14){ T = q(t[19],t[i+5],t[i+6]);}\n        F n = gp(v[T.x],v[T.y],v[T.z], uv);\n        if(n>z){z=n; c =(.2 + n/2.)+(w[T.x]+w[T.y]+w[T.z])/20.+.1;}\n    }\n    fC = k(c, 1.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tfSSzK",
    "date": "1742124045",
    "viewed": 9,
    "name": "Red Blob",
    "description": "circular gradient with sine warping",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "blob",
     "red"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.y;\n    float ar = iResolution.y/iResolution.x;\n    \n    vec3 blob = vec3(0.5/ar, 0.5, 0.4);\n    \n    if(iMouse.z>0.){ blob.x = iMouse.x/iResolution.x/ar;  blob.y = iMouse.y/iResolution.y; }\n    \n\n    vec3 col = vec3(0);\n    \n    vec2 muv = uv;\n    muv.y += sin(iTime*11.+(uv.x*37.))/40.;\n    muv.x += sin(iTime*17.+(uv.y*73.))/50.;\n    float dist = distance(muv, blob.xy);\n    if(dist<blob.z){\n        col = vec3(1. - (2.*dist/blob.z),0.,0.);\n    }\n\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tf2XzV",
    "date": "1742168573",
    "viewed": 62,
    "name": "Polyhedra by sphere intersection",
    "description": "Using intersection of spheres to draw a dodecahedron.\nWe can make the spheres bigger for more precision.\nHas the advantage that no faces are defined, just the points of the dual - so using icosahdreon points gives us a dodecahedron.",
    "likes": 6,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "sphere",
     "orthographic",
     "polyhedra",
     "dodecaheron"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec3 ar(vec3 p, vec3 a, float r){float c = cos(r);float s = sin(r); p = p-a;return vec3(p.z*c-p.x*s, p.y, p.z*s+p.x*c)+a;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sphereSize = 0.5;\n    float polySize = 0.1;\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 v[12];\n    vec4 m = vec4(iResolution.x/iResolution.y/2., .5, 0., sphereSize);\n    float z = 10.;\n    float bz = -10.;\n    for (int i = 0; i<4; i++){\n        v[i] = vec3(0., 1.618, 1.);\n        if(i>1){v[i].y = -v[i].y;};\n        if (i%2==1){v[i].z = -v[i].z;}\n        v[i+4] = v[i].zxy;v[i+8] = v[i].yzx;\n    }\n    vec3 col = vec3(0); int ci = -1;\n    bool inside = true; bool edge = false;\n    float ss = m.w *1.903; ss+=polySize;\n    for (int i = 0; i<12; i++){\n        normalize(v[i]);\n        v[i] *= m.w; v[i] += m.xyz;\n        v[i].yxz = ar(v[i].yxz, m.yxz, iMouse.y/-100.);\n        v[i] = ar(v[i], m.xyz, iMouse.x/-100.);\n        float dist = distance(uv, v[i].xy);\n        float disp = ss-dist;\n        if(abs(disp)<0.001){edge = true;}\n        if(disp>0.){\n            vec2 distv = uv - v[i].xy;\n            float height = sqrt((ss*ss)-(dist*dist));//vec3 normal = vec3(distv.x, distv.y, height)/ss;\n            float bheight = -height + v[i].z;height+=v[i].z;//vec3 bnormal = vec3(distv.x, distv.y, bheight)/ss;\n            float ndist = distance(vec3(uv,height-0.0001), m.xyz);\n            float bndist = distance(vec3(uv,bheight+0.0001), m.xyz);\n            if(bheight>bz){bz = bheight;}\n            if(height<z){z = height;ci = i;}\n            if(z<bz){ci=-1;}\n        } else {inside = false;}\n    }\n    if(ci>-1 ){col = vec3(float(ci)/12.);}\n    if(!inside){col = vec3(0,0,0);}\n    if(edge){col = vec3(0,0.2,0.7);}\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3cBXzc",
    "date": "1742188080",
    "viewed": 107,
    "name": "Polyhedra by sphere intersect 2",
    "description": "Using intersection of spheres to draw polyhedra.\nWe can geat a variety of shapes from relatively few points and no faces defined.",
    "likes": 12,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "sphere",
     "icosahedron",
     "orthographic",
     "octahedron",
     "polyhedra",
     "truncatedicosahedron",
     "dodecaheron"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Polyhedra by sphere intersection\" by Cotterzz. https://shadertoy.com/view/tf2XzV\n// 2025-03-17 04:58:15\n#define uv2 uv\n// remove this define for fix, if you see an truncated icosahedron in the top left.\n// It should be a regular icosahedron. See comments\nvec3 ar(vec3 p, vec3 a, float r){float c = cos(r);float s = sin(r); p = p-a;return vec3(p.z*c-p.x*s, p.y, p.z*s+p.x*c)+a;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sphereSize = 1.1;\n    float polySize = 0.15;\n    vec2 uv = fragCoord/iResolution.y;\n    float as = iResolution.x/iResolution.y;\n    int st = -1; int fi = 32; float ed = 0.002; float ued = 0.0035; bool uie = false;\n    #ifndef uv2\n    vec2 uv2 = uv;\n    #endif\n    if(abs(uv.x-0.33*as)<ued ){ uie = true;}\n    if(uv.x<0.33*as){\n        if(abs(uv.y-0.33)<ued || abs(uv.y-0.66)<ued){ uie = true;}\n        if(uv.y>0.66){\n            uv2.y-=0.66;\n            st = 11;\n        } else if(uv.y>0.33){\n            uv2.y-=0.33;\n            fi = 12;\n        } else {st=11;fi=20;}\n        uv2*=3.;\n        ed = 0.005;\n    } else {\n        uv2.x-=as*0.1666;\n    }\n    vec3 v[32];\n    vec4 m = vec4(as/2., .5, 0., sphereSize-polySize);\n    float z = 10.;\n    float bz = -10.;\n    v[12] = vec3(1.);v[13] = vec3(-1.,1,1);v[14] = v[13].yxz;v[15] = v[13].yzx;\n    for (int i = 0; i<4; i++){\n        v[i] = vec3(0., 1.618, 1.);\n        v[i+20] = vec3(0., 0.618, 1.618);\n        if(i>1){v[i].y = -v[i].y;v[i+20].y = -v[i+20].y;};\n        if (i%2==1){v[i].z = -v[i].z;v[i+20].z = -v[i+20].z;}\n        v[i+4] = v[i].zxy;v[i+8] = v[i].yzx;\n        v[i+28] = v[i+20].zxy;v[i+24] = v[i+20].yzx;\n        v[i+16] = -v[i+12];\n    }\n    float fct = 1.903;\n    vec3 col = vec3(0); int ci = -1;\n    bool inside = true; bool edge = false;\n    float ss = m.w*2.0+polySize;\n    for (int i = 0; i<32; i++){\n        if(i>st && i<fi){\n        \n        if(i>11){v[i]*=1.1;}\n        v[i] *= m.w; v[i] += m.xyz;\n        v[i].yxz = ar(v[i].yxz, m.yxz, iMouse.y/-100.);\n        v[i] = ar(v[i], m.xyz, iMouse.x/-100.);\n        float dist = distance(uv2, v[i].xy);\n        float disp = ss-dist;\n        if(abs(disp)<ed){edge = true;}\n        if(disp>0.){\n            vec2 distv = uv2 - v[i].xy;\n            float height = sqrt((ss*ss)-(dist*dist));//vec3 normal = vec3(distv.x, distv.y, height)/ss;\n            float bheight = -height + v[i].z;height+=v[i].z;//vec3 bnormal = vec3(distv.x, distv.y, bheight)/ss;\n            float ndist = distance(vec3(uv,height-0.0001), m.xyz);\n            float bndist = distance(vec3(uv,bheight+0.0001), m.xyz);\n            if(bheight>bz){bz = bheight;}\n            if(height<z){z = height;ci = i;}\n            if(z<bz){ci=-1;}\n        } else {inside = false;}\n        }\n    }\n    if(ci>-1 ){col = vec3(float(ci)/32.);}\n    if(!inside){col = vec3(0,0,0);}\n    if(edge){col = vec3(0,0.2,0.7);}\n    if(uie){col = vec3(0.1,0.7,0.3);}\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3f2SDV",
    "date": "0",
    "viewed": 0,
    "name": "Fork of Turbulent Flame",
    "description": "Fork of https://shadertoy.com/view/wffXDr",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "fire",
     "fluid",
     "glow",
     "turbulence"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdfGRn",
       "filepath": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Turbulent Flame\" by Xor. https://shadertoy.com/view/wffXDr\n// 2025-03-19 21:26:09\n\n/*\n    \"Turbulent Flame\" by @XorDev\n    \n    For my tutorial on Turbulence:\n    https://mini.gmshaders.com/p/turbulence\n    \n    Simulating proper fluid dynamics can be complicated, limited, and requires a multi-pass setup.\n\n    Sometimes you just want some smoke, fire, or fluid, and you don't want to go through all that trouble.\n\n    This method is very simple! Start with pixel coordinates and scale them down as desired,\n    then loop through adding waves, rotating the wave direction and increasing the frequency.\n    To animate it, you can add a time offset to the sine wave.\n    It also helps to shift each iteration with the iterator \"i\" to break up visible patterns.\n\n    The resulting coordinates will appear turbulent, and you can use these coordinates in a coloring function.\n    \n    Smooth, continious equations look best!\n    \n    To complete the flame look, we need to scroll the waves and expand the coordinate space upwards \n*/\n\n//Fire ring radius\n\n//Falloff gradient\n\n//Scroll speed\n#define SCROLL 1.6\n//Flicker intensity\n#define FLICKER 0.12\n//Flicker animation speed\n#define FLICKER_SPEED 6.0\n\n//Number of turbulence waves\n#define TURB_NUM 10.0\n//Turbulence wave amplitude\n#define TURB_AMP 0.4\n//Turbulence wave speed\n#define TURB_SPEED 6.0\n//Turbulence frequency (inverse of scale)\n#define TURB_FREQ 7.0\n//Turbulence frequency multiplier\n#define TURB_EXP 1.3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float RADIUS = iMouse.x/iResolution.x;\n    float GRADIENT = iMouse.y/iResolution.y;\n    //Screen coordinates, centered and aspect corrected\n    vec2 p = (fragCoord.xy*2.0-iResolution.xy) / iResolution.y;\n    p*=3.;\n    p.y+=0.6;\n    if(p.y<0.){p.y*=1.+abs(p.y);}\n    vec2 screen = p;\n    screen *=0.6;\n    screen.x *= 2.2;\n    screen.y-=1.2;\n    //Expand vertically\n    float xstretch = 2.0 - 1.5*smoothstep(-2.0,2.0,p.y);\n    //Decelerate horizontally\n    float ystretch = 1.0 - 0.5 / (1.0+p.x*p.x);\n    //Combine\n    vec2 stretch = vec2(xstretch, ystretch);\n    //Stretch coordinates\n    p *= stretch;\n    \n    //Scroll upward\n    float scroll = SCROLL*iTime;\n    p.y -= scroll;\n    \n    //Turbulence starting scale\n    float freq = TURB_FREQ;\n    \n    //Turbulence rotation matrix\n    mat2 rot = mat2(0.6, -0.8, 0.8, 0.6);\n    \n    //Loop through turbulence octaves\n    for(float i=0.0; i<TURB_NUM; i++)\n    {\n        //Scroll along the rotated y coordinate\n        float phase = freq * (p * rot).y + TURB_SPEED*iTime + i;\n        //Add a perpendicular sine wave offset\n        p += TURB_AMP * rot[0] * sin(phase) / freq;\n        \n        //Rotate for the next octave\n        rot *= mat2(0.6, -0.8, 0.8, 0.6);\n        //Scale down for the next octave\n        freq *= TURB_EXP;\n    }\n    //Reverse the scrolling offset\n    p.y += scroll;\n    \n    //Distance to fireball\n    float dist = length(min(p,p/vec2(1,stretch.y))) - RADIUS;\n    //Attenuate outward and fade vertically\n    float light = 1.0/pow(dist*dist+GRADIENT*max(p.y+.5,0.0),3.0);\n    //Coordinates relative to the source\n    vec2 source = p + 2.0*vec2(0,RADIUS) * stretch;\n    //RGB falloff gradient\n    vec3 grad = 0.1 / (1.0 + 8.0*length(source) / vec3(9, 2, 1));\n    \n    //Flicker animation time\n    float ft = FLICKER_SPEED * iTime;\n    //Flicker brightness\n    float flicker = 1.0+FLICKER*cos(ft+sin(ft*1.618-p.y));\n    //Ambient lighting\n    vec3 amb = 64.0*flicker/(1.0+dot(screen,screen))*grad;\n    amb.r*=0.4;\n    //Scrolling texture uvs\n    vec2 uv = (p - SCROLL*vec2(0,iTime)) / 1e2 * TURB_FREQ;\n    //Sample texture for fire\n    vec3 tex = texture(iChannel0,uv).rgb;\n    \n    //Combine ambient light and fire\n    vec3 col = amb + light*grad*tex;\n    //Exponential tonemap\n    //https://mini.gmshaders.com/p/tonemaps\n    col = 1.0 - exp(-col);\n    fragColor = vec4(col,1);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tfjXWK",
    "date": "1742423440",
    "viewed": 193,
    "name": "Turbulent Flame vs Glasshawk",
    "description": "Credit to the respective authors of the original shaders.\nI'm sure there's a better way of doing this that makes use of the individual facets.",
    "likes": 16,
    "published": "Public",
    "usePreview": 1,
    "tags": [
     "fire",
     "remix",
     "turbulence",
     "fork",
     "mlp",
     "bird",
     "phoenix"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdfGRn",
       "filepath": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Glasshawk\" by igneus https://www.shadertoy.com/view/3fsXWS\n// Fork of \"Turbulent Flame\" by Xor. https://shadertoy.com/view/wffXDr\n// Inspired by \"Phoenix Ascending\" by igneus https://www.shadertoy.com/view/WclSWl\n// 2025-03-19 21:26:09\n\n/*\n    \"Turbulent Flame\" by @XorDev\n    \n    For my tutorial on Turbulence:\n    https://mini.gmshaders.com/p/turbulence\n    \n    Simulating proper fluid dynamics can be complicated, limited, and requires a multi-pass setup.\n\n    Sometimes you just want some smoke, fire, or fluid, and you don't want to go through all that trouble.\n\n    This method is very simple! Start with pixel coordinates and scale them down as desired,\n    then loop through adding waves, rotating the wave direction and increasing the frequency.\n    To animate it, you can add a time offset to the sine wave.\n    It also helps to shift each iteration with the iterator \"i\" to break up visible patterns.\n\n    The resulting coordinates will appear turbulent, and you can use these coordinates in a coloring function.\n    \n    Smooth, continious equations look best!\n    \n    To complete the flame look, we need to scroll the waves and expand the coordinate space upwards \n*/\n\n//Fire ring radius\n#define RADIUS 0.2\n//Falloff gradient\n#define GRADIENT 0.05\n//Scroll speed\n#define SCROLL 2.6\n//Flicker intensity\n#define FLICKER 0.2\n//Flicker animation speed\n#define FLICKER_SPEED 6.0\n\n//Number of turbulence waves\n#define TURB_NUM 10.0\n//Turbulence wave amplitude\n#define TURB_AMP 0.4\n//Turbulence wave speed\n#define TURB_SPEED 3.0\n//Turbulence frequency (inverse of scale)\n#define TURB_FREQ 13.0\n//Turbulence frequency multiplier\n#define TURB_EXP 1.2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //Screen coordinates, centered and aspect corrected\n    vec2 p = (fragCoord.xy*2.0-iResolution.xy) / iResolution.y;\n    vec2 uv = p;\n    p*=2.3;\n    p.y+=0.7;\n    if(p.y<0.){p.y*=1.+abs(p.y);}\n    vec2 screen = p;\n    screen *=0.6;\n    screen.x *= 2.2;\n    screen.y-=1.;\n    //Expand vertically\n    float xstretch = 2.0 - 1.5*smoothstep(-2.0,2.0,p.y);\n    //Decelerate horizontally\n    float ystretch = 1.0 - 0.5 / (1.0+p.x*p.x);\n    //Combine\n    vec2 stretch = vec2(xstretch, ystretch);\n    //Stretch coordinates\n    p *= stretch;\n    \n    //Scroll upward\n    float scroll = SCROLL*iTime;\n    p.y -= scroll;\n    \n    //Turbulence starting scale\n    float freq = TURB_FREQ;\n    \n    //Turbulence rotation matrix\n    mat2 rot = mat2(0.6, -0.8, 0.8, 0.6);\n    \n    //Loop through turbulence octaves\n    for(float i=0.0; i<TURB_NUM; i++)\n    {\n        //Scroll along the rotated y coordinate\n        float phase = freq * (p * rot).y + TURB_SPEED*iTime + i;\n        //Add a perpendicular sine wave offset\n        p += TURB_AMP * rot[0] * sin(phase) / freq;\n        \n        //Rotate for the next octave\n        rot *= mat2(0.6, -0.8, 0.8, 0.6);\n        //Scale down for the next octave\n        freq *= TURB_EXP;\n    }\n    //Reverse the scrolling offset\n    p.y += scroll;\n    \n    vec4 bird = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    \n    //Distance to fireball\n    float dist = length(min(p,p/vec2(1,stretch.y))) - bird.a;\n    //Attenuate outward and fade vertically\n    float light = 0.6/pow(dist*dist+GRADIENT*max(p.y+.5,0.0),2.1);\n    //Coordinates relative to the source\n    vec2 source = p + 2.0*vec2(0,1) * stretch;\n    //RGB falloff gradient\n    vec3 grad = 0.1 / (1.0 + 8.0*length(source) / vec3(9, 2, 1));\n    //Flicker animation time\n    float ft = FLICKER_SPEED * iTime;\n    //Flicker brightness\n    float flicker = 1.0+FLICKER*cos(ft+sin(ft*1.618-p.y));\n    //Ambient lighting\n    vec3 amb = 32.0*flicker/(1.0+dot(screen,screen))*grad;\n    amb.r*=0.4;\n    //Scrolling texture uvs\n    //vec2 uv = (p - SCROLL*vec2(0,iTime)) / 1e2 * TURB_FREQ;\n    //Sample texture for fire\n    vec3 tex = vec3(bird.r/3.+bird.g/2.,bird.r/7.+bird.g/6.,0);\n    //Combine ambient light and fire\n    vec3 col = max(tex,amb +light*grad);\n    //Exponential tonemap\n    //https://mini.gmshaders.com/p/tonemaps\n    col = 1.0 - exp(-col);\n    fragColor = vec4(col,1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// *******************************************************************************************************\n//    Math functions\n// *******************************************************************************************************\n\n#define kPi                    3.14159265359\n#define kInvPi                 (1.0 / 3.14159265359)\n#define kTwoPi                 (2.0 * kPi)\n#define kFourPi                (4.0 * kPi)\n#define kHalfPi                (0.5 * kPi)\n#define kRootPi                1.77245385091\n#define kRoot2                 1.41421356237\n#define kLog10                 2.30258509299\n#define kFltMax                3.402823466e+38\n#define kLog2                  0.6931471805\n#define kOneThird              (1.0 / 3.0)\n#define kIntMax                0x7fffffff\n#define kOne                   vec3(1.)\n#define kZero                  vec3(0.)\n#define kRed                   vec3(1., 0., 0.)\n#define kYellow                vec3(1., 1., 0.)\n#define kGreen                 vec3(0., 1., 0.)\n#define kBlue                  vec3(0., 0., 1.)\n#define kPink                  vec3(1., 0., 0.2) \n#define kPackedZero            max(0., iTime - 1e15)\n#define Timecode               vec3\n\nfloat cubrt(float a)           { return sign(a) * pow(abs(a), 1.0 / 3.0); }\nfloat toRad(float deg)         { return kTwoPi * deg / 360.0; }\nfloat toDeg(float rad)         { return 360.0 * rad / kTwoPi; }\nfloat sqr(float a)             { return a * a; }\nvec2 sqr(vec2 a)               { return a * a; }\nvec3 sqr(vec3 a)               { return a * a; }\nvec4 sqr(vec4 a)               { return a * a; }\nint sqr(int a)                 { return a * a; }\nint cub(int a)                 { return a * a * a; }\nfloat cub(float a)             { return a * a * a; }\nfloat pow4(float a)            { a *= a; return a * a; }\nint mod2(int a, int b)         { return ((a % b) + b) % b; }\nfloat mod2(float a, float b)   { return mod(mod(a, b) + b, b); }\nvec3 mod2(vec3 a, vec3 b)      { return mod(mod(a, b) + b, b); }\nfloat length2(vec2 v)          { return dot(v, v); }\nfloat length2(vec3 v)          { return dot(v, v); }\nint sum(ivec2 a)               { return a.x + a.y; }\nfloat sum(vec2 v)              { return v.x + v.y; }\nfloat sum(vec3 v)              { return v.x + v.y + v.z; }\nfloat sum(vec4 v)              { return v.x + v.y + v.z + v.w; }\nfloat luminance(vec3 v)        { return v.x * 0.17691 + v.y * 0.8124 + v.z * 0.01063; }\nfloat mean(vec3 v)             { return v.x / 3.0 + v.y / 3.0 + v.z / 3.0; }\nvec4 mul4(vec3 a, mat4 m)      { return vec4(a, 1.0) * m; }\nvec3 mul3(vec3 a, mat4 m)      { return (vec4(a, 1.0) * m).xyz; }\nfloat sin01(float a)           { return 0.5 * sin(a) + 0.5; }\nfloat cos01(float a)           { return 0.5 * cos(a) + 0.5; }\n#define saturate(a)            clamp(a, 0.0, 1.0)\nfloat cwiseMax(vec3 v)         { return (v.x > v.y) ? ((v.x > v.z) ? v.x : v.z) : ((v.y > v.z) ? v.y : v.z); }\nfloat cwiseMax(vec2 v)         { return (v.x > v.y) ? v.x : v.y; }\nint cwiseMax(ivec2 v)          { return (v.x > v.y) ? v.x : v.y; }\nfloat cwiseMin(vec3 v)         { return (v.x < v.y) ? ((v.x < v.z) ? v.x : v.z) : ((v.y < v.z) ? v.y : v.z); }\nint cwiseMin(ivec3 v)          { return (v.x < v.y) ? ((v.x < v.z) ? v.x : v.z) : ((v.y < v.z) ? v.y : v.z); }\nfloat cwiseMin(vec2 v)         { return (v.x < v.y) ? v.x : v.y; }\nfloat max3(float a, float b, float c) { return (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c); }\nfloat min3(float a, float b, float c) { return (a < b) ? ((a < c) ? a : c) : ((b < c) ? b : c); }\nvoid sort(inout float a, inout float b) { if(a > b) { float s = a; a = b; b = s; } }\nvoid swap(inout float a, inout float b) { float s = a; a = b; b = s; }\nvoid swap(inout int a, inout int b) { int s = a; a = b; b = s; }\n\nfloat Smoothstep(float x) { return smoothstep(0., 1., x); }\nfloat Smoothstep(float a, float b, float x) { return mix(a, b, smoothstep(0., 1., x)); }\nfloat Smootherstep(float x) { return x * x * x * (x * (6. * x - 15.) + 10.); }\nfloat Smootherstep(float a, float b, float x) { return mix(0., 1., x * x * x * (x * (6. * x - 15.) + 10.)); }\n\nfloat atan2(float y, float x)\n{\n    float phi = atan(y, x);\n    return (phi < 0.) ? (kTwoPi + phi) : phi;\n}\n\nfloat saw(float a)             \n{ \n    a = mod(a / kPi, 2.);\n    return (1. - (2. * abs(fract(a) - 0.5))) * -(floor(a) * 2. - 1.);\n}\n\nfloat cosaw(float a) { return saw(a + kHalfPi); }\n\nfloat saw01(float a) { return saw(a) * 0.5 + 0.5; }\nfloat cosaw01(float a) { return saw(a + kHalfPi) * 0.5 + 0.5; }\n\nvec3 safeAtan(vec3 a, vec3 b)\n{\n    vec3 r;\n    #define kAtanEpsilon 1e-10\n    r.x = (abs(a.x) < kAtanEpsilon && abs(b.x) < kAtanEpsilon) ? 0.0 : atan(a.x, b.x); \n    r.y = (abs(a.y) < kAtanEpsilon && abs(b.y) < kAtanEpsilon) ? 0.0 : atan(a.y, b.y); \n    r.z = (abs(a.z) < kAtanEpsilon && abs(b.z) < kAtanEpsilon) ? 0.0 : atan(a.z, b.z); \n    return r;\n}\n\nvec3 SafeNormalize(vec3 v, vec3 n)\n{\n    float len = length(v);\n    return (len > 1e-10) ? (v / len) : n;\n}\n\nvec2 SafeNormalize(vec2 v) { return v / (1e-10 + length(v)); }\nvec3 SafeNormalize(vec3 v) { return v / (1e-10 + length(v)); }\nvec4 SafeNormalize(vec4 v) { return v / (1e-10 + length(v)); }\n\nvec3 SafeNormaliseTexel(vec4 t)\n{\n    return t.xyz / max(1e-15, t.w);\n}\n\nvec4 Sign(vec4 v)\n{\n    return step(vec4(0.0), v) * 2.0 - 1.0;\n}\n\nfloat Sign(float v)\n{\n    return step(0.0, v) * 2.0 - 1.0;\n}\n\nbool IsNan( float val )\n{\n    return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;\n}\n\nbvec3 IsNan( vec3 val )\n{\n    return bvec3( ( val.x < 0.0 || 0.0 < val.x || val.x == 0.0 ) ? false : true, \n                  ( val.y < 0.0 || 0.0 < val.y || val.y == 0.0 ) ? false : true, \n                  ( val.z < 0.0 || 0.0 < val.z || val.z == 0.0 ) ? false : true);\n}\n\nbvec4 IsNan( vec4 val )\n{\n    return bvec4( ( val.x < 0.0 || 0.0 < val.x || val.x == 0.0 ) ? false : true, \n                  ( val.y < 0.0 || 0.0 < val.y || val.y == 0.0 ) ? false : true, \n                  ( val.z < 0.0 || 0.0 < val.z || val.z == 0.0 ) ? false : true,\n                  ( val.w < 0.0 || 0.0 < val.w || val.w == 0.0 ) ? false : true);\n}\n\n\n#define SignedGamma(v, gamma) (sign(v) * pow(abs(v), gamma))\n\nbool QuadraticSolve(float a, float b, float c, out float t0, out float t1)\n{\n    float b2ac4 = b * b - 4.0 * a * c;\n    if(b2ac4 < 0.0) { return false; } \n\n    float sqrtb2ac4 = sqrt(b2ac4);\n    t0 = (-b + sqrtb2ac4) / (2.0 * a);\n    t1 = (-b - sqrtb2ac4) / (2.0 * a);    \n    return true;\n}\n\n// Closed-form approxiation of the error function.\n// See 'Uniform Approximations for Transcendental Functions', Winitzki 2003, https://doi.org/10.1007/3-540-44839-X_82\nfloat ErfApprox(float x)\n{    \n     float a = 8.0 * (kPi - 3.0) / (3.0 * kPi * (4.0 - kPi));\n     return sign(x) * sqrt(1.0 - exp(-(x * x) * (4.0 / kPi + a * x * x) / (1.0 + a * x * x)));\n}\n\nfloat UintToFloat01(uint i)\n{\n    return float(i) / float(0xffffffffu);\n}\n\nfloat UintToFloat01(uint i, int  bits)\n{\n    return float(i & ((1u << bits) - 1u)) / float(((1u << bits) - 1u));\n}\n\nfloat Sigmoid(float x)\n{\n    return 1. / (1. + exp(-x));\n}\n\nvec2 ScreenToNormalisedScreen(vec2 p, vec2 iRes)\n{   \n    return 2. * (p - vec2(iRes) * 0.5) / float(iRes.y); \n}\n\n#define PackVec2(v) uintBitsToFloat(packHalf2x16(v))\n#define PackFloat2(a, b) uintBitsToFloat(packHalf2x16(vec2(a, b)))\n#define PackInt2(a, b) uintBitsToFloat((uint(a) & 0xffffu) | (uint(b) << 16))\n#define PackIVec2(v) uintBitsToFloat((uint(v.x) & 0xffffu) | (uint(v.y) << 16))\n#define UnpackVec2(f) unpackHalf2x16(floatBitsToUint(f))\n\nivec2 UnpackIVec2(float f)\n{\n    uint bits = floatBitsToUint(f);\n    return ivec2(int(bits & 0xffffu), int(bits >> 16));\n}\n\nvec4 EvaluateCatmullRom(vec2 v0, vec2 v1, vec2 v2, vec2 v3, float t)\n{\n    // Finite-difference derivatives at control points v1 and v2\n    vec2 dv1dt = (v2 - v0) * 0.5;\n    vec2 dv2dt = (v3 - v1) * 0.5;\n\n    // Evaluate the position on the spline in Hermiteian form and the 1st derivative in standard form\n    vec4 p;\n    p.xy = v1 * (1. + t * t * (2. * t - 3.)) + dv1dt * (t * (1. + t * (t - 2.))) + v2 * (t * t * (3. - 2. * t)) + dv2dt * (t * t * (t - 1.));\n    p.zw = (v1*2. + dv1dt - v2*2. + dv2dt) * t*t*3. + (v2*3. - v1*3. - dv1dt*2. - dv2dt) * t*2.;\n    return p;\n}\n\n// *******************************************************************************************************\n//    Hash functions\n// *******************************************************************************************************\n\n// Constants for the Fowler-Noll-Vo hash function\n// https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function\n#define kFNVPrime              0x01000193u\n#define kFNVOffset             0x811c9dc5u\n#define kDimsPerBounce         4\n\n// Mix and combine two hashes\nuint HashCombine(uint a, uint b)\n{\n    return (((a << (31u - (b & 31u))) | (a >> (b & 31u)))) ^\n            ((b << (a & 31u)) | (b >> (31u - (a & 31u))));\n}\n\n// Compute a 32-bit Fowler-Noll-Vo hash for the given input\nuint HashOf(uint i)\n{\n    uint h = (kFNVOffset ^ (i & 0xffu)) * kFNVPrime;\n    h = (h ^ ((i >> 8u) & 0xffu)) * kFNVPrime;\n    h = (h ^ ((i >> 16u) & 0xffu)) * kFNVPrime;\n    h = (h ^ ((i >> 24u) & 0xffu)) * kFNVPrime;\n    return h;\n}\n\nuint HashOf(int a) { return HashOf(uint(a)); }\nuint HashOf(uint a, uint b) { return HashCombine(HashOf(a), HashOf(b)); }\nuint HashOf(uint a, uint b, uint c) { return HashCombine(HashCombine(HashOf(a), HashOf(b)), HashOf(c)); }\nuint HashOf(uint a, uint b, uint c, uint d) { return HashCombine(HashCombine(HashOf(a), HashOf(b)), HashCombine(HashOf(c), HashOf(d))); }\nuint HashOf(vec2 v) { return HashCombine(HashOf(uint(v.x)), HashOf(uint(v.y))); }\nuint HashOf(ivec2 v) { return HashCombine(HashOf(uint(v.x)), HashOf(uint(v.y))); }\n\nfloat HashOfAsFloat(uint i)\n{    \n    return float(HashOf(i)) / float(0xffffffffu);\n}\n\nfloat HashOfAsFloat(uint i, int bits)\n{    \n    return float(HashOf(i) & ((1u << bits) - 1u)) / float(((1u << bits) - 1u));\n}\n\nuvec2 Uvec2FromFloat(float f)\n{\n    uint u = floatBitsToUint(f);\n    return uvec2(u & 0xffffu, u >> 16);\n}\n\nfloat FloatFromUvec2(uvec2 v)\n{\n    return uintBitsToFloat((v.x & 0xffffu) | ((v.y & 0xffffu) << 16));\n}\n\n#define kUseHalfPrecisionIntrinsics\n\n#ifdef kUseHalfPrecisionIntrinsics\n\n    #define _unpackHalf2x16 unpackHalf2x16\n    #define _packHalf2x16 packHalf2x16\n    \n#else\n\n    uint FloatToHalfBits(float f)\n    {\n        uint u = floatBitsToUint(f);\n        \n        // Handle zero as special case\n        if(u == 0u) \n        { \n            return 0u; \n        } \n        else\n        {\n            uint expo = (u >> 23) & 0xffu;\n            if(expo < 127u - 15u) { expo = 0u; } // Underflow\n            else if(expo > 127u + 16u) { expo = 31u; } // Overflow\n            else { expo = ((u >> 23) & 0xffu) + 15u - 127u; } // Biased exponent\n\n            // Composite\n            return ((u >> 16) & (1u << 15)) |  // Sign bit\n                   ((u & ((1u << 23) - 1u)) >> 13) | // Fraction\n                   ((expo & ((1u << 5) - 1u)) << 10); // Exponent\n        }\n    }\n\n    float HalfBitsToFloat(uint u)\n    {\n        if(u == 0u) { return 0.; }\n\n        uint v = ((u & (1u << 15)) << 16) | // Sign bit \n                 ((u & ((1u << 10u) - 1u)) << 13) | // Fraction\n                 ((((u >> 10) & ((1u << 5) - 1u)) + 127u - 15u) << 23); // Exponent\n\n        return uintBitsToFloat(v);\n    }\n\n    vec2 _unpackHalf2x16Impl(uint u)\n    {\n        return vec2(HalfBitsToFloat(u & 0xffffu), HalfBitsToFloat(u >> 16));\n    }\n\n    uint _packHalf2x16Impl(vec2 v)\n    {\n        return (FloatToHalfBits(v.x) & 0xffffu) | (FloatToHalfBits(v.y) << 16);\n    }\n\n    #define _unpackHalf2x16 _unpackHalf2x16Impl\n    #define _packHalf2x16 _packHalf2x16Impl\n\n#endif\n\n\n\nvec3 BilinearHalf(sampler2D sampler, vec2 uv, int idx)\n{\n    uv *= vec2(textureSize(sampler, 0));\n    \n    vec4 t00 = texelFetch(sampler, ivec2(uv), 0);\n    vec4 t10 = texelFetch(sampler, ivec2(uv) + ivec2(1, 0), 0);\n    vec4 t01 = texelFetch(sampler, ivec2(uv) + ivec2(0, 1), 0);\n    vec4 t11 = texelFetch(sampler, ivec2(uv) + ivec2(1, 1), 0);\n    \n    idx = (idx & 1) << 1;\n    return mix(mix(vec3(_unpackHalf2x16(floatBitsToUint(t00[idx])), t00[idx+1]), vec3(_unpackHalf2x16(floatBitsToUint(t10[idx])), t10[idx+1]), fract(uv.x)), \n                mix(vec3(_unpackHalf2x16(floatBitsToUint(t01[idx])), t01[idx+1]), vec3(_unpackHalf2x16(floatBitsToUint(t11[idx])), t11[idx+1]), fract(uv.x)),\n                fract(uv.y));\n}\n\nfloat UnpackNormalise(sampler2D sampler, ivec2 xy, int chnl)\n{\n    vec2 p = _unpackHalf2x16(floatBitsToUint(texelFetch(sampler, ivec2(xy), 0)[chnl]));\n    return p.x / max(1., p.y);\n}\n\nfloat BilinearUnpackNormalise(sampler2D sampler, vec2 uv, int chnl)\n{\n    uv *= vec2(textureSize(sampler, 0));\n    \n    float t00 = UnpackNormalise(sampler, ivec2(uv), chnl);\n    float t10 = UnpackNormalise(sampler, ivec2(uv) + ivec2(1, 0), chnl);\n    float t01 = UnpackNormalise(sampler, ivec2(uv) + ivec2(0, 1), chnl);\n    float t11 = UnpackNormalise(sampler, ivec2(uv) + ivec2(1, 1), chnl);\n    \n    return mix(mix(t00, t10, fract(uv.x)), mix(t01, t11, fract(uv.x)), fract(uv.y));\n}\n\n///////\n\n\n// *******************************************************************************************************\n//    Random number generation\n// *******************************************************************************************************\n\n// Permuted congruential generator from \"Hash Functions for GPU Rendering\" (Jarzynski and Olano)\n// http://jcgt.org/published/0009/03/02/paper.pdf\n\n#define RNGCtx uvec4\n\nuvec4 PCGAdvance(inout RNGCtx rngSeed)\n{\n    rngSeed = rngSeed * 1664525u + 1013904223u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    rngSeed ^= rngSeed >> 16u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    return rngSeed;\n}\n\n// Generates a tuple of canonical random number and uses them to sample an input texture\nvec4 Rand4(inout RNGCtx ctx, ivec2 xy, sampler2D sampler)\n{\n    return texelFetch(sampler, (xy + ivec2(PCGAdvance(ctx) >> 16)) % 1024, 0);\n}\n\n// Generates a tuple of canonical random numbers in the range [0, 1]\nvec4 Rand4(inout RNGCtx ctx)\n{\n    return vec4(PCGAdvance(ctx)) / float(0xffffffffu);\n}\n\n// Generates a tuple of canonical random numbers in the range [0, 1]\nfloat[5] Rand5(inout RNGCtx ctx)\n{\n    vec4 v1 = vec4(PCGAdvance(ctx)) / float(0xffffffffu);\n    vec4 v2 = vec4(PCGAdvance(ctx)) / float(0xffffffffu);\n    return float[5](v1.x, v1.y, v1.z, v1.w, v2.x);\n}\n\n// Generates a tuple of canonical random numbers\nivec4 IRand4(inout RNGCtx ctx) { return ivec4(PCGAdvance(ctx)); }\n\n// Seed the PCG hash function with the current frame multipled by a prime\nRNGCtx PCGInitialise(uint frame)\n{    \n    return uvec4(20219u, 7243u, 12547u, 28573u) * frame;\n}\n\n// Reverse the bits of 32-bit inteter\nuint RadicalInverse(uint i)\n{\n    i = ((i & 0xffffu) << 16u) | (i >> 16u);\n    i = ((i & 0x00ff00ffu) << 8u) | ((i & 0xff00ff00u) >> 8u);\n    i = ((i & 0x0f0f0f0fu) << 4u) | ((i & 0xf0f0f0f0u) >> 4u);\n    i = ((i & 0x33333333u) << 2u) | ((i & 0xccccccccu) >> 2u);    \n    i = ((i & 0x55555555u) << 1u) | ((i & 0xaaaaaaaau) >> 1u);        \n    return i;\n}\n\n// Samples the radix-2 Halton sequence from seed value, i\nfloat HaltonBase2(uint i)\n{    \n    return float(RadicalInverse(i)) / float(0xffffffffu);\n}\n\nconst mat4 kOrderedDither = mat4(vec4(0.0, 8.0, 2.0, 10.), vec4(12., 4., 14., 6.), vec4(3., 11., 1., 9.), vec4(15., 7., 13., 5.));\nfloat OrderedDither(ivec2 xyScreen)\n{    \n    return (kOrderedDither[xyScreen.x & 3][xyScreen.y & 3] + 0.5) / 16.0;\n}\n\nfloat Noise(vec2 xy)\n{\n    uvec2 ij = uvec2(xy);\n    vec2 d = fract(xy);    \n    return Smoothstep(Smoothstep(HaltonBase2(HashOf(ij.x, ij.y)), HaltonBase2(HashOf(ij.x + 1u, ij.y)), d.x), \n                      Smoothstep(HaltonBase2(HashOf(ij.x, ij.y + 1u)), HaltonBase2(HashOf(ij.x + 1u, ij.y + 1u)), d.x), d.y);\n}\n\n// *******************************************************************************************************\n//    Bloom filter\n// *******************************************************************************************************\n\n#define kApplyBloom true \n#define kBloomDownsample 6\n\n#define kBloomBurnIn              (2. * vec3(0.22, 0.2, 0.18))\n#define kBloomBurnOut             vec3(kFltMax)\n\nvoid Gaussian(in int k, in int radius, in vec3 rgbK, in vec3 kernelShape, inout vec3 sigmaL, inout vec3 sigmaWeights)\n{\n    float d = float(abs(k)) / float(radius);\n    vec3 weight = pow(max(vec3(0.), (exp(-sqr(vec3(d) * 2.0)) - 0.0183156) / 0.981684), kernelShape);         \n\n    sigmaL += rgbK * weight;\n    sigmaWeights += weight;\n}\n\nvoid Epanechnikov(in int k, in int radius, in vec3 rgbK, in vec3 kernelShape, inout vec3 sigmaL, inout vec3 sigmaWeights)\n{\n    float d = float(abs(k)) / float(radius);\n    float weight = 1. - d*d;\n\n    sigmaL += rgbK * weight;\n    sigmaWeights += weight;\n}\n\n#define BlurKernel Gaussian\n//#define BlurKernel Epanechnikov\n\nvec3 SeparableBlurDown(ivec2 xy, ivec2 res, vec2 kernelSize, vec3 kernelShape, sampler2D sampler)\n{\n    if(xy.y == 0 || xy.x >= res.x / kBloomDownsample || xy.y >= res.y / kBloomDownsample)\n    {\n        return kZero;\n    }\n    else\n    {\n        int radius = int(0.5 + float(res.x)  * kernelSize.x / float(kBloomDownsample));    \n        vec3 sigmaL = kZero, sigmaWeights = kZero;\n        for(int k = -radius; k <= radius; ++k)\n        {\n            ivec2 ij = (xy + ivec2(k, 0)) * kBloomDownsample;\n            vec4 texel = texture(sampler, vec2(ij) / vec2(res.xy), 0.);\n            //texel.xyz /= max(1., texel.w);\n            texel.xyz = max(kZero, texel.xyz - kBloomBurnIn);\n            BlurKernel(k, radius, texel.xyz, kernelShape, sigmaL, sigmaWeights);\n        }\n\n        return sigmaL / max(kOne, sigmaWeights);\n    }\n}\n\nvec3 SeparableBlurUp(vec2 xy, ivec2 res, vec2 kernelSize, vec3 kernelShape, int layerIdx, sampler2D sampler)\n{   \n    int radius = int(0.5 + float(res.x) * kernelSize.y / float(kBloomDownsample));    \n    vec3 sigmaL = kZero, sigmaWeights = kZero;\n    for(int k = -radius; k <= radius; ++k)\n    {        \n        vec2 uv = (0.5 + xy + vec2(0, k * kBloomDownsample));\n        \n        //uv.x = clamp(uv.x, 0., float(res.x - kBloomDownsample));\n               \n        uv /= (vec2(res) * float(kBloomDownsample) + vec2(kBloomDownsample, 0.));\n        uv.y = saturate(uv.y);\n\n        vec3 texel = BilinearHalf(sampler, uv, layerIdx);\n        \n        BlurKernel(k, radius, texel, kernelShape, sigmaL, sigmaWeights);\n    }\n\n    return sigmaL / max(kOne, sigmaWeights);\n}\n\nmat2 RotMat2(float theta)\n{\n    float cosTheta = cos(theta), sinTheta = sin(theta);\n    return mat2(cosTheta, sinTheta, -sinTheta, cosTheta);\n}\n\n\n\n\n\nvec3 Cartesian2DToBarycentric(vec2 p)\n{    \n    return vec3(p, 0.0) * mat3(vec3(0.0, 1.0 / 0.8660254037844387, 0.0),\n                          vec3(1.0, 0.5773502691896257, 0.0),\n                          vec3(-1.0, 0.5773502691896257, 0.0));    \n}\n\nvec2 BarycentricToCartesian2D(vec3 b)\n{    \n    return vec2(b.y * 0.5 - b.z * 0.5, b.x * 0.8660254037844387);    \n}\n\n// Maps an input uv position to periodic hexagonal tiling\n//     inout vec2 uv: The mapped uv coordinate\n//     out vec3 bary: The Barycentric coordinates at the point on the hexagon\n//     out ivec2 ij: The coordinate of the tile\nvec2 Cartesian2DToHexagonalTiling(in vec2 uv, out vec3 bary, out ivec2 ij)\n{    \n    #define kHexRatio vec2(1.5, 0.8660254037844387)\n    vec2 uvClip = mod(uv + kHexRatio, 2.0 * kHexRatio) - kHexRatio;\n    \n    ij = ivec2((uv + kHexRatio) / (2.0 * kHexRatio)) * 2;\n    if(uv.x + kHexRatio.x <= 0.0) ij.x -= 2;\n    if(uv.y + kHexRatio.y <= 0.0) ij.y -= 2;\n    \n    bary = Cartesian2DToBarycentric(uvClip);\n    if(bary.x > 0.0)\n    {\n        if(bary.z > 1.0) { bary += vec3(-1.0, 1.0, -2.0); ij += ivec2(-1, 1); }\n        else if(bary.y > 1.0) { bary += vec3(-1.0, -2.0, 1.0); ij += ivec2(1, 1); }\n    }\n    else\n    {\n        if(bary.y < -1.0) { bary += vec3(1.0, 2.0, -1.0); ij += ivec2(-1, -1); }\n        else if(bary.z < -1.0) { bary += vec3(1.0, -1.0, 2.0); ij += ivec2(1, -1); }\n    }\n\n    return vec2(bary.y * 0.5773502691896257 - bary.z * 0.5773502691896257, bary.x);\n}\n\nbool InverseSternograph(inout vec2 uv, float zoom)\n{\n    float theta = length(uv) * kPi * zoom;\n    if(theta >= kPi - 1e-1) { return false; }\n    \n    float phi = atan(-uv.y, -uv.x) + kPi;\n    \n    vec3 sph = vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), -cos(theta));\n    \n    uv = vec2(sph.x / (1.0 - sph.z), sph.y / (1.0 - sph.z));\n    return true;\n}\n\n\n\n// *******************************************************************************************************\n//    2D SVG\n// *******************************************************************************************************\n\nfloat SDFLine(vec2 p, vec2 v0, vec2 v1, float thickness, float dPdXY)\n{\n    v1 -= v0;\n    float t = saturate((dot(p, v1) - dot(v0, v1)) / dot(v1, v1));\n    vec2 perp = v0 + t * v1;\n    return saturate((thickness - length(p - perp)) / dPdXY);\n}\n\n\nfloat SDFDashedLine(vec2 p, vec2 v0, vec2 v1, float thickness, float hashFreq, float hashDensity, float dPdXY)\n{\n    v1 -= v0;\n    hashFreq *= length(v1) / dPdXY;\n    float t = saturate((dot(p, v1) - dot(v0, v1)) / dot(v1, v1)) * hashFreq;\n    float f = fract(t);   \n    if(f > hashDensity)\n    {\n        if(f > 1. - ((1. - hashDensity) * 0.5)) t += 1. - f;\n        else t -= f - hashDensity;\n    }\n\n    vec2 perp = v0 + (t / hashFreq) * v1;\n    return saturate((thickness - length(p - perp)) / dPdXY);\n}\n\nfloat SDFQuad(vec2 p, vec2 v[4], float thickness, float dPdXY)\n{\n    float c = 0.0;\n    for(int i = 0; i < 4; i++)\n    {\n        c = max(c, SDFLine(p, v[i], v[(i+1)%4], thickness, dPdXY)); \n    }\n \n    return c;\n}\n\nfloat SDFCircle(vec2 p, vec2 o, float r, float dPdXY)\n{\n    return saturate((1. - length(p - o) / r) * (r / dPdXY));\n}\n\nfloat SDFTorus(vec2 p, vec2 o, float r1, float r2, float dPdXY)\n{\n    return saturate((1. - abs((length(p - o) - r1)) / r2) * (r2 / dPdXY));\n}\n\nfloat SDFPolygon(vec2 p, vec2 o, float r1, float r2, float phase, int numFaces, float dPdXY)\n{\n    p -= o;\n    float pTheta = kTwoPi * (0.5 + floor(float(numFaces) * (atan(p.y, p.x) + kPi - phase) / kTwoPi)) / float(numFaces) - kPi + phase;  \n    \n    vec2 x = vec2(cos(pTheta), sin(pTheta)) * r1;   \n    float perp = length(x * (1.  - dot(p, x) / dot(x, x)));    \n    return saturate((1. - abs(perp) / r2) * (r2 / (dPdXY)));\n}\n\nfloat SDFKaleidoscope(vec2 p, vec2 o1, vec2 o2, float r1, float r2, float phase, int numFaces, float dPdXY)\n{\n    p -= o1;\n    float phi = atan(o2.y, o2.x);\n    float m = length(o2) / r1;\n    float pTheta = kTwoPi * (0.5 + floor(float(numFaces) * (atan(p.y, p.x) + kPi - phase) / kTwoPi)) / float(numFaces) - kPi + phase;\n    \n    vec2 x = vec2(cos(pTheta), sin(pTheta)) * r1;    \n    vec2 d = vec2(cos(pTheta + phi), sin(pTheta + phi));\n    float tPerp = (dot(d, p) - dot(d, x)) / dot(d, d);\n    float dist = length(x + d * tPerp - p);\n    return saturate((1. - abs(dist) / r2) * (r2 / dPdXY));\n}\n\nfloat SDFCircleSegment(vec2 p, vec2 o, float r, vec2 range, float thickness, float dXYdP)\n{\n    p -= o;\n    if(length2(p) > sqr(r + thickness)) { return 0.; }  \n    \n    float phi = atan(p.y, p.x) + kPi;    \n    if((range.x < range.y && (phi < range.x || phi > range.y)) || \n       (range.x > range.y && (phi > range.x || phi < range.y)))\n    {\n        phi = (min(abs(range.x - phi), abs(range.x - kTwoPi * sign(range.x - kPi) - phi)) < \n               min(abs(range.y - phi), abs(range.y - kTwoPi * sign(range.y - kPi) - phi))) ? range.x : range.y;                   \n    }\n   \n    vec2 pPerp = r * vec2(-cos(phi), sin(-phi));     \n    return saturate((thickness - length(p - pPerp)) / dXYdP);\n}\n\nfloat SDFEllipse(vec2 p, vec2 o, vec2 scale, float theta, float dPdXY)\n{\n    p -= o;\n    mat2 M = RotMat2(theta);    \n    vec2 dx = (M * vec2(dPdXY, 0.)) / scale;\n    vec2 dy = (M * vec2(0., dPdXY)) / scale;\n    p = (M * p) / scale;\n\n    float len = max(1e-10, length(p));\n    return saturate((1. - (len - 1.)) / (2. * max(abs(dot(p, dx)), abs(dot(p, dy))) / len));\n}\n\n#define kKernelGamma 1.\n\nbool IsValidPixel(ivec2 p, vec3 iResolution)\n{\n    return p.x >= 0 && p.x < int(iResolution.x) && p.y >= 0 && p.y < int(iResolution.y);\n}\n\n// *******************************************************************************************************\n//    Colour functions\n// *******************************************************************************************************\n\nvec3 Hue(float phi)\n{\n    float phiColour = 6.0 * phi;\n    int i = int(phiColour);\n    vec3 c0 = vec3(((i + 4) / 3) & 1, ((i + 2) / 3) & 1, ((i + 0) / 3) & 1);\n    vec3 c1 = vec3(((i + 5) / 3) & 1, ((i + 3) / 3) & 1, ((i + 1) / 3) & 1);             \n    return mix(c0, c1, phiColour - float(i));\n}\n\nvec3 SignedColourMap(vec3 colourA, vec3 colourB, float f)\n{\n    return ((f > 0.) ? colourA : colourB) * abs(f);\n}\n\n// A Gaussian function that we use to sample the XYZ standard observer \nfloat CIEXYZGauss(float lambda, float alpha, float mu, float sigma1, float sigma2)\n{\n   return alpha * exp(sqr(lambda - mu) / (-2.0 * sqr(lambda < mu ? sigma1 : sigma2)));\n}\n\nvec3 HSVToRGB(vec3 hsv)\n{\n    return mix(vec3(0.0), mix(vec3(1.0), Hue(hsv.x), hsv.y), hsv.z);\n}\n\nvec3 RGBToHSV( vec3 rgb)\n{\n    // Value\n    vec3 hsv;\n    hsv.z = cwiseMax(rgb);\n\n    // Saturation\n    float chroma = hsv.z - cwiseMin(rgb);\n    hsv.y = (hsv.z < 1e-10) ? 0.0 : (chroma / hsv.z);\n\n    // Hue\n    if (chroma < 1e-10)        { hsv.x = 0.0; }\n    else if (hsv.z == rgb.x)    { hsv.x = (1.0 / 6.0) * (rgb.y - rgb.z) / chroma; }\n    else if (hsv.z == rgb.y)    { hsv.x = (1.0 / 6.0) * (2.0 + (rgb.z - rgb.x) / chroma); }\n    else                        { hsv.x = (1.0 / 6.0) * (4.0 + (rgb.x - rgb.y) / chroma); }\n    hsv.x = fract(hsv.x + 1.0);\n\n    return hsv;\n}\n\nvec3 SampleSpectrum(float lambda)\n{\n\t// Here we use a set of fitted Gaussian curves to approximate the CIE XYZ standard observer.\n\t// See https://en.wikipedia.org/wiki/CIE_1931_color_space for detals on the formula\n\t// This allows us to map the sampled wavelength to usable RGB values. This code needs cleaning \n\t// up because we do an unnecessary normalisation steps as we map from lambda to XYZ to RGB.\n\n\t#define kRNorm (7000.0 - 3800.0) / 1143.07\n\t#define kGNorm (7000.0 - 3800.0) / 1068.7\n\t#define kBNorm (7000.0 - 3800.0) / 1068.25\n\n\t// Sample the Gaussian approximations\n\tvec3 xyz;\n\txyz.x = (CIEXYZGauss(lambda, 1.056, 5998.0, 379.0, 310.0) +\n             CIEXYZGauss(lambda, 0.362, 4420.0, 160.0, 267.0) +\n             CIEXYZGauss(lambda, 0.065, 5011.0, 204.0, 262.0)) * kRNorm;\n\txyz.y = (CIEXYZGauss(lambda, 0.821, 5688.0, 469.0, 405.0) +\n             CIEXYZGauss(lambda, 0.286, 5309.0, 163.0, 311.0)) * kGNorm;\n\txyz.z = (CIEXYZGauss(lambda, 1.217, 4370.0, 118.0, 360.0) +\n             CIEXYZGauss(lambda, 0.681, 4590.0, 260.0, 138.0)) * kBNorm;\n\n\t// XYZ to RGB linear transform\n\tvec3 rgb;\n\trgb.r = (2.04159 * xyz.x - 0.5650 * xyz.y - 0.34473 * xyz.z) / (2.0 * 0.565);\n\trgb.g = (-0.96924 * xyz.x + 1.87596 * xyz.y + 0.04155 * xyz.z) / (2.0 * 0.472);\n\trgb.b = (0.01344 * xyz.x - 0.11863 * xyz.y + 1.01517 * xyz.z) / (2.0 * 0.452);\n\n\treturn rgb;\n}\n\nvec4 Blend(vec4 rgba1, vec3 rgb2, float w2)\n{\n    // Assume that RGB values are premultiplied so that when alpha-composited, they don't need to be renormalised\n    return vec4(mix(rgba1.xyz * rgba1.w, rgb2, w2) / max(1e-15, rgba1.w + (1. - rgba1.w) * w2),\n                    rgba1.w + (1. - rgba1.w) * w2);\n}\n\nvec4 Blend(vec4 rgba1, vec4 rgba2)\n{               \n    // Assume that RGB values are premultiplied so that when alpha-composited, they don't need to be renormalised\n    return vec4(mix(rgba1.xyz * rgba1.w, rgba2.xyz, rgba2.w) / max(1e-15, rgba1.w + (1. - rgba1.w) * rgba2.w),\n                    rgba1.w + (1. - rgba1.w) * rgba2.w);\n}\n\nvec3 ApplyRedGrade(vec3 inputColor) \n{\n    inputColor = saturate(inputColor.zyx);\n \n    // Named constants up front\n    const float ZERO  = 0.0;\n    const float PAD   = 0.0;  // used for padding only\n    const float HALF  = 0.5;\n    const float ONE   = 1.0;\n    const float TWO   = 2.0;\n    const float GELU_C1 = 0.7978845608;\n    const float GELU_C2 = 0.044715;\n\n   const mat4 layer0_chunk0_W0 = mat4(0.237038, 0.002839, -0.613395, 0.023955, 2.190638, 0.681709, -2.263870, -0.567830, 0.501725, 1.600221, -0.383257, 0.890942, PAD, PAD, PAD, PAD);\n   const vec4 layer0_chunk0_bias = vec4(-0.287044, 0.280783, 0.290978, 0.598706);\n\n   const mat4 layer0_chunk1_W0 = mat4(-0.137439, -0.103585, -0.010283, -1.756933, -0.938134, 1.964871, -0.696499, 1.249109, 1.416610, -0.654387, -0.856150, 1.315522, PAD, PAD, PAD, PAD);\n   const vec4 layer0_chunk1_bias = vec4(-0.027628, 0.506725, 0.573981, 0.743510);\n\n   const mat4 layer2_chunk0_W0 = mat4(3.334981, 0.692745, -2.249792, -1.533133, 0.759040, -0.884428, 0.228476, 1.654801, -1.449445, 0.674627, 1.597890, 0.084069, 1.227800, 0.103707, 2.272768, -3.488576);\n   const mat4 layer2_chunk0_W1 = mat4(-3.658784, 0.920236, 2.443871, 1.958547, 1.074470, -0.660618, 1.283018, 0.921886, 1.856311, -0.596886, -2.903828, 1.161765, 0.368526, -0.286363, -0.506707, -0.171955);\n   const vec4 layer2_chunk0_bias = vec4(1.218964, 0.054669, 0.264244, 0.295188);\n\n   const mat4 layer2_chunk1_W0 = mat4(-0.191983, -0.747375, 0.912338, -1.968686, 0.272265, -0.705990, 0.595160, 1.205564, -0.024412, -0.238474, -0.449195, 0.163486, -1.953892, 1.715119, -0.194429, -2.550383);\n   const mat4 layer2_chunk1_W1 = mat4(1.502533, -2.311996, -1.078473, 1.977682, -0.300410, 1.483174, 0.281399, 1.433337, -2.760890, -0.152508, -0.236289, 0.070996, 0.006024, -0.143973, 0.195464, -0.261372);\n   const vec4 layer2_chunk1_bias = vec4(1.241102, 0.342907, 0.901451, 0.191256);\n\n   const mat4 layer4_chunk0_W0 = mat4(0.208272, -0.118866, 0.661599, PAD, -1.598513, -2.092330, -0.095411, PAD, 0.630788, -0.224832, 0.052688, PAD, -3.094599, -0.439651, -0.093030, PAD);\n   const mat4 layer4_chunk0_W1 = mat4(3.054257, 0.375831, -0.121975, PAD, 0.069616, 0.252565, 0.532385, PAD, -0.114408, 0.896074, -0.793594, PAD, 3.216065, 0.745465, -0.031920, PAD);\n   const vec4 layer4_chunk0_bias = vec4(0.230162, -0.046474, -1.497791, PAD);\n\n    // Scale inputColor from [0,1] to [-1,1]\n    vec3 scaledColor = inputColor * TWO - ONE;\n\n    vec4 layer0_chunk0_out = layer0_chunk0_W0 * vec4(scaledColor, ZERO) + layer0_chunk0_bias;\n\n    vec4 layer0_chunk1_out = layer0_chunk1_W0 * vec4(scaledColor, ZERO) + layer0_chunk1_bias;\n\n    layer0_chunk0_out = layer0_chunk0_out * (ONE + tanh(GELU_C1 * (layer0_chunk0_out + GELU_C2 * layer0_chunk0_out*layer0_chunk0_out*layer0_chunk0_out))) * HALF;\n    layer0_chunk1_out = layer0_chunk1_out * (ONE + tanh(GELU_C1 * (layer0_chunk1_out + GELU_C2 * layer0_chunk1_out*layer0_chunk1_out*layer0_chunk1_out))) * HALF;\n\n    vec4 layer2_chunk0_out = layer2_chunk0_W0 * layer0_chunk0_out + layer2_chunk0_W1 * layer0_chunk1_out + layer2_chunk0_bias;\n\n    vec4 layer2_chunk1_out = layer2_chunk1_W0 * layer0_chunk0_out + layer2_chunk1_W1 * layer0_chunk1_out + layer2_chunk1_bias;\n\n    layer2_chunk0_out = layer2_chunk0_out * (ONE + tanh(GELU_C1 * (layer2_chunk0_out + GELU_C2 * layer2_chunk0_out*layer2_chunk0_out*layer2_chunk0_out))) * HALF;\n    layer2_chunk1_out = layer2_chunk1_out * (ONE + tanh(GELU_C1 * (layer2_chunk1_out + GELU_C2 * layer2_chunk1_out*layer2_chunk1_out*layer2_chunk1_out))) * HALF;\n\n    vec4 layer4_chunk0_out = layer4_chunk0_W0 * layer2_chunk0_out + layer4_chunk0_W1 * layer2_chunk1_out + layer4_chunk0_bias;\n\n    layer4_chunk0_out = ONE / (ONE + exp(-layer4_chunk0_out));\n\n    return saturate(layer4_chunk0_out.xyz);\n}\n\n// *******************************************************************************************************\n//    Solver parameters\n// *******************************************************************************************************\n\n// The number of grid cells in the y dimension\n#define kLGAGridDensity 300\n#define kLGAGridCellSize (1. / float(kLGAGridDensity))\n#define kLGAParticleRadiusGain 1.\n#define kLGAParticleRadius (kLGAParticleRadiusGain * 0.5 * kRoot2 / float(kLGAGridDensity))\n#define kLGAParticleRadiusSqr (kLGAParticleRadius*kLGAParticleRadius)\n\n#define kTimeStep 1.\n//#define kTime (iTime * kTimeStep)\n#define kTime (float(iFrame) / 60. * kTimeStep)\n            \n// Defines a boundary cell\n#define kParticleBoundary -1. \n// Defines a dormant cell with no mass inside it\n#define kParticleDormant 0.\n// Defines a cell whose mass is outside its boundary and needs transferring to an adjacent cell\n#define kParticleMigrating 1.\n// Defines a cell whose mass resides with its boundary\n#define kParticleActive 2.\n\n#define IsBoundary(state) (state.w == kParticleBoundary)\n#define IsDormant(state) (state.w == kParticleDormant)\n#define IsMigrating(state) (state.w == kParticleMigrating)\n#define IsActive(state) (state.w == kParticleActive)\n\n#define MakeBoundary(state) state.w = kParticleBoundary\n#define MakeDormant(state) state.w = kParticleDormant\n#define MakeMigrating(state) state.w = kParticleMigrating\n#define MakeActive(state) state.w = kParticleActive\n\nvoid PackLGAState(vec2 p, vec2 v, float m, vec2 cellPos, inout vec4 state)\n{\n    state.x = PackVec2((p - cellPos) / kLGAGridCellSize);\n    state.y = PackVec2(v / kLGAGridCellSize);\n    state.z = m;\n}\n\nvoid PackNormalisedLGAState(vec2 p, vec2 v, float m, inout vec4 state)\n{\n    state.x = uintBitsToFloat(packHalf2x16(p));\n    state.y = uintBitsToFloat(packHalf2x16(v));\n    state.z = m;\n}\n\nvoid UnpackLGAState(in vec4 state, vec2 cellPos, out vec2 p, out vec2 v, out float m)\n{\n    p = unpackHalf2x16(floatBitsToUint(state.x)) * kLGAGridCellSize + cellPos;\n    v = unpackHalf2x16(floatBitsToUint(state.y)) * kLGAGridCellSize;\n    m = state.z;\n}\n\nivec2 GetLGAGridDims(vec2 res)\n{\n    return ivec2(ceil((res.x / res.y) * float(kLGAGridDensity)), kLGAGridDensity);\n}\n\nvec2 ViewToLGAGridPos(vec2 xyView, ivec2 dims, vec2 res)\n{    \n    // Remap to UV coodinates in the range [0, 1]\n    xyView = (xyView * vec2(res.y / res.x, 1.)) * 0.5 + 0.5;\n    // Map to the position on the grid\n    return xyView * vec2(dims);\n}\n\nbool IsValidLGAGridIdx(ivec2 ij, ivec2 dims)\n{\n    return ij.x >= 0 && ij.x < dims.x && ij.y >= 0 && ij.y < dims.y;\n}\n\nvec2 LGAGridIdxToView(ivec2 ij, ivec2 dims, vec2 res)\n{\n    vec2 xyView = vec2(ij) / vec2(dims);\n    return (xyView * 2. - 1.) * vec2(res.x / res.y, 1.);\n}\n\nbool LGACellContains(in vec2 p, in vec2 cellPos)\n{\n    return p.x >= cellPos.x && p.x < cellPos.x + kLGAGridCellSize && p.y >= cellPos.y && p.y < cellPos.y + kLGAGridCellSize;\n}\n\n// *******************************************************************************************************\n//    Hawk parameters\n// *******************************************************************************************************\n\n#define kHawkScale 1.\n#define kHawkWingSpeed 1.5\n#define kHawkAdvection 0.001\n#define kHawkViewPos vec2(0.0, 0.5)\n#define kHawkGlide false\n#define kHawkGlideProbability 0.2\n\nvec2 ViewToHawkUV(vec2 xyView, vec2 res)\n{\n    return (xyView - kHawkViewPos + vec2(res.x / res.y, 1.) * kHawkScale) * 0.5 * vec2(res.y / res.x, 1.);\n}\n\nvec4 SampleHawk(vec2 xyView, vec2 res, sampler2D sampler)\n{\n    return texture(sampler, ViewToHawkUV(xyView, res), 0.);\n}\n\n\nvec4 SampleHawkUnsharpMask(vec2 xyView, vec2 res, float dFdXY, float magnitude, sampler2D sampler)\n{\n    vec4 lowPass = vec4(0.);\n    float sumW = 0.;\n    #define kUnsharpRadius 1\n    for(int v = -kUnsharpRadius; v <= kUnsharpRadius; ++v)\n    {\n        for(int u = -kUnsharpRadius; u <= kUnsharpRadius; ++u)\n        {\n            float w = 1.0 - max(0., float(u*u + v*v) - 0.5) / float(kUnsharpRadius*kUnsharpRadius);\n            if(w > 0.)\n            {\n                lowPass += w * SampleHawk(xyView + vec2(u, v) * dFdXY, res, sampler); \n                sumW += w;\n            }\n        }\n    }\n\n    vec4 thisPixel = SampleHawk(xyView, res, sampler); \n    vec4 highPass = thisPixel - saturate(lowPass / sumW);\n    \n    return thisPixel + highPass * magnitude;\n}\n\n\nvec4 GetHawkHoverCtx(float time)\n{\n    vec4 ctx = vec4(0.);\n    \n    ctx.x = time * kHawkWingSpeed;\n    uint interval = uint(ctx.x);\n    ctx.y = float(interval);\n    ctx.z = ctx.w = fract(ctx.x);    \n    \n    if(!kHawkGlide) { return ctx; }\n   \n    float p0 = HaltonBase2(HashOf(interval - 1u));\n    float p1 = HaltonBase2(HashOf(interval));\n    float p2 = HaltonBase2(HashOf(interval + 1u));\n        \n    ctx.z = 0.;\n    if(p1 > kHawkGlideProbability)\n    {\n        float ramp = Smootherstep(ctx.w);\n        ctx.z = ctx.w;\n        if(p0 < kHawkGlideProbability) { ctx.z = mix(ramp, ctx.z, ctx.w); }\n        if(p2 < kHawkGlideProbability) { ctx.z = mix(ctx.z, ramp, ctx.w); }\n    } \n\n    ctx.z += (mix(p1, p2, ctx.w)) * 0.02;\n   \n        \n    return ctx;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// *******************************************************************************************************\n//   Hovering hawk encoded as MLP\n// *******************************************************************************************************\n\n#define z4 vec4(0)\n#define m4 mat4\n#define v4 vec4\n#define kNNInputWidth 12\n#define kNNInputBlocks ((kNNInputWidth + 3) / 4)\n#define kNNOutputWidth 1\n#define kNumHarmonics 2\n#define kInputDimensions 3\n#define kW (2 * kInputDimensions * kNumHarmonics)\n\nvec4[kNNInputBlocks] FourierEncode(in vec3 p, in vec3 weights)\n{\n    vec4[kNNInputBlocks] v;\n    for (int harmonic = 0; harmonic < kNumHarmonics; ++harmonic)\n    {\n        for (int d = 0; d < 2 * kInputDimensions; ++d)\n        {\n            int i = 2 * kInputDimensions * harmonic + d;\n            v[i>>2][i&3] = sin( kPi * float(1 + harmonic) * p[d >> 1] + kHalfPi * float(d & 1)) * weights[d >> 1];\n        }\n    }\n    return v;\n}  \n\nfloat Sigmoid(vec4 v)\n{\n    return dot(vec4(1), 1. / (1. + exp(-(v * 50.))));\n}\n\nvec2 EvaluateMLP(vec3 uvt)\n{\n   uvt.z = mix(-1., 1., uvt.z);\n   vec4[3] I = FourierEncode(uvt, vec3(1., 1., 0.5));   \n   \n   v4[3] A0; v4[3] A1; v4[3] A2; float A3, code = 0.;\n   \n   A0[0] = m4(0.332,0.179,0.157,-0.519,0.064,-0.557,0.012,-0.304,0.252,0.358,0.302,0.248,0.373,-0.461,0.661,0.027) * I[0] + \n   m4(0.312,0.108,-0.527,0.767,0.243,-0.187,-1.250,-0.514,0.181,-0.336,-0.023,0.332,0.004,0.025,-0.192,0.103) * I[1] + \n   m4(-0.041,0.282,-0.766,-0.095,0.084,-0.109,0.074,-0.109,0.150,-0.250,0.069,-0.168,-0.048,-0.303,0.499,0.039) * I[2] + v4(0.569,-0.328,0.322,0.101);code += Sigmoid( A0[0]);\n A0[0] *= mix(v4(1e-2), v4(1), step(v4(0),  A0[0]));\n   A0[1] = m4(-0.244,-0.572,0.317,0.422,0.569,0.175,0.138,0.356,0.752,-0.380,0.695,-0.504,0.188,0.562,-0.297,-0.242) * I[0] + \n   m4(0.638,-0.614,0.097,-0.042,1.271,-0.882,0.946,0.625,0.150,0.161,-0.009,-0.179,-0.382,-0.260,-0.090,-0.001) * I[1] + \n   m4(-0.347,-0.122,0.058,0.118,-0.028,-0.043,0.159,-0.410,0.211,0.026,0.025,-0.209,0.072,-0.341,0.034,0.546) * I[2] + v4(0.012,-0.130,-0.490,0.140);code += Sigmoid( A0[1]);\n A0[1] *= mix(v4(1e-2), v4(1), step(v4(0),  A0[1]));\n   A0[2] = m4(-0.763,0.156,0.266,0.812,-0.017,0.165,-0.340,-0.629,-0.371,-0.071,-0.155,-0.687,-0.611,0.360,0.179,0.084) * I[0] + \n   m4(-0.303,0.380,0.287,-0.276,0.189,0.093,-0.212,-0.205,0.182,-0.278,-0.160,0.056,0.141,-0.047,0.609,0.459) * I[1] + \n   m4(0.440,0.246,-0.029,0.285,-0.180,-0.318,0.108,0.028,-0.253,-0.273,-0.112,0.065,0.255,0.245,-0.044,-0.074) * I[2] + v4(0.215,0.612,-0.817,-0.591);code += Sigmoid( A0[2]);\n A0[2] *= mix(v4(1e-2), v4(1), step(v4(0),  A0[2]));\n   A1[0] = m4(-0.602,0.111,-0.229,-0.184,-0.077,0.177,-0.389,0.192,-0.380,-0.010,0.058,-0.031,-1.074,0.431,0.339,-0.108) * A0[0] + \n   m4(-0.780,-0.047,-0.223,0.533,-0.128,0.352,0.748,-0.238,-1.078,-0.409,0.426,0.721,-0.055,0.472,0.338,-0.158) * A0[1] + \n   m4(-0.236,0.335,-0.088,-0.243,-0.161,-0.661,-0.356,0.315,0.877,-0.632,-0.408,-0.712,0.374,-0.328,-0.168,-1.506) * A0[2] + v4(0.080,0.493,0.601,-0.400);code += Sigmoid( A1[0]);\n A1[0] *= mix(v4(1e-2), v4(1), step(v4(0),  A1[0]));\n   A1[1] = m4(0.165,-0.108,0.423,0.358,-0.177,0.491,0.215,-0.097,0.686,0.671,-0.097,0.158,-0.256,0.235,-0.062,0.152) * A0[0] + \n   m4(-0.565,0.016,0.199,0.785,0.014,-0.649,-0.467,-0.604,0.903,1.419,0.425,-0.995,0.050,0.184,0.475,0.287) * A0[1] + \n   m4(-0.141,0.706,0.431,-0.219,0.260,-0.155,0.146,-0.064,0.626,-0.389,0.399,-0.317,0.361,0.185,-0.628,-0.223) * A0[2] + v4(-0.300,-0.259,-0.017,-0.170);code += Sigmoid( A1[1]);\n A1[1] *= mix(v4(1e-2), v4(1), step(v4(0),  A1[1]));\n   A1[2] = m4(-0.917,-0.322,0.473,0.343,0.056,0.087,-0.367,-0.565,-0.396,-0.243,-0.374,0.259,0.642,0.047,-0.144,0.039) * A0[0] + \n   m4(0.166,-0.142,0.286,-0.365,0.187,0.516,0.284,-0.571,-0.287,0.099,-0.985,-0.600,-2.283,0.317,-0.417,-0.094) * A0[1] + \n   m4(-0.089,-0.077,-0.138,-0.739,-0.111,-0.310,0.378,0.091,1.814,-0.207,0.600,0.752,-0.070,0.937,0.073,0.335) * A0[2] + v4(-0.680,0.415,0.336,0.504);code += Sigmoid( A1[2]);\n A1[2] *= mix(v4(1e-2), v4(1), step(v4(0),  A1[2]));\n   A2[0] = m4(-0.188,-0.070,0.745,0.810,-0.195,-0.802,0.328,0.080,-0.372,-0.035,0.638,0.110,-0.606,0.269,1.047,0.887) * A1[0] + \n   m4(0.269,0.213,-1.139,-0.505,-0.728,-0.508,0.316,0.428,-0.609,0.512,0.009,0.218,0.582,-0.346,-1.039,-0.728) * A1[1] + \n   m4(0.726,-0.603,-0.777,0.820,-0.450,0.546,-0.746,-0.411,-0.032,-0.245,-0.713,-0.341,-0.250,0.621,0.525,0.181) * A1[2] + v4(0.579,-0.154,0.475,0.530);code += Sigmoid( A2[0]);\n A2[0] *= mix(v4(1e-2), v4(1), step(v4(0),  A2[0]));\n   A2[1] = m4(-0.392,0.342,0.009,-0.525,-0.594,-0.885,0.272,-0.480,-0.616,0.014,0.032,-0.075,-0.280,0.287,0.887,-0.135) * A1[0] + \n   m4(0.144,0.480,-0.106,-0.037,-0.294,0.051,0.470,0.571,0.015,-0.062,-0.188,0.391,0.753,-0.308,-0.802,0.609) * A1[1] + \n   m4(1.073,0.212,3.231,-0.080,0.434,-0.521,-0.246,0.289,0.448,-0.102,0.352,-0.088,-0.025,-0.380,0.037,0.062) * A1[2] + v4(-0.169,-0.083,-0.241,0.554);code += Sigmoid( A2[1]);\n A2[1] *= mix(v4(1e-2), v4(1), step(v4(0),  A2[1]));\n   A2[2] = m4(-0.483,0.117,0.097,0.205,-0.461,-0.377,0.071,0.091,-0.584,-0.551,-0.509,0.512,-0.909,0.300,0.309,0.610) * A1[0] + \n   m4(0.244,0.261,-0.146,-0.794,0.016,0.207,-0.684,0.449,0.234,-0.090,0.500,0.003,0.399,-0.321,0.327,-0.447) * A1[1] + \n   m4(0.149,-0.362,-0.190,0.316,0.411,0.219,-0.459,-0.340,0.405,0.362,-0.011,-0.376,-0.046,0.335,-0.416,0.441) * A1[2] + v4(0.003,-0.081,-0.560,0.403);code += Sigmoid( A2[2]);\n A2[2] *= mix(v4(1e-2), v4(1), step(v4(0),  A2[2]));\n   A3 =dot(v4(-0.756,-0.544,-0.686,0.495), A2[0]) + dot(v4(-0.366,0.757,-0.237,-0.367), A2[1]) + dot(v4(-0.334,-0.315,0.700,0.722), A2[2]) + 0.918;\n   \n   return vec2(A3, code);\n}\n#undef z4\n#undef m4\n#undef v4\n#undef kNNInputWidth\n#undef kNNOutputWidth\n\nfloat EvaluateHead(vec2 p, float time)\n{\n    vec2 v0 = vec2(0., mix(0.075, 0.085, sin01(kTwoPi * time)));\n    vec2 v1 = vec2(0., -0.25);    \n    v1 -= v0;\n    float t = saturate((dot(p, v1) - dot(v0, v1)) / dot(v1, v1));\n    vec2 perp = v0 + t * v1;\n    return (length(p - perp) - 0.065) / 0.15;\n}\n\nvec3 EvaluateBody(vec2 uv, float time)\n{\n    float head = EvaluateHead(uv, time);\n    \n    uv.x = mix(-1., 1., 1. - abs(uv.x) - 0.015) * 0.9;\n    uv.y *= 2. * 0.9;\n    \n    //if(cwiseMax(abs(uv)) > 0.9) { return vec3(1); }\n    \n    #define kDeltaT 1e-3\n    vec3 f;\n    f.xy = EvaluateMLP(vec3(uv, time));\n    f.z = (EvaluateMLP(vec3(uv, time + kDeltaT)).x - f.x) / kDeltaT;\n    \n    // x: field value, y: accumulated activations, z: temporal differential dF/dt\n    return vec3(min(head, f.x), f.yz);\n}\n\nvoid mainImage( out vec4 rgbaFrag, in vec2 xyFrag )\n{        \n    xyFrag /= kHawkScale;\n    \n    rgbaFrag *= 0.;\n    \n    vec2 xyView = ScreenToNormalisedScreen(xyFrag, iResolution.xy);\n        \n    #define kGlidePose 0.45\n    vec4 hawkCtx = GetHawkHoverCtx(kTime);\n    vec3 f = EvaluateBody(xyView, fract(hawkCtx.z + kGlidePose));\n    \n    float outline = saturate(1. - abs(f.x) * 20.);\n    float mask = max(outline, 1. - step(0., f.x));\n    \n    float features = 0.;   \n    \n    // Eyes\n    xyView.x = abs(xyView.x);\n    float headBob = 0.01 * sin01(kPi * 0.1 + kTwoPi * hawkCtx.z);\n    float blink = saturate(sin01(kTime * 2.) * 50.);\n    features = mix(features, 1., SDFEllipse(xyView, vec2(0.032, 0.065 + headBob), vec2(0.6 * blink, 1.) * 0.007, 0.9, 1.5 / iResolution.y));\n    \n    // Beak\n    xyView.y = xyView.y - headBob - 0.017;\n    features = mix(features, 0.7, saturate(1. - sqr(xyView.y / 0.015)) * SDFLine(xyView, vec2(0.005, 0.015), vec2(0.0, 0.), 0.003, 1. / iResolution.y));\n   \n    rgbaFrag.x = sin(2. * f.y) * mask;\n    rgbaFrag.y = 0.5 * f.z * mask;\n    rgbaFrag.z = features* mask;\n    rgbaFrag.w = (f.x+features);\n    \n    float mx = smoothstep(0.9, 1.0, abs(xyView.x));\n    rgbaFrag = mix(rgbaFrag, vec4(0,0,0,1), mx);\n    float my = smoothstep(0.5, 0.6, abs(xyView.y));\n    rgbaFrag = mix(rgbaFrag, vec4(0,0,0,1), my);\n\n        \n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wcSSD3",
    "date": "1742555185",
    "viewed": 87,
    "name": "GameOfLife by JohnC",
    "description": "I wanted to try this variation - if an empty cell has adjacent cells for a certain amount of time it comes to life.\nKMIN and DELAY to adjust the delay and number of cells.\nFor some reason this configuration is symmetrical, and has an interesting start",
    "likes": 4,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "2d",
     "simulation",
     "automata",
     "life",
     "conway",
     "gameoflife",
     "multipass"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"GameOfLife\" by iq. https://shadertoy.com/view/XstGRf\n// 2025-03-20 11:04:31\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    if(col.r>0.){col=vec3(1);}else{col=vec3(0,col.g/10.,col.g/2.);}\n    fragColor = vec4(col , 1.0 );\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define STARTAREA 19\n#define KMIN 2\n#define DELAY 3.0\n\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return (texelFetch(iChannel0, p, 0 ).x > 0.5 ) ? 1 : 0;\n}\n\nfloat gcell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).y;\n}\n\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n    \n\n\tint k =   cell(px+ivec2(-1,-1)) + cell(px+ivec2(0,-1)) + cell(px+ivec2(1,-1))\n            + cell(px+ivec2(-1, 0))                        + cell(px+ivec2(1, 0))\n            + cell(px+ivec2(-1, 1)) + cell(px+ivec2(0, 1)) + cell(px+ivec2(1, 1));\n    int e = cell(px);\n    float f = ( ((k==2)&&(e==1)) || (k==3) || (k==7)) ? 1.0 : 0.0;\n    \n    float g = gcell(px+ivec2(0, 0));\n    if(e==0 && k>=KMIN){g+=0.1;} else {g=0.;}\n    if(g>DELAY){g=0.;f=1.;}\n\n    int offset = int(iResolution.y)/2;\n    int offdiff = offset-200;\n    \n    int offx = 200;\n    if(iResolution.x<300.){offx=80;}\n\n    if( iFrame<2 && abs(px.y-offset )<STARTAREA && abs(px.x-offx )<STARTAREA )f = step(0.9, hash1(fragCoord.x*13.0+hash1((fragCoord.y-float(offdiff))*71.1)));\n\t\n\tfragColor = vec4( f, g, 0.0, 0.0 );\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tXXGR8",
    "date": "1753914509",
    "viewed": 9,
    "name": "Blue Fire/hair/fabric",
    "description": "could work for hair/fabric",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "fire",
     "turbulent"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xsf3zn",
       "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"One-Pass Fire\" by Xor. https://shadertoy.com/view/tf2SWc\n// 2025-03-22 17:16:30\n\n/*\n    \"One-Pass Fire\" by @XorDev\n    \n    Here's the continuation of my experiments with fire effects\n    \n    Also see Turbulent Flame:\n    https://www.shadertoy.com/view/wffXDr\n*/\n//Fire ring radius\n#define COLOR vec3(0.06, 0.06, 0.01)\n//Scroll speed\n#define SCROLL 1.2\n\n//Number of turbulence waves\n#define FIRE_NUM 8.0\n//Turbulence wave amplitude\n#define FIRE_AMP 0.4\n//Turbulence wave speed\n#define FIRE_SPEED 6.0\n//Turbulence frequency (inverse of scale)\n#define FIRE_FREQ 12.0\n//Turbulence frequency multiplier\n#define FIRE_EXP 1.2\nfloat nTime = 0.;\n//Bicubic noise texture sample\nvec4 noise(vec2 p)\n{\n    vec2 f = floor(p);\n    vec2 s = p-f;\n    s *= s * (3.0 - 2.0*s);\n    \n    return texture(iChannel0, (f+s+.5) / 256.0);\n}\n\n//https://mini.gmshaders.com/p/turbulence\nvec2 turbulence(vec2 p, float F, float N, float S, float A, float E)\n{\n    //Turbulence starting scale\n    float freq = F;\n    \n    //Turbulence rotation matrix\n    mat2 rot = mat2(0.6, -0.8, 0.8, 0.6);\n    \n    //Loop through turbulence octaves\n    for(float i=0.0; i<N; i++)\n    {\n        //Scroll along the rotated y coordinate\n        float phase = freq * (p * rot).y + S*nTime + i;\n        //Add a perpendicular sine wave offset\n        p += A * rot[0] * sin(phase) / freq;\n        \n        //Rotate for the next octave\n        rot *= mat2(0.6, -0.8, 0.8, 0.6);\n        //Scale down for the next octave\n        freq *= E;\n    }\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    nTime = iTime/10.;\n    //Screen coordinates, centered and aspect corrected\n    vec2 p = (fragCoord.xy*2.0-iResolution.xy) / iResolution.y;\n    \n    //Expand vertically\n    float xstretch = 2.0 - 1.5*smoothstep(-2.0,2.0,p.y);\n    //Decelerate horizontally\n    float ystretch = 1.0 - 0.3 / (1.0+p.x*p.x);\n    //Combine\n    vec2 stretch = vec2(xstretch, ystretch);\n    //Stretch coordinates\n    p *= stretch;\n    \n    //Scroll upward\n    float scroll = SCROLL*nTime;\n    p.y -= scroll;\n    \n    //Apply turbulence\n    p = turbulence(p, FIRE_FREQ, FIRE_NUM, FIRE_SPEED, FIRE_AMP, FIRE_EXP);\n    \n    //Scrolling coordinates\n    vec2 sp = p;\n   \n    //Reverse the scrolling offset\n    p.y += scroll + 0.5;\n    \n    //Set radius with noise\n    float radius = 0.1 + 0.5*noise(sp/0.1).x;\n    //Distance to fire\n    float dist = length(p) - radius;\n    \n    //Scrolling texture uvs\n    vec2 uv = sp * FIRE_FREQ*1.5;\n    //Sample noise\n    float n = noise(uv).x + noise(uv*0.3).y + noise(uv*0.1).z;\n    //Glow brightness\n    float light = smoothstep(0.3, 0.1, dist) / (0.1 - 0.03*n + dist*dist);\n    \n    //Spark highlights\n    //float spec = 1.0 / noise(sp*3e1).a;\n    //Blend color, intensity and fad edges\n    //vec3 sparks = 0.02 * spec * spec * COLOR / (1.0+20.0*p.x*p.x);\n    \n    //Combine ambient light and fire\n    vec3 col = 1.0 - (n * light * COLOR);// + sparks;\n    \n    //Exponential tonemap\n    //https://mini.gmshaders.com/p/tonemaps\n    //col = 1.5-exp(-col);\n    fragColor = vec4(col,1);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "W3s3zH",
    "date": "1742724659",
    "viewed": 74,
    "name": "Fork of Blue Sound Reactive",
    "description": "Connected turbulence function to levels of a semitone over several octaves",
    "likes": 2,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "fft",
     "flame",
     "audio",
     "visualisation"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sXGRr",
       "filepath": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3",
       "type": "music",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsBSR3",
       "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Blue Sound Reactive Particulate\" by johnbundy3000. https://shadertoy.com/view/W3l3z8\n// Fork of \"One-Pass Fire\" by Xor. https://www.shadertoy.com/view/tf2SWc\n\n/*\n    Adjusted the turbulence function.\n    Now it extracts the level of the note C from each octave.\n    And uses that as amplitude for each of the wave distortion octaves.\n    Or that's the idea anyway\n*/\n\n// Scroll speed\n#define SCROLL 0.3  // Reduced for a more relaxed effect\n// Number of turbulence waves\n#define FIRE_NUM 10.0  // Fewer waves to reduce chaos\n// Turbulence wave amplitude\n#define FIRE_AMP 0.6  // Softer flickering\n// Turbulence wave speed\n#define FIRE_SPEED 6.5  // Slower, smoother movement\n// Turbulence frequency (inverse of scale)\n#define FIRE_FREQ 8.  // Lower frequency for calmer movement\n// Turbulence frequency multiplier\n#define FIRE_EXP 1.3 // Less variation\n\n// Audio-reactive intensity scale\n#define SOUND_INTENSITY 0.4  // Very subtle reaction to sound\n#define SOUND_SMOOTHING 0.98  // Strong smoothing for gradual changes\n\nvec3 colour = vec3(0);\n// Bicubic noise texture sample\nvec4 noise(vec2 p)\n{\n    vec2 f = floor(p);\n    vec2 s = p - f;\n    s *= s * (3.0 - 2.0 * s);\n    \n    return texture(iChannel0, (f + s + 0.5) / 256.0);\n}\n\n// Turbulence function\nvec2 turbulence(vec2 p, float F, float N, float S, float A, float E)\n{\n    float freq = F;\n    mat2 rot = mat2(0.6, -0.8, 0.8, 0.6);\n    float speed = 0.;\n    for (float i = 0.0; i < N; i++)\n    {\n        float freqC = 8372.02/pow(2.0, 9.0-float(i));\n        float freqv = texture(iChannel1, vec2(freqC/10000.,0.0)).r;\n        freqv*=(i/4.)+1.;\n        float phase = freq * (p * rot).y + freqv * iTime * 0.1;\n        \n        if(i<3.){colour.r += freqv;} else if (i<5.){colour.g += freqv;} else {colour.b += freqv;}\n        p += freqv * A * rot[0] * sin(phase) / freq;\n        rot *= mat2(0.6, -0.8, 0.8, 0.6);\n        freq *= E;\n    }\n    \n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Centered, aspect-corrected coordinates\n    vec2 p = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    p*=1.4;\n    float xstretch = 1.5 - 1.0 * smoothstep(-2.0, 2.0, length(p)); // Circular scaling\n    float ystretch = 1.05 - 0.15 / (1.0 + dot(p, p)); // Reduced distortion\n    vec2 stretch = vec2(xstretch, ystretch);\n    p *= stretch;\n    \n    // Get sound input from iChannel1 and apply a gentle effect\n    float rawAudio = texture(iChannel1, vec2(0.01, 0.25)).r;\n    float audio = mix(1.0, 1.0 + rawAudio * SOUND_INTENSITY, SOUND_SMOOTHING);\n    \n    //vec3 pd = \n    \n    float scroll = SCROLL  * iTime * audio;  // Gentle sound response\n    p.y -= scroll * 0.5; // Keep movement subtle\n    \n    \n    p = turbulence(p, FIRE_FREQ, FIRE_NUM, FIRE_SPEED, FIRE_AMP, FIRE_EXP);\n    \n    vec2 sp = p;\n    p.y += scroll * 0.5;\n    \n    float radius = 0.03 + 0.03 * noise(sp / 0.05).x * audio; // Smooth circular pulsing\n    float dist = length(p) - radius;\n    \n    vec2 uv = sp * FIRE_FREQ * 1.1;\n    float n = noise(uv * 1.5).x + noise(uv * 0.5).y + noise(uv * 0.2).z;\n    float light = smoothstep(0.4, 0.15, dist) / (0.1 - 0.015 * n + dist * dist);\n    colour *= 0.3;colour *= colour;\n    float spec = 1.0 / noise(sp * 30.0).a;\n    vec3 sparks = 0.02 * spec * spec * colour / (1.0 + 6.0 * dot(p, p)); // Subtle radial sparks\n    \n    vec3 col = n * light * colour + sparks;\n    \n    col = 1.0 - exp(-col);\n    fragColor = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "W3f3WH",
    "date": "0",
    "viewed": 0,
    "name": "Sphere warping",
    "description": "By changing the centre or radius depending on uv position we can create some really interesting effects, pity that it's not possible to translate it to 3D, afaik...",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "sphere",
     "sine",
     "analytical",
     "orthographic"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec3 addLight(vec3 pos, vec3 norm, vec3 scol, vec3 lcol, vec3 lpos){\n    vec3 ref = reflect(vec3(0.0, 0.0, -1.0), norm);\n    vec3 diff = lpos - pos;\n    float ldist = length(diff);\n    diff = diff/ldist;\n    float specular = pow(max(0.0, dot(diff, ref)), 16.0);\n    float diffuse = max(0.0, dot(diff, norm));\n    vec3 col1 = scol*0.5;\n    vec3 col2 = scol*0.5*(lcol*diffuse);\n    col2 = col2+(lcol*specular);\n    return col1+col2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec2 mouse = iMouse.xy/iResolution.y;\n    \n    vec3 sphere = vec3(mouse.x,mouse.y, 0.08);\n    vec2 distov = uv;// - sphere.xy;\n    vec3 col = vec3(1);\n    \n    float uvx = 120.;\n    \n    sphere.z += sin(distov.x*30.)/ uvx;\n    sphere.z += sin(distov.y*40.)/ uvx;\n    sphere.x += sin(distov.x*30.)/ uvx;\n    sphere.x += sin(distov.y*50.)/ uvx;\n    sphere.y += sin(distov.x*20.)/ uvx;\n    sphere.y += sin(distov.x*20.)/ uvx;\n    sphere.z += sin(distov.y*30.)/ uvx;\n    sphere.z += sin(distov.x*40.)/ uvx;\n    float dist = distance(sphere.xy, uv);\n    vec2 distv = uv - sphere.xy;\n    float height = sqrt((sphere.z*sphere.z)-(dist*dist));\n    vec3 normal = vec3(distv.x, distv.y, height)/sphere.z;\n    if(dist<sphere.z){\n        col = vec3(1,0.6,0.5);\n        col = addLight(vec3(sphere.xy, height), normal, col, vec3(1), vec3(3.,1., 0));\n\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "W3XGWS",
    "date": "1743751351",
    "viewed": 237,
    "name": "Blue Porcelain",
    "description": "Trying to recreate https://arthur.io/art/bao-pham/blue-porcelain with SDFs and raymarching\nStill lots to do, but it's starting to look nice.",
    "likes": 33,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "3d",
     "sdf",
     "painting",
     "brush",
     "human",
     "china",
     "anatomy",
     "porcelain",
     "asian",
     "vietnamese"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// This is my first attempt at using SDFs and raymarching\n// It's a bit ambitious, and is still very much a work in progress.\n// There's lots more I want to do with it, but I have some tidying and optimisation to look into before I take it any further.\n// --\n// Based on/inspired by Bao Pham's painting 'Blue Porcelain' https://arthur.io/art/bao-pham/blue-porcelain\n// Uses code and functions from the following shaders:\n// \"Capped torus - distance\" by iq. https://www.shadertoy.com/view/tl23RK\n// \"Elongation SDF\" by iq.          https://www.shadertoy.com/view/Ml3fWj\n// \"Vesica Segment\" by iq.          https://www.shadertoy.com/view/Ds2czG\n// \"Brush Experiment 3\" by 104      https://www.shadertoy.com/view/ltj3Wc\n// \"Magic Fractal\" by dgreensp      https://www.shadertoy.com/view/4ljGDd\n// --\n// 2025-03-31 04:38:41\n// Copyright/licensing of forked code belongs to respective artists/authors.\n// Everything else assembled here is the work of John Cotterell johnmdcotterell@gmail.com\n// and cannot be use outside shadertoy without permission.\n\n#define AA 2\n// The porcelain looks better with anti-aliasing, but it tanks the fps on slower machines.\n// 1 is off, 2 is 2x2 AA, 3 is 3x3 AA etc..\n\n#define SAA 2\n// Selective anti-aliasing tries to target edges and doesn't look quite as good, but is faster.\n// 1 is off, 2 is on\n\nfloat sdHead( vec3 p, float r ){\n    // TOP - Cranium\n    float cran = sdSphere(p, r);\n    // BOTTOM - Jaw/Cheekbones\n    vec2 os = vec2(-0.14,0.05);\n    float ms = 0.1215;\n    vec3 ql = p - vec3(ms,os);\n    vec3 qr = p - vec3(-ms,os);\n    ql = ql*rotateZ(0.26);\n    qr = qr*rotateZ(-0.26);\n    ql = ql*rotateX(0.42);\n    qr = qr*rotateX(0.42);\n    vec3 a = vec3(0.,-0.4, 0.0);\n    vec3 b = vec3( 0., 0.4, 0.0);\n    float l = length(b-a);\n    float wv = sqrt(0.12/l);\n    float jaw = opSmoothUnion(sdVerticalVesicaSegment( ql-a, l, wv*0.85 ) - wv*0.15, \n    sdVerticalVesicaSegment( qr-a, l, wv*0.85 ) - wv*0.15, 0.07);\n    cran = opSmoothUnion( cran, jaw, 0.03);\n    // SHAPING - sides\n    float d2 = sdRoundBox(p-vec3(0.76,-0.6,-0.15), vec3(0.4,0.4,0.4), 0.02 ); \n    float d1 = sdRoundBox(p-vec3(-0.76,-0.6,-0.15), vec3(0.4,0.4,0.4), 0.02); \n    float d3 = sdRoundBox(p-vec3(0.76,0.35,-0.2), vec3(0.4,0.4,0.4), 0.02 ); \n    float d4 = sdRoundBox(p-vec3(-0.76,0.35,-0.2), vec3(0.4,0.4,0.4), 0.02 ); \n    cran = opSmoothSubtraction(d4,opSmoothSubtraction(d3,cran, .2), .2);\n    cran = opSmoothSubtraction(d2,opSmoothSubtraction(d1,cran, .2), .2);\n    // SHAPING - top\n    float d6 = sdRoundBox(p-vec3(0.,0.8,-0.0), vec3(0.4,0.4,0.4), 0.03 ); \n    cran = opSmoothSubtraction(d6,cran,.5);\n    // SHAPING - front\n    float d7 = sdRoundBox(p-vec3(0.,0.42,0.82), vec3(0.4,0.4,0.4), 0.03 ); \n    cran = opSmoothSubtraction(d7,cran,.17);\n    // Eye Sockets\n    float d5 = sdRoundBox(p-vec3(0.0,-0.22,0.39), vec3(0.18,0.001,0.001), 0.03 );\n    cran = opSmoothSubtraction( d5, cran, .08);\n    // Nose\n    cran = opSmoothUnion( cran, sdRoundCone(   p-vec3( 0.0,-0.3, 0.34), vec3(0.0,0.0,0), vec3(0.0,0.17,-0.06), 0.03, 0.001), 0.05);\n    // Eyes\n    float eyel = sdSphere(p-vec3(0.11,-0.2,0.257), 0.05);\n    float eyer = sdSphere(p-vec3(-0.11,-0.2,0.257), 0.05);\n    cran = opSmoothUnion( cran, eyer, 0.025);\n    cran = opSmoothUnion( cran, eyel, 0.025);\n\n    return cran;\n}\n\nfloat map( in vec3 pos )\n{\n    float d = 1e10;\n    pos *= 0.9;\n    // Shoulders-Arms-Torso\n    vec3 q = pos - vec3(0.0,0.0,0.0);\n    q.z-=0.3;\n    q.y+=1.8 - q.x/20.;\n    q.x+=0.35 + q.y/20.;;\n    q = q*rotateX(1.7);\n    q = q*rotateZ(0.4);\n    q = q*rotateY(0.25);\n    float an = 1.0;\n    vec2 c = vec2(sin(an),cos(an));\n    vec4 w = opElongate( q, vec3(0.13,0.27,0.78) );\n    float shoulder = sdCappedTorus(w.xyz, c, 0.7, 0.2);\n    shoulder = shoulder+ sin((1.75+q.x)*3.)/15.;\n    shoulder = shoulder+0.04;\n    d = min( d, shoulder);\n    // Collar Bones\n    vec3 qt = pos - vec3(-0.8,-1.1,-0.7);\n    float collar = rounding( udTriangle( qt, vec3(0.6,0.0,0.19), vec3(0.4,-0.7,0.2), vec3(-0.1,-0.2,0.03) ), 0.05 );\n    collar = opSmoothUnion(collar, rounding( udTriangle( qt, vec3(0.7,0.0,0.1), vec3(0.8,-0.7,0.2), vec3(1.1,0.2,0.5) ), 0.01 ), 0.1);\n    d = opSmoothUnion(d, collar , 0.13);\n    // Extra Arm Padding\n    vec3 qv = pos - vec3(-0.9,-2.3,-0.6);\n    vec3 a = vec3(0.,-0.5, 0.0);\n    vec3 b = vec3( 0., 0.5, 0.0);\n    float l = length(b-a);\n    float wv = sqrt(0.1/l);\n    d = opSmoothUnion( d, sdVerticalVesicaSegment( qv-a, l, wv*0.85 ) - wv*0.15 , 0.2);\n    // Extra Chest Padding\n    qv = pos - vec3(-0.1,-1.8,-0.5);\n    a = vec3(0.,-0.35, 0.0);\n    b = vec3( 0., 0.35, 0.0);\n    l = length(b-a);\n    wv = sqrt(0.2/l);\n    d = opSmoothUnion( d, sdVerticalVesicaSegment( qv-a, l, wv*0.85 ) - wv*0.15 , 0.3);\n    // Neck\n    qv = pos - vec3(0.2,-1.5,-0.3);\n    a = vec3(0.,-0.2, 0.0);\n    b = vec3( 0., 0.3, 0.0);\n    l = length(b-a);\n    qv = pos - vec3(-0.2,-0.9,-0.55);\n    qv = qv*rotateX(-0.3);\n    float neck = sdCylinder(qv, vec2(0.185, 0.65));\n    d = opSmoothUnion( d, neck, 0.2);\n    // Head\n    vec3 qh = pos - vec3(-0.1,-0.07,-0.3);\n    qh = qh*rotateY(-0.8);\n    float head = sdHead(qh, 0.36);\n    d = opSmoothUnion( d, head , 0.15);\n    return d;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.9+(0.3*sin(iTime/1.5));\n    //float an = iMouse.x/100.;\n\tvec3 ro = vec3( 1.8*cos(an), 0.3,1.8*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 edge = ww;\n           bool close = false;\n        bool miss = false;\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    // render\n    vec3 tot = vec3(0.0);\n    int count = 0;\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    #if SAA<2\n    for( int n=0; n<AA; n++ )\n    #endif\n    {\n        count++;\n        // pixel coordinates\n         #if SAA>1\n        int n = 0;\n        #endif\n        vec2 mn = vec2(float(m),float(n));\n        #if SAA>1\n        if(fragCoord.y>iResolution.y/2.){mn = mn.yx;}\n        #endif\n        vec2 o =  mn/ float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n        // raymarch\n        const float tmax = 5.0;\n \n        float cth = 0.01;\n        float mth = 0.02;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            #if SAA>1\n            close = h<cth?true:close;\n            miss = close&&h>mth?true:miss;\n            #endif\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        // shading/lighting\t\n        vec3 bg = vec3(0.7,0.75,0.9);\n        vec3 col = bg;\n        // paint blotches\n        float blotchAmt = smoothstep(30.,44.5, magicBox((p+5.2)*5.));\n        blotchAmt = pow(blotchAmt, 3.);// attenuate\n        blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\n        col *= vec3(1.-blotchAmt,1.-blotchAmt,1.0);\n        // grain\n        col.rgb += (rand(p)-.5)*.08;\n        col.rgb = saturate(col.rgb);\n        vec3 bd = col;\n        vec2 hres = vec2(800., 450.)/iResolution.xy;\n       // edge = cross(edge, nor);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            edge = abs(cross(edge, nor));\n            vec3  lig = normalize(vec3(0.5,5.5,3.0));\n            vec3 ref = reflect(rd, nor);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float spe = pow(max(0.0, dot(lig, ref)),32.0);\n            float sha = calcSoftshadow( pos, lig, 0.03,3.0, 8.0 );\n            float amb = 0.6 + 0.2*dot(nor,normalize(vec3(1.0,1.0,0.0)));\n            vec2 tpoz = pos.xy*200.;tpoz.y+=90.0;tpoz.x+=460.; tpoz = abs(tpoz);\n            vec2 tpoy = pos.zy*200.;tpoy.y+=300.;tpoy.x-=450.; tpoy = abs(tpoy);\n            vec3 alb = texture(iChannel0, (tpoy.xy/hres)/iResolution.xy, 0.).rgb*0.75;\n            alb = min(alb, texture(iChannel0, (tpoz.xy/hres)/iResolution.xy, 0.).rgb*0.75);\n            //vec3 alb = texelFetch(iChannel0, ivec2(tpoy.xy/hres), 0).rgb*0.75;\n            //alb = min(alb, texelFetch(iChannel0, ivec2(tpoz.xy/hres), 0).rgb*0.75);\n            col = alb*amb + (spe*sha) + vec3(0.4,0.4,0.6)*dif*sha;\n        }\n        float f = smoothstep(-0.7,-1.0, p.y);\n        col = mix(col, bg, f);\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n        #if SAA>1\n        vec3 edgef = fwidth(edge);\n        float edget = edgef.x+edgef.y+edgef.z;\n        if(edget<0.1&&!miss){m=AA;}//else{tot=vec3(0);}\n        #endif\n    }\n    tot /= float(count);\n    #endif\n    //if(miss){tot=vec3(0);}\n\tfragColor = vec4( tot, 1.0 );\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// todo: implement sweep amt\nvec2 mouse;\n\n////////////////////////////////////////////////////////////////\n// BOILERPLATE UTILITIES...................\nconst float pi = 3.14159;\nconst float pi2 = pi * 2.;\n\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\nfloat opI( float d1, float d2) { return max(d1,d2); }\n\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\nfloat nsin(float a){return .5+.5*sin(a);}\nfloat ncos(float a){return .5+.5*cos(a);}\n\nfloat dtoa(float d, float amount)\n{\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n}\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n    vec2 d = max(tl-uv, uv-br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\n{\n    return length(uv - origin) - radius;\n}\n// 0-1 1-0\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\n{\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\n}\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n// returns -.5 to 1.5. i think.\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\t\n}\nfloat noise01(vec2 p)\n{\n    return clamp((noise(p)+.5)*.5, 0.,1.);\n}\n// debug function to convert distance to color, revealing sign.\nvec3 dtocolor(vec3 inpColor, float dist)\n{\n    vec3 ret;\n    if(dist > 0.)\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\n    else\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\n    return ret;\n}\n\nfloat smoothf(float x)\n{\n    return x*x*x*(x*(x*6. - 15.) + 10.);\n}\n\n////////////////////////////////////////////////////////////////\n// APP CODE ...................\n\n// this function will produce a line with brush strokes. the inputs are such\n// that you can apply it to pretty much any line; the geometry is separated from this function.\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\n{\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\n\n    if(iMouse.z > 0.)\n    {\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\n    \tfloat okthen = 42.;// NOP\n    }\n    \n    // warp the position-in-line, to control the curve of the brush falloff.\n    if(posInLineY > 0.)\n    {\n        float mouseX = 200. == 0. ? 0.2 : (200. / iResolution.x);\n\t   posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\n        //posInLineY = pow(posInLineY, (pow(200.,2.) * 15.) + 1.5);\n        \n    }\n\n    // brush stroke fibers effect.\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\n    float strokeTexture = 0.\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\n        ;\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\n    // fade out the end of the stroke by shifting the noise curve below 0\n    const float strokeAlphaBoost = 1.09;\n    if(posInLineY > 0.)\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.8));// fade out\n    else\n        strokeAlpha *= strokeAlphaBoost;\n\n    strokeAlpha = smoothf(strokeAlpha);\n    \n    // paper bleed effect.\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\n paperBleedAmt = 200.;// disable paper bleed    \n    \n    // blotches (per stroke)\n    //float blotchAmt = smoothstep(2.,28.5,magicBox(vec3(uvPaper, uvLine.x)));\n    //blotchAmt *= (strokeAlpha+0.1);\n    //strokeAlpha += blotchAmt;\n\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\n    alpha = clamp(alpha, 0.,1.);\n    return mix(inpColor, brushColor.rgb, alpha);\n}\n\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\n{\n    // flatten the line to be axis-aligned.\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\n    mat2 rotMat = rot2D(lineAngle);\n\n    float lineLength = distance(p2_, p1_);\n    // make an axis-aligned line from this line.\n    vec2 tl = (p1_ * rotMat);// top left\n    vec2 br = tl + vec2(0,lineLength);// bottom right\n    vec2 uvLine = uv * rotMat;\n\n    // make line slightly narrower at end.\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\n    \n    // wobble it around, humanize\n    float res = min(iResolution.y,iResolution.x);\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\n    uvLine = tl - uvLine;\n    \n    vec2 lineSize = vec2(lineWidth, lineLength);\n    \n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\n                                d, inpColor, brushColor);\n    return ret;\n}\n\n// returns:\n// xy = uvLine\n// z = radius\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\n{\n    vec2 humanizedUVLine = uvLine;\n    \n\t// offsetting the circle along its path creates a twisting effect.\n    float twistAmt = .24;\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\n    humanizedUVLine.x += linePosY * twistAmt;\n    \n    // perturb radius / x\n    float humanizedRadius = radius_;\n    float res = min(iResolution.y,iResolution.x);\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n    \n    return vec3(humanizedUVLine, humanizedRadius);\n}\n\n// there's something about calling an Enso a \"donut\" that makes me giggle.\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\n{\n\tvec2 uvLine = uv - o;\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\n    angle = mod(angle-angleStart+pi, pi2);\n    if(!clockwise)\n        angle = pi2 - angle;\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\n    uvLine = vec2(\n        radius_ - length(uvLine),\n        angle / pi2 * lineLength\n    );\n    \n    // make line slightly narrower at end.\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\n    \n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n    vec2 humanizedUVLine = hu.xy;\n    float humanizedRadius = hu.z;\n\n    float d = opS(sdCircle(uv, o, humanizedRadius),\n                  sdCircle(uv, o, humanizedRadius));\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\n\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\n    \n    // do the same but for before the beginning of the line. distance field is just a single point\n    vec3 ret2 = vec3(1);\n    if(angle > pi)\n    {\n        uvLine.y -= lineLength;\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n        humanizedUVLine = hu.xy;\n        humanizedRadius = hu.z;\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\n        d = distance(uv, strokeStartPos);\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\n\t}\n    return min(ret, ret2);\n}\n\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\n{\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\n    ret *= newSize;// scale up to new dimensions\n    float aspect = iResolution.x / iResolution.y;\n    ret.x *= aspect;// orig aspect ratio\n    float newWidth = newSize.x * aspect;\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\n}\n\n// Blue Porcelain specific code below\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(1);\n    // Caching output - if we're on the first frame or the resolution has changed, draw everything.\n    if(iFrame<2 || texelFetch(iChannel0, ivec2(0), 0).r != iResolution.x){\n\n        vec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));\n        float yo = sin(-uv.x*pi*0.5)*0.2;\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.05,.5),1.5),vec2(0.52, -0.3+yo ),vec2(0.25, 0.0+yo), 0.4);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.36, 0.+yo ),vec2(0.9, -0.1+yo), 0.002);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.36, 0.055+yo + (sin(uv.x * 36.) * 0.02)),vec2(0.9, 0.+yo), 0.002);                    \n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.24, -0.18-yo ),vec2(-0.4, -0.1-yo), 0.002);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.26, -0.12-yo + (sin(uv.x * 36.) * 0.02)),vec2(-0.4, -0.2-yo), 0.002);                      \n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.35, .25+yo + (sin(uv.x * 35.5) * 0.025)),vec2(0.17, .21+yo), 0.002);                     \n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.35, .24+yo + (sin(uv.x * 35.5) * -0.025)),vec2(0.17, .2+yo), 0.002);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.35, .245+yo),vec2(0.17, .205+yo), 0.002);\n        vec2 sps = vec2(0.55,0.55);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.03,0.0,0.3,0.0002,true);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,0.0,0.3,0.0002,true);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.09,0.0,0.3,0.0002,true);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.12,0.0,0.3,0.0002,true);   \n        \n        if(ivec2(fragCoord.xy) == ivec2(0)){ col.r = iResolution.x;}// Store resolution in 0,0 pixel\n    } else {\n       // We've already drawn everything, use buffer instead\n       col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    }\n    fragColor = vec4(col, 1.);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "\nfloat magicBox(vec3 p) {\n    const int MAGIC_BOX_ITERS = 13;\n    const float MAGIC_BOX_MAGIC = 0.55;\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\nfloat magicBox(vec2 uv){\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n    // volume along the same axes as the fractal's bounding box.\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    return magicBox(p);\n}\n\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\n\n\n\nfloat sdSphere( in vec3 p, in float r)\n{\n    return length(p)-r;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat dot2(in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    return -opSmoothUnion(d1,-d2,k);\n    \n    //float h = max(k-abs(-d1-d2),0.0);\n    //return max(-d1, d2) + h*h*0.25/k;\n}\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    //vec3 q = abs(p)-h;\n    //return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n// Euclidean distance to a capped torus\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdVerticalVesicaSegment( in vec3 p, in float h, in float w )\n{\n    // shape constants\n    h *= 0.5;\n    w *= 0.5;\n    float d = 0.5*(h*h-w*w)/w;\n    \n    // project to 2D\n    vec2  q = vec2(length(p.xz), abs(p.y-h));\n    \n    // feature selection (vertex or body)\n    vec3  t = (h*q.x < d*(q.y-h)) ? vec3(0.0,h,0.0) : vec3(-d,0.0,d+w);\n    \n    // distance\n    return length(q-t.xy) - t.z;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3XS3RV",
    "date": "1745138363",
    "viewed": 257,
    "name": "Blue Porcelain v2",
    "description": "Trying to recreate https://arthur.io/art/bao-pham/blue-porcelain with SDFs and raymarching\nVersion 2. I think this is as close as I can get.",
    "likes": 23,
    "published": "Public",
    "usePreview": 1,
    "tags": [
     "sdf",
     "painting",
     "face",
     "brush",
     "human",
     "china",
     "reproduction",
     "anatomy",
     "woman",
     "porcelain",
     "asian",
     "vietnamese"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Blue Porcelain\" by Cotterzz. https://shadertoy.com/view/W3XGWS\n// 2025-04-10 04:23:43\n\n// This is my first attempt at using SDFs and raymarching\n// It's a bit ambitious, and is still very much a work in progress.\n// There's lots more I want to do with it, but I have some tidying and optimisation to look into before I take it any further.\n// --\n// Based on/inspired by Bao Pham's painting 'Blue Porcelain' https://arthur.io/art/bao-pham/blue-porcelain\n// Uses code and functions from the following shaders:\n// \"Bottomless depth\" by leon       https://www.shadertoy.com/view/tsBXRh\n// \"Capped torus - distance\" by iq. https://www.shadertoy.com/view/tl23RK\n// \"Elongation SDF\" by iq.          https://www.shadertoy.com/view/Ml3fWj\n// \"Vesica Segment\" by iq.          https://www.shadertoy.com/view/Ds2czG\n// \"Brush Experiment 3\" by 104      https://www.shadertoy.com/view/ltj3Wc\n// \"Magic Fractal\" by dgreensp      https://www.shadertoy.com/view/4ljGDd\n// --\n// 2025-03-31 04:38:41\n// Copyright/licensing of forked code belongs to respective artists/authors.\n// Everything else assembled here is the work of John Cotterell johnmdcotterell@gmail.com\n// and cannot be use outside shadertoy without permission.\n\n#define AA 2\n// The porcelain looks better with anti-aliasing, but it tanks the fps on slower machines.\n// 1 is off, 2 is 2x2 AA, 3 is 3x3 AA etc..\n\n#define SAA 1\n// Selective anti-aliasing tries to target edges and doesn't look quite as good, but is faster.\n// 1 is off, 2 is on\n\nint area = 0;\nvec2 facepos = vec2(0);\nbool necka = false;\nbool roses = false;\nfloat sdHead( vec3 p ){\n    // TOP - Cranium\n\n    float cran = sdSphere(p-vec3(0,0,0.03),0.35);\n    // BOTTOM - Jaw/Cheekbones\n    vec2 os = vec2(-0.14,0.05);\n    float ms = 0.127;\n    vec3 ql = p - vec3(ms,os);\n    vec3 qr = p - vec3(-ms,os);\n    ql = ql*rotateZ(0.26);\n    qr = qr*rotateZ(-0.26);\n    ql = ql*rotateX(0.42);\n    qr = qr*rotateX(0.42);\n    vec3 a = vec3(0.,-0.4, 0.0);\n    vec3 b = vec3( 0., 0.4, 0.0);\n    float l = length(b-a);\n    float wv = sqrt(0.105/l);\n    float jaw = opSmoothUnion(sdVerticalVesicaSegment( ql-a, l, wv*0.85 ) - wv*0.15, \n    sdVerticalVesicaSegment( qr-a, l, wv*0.85 ) - wv*0.15, 0.07);\n    cran = opSmoothUnion( cran, jaw, 0.03);\n    // SHAPING - sides\n    float d2 = sdRoundBox(p-vec3(0.74,-0.4,-0.15), vec3(0.4,0.6,0.4), 0.02 ); \n    float d1 = sdRoundBox(p-vec3(-0.74,-0.4,-0.15), vec3(0.4,0.6,0.4), 0.02); \n\n    cran = opSmoothSubtraction(d2,opSmoothSubtraction(d1,cran, .2), .2);\n    // SHAPING - top\n    float d6 = sdRoundBox(p-vec3(0.,0.75,-0.0), vec3(0.4,0.4,0.4), 0.04 ); \n    cran = opSmoothSubtraction(d6,cran,.52);\n    // SHAPING - front\n    float d7 = sdRoundBox(p-vec3(0.,0.25,0.77), vec3(0.4,0.4,0.4), 0.01 ); \n    cran = opSmoothSubtraction(d7,cran,.15);\n    // Eye Sockets\n    float d5 = sdRoundBox(p-vec3(0.0,-0.21,0.385), vec3(0.18,0.001,0.001), 0.06 );\n    cran = opSmoothSubtraction( d5, cran, .04);\n    // nose\n    float nose = sdRoundCone(   p-vec3( 0.0,-0.32, 0.32), vec3(0.0,0.0,0), vec3(0.0,0.2,-0.06), 0.033, 0.01);\n    nose = opSmoothUnion( nose, sdRoundCone(   p-vec3( 0.0,-0.34, 0.3), vec3(-0.026,0,0), vec3(0.026,0,0), 0.015, 0.015), 0.03);\n    float nos = sdSphere(p-vec3(0.,-0.21,0.45), 0.11);\n    nose = opSmoothSubtraction( nos, nose, .08);\n    cran = opSmoothUnion( cran, nose, 0.02);\n    \n    \n    // Eyes\n    float eyel = sdSphere(p-vec3(0.11,-0.22,0.257), 0.035);\n    \n    \n    float eyer = sdVerticalVesicaSegment(p-vec3(-0.15,-0.43,0.2), 0.35, 0.23);\n    \n    eyer+=sin(p.y*70.)/300.;\n    eyer+=sin(p.x*80.)/400.;\n    eyer+=sin(p.z*90.)/500.;\n    if(eyer<0.01){roses = true;}\n    cran = opSmoothUnion( cran, eyer, 0.01);\n    \n    cran = opSmoothUnion( cran, eyel, 0.03);\n\n    float fan = sdRoundBox(p-vec3(0.,0.37,-0.7), vec3(0.8,0.8,0.8), 0.01 ); \n    \n    cran = min(fan,cran);\n\n    if(cran<0.001){area = 1;facepos = p.xy;}\n    if(fan<0.02){area = 2;facepos = p.xy;}\n    \n    return cran;\n}\n\nfloat map( in vec3 pos )\n{\n    float d = 1e10;\n    pos *= 0.9;\n    pos = pos*rotateZ(-0.08);\n    // Shoulders-Arms-Torso\n    vec3 q = pos - vec3(0.0,0.0,0.0);\n    q.z-=0.3;\n    q.y+=1.8 - q.x/20.;\n    q.x+=0.35 + q.y/20.;;\n    q = q*rotateX(1.7);\n    q = q*rotateZ(0.4);\n    q = q*rotateY(0.25);\n    float an = 1.0;\n    vec2 c = vec2(sin(an),cos(an));\n    vec4 w = opElongate( q, vec3(0.13,0.27,0.78) );\n    float shoulder = sdCappedTorus(w.xyz, c, 0.7, 0.2);\n    shoulder = shoulder+ sin((1.75+q.x)*3.)/15.;\n    shoulder = shoulder+0.04;\n    d = min( d, shoulder);\n    // Collar Bones\n    vec3 qt = pos - vec3(-0.8,-1.1,-0.7);\n    float collar = rounding( udTriangle( qt, vec3(0.6,0.0,0.1), vec3(0.4,-0.7,0.2), vec3(-0.1,-0.2,0.03) ), 0.05 );\n    collar = opSmoothUnion(collar, rounding( udTriangle( qt, vec3(0.7,0.0,0.1), vec3(0.8,-0.7,0.2), vec3(1.1,0.2,0.4) ), 0.01 ), 0.1);\n    d = opSmoothUnion(d, collar , 0.13);\n\n    // Neck\n     vec3 qv = pos - vec3(0.2,-1.5,-0.3);\n     vec3 a = vec3(0.,-0.2, 0.0);\n     vec3 b = vec3( 0., 0.3, 0.0);\n   float l = length(b-a);\n    qv = pos - vec3(-0.2,-0.9,-0.55);\n    qv = qv*rotateX(-0.3);\n    float neck = sdCylinder(qv, vec2(0.16, 0.65));\n    \n    d = opSmoothUnion( d, neck, 0.2);\n    if(d<0.01){necka=true;}\n    // Head\n    vec3 qh = pos - vec3(-0.15,-0.12,-0.36);\n    qh = qh*rotateY(-0.9-(0.1*sin(iTime/1.5)));\n    float head = sdHead(qh/1.03);\n    d = opSmoothUnion( d, head , 0.15);\n    return d;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n     // camera movement\t\n\tfloat an = 0.8+(0.2*sin(iTime/1.5));\n    //float an = iMouse.x/100.;\n\tvec3 ro = vec3( 1.8*cos(an), 0.3,1.8*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 edge = ww;\n    float ed = 0.;\n    vec3 ndif = vec3(0);\n    bool close = false;\n    bool miss = false;\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    // render\n    vec3 tot = vec3(0.0);\n    int count = 0;\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    #if SAA<2\n    for( int n=0; n<AA; n++ )\n    #endif\n    {\n        count++;\n        // pixel coordinates\n         #if SAA>1\n        int n = 0;\n        #endif\n        vec2 mn = vec2(float(m),float(n));\n        #if SAA>1\n        if(fragCoord.y>iResolution.y/2.){mn = mn.yx;}\n        #endif\n        vec2 o =  mn/ float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n                // shading/lighting\t\n        vec3 bg = vec3(0.6,0.65,0.8);\n        vec3 col = bg;\n        // paint blotches\n        float blotchAmt = smoothstep(30.,44.5, magicBox((p+5.2)*5.));\n        blotchAmt = pow(blotchAmt, 3.);// attenuate\n        blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\n        col *= vec3(1.-blotchAmt,1.-blotchAmt,1.0);\n        // grain\n        col.rgb += (rand(p)-.5)*.08;\n        col.rgb = saturate(col.rgb);\n        vec3 bd = col;\n        // raymarch\n        if(uv.x>0.4 && uv.x<0.7 && uv.y<0.7){\n        const float tmax = 5.0;\n \n        float cth = 0.01;\n        float mth = 0.02;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            #if SAA>1\n            close = h<cth?true:close;\n            miss = close&&h>mth?true:miss;\n            #endif\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n\n        vec2 hres = vec2(800., 450.)/iResolution.xy;\n       // edge = cross(edge, nor);\n            vec2 tpoz = facepos.xy*370.;tpoz.y+=234.;tpoz.x+=400.; tpoz = abs(tpoz); //350\n            vec2 rpoz = tpoz; rpoz.y += 116.;\n            vec3 alb = vec3(1);\n            if(area>0){alb = textureLod(iChannel0, (tpoz/hres)/iResolution.xy, 0.5).rgb;}\n        if( t<tmax )\n        {\n           \n            \n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            ed = 10.*(dot(nor,rd)+0.3);\n            //ndif = normalize(vec3(0,0,1)-nor);\n            edge = abs(cross(edge, nor));\n            vec3  lig = normalize(vec3(0.5,2.0,1.5));\n            //vec3  lig2 = normalize(vec3(1.0,0.5,1.5));\n            vec3 ref = reflect(rd, nor);\n            ndif = normalize(ref+nor);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            //float dif2 = clamp( dot(nor,lig2), 0.0, 1.0 );\n            \n            \n           // vec2 tpoy = pos.zy*200.;tpoy.y+=300.;tpoy.x-=450.; tpoy = abs(tpoy);\n \n            //if(necka){alb = vec3(0,1,0);}\n            //vec3 alb = texture(iChannel0, (tpoy.xy/hres)/iResolution.xy, 0.).rgb;\n            //alb=alb*alb;\n            //alb = min(alb, texture(iChannel0, (tpoz.xy/hres)/iResolution.xy, 0.).rgb*0.75);\n            //vec3 alb = texelFetch(iChannel0, ivec2(tpoy.xy/hres), 0).rgb*0.75;\n            //alb = min(alb, texelFetch(iChannel0, ivec2(tpoz.xy/hres), 0).rgb*0.75);\n            if(area!=2||pos.y<-0.7) {\n\n                if(necka){\n                  vec2 bpoz = pos.xy*570.;bpoz.y+=400.;bpoz.x+=600.; bpoz = abs(bpoz);\n                  alb = textureLod(iChannel0, (bpoz/hres)/iResolution.xy, 0.5).rgb;\n                  vec2 bpox = pos.xz*370.;bpox.y+=225.;bpox.x+=310.; bpox = abs(bpox);\n                  alb = min(alb,textureLod(iChannel0, (bpox/hres)/iResolution.xy, 0.5).rgb);\n                }\n\n                float spe = pow(max(0.0, dot(lig, ref)),32.0);\n                float sha = 1.;//calcSoftshadow( pos, lig, 0.03,3.0, 8.0 );\n                float amb = 0.55 + 0.2*dot(nor,normalize(vec3(0.0,1.0,0.0)));\n                if(roses){\n                  vec3 rcol = textureLod(iChannel1, (rpoz/hres)/iResolution.xy, 0.5).rgb;\n                  if(rcol.r>0.3&&rcol.g<0.3&&rcol.b<0.3){\n                        alb=rcol;\n                  }\n                  alb = min(alb, rcol);\n                  spe=0.;\n                  dif=0.4;\n                }\n                col =alb*amb + (spe*sha) + vec3(0.4,0.4,0.6)*dif/2.*sha;\n            } else {\n                col=min(col,alb);\n                \n            }\n            \n            if(alb.r>0.3&&alb.g<0.3&&alb.b<0.3){\n                col=alb;\n            }\n        }\n        }\n   \n        float f = smoothstep(-0.7,-1.0, p.y);\n        col = mix(col, bg, f);\n        // gamma        \n        col = (col + sqrt( col ) + sqrt( col ))/3.;\n\t    tot += col;\n    #if AA>1\n        #if SAA>1\n        vec3 edgef = fwidth(edge);\n        float edget = edgef.x+edgef.y+edgef.z;\n        if(edget<0.1&&!miss){m=AA;}//else{tot=vec3(0);}\n        #endif\n    }\n    tot /= float(count);\n    #endif\n    //if(miss){tot=vec3(0);}\n    //if(sqrt((ndif.x*ndif.x) + (ndif.y*ndif.y)+ (ndif.z*ndif.z))>1.){tot=ndif;}\n    \n\tfragColor = vec4( tot, 1.0 );\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// todo: implement sweep amt\nvec2 mouse;\n\n////////////////////////////////////////////////////////////////\n// BOILERPLATE UTILITIES...................\nconst float pi = 3.14159;\nconst float pi2 = pi * 2.;\n\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\nfloat opI( float d1, float d2) { return max(d1,d2); }\n\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\nfloat nsin(float a){return .5+.5*sin(a);}\nfloat ncos(float a){return .5+.5*cos(a);}\n\nfloat dtoa(float d, float amount)\n{\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n}\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n    vec2 d = max(tl-uv, uv-br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\n{\n    return length(uv - origin) - radius;\n}\n// 0-1 1-0\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\n{\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\n}\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n// returns -.5 to 1.5. i think.\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\t\n}\nfloat noise01(vec2 p)\n{\n    return clamp((noise(p)+.5)*.5, 0.,1.);\n}\n// debug function to convert distance to color, revealing sign.\nvec3 dtocolor(vec3 inpColor, float dist)\n{\n    vec3 ret;\n    if(dist > 0.)\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\n    else\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\n    return ret;\n}\n\nfloat smoothf(float x)\n{\n    return x*x*x*(x*(x*6. - 15.) + 10.);\n}\n\n////////////////////////////////////////////////////////////////\n// APP CODE ...................\n\n// this function will produce a line with brush strokes. the inputs are such\n// that you can apply it to pretty much any line; the geometry is separated from this function.\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\n{\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\n\n    if(iMouse.z > 0.)\n    {\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\n    \tfloat okthen = 42.;// NOP\n    }\n    \n    // warp the position-in-line, to control the curve of the brush falloff.\n    if(posInLineY > 0.)\n    {\n        float mouseX = 200. == 0. ? 0.2 : (200. / iResolution.x);\n\t   posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\n        //posInLineY = pow(posInLineY, (pow(200.,2.) * 15.) + 1.5);\n        \n    }\n\n    // brush stroke fibers effect.\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\n    float strokeTexture = 0.\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\n        ;\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\n    // fade out the end of the stroke by shifting the noise curve below 0\n    const float strokeAlphaBoost = 1.09;\n    if(posInLineY > 0.)\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.8));// fade out\n    else\n        strokeAlpha *= strokeAlphaBoost;\n\n    strokeAlpha = smoothf(strokeAlpha);\n    \n    // paper bleed effect.\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\n paperBleedAmt = 400.;// disable paper bleed    \n    \n    // blotches (per stroke)\n    //float blotchAmt = smoothstep(2.,28.5,magicBox(vec3(uvPaper, uvLine.x)));\n    //blotchAmt *= (strokeAlpha+0.1);\n    //strokeAlpha += blotchAmt;\n\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\n    alpha = clamp(alpha, 0.,1.);\n    return mix(inpColor, brushColor.rgb, alpha);\n}\n\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\n{\n    // flatten the line to be axis-aligned.\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\n    mat2 rotMat = rot2D(lineAngle);\n\n    float lineLength = distance(p2_, p1_);\n    // make an axis-aligned line from this line.\n    vec2 tl = (p1_ * rotMat);// top left\n    vec2 br = tl + vec2(0,lineLength);// bottom right\n    vec2 uvLine = uv * rotMat;\n\n    // make line slightly narrower at end.\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\n    \n    // wobble it around, humanize\n    float res = min(iResolution.y,iResolution.x);\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\n    uvLine = tl - uvLine;\n    \n    vec2 lineSize = vec2(lineWidth, lineLength);\n    \n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\n                                d, inpColor, brushColor);\n    return ret;\n}\n\n// returns:\n// xy = uvLine\n// z = radius\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\n{\n    vec2 humanizedUVLine = uvLine;\n    \n\t// offsetting the circle along its path creates a twisting effect.\n    float twistAmt = .24;\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\n    humanizedUVLine.x += linePosY * twistAmt;\n    \n    // perturb radius / x\n    float humanizedRadius = radius_;\n    float res = min(iResolution.y,iResolution.x);\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n    \n    return vec3(humanizedUVLine, humanizedRadius);\n}\n\n// there's something about calling an Enso a \"donut\" that makes me giggle.\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\n{\n\tvec2 uvLine = uv - o;\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\n    angle = mod(angle-angleStart+pi, pi2);\n    if(!clockwise)\n        angle = pi2 - angle;\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\n    uvLine = vec2(\n        radius_ - length(uvLine),\n        angle / pi2 * lineLength\n    );\n    \n    // make line slightly narrower at end.\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\n    \n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n    vec2 humanizedUVLine = hu.xy;\n    float humanizedRadius = hu.z;\n\n    float d = opS(sdCircle(uv, o, humanizedRadius),\n                  sdCircle(uv, o, humanizedRadius));\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\n\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\n    \n    // do the same but for before the beginning of the line. distance field is just a single point\n    vec3 ret2 = vec3(1);\n    if(angle > pi)\n    {\n        uvLine.y -= lineLength;\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n        humanizedUVLine = hu.xy;\n        humanizedRadius = hu.z;\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\n        d = distance(uv, strokeStartPos);\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\n\t}\n    return min(ret, ret2);\n}\n\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\n{\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\n    ret *= newSize;// scale up to new dimensions\n    float aspect = iResolution.x / iResolution.y;\n    ret.x *= aspect;// orig aspect ratio\n    float newWidth = newSize.x * aspect;\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\n}\n\n// Blue Porcelain specific code below\nfloat lips(vec2 a , vec2 b, float h, vec2 p){\n    float col = 0.;\n    if(p.x>a.x && p.x<b.x){col = 1.;}\n    float sc = 1./h/(b.x-a.x);\n    float bottom = (a.y - sin((a.x-p.x)/(b.x-a.x)*3.1416)/(sc*2.7)) - p.y;\n    //float f = smoothstep(-1.0, 1000.5, bottom);col = mix(1.,0.5, f);\n    if(col==1. && bottom>0.) {col =1.0;} else {col = 0.;}\n    //col=bottom;\n    float dist = (b.x-a.x)/4.5;\n    a.x+=dist;b.x-=dist;\n    if(col==1. && p.y>(a.y + sin((a.x-p.x)/(b.x-a.x)*9.423)/(sc*20.))) {col = 1.;} else {col = 0.;}\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(1);\n    vec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));\n    // Caching output - if we're on the first frame or the resolution has changed, draw everything.\n    uv.y-=0.5;\n    if(iFrame<2 || texelFetch(iChannel0, ivec2(0), 0).r != iResolution.x){\n\n        \n        float yo = sin(-uv.x*pi*0.5)*0.2;\n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.03,.5),1.),vec2(0.4, -0.35+yo ),vec2(0.25, 0.12+yo), 0.05);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.1, -0.24 ),vec2(0.9, -0.6), 0.01);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.1, -0.1 + (sin((uv.x+0.1) * 25.) * 0.03)),vec2(0.85, -0.6), 0.01);                    \n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.09, -0.12 ),vec2(0.13, -0.17 ), 0.001);\n              \n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.1, -0.24 ),vec2(-0.9, -0.6), 0.02);\n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.1, -0.1 - (sin((uv.x+0.1) * 25.) * 0.03)),vec2(-0.85, -0.5), 0.01);                    \n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.09, -0.12),vec2(-0.13, -0.17 ), 0.001);\n//col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.4),vec2(0.32, .245+yo),vec2(0.2, .205+yo), 0.002);\n        vec2 sps = vec2(0.25,-0.01);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,4.0,6.6,0.0001,true);\n        sps+=vec2(-0.015,-0.015);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,3.0,1.6,0.03,true);\n        sps+=vec2(0.07,0.07);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,5.0,6.6,0.0001,true);\n        sps+=vec2(0.015,-0.0);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,3.0,1.6,0.03,true);\n        \n        sps = vec2(-0.18,0.12);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,1.0,6.6,0.0001,true);\n        sps+=vec2(-0.01,-0.015);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,-3.0,1.6,0.02,true);\n        sps+=vec2(0.05,0.05);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,1.0,6.6,0.0001,true);\n        sps+=vec2(0.01,-0.015);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,-3.0,1.6,0.02,true);\n//colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\n        sps = vec2(-0.23,-0.3);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.3,6.3,5.1,0.02,false);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.2,6.3,5.1,0.02,false);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.15,6.3,5.1,0.015,false);\n        sps+=vec2(-0.05,0.03);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.2,6.3,5.1,0.04,false);\n        //col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.25,6.3,5.1,0.04,false);\n        \n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.24, 0.15 + (sin((uv.x+0.1) * 25.) * 0.06)),vec2(-1.3, -1.3), 0.07);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.2, -0.2 + (sin((uv.x+0.1) * 25.) * 0.06)),vec2(-1.3, -1.0), 0.04);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.25 + sin(uv.y * 25.) * 0.03, -0.0 - (sin(uv.x * 15.) * 0.04)),vec2(0.8, -2.5), 0.03);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.55 + sin(uv.y * 25.) * 0.03, -0.4 - (sin(uv.x * 15.) * 0.04)),vec2(0.8, -2.), 0.06);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.55 + sin(uv.y * 25.) * 0.07, -0.4 - (sin(uv.x * 15.) * 0.06)),vec2(-0.8, -2.), 0.05);\n         col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.4 + sin(uv.y * 25.) * 0.07, -0.1 - (sin(uv.x * 15.) * 0.06)),vec2(1.2, -1.5), 0.06);    \n         col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.0 + sin(uv.y * 25.) * 0.07, -0.9 - (sin(uv.x * 15.) * 0.06)),vec2(0.0, -1.9), 0.12);    \n\ncol = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.0, -0.44),0.44,-2.,5.1,0.06,false);\n        \n        //col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.09,0.0,0.3,0.0002,true);\n        //col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.12,0.0,0.3,0.0002,true);\n\n       // if(lips(vec2(0.27, 0.14), vec2(0.385, 0.15), 0.8, uv)>0.){col = vec3(.0,.1,.7);}\n       float lp = lips(vec2(-0.12, 0.13), vec2(0.12, 0.13), 0.9, uv);\n        if(lp>0.){col = vec3(.0,.1,.7)*lp;}\n\n        \n        //col = colorBrushStroke(vec2(0.1,0.1), vec2(0.1,0.1), vec2(0.1,0.1), sdCircle(uv, vec2(0.1,0.1), 0.1), vec3(1,0,0), vec4(0,1,0,1));\n        \n        if(ivec2(fragCoord.xy) == ivec2(0)){ col.r = iResolution.x;}// Store resolution in 0,0 pixel\n    } else {\n       // We've already drawn everything, use buffer instead\n      col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n  }\n   \n\n\n       \n\n    fragColor = vec4(col, 1.);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "\nfloat magicBox(vec3 p) {\n    const int MAGIC_BOX_ITERS = 13;\n    const float MAGIC_BOX_MAGIC = 0.55;\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\nfloat magicBox(vec2 uv){\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n    // volume along the same axes as the fractal's bounding box.\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    return magicBox(p);\n}\n\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\n\n\n\nfloat sdSphere( in vec3 p, in float r)\n{\n    return length(p)-r;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat dot2(in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    return -opSmoothUnion(d1,-d2,k);\n    \n    //float h = max(k-abs(-d1-d2),0.0);\n    //return max(-d1, d2) + h*h*0.25/k;\n}\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    //vec3 q = abs(p)-h;\n    //return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n// Euclidean distance to a capped torus\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdVerticalVesicaSegment( in vec3 p, in float h, in float w )\n{\n    // shape constants\n    h *= 0.5;\n    w *= 0.5;\n    float d = 0.5*(h*h-w*w)/w;\n    \n    // project to 2D\n    vec2  q = vec2(length(p.xz), abs(p.y-h));\n    \n    // feature selection (vertex or body)\n    vec3  t = (h*q.x < d*(q.y-h)) ? vec3(0.0,h,0.0) : vec3(-d,0.0,d+w);\n    \n    // distance\n    return length(q-t.xy) - t.z;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Bottomless depth https://www.shadertoy.com/view/tsBXRh\n// Exploring procedural painting\n// Licensed under hippie love conspiracy\n// Leon Denise (ponk) 2019.03.17\n// Using code from:\n// Inigo Quilez (shadertoy.com/view/Xds3zN)\n// Morgan McGuire (shadertoy.com/view/4dS3Wd)\n\nconst float zoomSpeed = 0.05;\nconst float noiseScale = 4.;\nconst float noiseSpeed = 0.0;\n\nconst float PI = 3.1415;\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\nfloat fbm (vec3 p) {\n  float amplitude = .5;\n  float result = 0.0;\n  for (float index = 0.0; index <= 5.0; ++index) {\n    result += noise(p / amplitude) * amplitude;\n    amplitude /= 2.;\n  }\n  return result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 color = vec3(1);\n  float timeline = iTime*zoomSpeed;\n  vec2 unit = 1./iResolution.xy;\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  vec2 p = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  float stage = floor(timeline);\n  float ratio = fract(timeline);\n  const float iterations = 3.;\n  float spawn = 1.;\n  float zoom = .5;\n  float scale = noiseScale * iResolution.y / 320.;\n  for (float index = iterations; index > 0.; --index) {\n    ratio = mod(ratio+1./iterations, 1.);\n    vec3 s = vec3(p*scale*(zoom-ratio*zoom), 1. + timeline*noiseSpeed);\n    float salty = fbm(s) * 2. - 1.;\n    float angle = salty * PI * 8.;\n    uv += vec2(cos(angle),sin(angle)) * unit * sin(ratio*PI);\n    spawn *= 1. - abs(sin(angle)) * sin(ratio*PI);\n  }\n  color *= spawn;\n  float blend = (.5+.5*(1.-spawn));\n  fragColor = texture(iChannel0, uv)*blend + (1.-blend)*vec4(color, 1);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if(iFrame<30){\n        fragColor = texture(iChannel0, (uv*1.45));\n        if(fragColor.r>0.25){\n            fragColor.g=0.1; fragColor.b=0.1;fragColor.r*=1.5;\n        } else if(fragColor.r>0.15){fragColor.g=0.1; fragColor.r=0.1;fragColor.b=0.7;}else{fragColor = vec4(1);}\n    } else {fragColor = texture(iChannel1, uv);}\n    }",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wXB3zc",
    "date": "1744349799",
    "viewed": 10,
    "name": "fork framerate agnosticism..",
    "description": "sound envelope refactoring",
    "likes": 1,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "audio"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"framerate agnosticism study\" by meisei4. https://shadertoy.com/view/WXjGWw\n// 2025-04-11 05:35:43\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "XsXGzn",
       "filepath": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3",
       "type": "music",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define WAVEFORM_SAMPLE_COUNT 512 //TODO: derive this from the actual ShaderToyAudioTexture constants??? it doesnt even need to 512?\n#define WAVEFORM_SAMPLE_COUNT_F float(WAVEFORM_SAMPLE_COUNT)\n#define AUDIO_TEXTURE_WAVEFORM_ROW 1.0 //TODO: derive this from the actual ShaderToyAudioTexture constants\n\n#define UNUSED_FEEDBACK_CHANNEL 0.0\n#define WAVEFORM_SEGMENT_CENTERING_OFFSET 0.5\n\n#define WAVEFORM_SAMPLES_PER_SEGMENT (WAVEFORM_SAMPLE_COUNT / DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS)\n#define WAVEFORM_SAMPLES_PER_SEGMENT_F (WAVEFORM_SAMPLE_COUNT_F / DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS_F)\n\n#define TARGET_BLEND_INTENSITY_BETWEEN_ENVELOPE_INJECTION_SNAPSHOTS 0.6\n#define INJECTION_INTERVAL 0.1 //e.g. every 0.1 second: open the injection window\n\n#define INJECTION_WINDOW 0.8 // e.g. when injection occurs allow 80% of 0.1 second = 0.08 seconds of buffered waveforms to enter the envelope???\n\n#define PROPAGATION_RATE_FRAME 0.5 // coupled to frame rate?????  e.g. for 30fps, every 15 frames (50% of 30fps) = 15/30 fps -> propagation occurs every 0.5 seconds, i.e. ~2 times per second. propagate the injected waveforms upwards through the envelope snapshots\n\nfloat compute_normalized_sample_coordinate_for_downscaled_segment_in_1D(float segment_index, float sample_index) {\n    float sample_coordinate_on_1D_x_axis = segment_index * WAVEFORM_SAMPLES_PER_SEGMENT_F + sample_index + WAVEFORM_SEGMENT_CENTERING_OFFSET;\n    return sample_coordinate_on_1D_x_axis / WAVEFORM_SAMPLE_COUNT_F; \n}\n\nfloat sample_audio_texture_waveform_data(int segment_index) {\n    float accumulated_amplitude = 0.0;\n    for (int sample_index = 0; sample_index < WAVEFORM_SAMPLES_PER_SEGMENT; sample_index++) {\n        float segment_index_in_continious_space = float(segment_index);\n        float sample_index_in_continious_space = float(sample_index);\n        float normalized_sample_coordinate_for_downscaled_segment_in_1D = compute_normalized_sample_coordinate_for_downscaled_segment_in_1D(segment_index_in_continious_space, sample_index_in_continious_space);\n        vec2 sample_coordinates = vec2(normalized_sample_coordinate_for_downscaled_segment_in_1D, AUDIO_TEXTURE_WAVEFORM_ROW);\n        float amplitude_value_at_sample_coordinates = texture(iChannel1, sample_coordinates).r;\n        accumulated_amplitude += abs(amplitude_value_at_sample_coordinates);\n    }\n    return accumulated_amplitude / WAVEFORM_SAMPLES_PER_SEGMENT_F;\n}\n\nfloat propagate_envelope_injection_snapshot_upwards(vec2 uv, float y_shift) {\n    vec4 envelope_fragment = texture(iChannel0, uv + vec2(0.0, y_shift));\n    return envelope_fragment.r;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 uv = frag_coord.xy / iResolution.xy;\n    float uv_height_per_envelope_snapshot = 1.0 / float(NUMBER_OF_HISTORICAL_ENVELOPE_SNAPSHOTS);\n    if (uv.y < 1.0 - uv_height_per_envelope_snapshot) {\n        float envelope_fragment = propagate_envelope_injection_snapshot_upwards(uv, PROPAGATION_RATE_FRAME * uv_height_per_envelope_snapshot);\n        frag_color = vec4(envelope_fragment, UNUSED_FEEDBACK_CHANNEL, UNUSED_FEEDBACK_CHANNEL, UNUSED_FEEDBACK_CHANNEL);\n    } else {\n        float current_envelope = texture(iChannel0, uv).r;\n        float normalized_time_since_last_injection = fract(iTime / INJECTION_INTERVAL);\n        if (normalized_time_since_last_injection < INJECTION_WINDOW) {\n            int segment_index_in_discrete_space = int(floor(uv.x * DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS_F));\n            float next_envelope = sample_audio_texture_waveform_data(segment_index_in_discrete_space);\n            float injection_blend_intensity_coefficient = 1.0;\n            float t = normalized_time_since_last_injection / INJECTION_WINDOW;\n\n            float smooth_injection = 0.5 * (1.0 - cos(6.28318 * t)); //TODO: I dont like this, but it kind of helps with smoothing?\n            float effective_injection_blend = smooth_injection * injection_blend_intensity_coefficient * TARGET_BLEND_INTENSITY_BETWEEN_ENVELOPE_INJECTION_SNAPSHOTS;\n            float blended_envelope = mix(current_envelope, next_envelope, effective_injection_blend);\n            frag_color = vec4(blended_envelope, UNUSED_FEEDBACK_CHANNEL, UNUSED_FEEDBACK_CHANNEL, UNUSED_FEEDBACK_CHANNEL);\n        } else {\n            frag_color = vec4(current_envelope, UNUSED_FEEDBACK_CHANNEL, UNUSED_FEEDBACK_CHANNEL, UNUSED_FEEDBACK_CHANNEL);\n        }\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS 64\n#define DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS_F 64.\n#define NUMBER_OF_HISTORICAL_ENVELOPE_SNAPSHOTS 1\n#define AMPLITUDE_SCALE 200.0\n#define ISOMETRIC_ZOOM 6.0\n#define ROW_SPACING 8.0\n\nvec2 project_envelope(vec3 envelope_coordinate) {\n    float segment_index   = envelope_coordinate.x;\n    float envelope_value  = envelope_coordinate.y;\n    float history_row     = envelope_coordinate.z;\n    float effective_row   = history_row * ROW_SPACING;\n    float projected_x = segment_index - effective_row;\n    float projected_y = (segment_index + effective_row) * 0.5 - envelope_value * AMPLITUDE_SCALE;\n    return vec2(projected_x, projected_y) * ISOMETRIC_ZOOM;\n}\n\nvec2 compute_envelope_grid_center() {\n    vec2 projected_bottom_left  = project_envelope(vec3(0.0, 0.0, 0.0));\n    vec2 projected_bottom_right = project_envelope(vec3(float(DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS - 1), 0.0, 0.0));\n    vec2 projected_top_left     = project_envelope(vec3(0.0, 1.0, float(NUMBER_OF_HISTORICAL_ENVELOPE_SNAPSHOTS - 1)));\n    vec2 projected_top_right    = project_envelope(vec3(float(DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS - 1), 1.0, float(NUMBER_OF_HISTORICAL_ENVELOPE_SNAPSHOTS - 1)));\n\n    vec2 minimum_corner = min(min(projected_bottom_left, projected_bottom_right),\n                              min(projected_top_left, projected_top_right));\n    vec2 maximum_corner = max(max(projected_bottom_left, projected_bottom_right),\n                              max(projected_top_left, projected_top_right));\n    return (minimum_corner + maximum_corner) * 0.5;\n}\n\nfloat distance_to_line(vec2 pixel_coordinate, vec2 line_start, vec2 line_end) {\n    vec2 line_vector = line_end - line_start;\n    float line_length_squared = dot(line_vector, line_vector);\n    float projection_factor = dot(pixel_coordinate - line_start, line_vector) / line_length_squared;\n    float clamped_projection_factor = clamp(projection_factor, 0.0, 1.0);\n    vec2 closest_point = line_start + clamped_projection_factor * line_vector;\n    return distance(pixel_coordinate, closest_point);\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#define LINE_RENDER_WIDTH 0.75\n#define LINE_RENDER_MARGIN (LINE_RENDER_WIDTH * 2.0) // amount of thickness (in fragment size/single pixel) that surrounds both sides of the wave signal lines\n#define MAX_DISTANCE 1e6 // some stupid number to just initialize the min distance to closest wave signal logic\n\n#define WHITE vec4(1.0, 1.0, 1.0, 1.0)\n#define BLACK vec4(0.0, 0.0, 0.0, 1.0)\n\n\nfloat get_envelope_from_buffer(int history_row, int segment_index) {\n    float texture_v = 1.0 - (float(history_row) + 0.5) / float(NUMBER_OF_HISTORICAL_ENVELOPE_SNAPSHOTS);\n    float texture_u = (float(segment_index) + 0.5) / float(DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS);\n    return texture(iChannel0, vec2(texture_u, texture_v)).r;\n}\n\nvec2 project_centered_envelope(vec3 envelope_coordinate) {\n    vec2 raw_projected_coordinate = project_envelope(envelope_coordinate);\n    vec2 grid_center = compute_envelope_grid_center();\n    vec2 screen_center = iResolution.xy * 0.5;\n    return raw_projected_coordinate + (screen_center - grid_center);\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    float closest_distance = MAX_DISTANCE;\n   // for (int history_row = 0; history_row < NUMBER_OF_HISTORICAL_ENVELOPE_SNAPSHOTS; history_row++) {\n        for (int segment_index = 0; segment_index < DOWNSCALED_TARGET_NUMBER_OF_WAVEFORM_SEGMENTS - 1; segment_index++) {\n            float envelope_left = get_envelope_from_buffer(0, segment_index);\n            float envelope_right = get_envelope_from_buffer(0, segment_index + 1);\n\n            vec3 envelope_coordinate_left = vec3(float(segment_index), envelope_left, 0.);\n            vec3 envelope_coordinate_right = vec3(float(segment_index + 1), envelope_right, 0.);\n\n            vec2 screen_position_left = project_centered_envelope(envelope_coordinate_left);\n            vec2 screen_position_right = project_centered_envelope(envelope_coordinate_right);\n\n            float distance_to_wave_line = distance_to_line(frag_coord.xy, screen_position_left, screen_position_right);\n            closest_distance = min(closest_distance, distance_to_wave_line);\n        }\n   // }\n\n    float intensity = 1.0 - smoothstep(LINE_RENDER_WIDTH, LINE_RENDER_MARGIN, closest_distance);\n    vec3 oldb = texture(iChannel1, (frag_coord+vec2(30., -20.))/iResolution.xy, 0.).rgb;\n    frag_color = vec4(oldb+vec3(intensity), 1.0);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "w3j3z3",
    "date": "0",
    "viewed": 0,
    "name": "Drawing for porcelain",
    "description": "the 2d buffer for the bp shader",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "2d",
     "shapes",
     "porcelain"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// todo: implement sweep amt\nvec2 mouse;\n\n////////////////////////////////////////////////////////////////\n// BOILERPLATE UTILITIES...................\nconst float pi = 3.14159;\nconst float pi2 = pi * 2.;\n\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\nfloat opI( float d1, float d2) { return max(d1,d2); }\n\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\nfloat nsin(float a){return .5+.5*sin(a);}\nfloat ncos(float a){return .5+.5*cos(a);}\n\nfloat dtoa(float d, float amount)\n{\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n}\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n    vec2 d = max(tl-uv, uv-br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\n{\n    return length(uv - origin) - radius;\n}\n// 0-1 1-0\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\n{\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\n}\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n// returns -.5 to 1.5. i think.\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\t\n}\nfloat noise01(vec2 p)\n{\n    return clamp((noise(p)+.5)*.5, 0.,1.);\n}\n// debug function to convert distance to color, revealing sign.\nvec3 dtocolor(vec3 inpColor, float dist)\n{\n    vec3 ret;\n    if(dist > 0.)\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\n    else\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\n    return ret;\n}\n\nfloat smoothf(float x)\n{\n    return x*x*x*(x*(x*9. - 17.5) + 10.0);\n}\n\n////////////////////////////////////////////////////////////////\n// APP CODE ...................\n\n// this function will produce a line with brush strokes. the inputs are such\n// that you can apply it to pretty much any line; the geometry is separated from this function.\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\n{\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\n\n    // warp the position-in-line, to control the curve of the brush falloff.\n    if(posInLineY > 0.)\n    {\n        float mouseX = 200. == 0. ? 0.2 : (200. / iResolution.x);\n\t   posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\n        //posInLineY = pow(posInLineY, (pow(200.,2.) * 15.) + 1.5);\n        \n    }\n\n    // brush stroke fibers effect.\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\n    float strokeTexture = 0.\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\n        ;\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\n    // fade out the end of the stroke by shifting the noise curve below 0\n    const float strokeAlphaBoost = 1.09;\n    if(posInLineY > 0.)\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.8));// fade out\n    else\n        strokeAlpha *= strokeAlphaBoost;\n\n    strokeAlpha = smoothf(strokeAlpha);\n    \n    // paper bleed effect.\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\n paperBleedAmt = 400.;// disable paper bleed    \n    \n    // blotches (per stroke)\n    //float blotchAmt = smoothstep(2.,28.5,magicBox(vec3(uvPaper, uvLine.x)));\n    //blotchAmt *= (strokeAlpha+0.1);\n    //strokeAlpha += blotchAmt;\n\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\n    alpha = clamp(alpha, 0.,1.);\n    return mix(inpColor, brushColor.rgb, alpha);\n}\n\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\n{\n    // flatten the line to be axis-aligned.\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\n    mat2 rotMat = rot2D(lineAngle);\n\n    float lineLength = distance(p2_, p1_);\n    // make an axis-aligned line from this line.\n    vec2 tl = (p1_ * rotMat);// top left\n    vec2 br = tl + vec2(0,lineLength);// bottom right\n    vec2 uvLine = uv * rotMat;\n\n    // make line slightly narrower at end.\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\n    \n    // wobble it around, humanize\n    float res = min(iResolution.y,iResolution.x);\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\n    uvLine = tl - uvLine;\n    \n    vec2 lineSize = vec2(lineWidth, lineLength);\n    \n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\n                                d, inpColor, brushColor);\n    return ret;\n}\n\n// returns:\n// xy = uvLine\n// z = radius\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\n{\n    vec2 humanizedUVLine = uvLine;\n    \n\t// offsetting the circle along its path creates a twisting effect.\n    float twistAmt = .24;\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\n    humanizedUVLine.x += linePosY * twistAmt;\n    \n    // perturb radius / x\n    float humanizedRadius = radius_;\n    float res = min(iResolution.y,iResolution.x);\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n    \n    return vec3(humanizedUVLine, humanizedRadius);\n}\n\n// there's something about calling an Enso a \"donut\" that makes me giggle.\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\n{\n\tvec2 uvLine = uv - o;\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\n    angle = mod(angle-angleStart+pi, pi2);\n    if(!clockwise)\n        angle = pi2 - angle;\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\n    uvLine = vec2(\n        radius_ - length(uvLine),\n        angle / pi2 * lineLength\n    );\n    \n    // make line slightly narrower at end.\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\n    \n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n    vec2 humanizedUVLine = hu.xy;\n    float humanizedRadius = hu.z;\n\n    float d = opS(sdCircle(uv, o, humanizedRadius),\n                  sdCircle(uv, o, humanizedRadius));\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\n\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\n    \n    // do the same but for before the beginning of the line. distance field is just a single point\n    vec3 ret2 = vec3(1);\n    if(angle > pi)\n    {\n        uvLine.y -= lineLength;\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n        humanizedUVLine = hu.xy;\n        humanizedRadius = hu.z;\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\n        d = distance(uv, strokeStartPos);\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\n\t}\n    return min(ret, ret2);\n}\n\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\n{\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\n    ret *= newSize;// scale up to new dimensions\n    float aspect = iResolution.x / iResolution.y;\n    ret.x *= aspect;// orig aspect ratio\n    float newWidth = newSize.x * aspect;\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\n}\n// Blue Porcelain specific code below\nfloat lips(vec2 a , vec2 b, float h, vec2 p){\n    float col = 0.;\n    if(p.x>a.x && p.x<b.x){col = 1.;}\n    float sc = 1./h/(b.x-a.x);\n    float bottom = (a.y - sin((a.x-p.x)/(b.x-a.x)*3.1416)/(sc*2.7)) - p.y;\n    //float f = smoothstep(-1.0, 1000.5, bottom);col = mix(1.,0.5, f);\n    if(col==1. && bottom>0.) {col =1.0;} else {col = 0.;}\n    //col=bottom;\n    float dist = (b.x-a.x)/4.5;\n    a.x+=dist;b.x-=dist;\n    if(col==1. && p.y>(a.y + sin((a.x-p.x)/(b.x-a.x)*9.423)/(sc*20.))) {col = 1.;} else {col = 0.;}\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(1);\n    vec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));\n    // Caching output - if we're on the first frame or the resolution has changed, draw everything.\n    if(iFrame<2 || texelFetch(iChannel0, ivec2(0), 0).r != iResolution.x){\n\n        vec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));\n        float yo = sin(-uv.x*pi*0.5)*0.2;\n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.03,.5),1.),vec2(0.4, -0.35+yo ),vec2(0.25, 0.12+yo), 0.05);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.1, -0.24 ),vec2(0.9, -0.6), 0.01);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.1, -0.1 + (sin((uv.x+0.1) * 25.) * 0.03)),vec2(0.85, -0.6), 0.01);                    \n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.09, -0.12 ),vec2(0.13, -0.17 ), 0.001);\n              \n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.1, -0.24 ),vec2(-0.9, -0.6), 0.02);\n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.1, -0.1 - (sin((uv.x+0.1) * 25.) * 0.03)),vec2(-0.85, -0.5), 0.01);                    \n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.09, -0.12),vec2(-0.13, -0.17 ), 0.001);\n//col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.4),vec2(0.32, .245+yo),vec2(0.2, .205+yo), 0.002);\n        vec2 sps = vec2(0.25,-0.01);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,4.0,6.6,0.0001,true);\n        sps+=vec2(-0.015,-0.015);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,3.0,1.6,0.03,true);\n        sps+=vec2(0.07,0.07);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,5.0,6.6,0.0001,true);\n        sps+=vec2(0.015,-0.0);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,3.0,1.6,0.03,true);\n        \n       sps = vec2(-0.18,0.12);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,1.0,6.6,0.0001,true);\n        sps+=vec2(-0.01,-0.015);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,-3.0,1.6,0.02,true);\n        sps+=vec2(0.05,0.05);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,1.0,6.6,0.0001,true);\n        sps+=vec2(0.01,-0.015);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,-3.0,1.6,0.02,true);\n        //col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,0.0,0.3,0.0002,true);\n        //col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.09,0.0,0.3,0.0002,true);\n        //col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.12,0.0,0.3,0.0002,true);\n\n       // if(lips(vec2(0.27, 0.14), vec2(0.385, 0.15), 0.8, uv)>0.){col = vec3(.0,.1,.7);}\n       float lp = lips(vec2(-0.12, 0.13), vec2(0.12, 0.13), 0.9, uv);\n        if(lp>0.){col = vec3(.0,.1,.7)*lp;}\n        \n        \n        //col = colorBrushStroke(vec2(0.1,0.1), vec2(0.1,0.1), vec2(0.1,0.1), sdCircle(uv, vec2(0.1,0.1), 0.1), vec3(1,0,0), vec4(0,1,0,1));\n        \n        if(ivec2(fragCoord.xy) == ivec2(0)){ col.r = iResolution.x;}// Store resolution in 0,0 pixel\n    } else {\n       // We've already drawn everything, use buffer instead\n       col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n       \n\n       \n   }\n   \n   if(distance(uv, vec2(-0.2, -0.12))<0.25){\n    vec4 roses = texture(iChannel0, (uv/2.)+0.5);\n    if(roses.r>0.3){\n        roses.g=0.1; roses.b=0.1;roses.r*=1.5;\n    } else if(roses.r>0.15&&distance(uv, vec2(-0.2, -0.12))<0.2){\n        roses.g=0.1; roses.r=0.1;roses.b=0.5;\n    } else {roses = vec4(col,1.);}\n    col =  roses.rgb;\n}\n       \n    fragColor = vec4(col, 1.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "\nfloat magicBox(vec3 p) {\n    const int MAGIC_BOX_ITERS = 13;\n    const float MAGIC_BOX_MAGIC = 0.55;\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\nfloat magicBox(vec2 uv){\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n    // volume along the same axes as the fractal's bounding box.\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    return magicBox(p);\n}\n\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Bottomless depth https://www.shadertoy.com/view/tsBXRh\n// Exploring procedural painting\n// Licensed under hippie love conspiracy\n// Leon Denise (ponk) 2019.03.17\n// Using code from:\n// Inigo Quilez (shadertoy.com/view/Xds3zN)\n// Morgan McGuire (shadertoy.com/view/4dS3Wd)\n\nconst float zoomSpeed = 0.05;\nconst float noiseScale = 4.;\nconst float noiseSpeed = 0.0;\n\nconst float PI = 3.1415;\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\nfloat fbm (vec3 p) {\n  float amplitude = .5;\n  float result = 0.0;\n  for (float index = 0.0; index <= 5.0; ++index) {\n    result += noise(p / amplitude) * amplitude;\n    amplitude /= 2.;\n  }\n  return result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 color = vec3(1);\n  float timeline = iTime*zoomSpeed;\n  vec2 unit = 1./iResolution.xy;\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  vec2 p = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  float stage = floor(timeline);\n  float ratio = fract(timeline);\n  const float iterations = 3.;\n  float spawn = 1.;\n  float zoom = .5;\n  float scale = noiseScale * iResolution.y / 320.;\n  for (float index = iterations; index > 0.; --index) {\n    ratio = mod(ratio+1./iterations, 1.);\n    vec3 s = vec3(p*scale*(zoom-ratio*zoom), 1. + timeline*noiseSpeed);\n    float salty = fbm(s) * 2. - 1.;\n    float angle = salty * PI * 8.;\n    uv += vec2(cos(angle),sin(angle)) * unit * sin(ratio*PI);\n    spawn *= 1. - abs(sin(angle)) * sin(ratio*PI);\n  }\n  color *= spawn;\n  float blend = (.5+.5*(1.-spawn));\n  fragColor = texture(iChannel0, uv)*blend + (1.-blend)*vec4(color, 1);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "w3j3WV",
    "date": "1744583629",
    "viewed": 2,
    "name": "Fork of Bezier quadratic AA",
    "description": "Implementation of the Loop/Blinn quadratic Bezier curve rendering algorithm using barycentric coordinates to simulate the vertex interpolation stage. Click and drag to control the center point. Antialiasing applied to the curve only",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "bezier",
     "curve",
     "vector",
     "quadratic"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Bezier quadratic (Loop/Blinn)\" by mrboggieman. https://shadertoy.com/view/flG3Rt\n// 2025-04-13 22:32:17\n\n/**\n* An example of rendering quadratic beziers via interpolation\n* Not efficient doing the whole thing in a fragment shader, just for demo purposes\n* \n* Barycentric code based on https://www.shadertoy.com/view/lsl3Wn by nuclear \n* Technique based on the Charles Loop and Jim Blinn solution from:\n* https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-25-rendering-vector-art-gpu\n*/\n\nfloat circleDist = 3.0;\nfloat EPSILON = 0.00001;\nvec3 normal = vec3(0.0, 0.0, 1.0);\n\nvec4 white = vec4(1.0, 1.0, 1.0, 1.0); //rgba\nvec4 black = vec4(0.0, 0.0, 0.0, 1.0);\nvec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\n\n//interpolants at each triangle coord\nvec2 d = vec2(0.0, 0.0);\nvec2 e = vec2(0.5, 0.0);\nvec2 f = vec2(1.0, 1.0);\n\n//utils\nvec3 barycentric(in vec3 v0, in vec3 v1, in vec3 v2, in vec3 p, in vec3 normal)\n{\n\tfloat area = dot(cross(v1 - v0, v2 - v0), normal);\n\n\tif(abs(area) < EPSILON) {\n\t\treturn vec3(0.0, 0.0, 0.0);\n\t}\n\n\tvec3 pv0 = v0 - p;\n\tvec3 pv1 = v1 - p;\n\tvec3 pv2 = v2 - p;\n\t\n\tvec3 asub = vec3(dot(cross(pv1, pv2), normal),\n\t\t\t\t\t dot(cross(pv2, pv0), normal),\n\t\t\t\t\t dot(cross(pv0, pv1), normal));\n\treturn abs(asub) / abs(area);\n}\n\n//start\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 fragPos = vec3(fragCoord, 0.0);\n    \n    //triangle\n    vec3 a = vec3(200.0, 200.0, 0.0);\n    vec3 b = vec3(300.0, 50.0, 0.0);\n    vec3 c = vec3(500.0, 200.0, 0.0);\n    \n    //draw triangle points\n    float insidePoint = step(circleDist, length(fragPos - a));\n    insidePoint *= step(circleDist, length(fragPos - b));\n    insidePoint *= step(circleDist, length(fragPos - c));\n    \n    if (insidePoint < EPSILON) {\n        fragColor = black;\n        return;\n    }\n    \n    //barycentric coords in the triangle for using as weights\n    vec3 bary = barycentric(a, b, c, fragPos, normal);\n    \n    float baryLength = bary.x + bary.y + bary.z;\n    if (baryLength < EPSILON || baryLength - EPSILON > 1.0) {\n        //outside triangle\n        fragColor = white;\n        return;\n    }\n    \n    //interpolation\n    vec2 uv = (d * bary.x) + (e * bary.y) + (f * bary.z);\n    \n    //antialiasing using derivatives\n    vec2 px = dFdx(uv);   \n    vec2 py = dFdy(uv);   \n\n    //chain rule    \n    float fx = (2.0*uv.x)*px.x - px.y;   \n    float fy = (2.0*uv.x)*py.x - py.y;   \n\n    //signed distance  \n    float sd = (uv.x*uv.x - uv.y) / sqrt(fx*fx + fy*fy); \n    float alpha = (iMouse.x-iResolution.x/2.)/(iResolution.x/5.) - sd;\n    \n    if (alpha < 0.0) {\n        fragColor = blue;\n        return;\n    }\n    \n    fragColor = mix(blue, white, alpha);\n    return;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "w3sXz8",
    "date": "0",
    "viewed": 0,
    "name": "Forked lightning experiment",
    "description": "Seeing if this attempt at lightning works...",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "chaos",
     "phyics",
     "rwm"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 color, in vec2 coord) {\n    color = texelFetch(iChannel0, ivec2(coord), 0);\n    color.a = 1.0;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Fork of \"ColorRWM\" by jlindermeir. https://shadertoy.com/view/tXXSRr\n// Real random wave model with phase-based coloring.\n// 2025-04-17 01:13:11\n\nfloat h(float p){return fract(sin(p*11.3158)*45413. + (iTime/1000.));}\nvec2 rd(float s){float a=s*6.28318530718;return vec2(cos(a),sin(a));}\nvec3 h2r(vec3 c){vec3 r=clamp(abs(mod(c.x*6.0+vec3(0,4,2),6.0)-3.0)-1.0,0.0,1.0);return c.z*mix(vec3(1),r,c.y);}\nvoid mainImage(out vec4 o,in vec2 f){\n  float k=200.0*(cos(1.0/15.0*6.28318530718)+1.1),om=3.0,s=0.0;\n  vec2 uv=f/iResolution.xy,p=(uv-0.5)*2.0; p.x*=iResolution.x/iResolution.y; vec2 si=vec2(0);\n  int n=100;float sd=h(1337.0);\n  for(int i=0;i<n;i++){\n    sd=h(float(i));\n    vec2 d=rd(sd),kv=d*k;\n    float ph=h(float(i)+1337.0),tp=dot(p,kv)+om*(iTime/1000.)+ph*6.28318530718;\n    s+=cos(tp),si+=vec2(cos(tp),sin(tp));\n  }\n  s*=s*0.4;\n  float ha=atan(si.y,si.x),hu=(ha+3.14159265)/(6.28318530718),v=(s/float(n))*0.5,sa=2.0*abs(v-1.0);\n  o=vec4(h2r(vec3(hu,sa,v)),1.0);\n  \n  vec4 color = texelFetch(iChannel0, ivec2(f), 0);\n  o=o+(color/3.1);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WXfXWj",
    "date": "0",
    "viewed": 0,
    "name": "Blue Porcelain v3",
    "description": "Trying to recreate https://arthur.io/art/bao-pham/blue-porcelain with SDFs and raymarching\nVersion 2. I think this is as close as I can get.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "sdf",
     "painting",
     "face",
     "brush",
     "human",
     "china",
     "reproduction",
     "anatomy",
     "woman",
     "porcelain",
     "asian",
     "vietnamese"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Blue Porcelain v2\" by Cotterzz. https://shadertoy.com/view/3XS3RV\n// 2025-04-24 08:41:19\n\n// Fork of \"Blue Porcelain\" by Cotterzz. https://shadertoy.com/view/W3XGWS\n// 2025-04-10 04:23:43\n\n// This is my first attempt at using SDFs and raymarching\n// It's a bit ambitious, and is still very much a work in progress.\n// There's lots more I want to do with it, but I have some tidying and optimisation to look into before I take it any further.\n// --\n// Based on/inspired by Bao Pham's painting 'Blue Porcelain' https://arthur.io/art/bao-pham/blue-porcelain\n// Uses code and functions from the following shaders:\n// \"Bottomless depth\" by leon       https://www.shadertoy.com/view/tsBXRh\n// \"Capped torus - distance\" by iq. https://www.shadertoy.com/view/tl23RK\n// \"Elongation SDF\" by iq.          https://www.shadertoy.com/view/Ml3fWj\n// \"Vesica Segment\" by iq.          https://www.shadertoy.com/view/Ds2czG\n// \"Brush Experiment 3\" by 104      https://www.shadertoy.com/view/ltj3Wc\n// \"Magic Fractal\" by dgreensp      https://www.shadertoy.com/view/4ljGDd\n// --\n// 2025-03-31 04:38:41\n// Copyright/licensing of forked code belongs to respective artists/authors.\n// Everything else assembled here is the work of John Cotterell johnmdcotterell@gmail.com\n// and cannot be use outside shadertoy without permission.\n\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// trying to resemble watercolors\n\n// Turns color to water color\nvec3 getWaterColor(vec3 color) {\n    // Makes so each channel of the color has definition of \"bands\" (instead of normal color definition of 256)  \n    const float bands = 6.0;\n    vec3 col = round(color * bands) / bands;\n    // \"length(col)\" make brightness of \"color\" limited, since \"col\" has limited definition and we are grabbing brightness from that\n    // While \"normalize(color)\" get's only color, which has normal definition\n    // So multiplying length(col) with normalize(color) gives color which has low definition brightness but high definition color\n    // Making it look similar to watercolor painting\n    // Then it interpolates normal color with this constrained color to add a bit of detail\n    return mix(color, length(col) * normalize(color), 0.7);\n}\n\n// get's random number for 2D coordinate\nfloat rand(vec2 uv) {\n\treturn fract(sin(dot(vec2(12.9898,78.233), uv)) * 43758.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Split's screen in 2 parts for comparision\n    if(uv.x >= 0.5) // watercolored texture color\n    {\n        // this adds some randomness to the uv, making it look grainy        \n        vec2 ruv = clamp(uv + (vec2(rand(uv), rand(uv + vec2(13.61, -21.35))) * 2.0 - 1.0) / iResolution.xy * 2., vec2(0), vec2(1));\n        // mixing between grainy and smooth texture\n        vec3 t = mix(textureLod(iChannel0, ruv, 2.0).rgb, textureLod(iChannel0, uv, 2.0).rgb, 0.5);\n        fragColor.rgb = getWaterColor(t);\n    }\n    else // normal texture color\n    {\n        fragColor.rgb = texture(iChannel0, uv).rgb;\n    }\n    \n    // middle line in split screen\n    float d = abs(uv.x - 0.5) / 0.005;\n    if(d < 1.0) \n    {\n        // Added smoothstep interpolation to make middle line look smoother\n        fragColor.rgb = mix(vec3(0), fragColor.rgb, smoothstep(0.0, 1.0, d * d));\n    }\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// todo: implement sweep amt\nvec2 mouse;\n\n////////////////////////////////////////////////////////////////\n// BOILERPLATE UTILITIES...................\nconst float pi = 3.14159;\nconst float pi2 = pi * 2.;\n\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\nfloat opI( float d1, float d2) { return max(d1,d2); }\n\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\nfloat nsin(float a){return .5+.5*sin(a);}\nfloat ncos(float a){return .5+.5*cos(a);}\n\nfloat dtoa(float d, float amount)\n{\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n}\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n    vec2 d = max(tl-uv, uv-br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\n{\n    return length(uv - origin) - radius;\n}\n// 0-1 1-0\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\n{\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\n}\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n// returns -.5 to 1.5. i think.\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\t\n}\nfloat noise01(vec2 p)\n{\n    return clamp((noise(p)+.5)*.5, 0.,1.);\n}\n// debug function to convert distance to color, revealing sign.\nvec3 dtocolor(vec3 inpColor, float dist)\n{\n    vec3 ret;\n    if(dist > 0.)\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\n    else\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\n    return ret;\n}\n\nfloat smoothf(float x)\n{\n    return x*x*x*(x*(x*6. - 15.) + 10.);\n}\n\n////////////////////////////////////////////////////////////////\n// APP CODE ...................\n\n// this function will produce a line with brush strokes. the inputs are such\n// that you can apply it to pretty much any line; the geometry is separated from this function.\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\n{\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\n\n    if(iMouse.z > 0.)\n    {\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\n    \tfloat okthen = 42.;// NOP\n    }\n    \n    // warp the position-in-line, to control the curve of the brush falloff.\n    if(posInLineY > 0.)\n    {\n        float mouseX = 200. == 0. ? 0.2 : (200. / iResolution.x);\n\t   posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\n        //posInLineY = pow(posInLineY, (pow(200.,2.) * 15.) + 1.5);\n        \n    }\n\n    // brush stroke fibers effect.\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\n    float strokeTexture = 0.\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\n        ;\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\n    // fade out the end of the stroke by shifting the noise curve below 0\n    const float strokeAlphaBoost = 1.09;\n    if(posInLineY > 0.)\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.8));// fade out\n    else\n        strokeAlpha *= strokeAlphaBoost;\n\n    strokeAlpha = smoothf(strokeAlpha);\n    \n    // paper bleed effect.\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\n paperBleedAmt = 400.;// disable paper bleed    \n    \n    // blotches (per stroke)\n    //float blotchAmt = smoothstep(2.,28.5,magicBox(vec3(uvPaper, uvLine.x)));\n    //blotchAmt *= (strokeAlpha+0.1);\n    //strokeAlpha += blotchAmt;\n\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\n    alpha = clamp(alpha, 0.,1.);\n    return mix(inpColor, brushColor.rgb, alpha);\n}\n\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\n{\n    // flatten the line to be axis-aligned.\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\n    mat2 rotMat = rot2D(lineAngle);\n\n    float lineLength = distance(p2_, p1_);\n    // make an axis-aligned line from this line.\n    vec2 tl = (p1_ * rotMat);// top left\n    vec2 br = tl + vec2(0,lineLength);// bottom right\n    vec2 uvLine = uv * rotMat;\n\n    // make line slightly narrower at end.\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\n    \n    // wobble it around, humanize\n    float res = min(iResolution.y,iResolution.x);\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\n    uvLine = tl - uvLine;\n    \n    vec2 lineSize = vec2(lineWidth, lineLength);\n    \n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\n                                d, inpColor, brushColor);\n    return ret;\n}\n\n// returns:\n// xy = uvLine\n// z = radius\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\n{\n    vec2 humanizedUVLine = uvLine;\n    \n\t// offsetting the circle along its path creates a twisting effect.\n    float twistAmt = .24;\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\n    humanizedUVLine.x += linePosY * twistAmt;\n    \n    // perturb radius / x\n    float humanizedRadius = radius_;\n    float res = min(iResolution.y,iResolution.x);\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n    \n    return vec3(humanizedUVLine, humanizedRadius);\n}\n\n// there's something about calling an Enso a \"donut\" that makes me giggle.\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\n{\n\tvec2 uvLine = uv - o;\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\n    angle = mod(angle-angleStart+pi, pi2);\n    if(!clockwise)\n        angle = pi2 - angle;\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\n    uvLine = vec2(\n        radius_ - length(uvLine),\n        angle / pi2 * lineLength\n    );\n    \n    // make line slightly narrower at end.\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\n    \n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n    vec2 humanizedUVLine = hu.xy;\n    float humanizedRadius = hu.z;\n\n    float d = opS(sdCircle(uv, o, humanizedRadius),\n                  sdCircle(uv, o, humanizedRadius));\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\n\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\n    \n    // do the same but for before the beginning of the line. distance field is just a single point\n    vec3 ret2 = vec3(1);\n    if(angle > pi)\n    {\n        uvLine.y -= lineLength;\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n        humanizedUVLine = hu.xy;\n        humanizedRadius = hu.z;\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\n        d = distance(uv, strokeStartPos);\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\n\t}\n    return min(ret, ret2);\n}\n\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\n{\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\n    ret *= newSize;// scale up to new dimensions\n    float aspect = iResolution.x / iResolution.y;\n    ret.x *= aspect;// orig aspect ratio\n    float newWidth = newSize.x * aspect;\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\n}\n\n// Blue Porcelain specific code below\nfloat lips(vec2 a , vec2 b, float h, vec2 p){\n    float col = 0.;\n    if(p.x>a.x && p.x<b.x){col = 1.;}\n    float sc = 1./h/(b.x-a.x);\n    float bottom = (a.y - sin((a.x-p.x)/(b.x-a.x)*3.1416)/(sc*2.7)) - p.y;\n    //float f = smoothstep(-1.0, 1000.5, bottom);col = mix(1.,0.5, f);\n    if(col==1. && bottom>0.) {col =1.0;} else {col = 0.;}\n    //col=bottom;\n    float dist = (b.x-a.x)/4.5;\n    a.x+=dist;b.x-=dist;\n    if(col==1. && p.y>(a.y + sin((a.x-p.x)/(b.x-a.x)*9.423)/(sc*20.))) {col = 1.;} else {col = 0.;}\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(1);\n    vec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));\n    // Caching output - if we're on the first frame or the resolution has changed, draw everything.\n    uv.y-=0.5;\n    if(iFrame<2 || texelFetch(iChannel0, ivec2(0), 0).r != iResolution.x){\n\n        \n        float yo = sin(-uv.x*pi*0.5)*0.2;\n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.03,.5),1.),vec2(0.4, -0.35+yo ),vec2(0.25, 0.12+yo), 0.05);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.1, -0.24 ),vec2(0.9, -0.6), 0.01);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.1, -0.1 + (sin((uv.x+0.1) * 25.) * 0.03)),vec2(0.85, -0.6), 0.01);                    \n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.09, -0.12 ),vec2(0.13, -0.17 ), 0.001);\n              \n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.1, -0.24 ),vec2(-0.9, -0.6), 0.02);\n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.1, -0.1 - (sin((uv.x+0.1) * 25.) * 0.03)),vec2(-0.85, -0.5), 0.01);                    \n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.09, -0.12),vec2(-0.13, -0.17 ), 0.001);\n//col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.4),vec2(0.32, .245+yo),vec2(0.2, .205+yo), 0.002);\n        vec2 sps = vec2(0.25,-0.01);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,4.0,6.6,0.0001,true);\n        sps+=vec2(-0.015,-0.015);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,3.0,1.6,0.03,true);\n        sps+=vec2(0.07,0.07);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,5.0,6.6,0.0001,true);\n        sps+=vec2(0.015,-0.0);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,3.0,1.6,0.03,true);\n        \n        sps = vec2(-0.18,0.12);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,1.0,6.6,0.0001,true);\n        sps+=vec2(-0.01,-0.015);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,-3.0,1.6,0.02,true);\n        sps+=vec2(0.05,0.05);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,1.0,6.6,0.0001,true);\n        sps+=vec2(0.01,-0.015);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,-3.0,1.6,0.02,true);\n//colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\n        sps = vec2(-0.23,-0.3);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.3,6.3,5.1,0.02,false);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.2,6.3,5.1,0.02,false);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.15,6.3,5.1,0.015,false);\n        sps+=vec2(-0.05,0.03);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.2,6.3,5.1,0.04,false);\n        //col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.25,6.3,5.1,0.04,false);\n        \n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.24, 0.15 + (sin((uv.x+0.1) * 25.) * 0.06)),vec2(-1.3, -1.3), 0.07);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.2, -0.2 + (sin((uv.x+0.1) * 25.) * 0.06)),vec2(-1.3, -1.0), 0.04);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.25 + sin(uv.y * 25.) * 0.03, -0.0 - (sin(uv.x * 15.) * 0.04)),vec2(0.8, -2.5), 0.03);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.55 + sin(uv.y * 25.) * 0.03, -0.4 - (sin(uv.x * 15.) * 0.04)),vec2(0.8, -2.), 0.06);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.55 + sin(uv.y * 25.) * 0.07, -0.4 - (sin(uv.x * 15.) * 0.06)),vec2(-0.8, -2.), 0.05);\n         col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.4 + sin(uv.y * 25.) * 0.07, -0.1 - (sin(uv.x * 15.) * 0.06)),vec2(1.2, -1.5), 0.06);    \n         col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.0 + sin(uv.y * 25.) * 0.07, -0.9 - (sin(uv.x * 15.) * 0.06)),vec2(0.0, -1.9), 0.12);    \n\ncol = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.0, -0.44),0.44,-2.,5.1,0.06,false);\n        \n        //col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.09,0.0,0.3,0.0002,true);\n        //col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.12,0.0,0.3,0.0002,true);\n\n       // if(lips(vec2(0.27, 0.14), vec2(0.385, 0.15), 0.8, uv)>0.){col = vec3(.0,.1,.7);}\n       float lp = lips(vec2(-0.12, 0.13), vec2(0.12, 0.13), 0.9, uv);\n        if(lp>0.){col = vec3(.0,.1,.7)*lp;}\n\n        \n        //col = colorBrushStroke(vec2(0.1,0.1), vec2(0.1,0.1), vec2(0.1,0.1), sdCircle(uv, vec2(0.1,0.1), 0.1), vec3(1,0,0), vec4(0,1,0,1));\n        \n        if(ivec2(fragCoord.xy) == ivec2(0)){ col.r = iResolution.x;}// Store resolution in 0,0 pixel\n    } else {\n       // We've already drawn everything, use buffer instead\n      col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n  }\n   \n\n\n       \n\n    fragColor = vec4(col, 1.);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "\nfloat magicBox(vec3 p) {\n    const int MAGIC_BOX_ITERS = 13;\n    const float MAGIC_BOX_MAGIC = 0.55;\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\nfloat magicBox(vec2 uv){\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n    // volume along the same axes as the fractal's bounding box.\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    return magicBox(p);\n}\n\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\n\n\n\nfloat sdSphere( in vec3 p, in float r)\n{\n    return length(p)-r;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat dot2(in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    return -opSmoothUnion(d1,-d2,k);\n    \n    //float h = max(k-abs(-d1-d2),0.0);\n    //return max(-d1, d2) + h*h*0.25/k;\n}\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    //vec3 q = abs(p)-h;\n    //return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n// Euclidean distance to a capped torus\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdVerticalVesicaSegment( in vec3 p, in float h, in float w )\n{\n    // shape constants\n    h *= 0.5;\n    w *= 0.5;\n    float d = 0.5*(h*h-w*w)/w;\n    \n    // project to 2D\n    vec2  q = vec2(length(p.xz), abs(p.y-h));\n    \n    // feature selection (vertex or body)\n    vec3  t = (h*q.x < d*(q.y-h)) ? vec3(0.0,h,0.0) : vec3(-d,0.0,d+w);\n    \n    // distance\n    return length(q-t.xy) - t.z;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Bottomless depth https://www.shadertoy.com/view/tsBXRh\n// Exploring procedural painting\n// Licensed under hippie love conspiracy\n// Leon Denise (ponk) 2019.03.17\n// Using code from:\n// Inigo Quilez (shadertoy.com/view/Xds3zN)\n// Morgan McGuire (shadertoy.com/view/4dS3Wd)\n\nconst float zoomSpeed = 0.05;\nconst float noiseScale = 4.;\nconst float noiseSpeed = 0.0;\n\nconst float PI = 3.1415;\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\nfloat fbm (vec3 p) {\n  float amplitude = .5;\n  float result = 0.0;\n  for (float index = 0.0; index <= 5.0; ++index) {\n    result += noise(p / amplitude) * amplitude;\n    amplitude /= 2.;\n  }\n  return result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 color = vec3(1);\n  float timeline = iTime*zoomSpeed;\n  vec2 unit = 1./iResolution.xy;\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  vec2 p = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  float stage = floor(timeline);\n  float ratio = fract(timeline);\n  const float iterations = 3.;\n  float spawn = 1.;\n  float zoom = .5;\n  float scale = noiseScale * iResolution.y / 320.;\n  for (float index = iterations; index > 0.; --index) {\n    ratio = mod(ratio+1./iterations, 1.);\n    vec3 s = vec3(p*scale*(zoom-ratio*zoom), 1. + timeline*noiseSpeed);\n    float salty = fbm(s) * 2. - 1.;\n    float angle = salty * PI * 8.;\n    uv += vec2(cos(angle),sin(angle)) * unit * sin(ratio*PI);\n    spawn *= 1. - abs(sin(angle)) * sin(ratio*PI);\n  }\n  color *= spawn;\n  float blend = (.5+.5*(1.-spawn));\n  fragColor = texture(iChannel0, uv)*blend + (1.-blend)*vec4(color, 1);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if(iFrame<30){\n        fragColor = texture(iChannel0, (uv*1.45));\n        if(fragColor.r>0.25){\n            fragColor.g=0.1; fragColor.b=0.1;fragColor.r*=1.5;\n        } else if(fragColor.r>0.15){fragColor.g=0.1; fragColor.r=0.1;fragColor.b=0.7;}else{fragColor = vec4(1);}\n    } else {fragColor = texture(iChannel1, uv);}\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "\n#define AA 2\n// The porcelain looks better with anti-aliasing, but it tanks the fps on slower machines.\n// 1 is off, 2 is 2x2 AA, 3 is 3x3 AA etc..\n\n#define SAA 2\n// Selective anti-aliasing tries to target edges and doesn't look quite as good, but is faster.\n// 1 is off, 2 is \n\nint area = 0;\nvec2 facepos = vec2(0);\nbool necka = false;\nbool roses = false;\nfloat sdHead( vec3 p ){\n    // TOP - Cranium\n\n    float cran = sdSphere(p-vec3(0,0,0.03),0.35);\n    // BOTTOM - Jaw/Cheekbones\n    vec2 os = vec2(-0.14,0.05);\n    float ms = 0.127;\n    vec3 ql = p - vec3(ms,os);\n    vec3 qr = p - vec3(-ms,os);\n    ql = ql*rotateZ(0.26);\n    qr = qr*rotateZ(-0.26);\n    ql = ql*rotateX(0.42);\n    qr = qr*rotateX(0.42);\n    vec3 a = vec3(0.,-0.4, 0.0);\n    vec3 b = vec3( 0., 0.4, 0.0);\n    float l = length(b-a);\n    float wv = sqrt(0.105/l);\n    float jaw = opSmoothUnion(sdVerticalVesicaSegment( ql-a, l, wv*0.85 ) - wv*0.15, \n    sdVerticalVesicaSegment( qr-a, l, wv*0.85 ) - wv*0.15, 0.07);\n    cran = opSmoothUnion( cran, jaw, 0.03);\n    // SHAPING - sides\n    float d2 = sdRoundBox(p-vec3(0.74,-0.4,-0.15), vec3(0.4,0.6,0.4), 0.02 ); \n    float d1 = sdRoundBox(p-vec3(-0.74,-0.4,-0.15), vec3(0.4,0.6,0.4), 0.02); \n\n    cran = opSmoothSubtraction(d2,opSmoothSubtraction(d1,cran, .2), .2);\n    // SHAPING - top\n    float d6 = sdRoundBox(p-vec3(0.,0.75,-0.0), vec3(0.4,0.4,0.4), 0.04 ); \n    cran = opSmoothSubtraction(d6,cran,.52);\n    // SHAPING - front\n    float d7 = sdRoundBox(p-vec3(0.,0.25,0.77), vec3(0.4,0.4,0.4), 0.01 ); \n    cran = opSmoothSubtraction(d7,cran,.15);\n    // Eye Sockets\n    float d5 = sdRoundBox(p-vec3(0.0,-0.21,0.385), vec3(0.18,0.001,0.001), 0.06 );\n    cran = opSmoothSubtraction( d5, cran, .04);\n    // nose\n    float nose = sdRoundCone(   p-vec3( 0.0,-0.32, 0.32), vec3(0.0,0.0,0), vec3(0.0,0.2,-0.06), 0.033, 0.01);\n    nose = opSmoothUnion( nose, sdRoundCone(   p-vec3( 0.0,-0.34, 0.3), vec3(-0.026,0,0), vec3(0.026,0,0), 0.015, 0.015), 0.03);\n    float nos = sdSphere(p-vec3(0.,-0.21,0.45), 0.11);\n    nose = opSmoothSubtraction( nos, nose, .08);\n    cran = opSmoothUnion( cran, nose, 0.02);\n    \n    \n    // Eyes\n    float eyel = sdSphere(p-vec3(0.11,-0.22,0.257), 0.035);\n    \n    \n    float eyer = sdVerticalVesicaSegment(p-vec3(-0.15,-0.43,0.2), 0.35, 0.23);\n    \n    eyer+=sin(p.y*70.)/300.;\n    eyer+=sin(p.x*80.)/400.;\n    eyer+=sin(p.z*90.)/500.;\n    if(eyer<0.01){roses = true;}\n    cran = opSmoothUnion( cran, eyer, 0.01);\n    \n    cran = opSmoothUnion( cran, eyel, 0.03);\n\n    float fan = sdRoundBox(p-vec3(0.,0.37,-0.7), vec3(0.8,0.8,0.8), 0.01 ); \n    \n    cran = min(fan,cran);\n\n    if(cran<0.001){area = 1;facepos = p.xy;}\n    if(fan<0.02){area = 2;facepos = p.xy;}\n    \n    return cran;\n}\n\nfloat map( in vec3 pos )\n{\n    float d = 1e10;\n    pos *= 0.9;\n    pos = pos*rotateZ(-0.08);\n    // Shoulders-Arms-Torso\n    vec3 q = pos - vec3(0.0,0.0,0.0);\n    q.z-=0.3;\n    q.y+=1.8 - q.x/20.;\n    q.x+=0.35 + q.y/20.;;\n    q = q*rotateX(1.7);\n    q = q*rotateZ(0.4);\n    q = q*rotateY(0.25);\n    float an = 1.0;\n    vec2 c = vec2(sin(an),cos(an));\n    vec4 w = opElongate( q, vec3(0.13,0.27,0.78) );\n    float shoulder = sdCappedTorus(w.xyz, c, 0.7, 0.2);\n    shoulder = shoulder+ sin((1.75+q.x)*3.)/15.;\n    shoulder = shoulder+0.04;\n    d = min( d, shoulder);\n    // Collar Bones\n    vec3 qt = pos - vec3(-0.8,-1.1,-0.7);\n    float collar = rounding( udTriangle( qt, vec3(0.6,0.0,0.1), vec3(0.4,-0.7,0.2), vec3(-0.1,-0.2,0.03) ), 0.05 );\n    collar = opSmoothUnion(collar, rounding( udTriangle( qt, vec3(0.7,0.0,0.1), vec3(0.8,-0.7,0.2), vec3(1.1,0.2,0.4) ), 0.01 ), 0.1);\n    d = opSmoothUnion(d, collar , 0.13);\n\n    // Neck\n     vec3 qv = pos - vec3(0.2,-1.5,-0.3);\n     vec3 a = vec3(0.,-0.2, 0.0);\n     vec3 b = vec3( 0., 0.3, 0.0);\n   float l = length(b-a);\n    qv = pos - vec3(-0.2,-0.9,-0.55);\n    qv = qv*rotateX(-0.3);\n    float neck = sdCylinder(qv, vec2(0.16, 0.65));\n    \n    d = opSmoothUnion( d, neck, 0.2);\n    if(d<0.01){necka=true;}\n    // Head\n    vec3 qh = pos - vec3(-0.15,-0.12,-0.36);\n    qh = qh*rotateY(-0.9-(0.1*sin(iTime/1.5)));\n    float head = sdHead(qh/1.03);\n    d = opSmoothUnion( d, head , 0.15);\n    return d;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n     // camera movement\t\n\tfloat an = 0.8+(0.2*sin(iTime/1.5));\n    //float an = iMouse.x/100.;\n\tvec3 ro = vec3( 1.8*cos(an), 0.3,1.8*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 edge = ww;\n           bool close = false;\n        bool miss = false;\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    // render\n    vec3 tot = vec3(0.0);\n    int count = 0;\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    #if SAA<2\n    for( int n=0; n<AA; n++ )\n    #endif\n    {\n        count++;\n        // pixel coordinates\n         #if SAA>1\n        int n = 0;\n        #endif\n        vec2 mn = vec2(float(m),float(n));\n        #if SAA>1\n        if(fragCoord.y>iResolution.y/2.){mn = mn.yx;}\n        #endif\n        vec2 o =  mn/ float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n                // shading/lighting\t\n        vec3 bg = vec3(0.6,0.65,0.8);\n        vec3 col = bg;\n        // paint blotches\n        float blotchAmt = smoothstep(30.,44.5, magicBox((p+5.2)*5.));\n        blotchAmt = pow(blotchAmt, 3.);// attenuate\n        blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\n        col *= vec3(1.-blotchAmt,1.-blotchAmt,1.0);\n        // grain\n        col.rgb += (rand(p)-.5)*.08;\n        col.rgb = saturate(col.rgb);\n        vec3 bd = col;\n        // raymarch\n        if(uv.x>0.4 && uv.x<0.7 && uv.y<0.7){\n        const float tmax = 5.0;\n \n        float cth = 0.01;\n        float mth = 0.02;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            #if SAA>1\n            close = h<cth?true:close;\n            miss = close&&h>mth?true:miss;\n            #endif\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n\n        vec2 hres = vec2(800., 450.)/iResolution.xy;\n       // edge = cross(edge, nor);\n            vec2 tpoz = facepos.xy*370.;tpoz.y+=234.;tpoz.x+=400.; tpoz = abs(tpoz); //350\n            vec2 rpoz = tpoz; rpoz.y += 116.;\n            vec3 alb = vec3(1);\n            if(area>0){alb = texture(iChannel0, (tpoz/hres)/iResolution.xy, 0.).rgb;}\n        if( t<tmax )\n        {\n           \n            \n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            edge = abs(cross(edge, nor));\n            vec3  lig = normalize(vec3(0.5,2.0,1.5));\n            //vec3  lig2 = normalize(vec3(1.0,0.5,1.5));\n            vec3 ref = reflect(rd, nor);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            //float dif2 = clamp( dot(nor,lig2), 0.0, 1.0 );\n            \n            \n           // vec2 tpoy = pos.zy*200.;tpoy.y+=300.;tpoy.x-=450.; tpoy = abs(tpoy);\n \n            //if(necka){alb = vec3(0,1,0);}\n            //vec3 alb = texture(iChannel0, (tpoy.xy/hres)/iResolution.xy, 0.).rgb;\n            //alb=alb*alb;\n            //alb = min(alb, texture(iChannel0, (tpoz.xy/hres)/iResolution.xy, 0.).rgb*0.75);\n            //vec3 alb = texelFetch(iChannel0, ivec2(tpoy.xy/hres), 0).rgb*0.75;\n            //alb = min(alb, texelFetch(iChannel0, ivec2(tpoz.xy/hres), 0).rgb*0.75);\n            if(area!=2||pos.y<-0.7) {\n\n                if(necka){\n                  vec2 bpoz = pos.xy*570.;bpoz.y+=400.;bpoz.x+=600.; bpoz = abs(bpoz);\n                  alb = texture(iChannel0, (bpoz/hres)/iResolution.xy, 0.).rgb;\n                  vec2 bpox = pos.xz*370.;bpox.y+=225.;bpox.x+=310.; bpox = abs(bpox);\n                  alb = min(alb,texture(iChannel0, (bpox/hres)/iResolution.xy, 0.).rgb);\n                }\n\n                float spe = pow(max(0.0, dot(lig, ref)),32.0);\n                float sha = 1.;//calcSoftshadow( pos, lig, 0.03,3.0, 8.0 );\n                float amb = 0.55 + 0.2*dot(nor,normalize(vec3(0.0,1.0,0.0)));\n                if(roses){\n                  vec3 rcol = texture(iChannel1, (rpoz/hres)/iResolution.xy, 0.).rgb;\n                  if(rcol.r>0.3&&rcol.g<0.3&&rcol.b<0.3){\n                        alb=rcol;\n                  }\n                  alb = min(alb, rcol);\n                  spe=0.;\n                  dif=0.2;\n                }\n                col =alb*amb + (spe*sha) + vec3(0.4,0.4,0.6)*dif/2.*sha;\n            } else {\n                col=min(col,alb);\n                \n            }\n            \n            if(alb.r>0.3&&alb.g<0.3&&alb.b<0.3){\n                col=alb;\n            }\n            \n        }\n        }\n   \n        float f = smoothstep(-0.7,-1.0, p.y);\n        col = mix(col, bg, f);\n        // gamma        \n        col = (col + sqrt( col ) + sqrt( col ))/3.;\n\t    tot += col;\n    #if AA>1\n        #if SAA>1\n        vec3 edgef = fwidth(edge);\n        float edget = edgef.x+edgef.y+edgef.z;\n        if(edget<0.1&&!miss){m=AA;}//else{tot=vec3(0);}\n        #endif\n    }\n    tot /= float(count);\n    #endif\n    //if(miss){tot=vec3(0);}\n\tfragColor = vec4( tot, 1.0 );\n}",
     "name": "Buffer D",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "332SRD",
    "date": "1745859044",
    "viewed": 140,
    "name": "Fork of Mona Lisa in triangles",
    "description": "Fork of Dave Hoskins shader from 2013.\nI made the triangle count proportional to the frame number so they appear over time.\n",
    "likes": 10,
    "published": "Public",
    "usePreview": 1,
    "tags": [
     "triangles",
     "monalisa",
     "genetic",
     "photo",
     "image",
     "reproduction"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Mona Lisa in triangles\" by Dave_Hoskins. https://shadertoy.com/view/MsX3WH\n// 2025-04-28 16:45:11\n\n// Mona Lisa in triangles - by Dave Hoskins 2013\n// Made with Shadertoy:- https://www.shadertoy.com/view/MsX3WH\n\n// This was done using ideas Roger Alsing presented in 2008\n// His blog:  http://rogeralsing.com/2008/12/07/genetic-programming-evolution-of-mona-lisa/\n\n\n// Add noise to the triangles to make it a little clearer...\n#define ADD_DITHER\n#define MOVE_DITHER //... For temporal dithering\n\n\nvec3 col = vec3(0.0);\nvec2 uv;\n\n\n#define CO_SCALE (1.0 / vec2(512, 262144.0*.5625)) // Scale includes aspect ratio adjustment for Y\nvec2 fcoord;\n\n#ifdef ADD_DITHER\nvec2 randValues = vec2(0.025, 0.0125);\nvec2 Hash2( vec2 x )\n{\n#ifdef MOVE_DITHER\n    x.xy += iTime;\n#endif\n\tfloat n = dot(x,vec2(13.9,15.33));\n    return fract(sin(vec2(n,n+1.0))*vec2(3175.233,2258.1459));\n}\n#endif\n\n\nvec2 unpackCoord(float f) \n{\n    return fract(f * CO_SCALE);\n}\n\nvec2 unpackColour(float f) \n{\n    return fract(f * (1.0/vec2(256.0, 65536.0)));\n}\n\nvoid Tri(inout float tricount, float pA, float pB, float pC, float pCol1, float pCol2)\n{\n    \n    tricount+=1.;\n    if(iTime>tricount/10.){\n        vec2 pos = uv;\n        vec2 a = unpackCoord(pA);\n        vec2 b = unpackCoord(pB);\n        vec2 c = unpackCoord(pC);\n#ifdef ADD_DITHER\n        pos += Hash2(fcoord) * randValues.x - randValues.y;\n        pos = clamp(pos, vec2(0.0001), vec2(.996));\n#endif\n\n        // This is the smallest 2D triangle test I could find...\n        float as_x = pos.x-a.x;\n        float as_y = pos.y-a.y;\n        bool si = (b.x-a.x)*as_y-(b.y-a.y)*as_x > 0.0;\n        if ((c.x-a.x)*as_y-(c.y-a.y)*as_x > 0.0 == si) return;\n        if ((c.x-b.x)*(pos.y-b.y)-(c.y-b.y)*(pos.x-b.x) > 0.0 != si) return;\n        // ...done triangle test! :)\n\t\n        vec4 triCol = vec4(unpackColour(pCol1), unpackColour(pCol2));\n        col = mix (col, triCol.rgb, triCol.a); \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fcoord = fragCoord;\n\tuv = fragCoord.xy / iResolution.xy;\n    float tricount = 0.0;\n\tTri(tricount,113981.0, 10049.0,273.0, 58787.0, 3720.0);\n\tTri(tricount,23756.0, 21755.0,15595.0, 64507.0, 15350.0);\n\tTri(tricount,91962.0, 70504.0,46344.0, 62715.0, 15338.0);\n\tTri(tricount,23801.0, 24221.0,16122.0, 62972.0, 15334.0);\n\tTri(tricount,122620.0, 124177.0,46213.0, 32275.0, 13246.0);\n\tTri(tricount,96768.0, 147019.0,146944.0, 65277.0, 15349.0);\n\tTri(tricount,88180.0, 46291.0,94092.0, 64248.0, 14935.0);\n\tTri(tricount,56162.0, 29454.0,63758.0, 55793.0, 15267.0);\n\tTri(tricount,367.0, 38241.0,6025.0, 7429.0, 7755.0);\n\tTri(tricount,112227.0, 65538.0,123472.0, 42163.0, 12090.0);\n\tTri(tricount,41995.0, 93334.0,5668.0, 17476.0, 7737.0);\n\tTri(tricount,20480.0, 28185.0,37888.0, 13830.0, 4559.0);\n\tTri(tricount,66705.0, 81054.0,135013.0, 63118.0, 15288.0);\n\tTri(tricount,141666.0, 146074.0,123239.0, 43930.0, 15354.0);\n\tTri(tricount,128923.0, 36856.0,128923.0, 10267.0, 11031.0);\n\tTri(tricount,100242.0, 106898.0,136814.0, 40349.0, 9761.0);\n\tTri(tricount,47964.0, 55942.0,104835.0, 61182.0, 15217.0);\n\tTri(tricount,56454.0, 97912.0,71928.0, 65278.0, 15218.0);\n\tTri(tricount,147356.0, 79250.0,146952.0, 7873.0, 7944.0);\n\tTri(tricount,89956.0, 91290.0,58503.0, 65022.0, 15357.0);\n\tTri(tricount,136094.0, 94226.0,102415.0, 19293.0, 15168.0);\n\tTri(tricount,127876.0, 135021.0,88231.0, 55289.0, 11616.0);\n\tTri(tricount,80791.0, 106817.0,85918.0, 29023.0, 12904.0);\n\tTri(tricount,60928.0, 146944.0,147035.0, 64766.0, 15200.0);\n\tTri(tricount,111323.0, 111670.0,116062.0, 49635.0, 7793.0);\n\tTri(tricount,1883.0, 115381.0,36233.0, 50641.0, 8205.0);\n\tTri(tricount,51326.0, 118080.0,29318.0, 63478.0, 2590.0);\n\tTri(tricount,60455.0, 85559.0,91172.0, 64219.0, 15246.0);\n\tTri(tricount,64247.0, 115418.0,71365.0, 59118.0, 15358.0);\n\tTri(tricount,12105.0, 20623.0,120610.0, 37628.0, 14612.0);\n\tTri(tricount,111229.0, 147077.0,147321.0, 53246.0, 15200.0);\n\tTri(tricount,146944.0, 62518.0,147012.0, 65011.0, 15266.0);\n\tTri(tricount,58589.0, 58579.0,57856.0, 64243.0, 15307.0);\n\tTri(tricount,29184.0, 126042.0,28688.0, 27489.0, 15173.0);\n\tTri(tricount,34479.0, 8407.0,27791.0, 53752.0, 14696.0);\n\tTri(tricount,99962.0, 49348.0,106626.0, 54599.0, 13788.0);\n\tTri(tricount,87940.0, 31972.0,28947.0, 35830.0, 15168.0);\n\tTri(tricount,143492.0, 129295.0,147136.0, 20905.0, 12739.0);\n\tTri(tricount,88798.0, 147131.0,95990.0, 63997.0, 14607.0);\n\tTri(tricount,48905.0, 42306.0,91964.0, 65017.0, 14589.0);\n\tTri(tricount,147109.0, 108757.0,147232.0, 64191.0, 15089.0);\n\tTri(tricount,97173.0, 26888.0,113355.0, 54268.0, 14134.0);\n\tTri(tricount,24597.0, 25154.0,4170.0, 36948.0, 5722.0);\n\tTri(tricount,116072.0, 115546.0,128283.0, 50426.0, 13675.0);\n\tTri(tricount,81649.0, 147325.0,147063.0, 37374.0, 14344.0);\n\tTri(tricount,86369.0, 87833.0,71478.0, 63802.0, 15357.0);\n\tTri(tricount,95232.0, 121923.0,139776.0, 62713.0, 14759.0);\n\tTri(tricount,99992.0, 99519.0,93864.0, 64253.0, 15342.0);\n\tTri(tricount,119808.0, 94304.0,57908.0, 58827.0, 12153.0);\n\tTri(tricount,123828.0, 123828.0,114723.0, 23888.0, 7965.0);\n\tTri(tricount,89163.0, 120929.0,81503.0, 2668.0, 13095.0);\n\tTri(tricount,147247.0, 147091.0,125587.0, 54009.0, 14840.0);\n\tTri(tricount,122458.0, 102478.0,115790.0, 27546.0, 13626.0);\n\tTri(tricount,87781.0, 104307.0,104263.0, 53240.0, 15298.0);\n\tTri(tricount,147081.0, 147256.0,9023.0, 42488.0, 11817.0);\n\tTri(tricount,60221.0, 51399.0,116516.0, 65277.0, 15278.0);\n\tTri(tricount,68673.0, 62018.0,83489.0, 27794.0, 9484.0);\n\tTri(tricount,19143.0, 18169.0,86156.0, 49913.0, 15217.0);\n\tTri(tricount,62216.0, 122754.0,38167.0, 55004.0, 8656.0);\n\tTri(tricount,139103.0, 141130.0,128355.0, 46269.0, 11500.0);\n\tTri(tricount,30041.0, 99590.0,11575.0, 45233.0, 13742.0);\n\tTri(tricount,105366.0, 85217.0,116619.0, 57853.0, 13641.0);\n\tTri(tricount,70334.0, 34499.0,37037.0, 64757.0, 14763.0);\n\tTri(tricount,105873.0, 113034.0,109945.0, 55797.0, 13386.0);\n\tTri(tricount,59025.0, 116297.0,60450.0, 2347.0, 14854.0);\n\tTri(tricount,6443.0, 109910.0,283.0, 46838.0, 3543.0);\n\tTri(tricount,70481.0, 146952.0,41932.0, 32426.0, 13465.0);\n\tTri(tricount,32628.0, 35706.0,26994.0, 58351.0, 9523.0);\n\tTri(tricount,147391.0, 98132.0,109854.0, 3334.0, 14868.0);\n\tTri(tricount,111372.0, 112970.0,139159.0, 53238.0, 12401.0);\n\tTri(tricount,55805.0, 55805.0,64810.0, 56591.0, 10462.0);\n\tTri(tricount,28549.0, 2719.0,365.0, 65012.0, 2983.0);\n\tTri(tricount,49.0, 8234.0,7.0, 64507.0, 4292.0);\n\tTri(tricount,98608.0, 46344.0,41710.0, 259.0, 13829.0);\n\tTri(tricount,71276.0, 94020.0,104178.0, 14635.0, 14336.0);\n\tTri(tricount,3923.0, 23418.0,12523.0, 20324.0, 14597.0);\n\tTri(tricount,40830.0, 6508.0,141205.0, 25972.0, 15142.0);\n\tTri(tricount,125017.0, 29184.0,146944.0, 60145.0, 12430.0);\n\tTri(tricount,147326.0, 129660.0,118664.0, 47353.0, 15166.0);\n\tTri(tricount,67358.0, 95122.0,21285.0, 36299.0, 13057.0);\n\tTri(tricount,118553.0, 63828.0,69386.0, 60670.0, 14514.0);\n\tTri(tricount,19456.0, 14352.0,0.0, 24146.0, 13380.0);\n\tTri(tricount,10087.0, 91521.0,64739.0, 31979.0, 14100.0);\n\tTri(tricount,11615.0, 38253.0,2441.0, 9510.0, 14872.0);\n\tTri(tricount,110808.0, 44752.0,90857.0, 64984.0, 14842.0);\n\tTri(tricount,147455.0, 142459.0,104944.0, 24203.0, 7775.0);\n\tTri(tricount,92988.0, 146558.0,68726.0, 12259.0, 10247.0);\n\tTri(tricount,35842.0, 42029.0,4142.0, 64159.0, 3457.0);\n\tTri(tricount,125612.0, 143002.0,116353.0, 54782.0, 12737.0);\n\tTri(tricount,115271.0, 146443.0,134736.0, 43990.0, 14912.0);\n\tTri(tricount,146944.0, 147033.0,84992.0, 64766.0, 15036.0);\n\tTri(tricount,137373.0, 55475.0,146570.0, 39412.0, 7811.0);\n\tTri(tricount,60124.0, 74938.0,147246.0, 1.0, 15104.0);\n\tTri(tricount,136152.0, 146394.0,147402.0, 15948.0, 7744.0);\n\tTri(tricount,16019.0, 109180.0,262.0, 38132.0, 13876.0);\n\tTri(tricount,142743.0, 147091.0,111420.0, 47346.0, 11607.0);\n\tTri(tricount,48350.0, 79593.0,76023.0, 54270.0, 13565.0);\n\tTri(tricount,111486.0, 85809.0,39223.0, 56047.0, 12896.0);\n\tTri(tricount,90253.0, 91513.0,11101.0, 52732.0, 13163.0);\n\tTri(tricount,121724.0, 1269.0,7052.0, 33272.0, 10001.0);\n\tTri(tricount,67207.0, 101582.0,41629.0, 40623.0, 15310.0);\n\tTri(tricount,147304.0, 123708.0,147177.0, 46842.0, 14975.0);\n\tTri(tricount,13363.0, 3659.0,136500.0, 5922.0, 15131.0);\n\tTri(tricount,146687.0, 53892.0,27346.0, 62205.0, 13486.0);\n\tTri(tricount,145054.0, 120591.0,121461.0, 46317.0, 12363.0);\n\tTri(tricount,132949.0, 147298.0,135558.0, 46070.0, 10836.0);\n\tTri(tricount,43252.0, 42258.0,27394.0, 56825.0, 15162.0);\n\tTri(tricount,96354.0, 117334.0,93231.0, 42487.0, 8042.0);\n\tTri(tricount,109133.0, 147029.0,133122.0, 42194.0, 15176.0);\n\tTri(tricount,105082.0, 83847.0,6315.0, 49405.0, 11405.0);\n\tTri(tricount,65757.0, 90303.0,105190.0, 58543.0, 15080.0);\n\tTri(tricount,147350.0, 82339.0,147239.0, 56310.0, 3081.0);\n\tTri(tricount,85194.0, 46289.0,50378.0, 65021.0, 14571.0);\n\tTri(tricount,146552.0, 110779.0,111262.0, 43262.0, 15157.0);\n\tTri(tricount,146943.0, 119285.0,113663.0, 40446.0, 2764.0);\n\tTri(tricount,49824.0, 29998.0,28357.0, 64766.0, 15270.0);\n\tTri(tricount,97441.0, 130060.0,52776.0, 24721.0, 7748.0);\n\tTri(tricount,9919.0, 23271.0,27787.0, 62717.0, 14506.0);\n\tTri(tricount,147066.0, 112250.0,147296.0, 61438.0, 14996.0);\n\tTri(tricount,511.0, 305.0,127487.0, 40692.0, 3253.0);\n\tTri(tricount,147333.0, 75156.0,120432.0, 28663.0, 8964.0);\n\tTri(tricount,146217.0, 136030.0,131241.0, 41379.0, 15218.0);\n\tTri(tricount,22479.0, 13229.0,38354.0, 7983.0, 8741.0);\n\tTri(tricount,855.0, 86379.0,136700.0, 10798.0, 11056.0);\n\tTri(tricount,132873.0, 38058.0,147152.0, 40957.0, 15139.0);\n\tTri(tricount,71803.0, 99203.0,26762.0, 48125.0, 10106.0);\n\tTri(tricount,102275.0, 97622.0,84857.0, 39599.0, 13985.0);\n\tTri(tricount,10908.0, 131816.0,226.0, 54525.0, 14942.0);\n\tTri(tricount,119092.0, 69504.0,94108.0, 56827.0, 4197.0);\n\tTri(tricount,15162.0, 27824.0,38033.0, 519.0, 15105.0);\n\tTri(tricount,96564.0, 70954.0,106312.0, 30395.0, 7764.0);\n\tTri(tricount,47052.0, 64968.0,56291.0, 11835.0, 8726.0);\n\tTri(tricount,99075.0, 95998.0,82863.0, 15705.0, 9989.0);\n\tTri(tricount,58770.0, 112027.0,84102.0, 46837.0, 9796.0);\n\tTri(tricount,82682.0, 32986.0,68953.0, 6.0, 10765.0);\n\tTri(tricount,105149.0, 28507.0,100015.0, 35266.0, 15185.0);\n\tTri(tricount,69253.0, 75407.0,4790.0, 54263.0, 10971.0);\n\tTri(tricount,82434.0, 141855.0,78364.0, 61665.0, 13779.0);\n\tTri(tricount,147010.0, 130560.0,72235.0, 65266.0, 15283.0);\n\tTri(tricount,82944.0, 102912.0,60039.0, 6704.0, 15105.0);\n\tTri(tricount,45325.0, 139518.0,34009.0, 518.0, 15104.0);\n\tTri(tricount,9584.0, 22392.0,11089.0, 51451.0, 7756.0);\n\tTri(tricount,86461.0, 112558.0,104924.0, 9247.0, 14378.0);\n\tTri(tricount,87264.0, 89287.0,81601.0, 16284.0, 15112.0);\n\tTri(tricount,93031.0, 61241.0,87825.0, 64718.0, 15064.0);\n\tTri(tricount,29213.0, 54322.0,145430.0, 25105.0, 4422.0);\n\tTri(tricount,103480.0, 132158.0,24754.0, 1291.0, 13828.0);\n\tTri(tricount,89100.0, 78849.0,57870.0, 42702.0, 10086.0);\n\tTri(tricount,135185.0, 146975.0,147020.0, 63998.0, 14253.0);\n\tTri(tricount,41233.0, 23806.0,71436.0, 9531.0, 14850.0);\n\tTri(tricount,121739.0, 120111.0,105822.0, 6930.0, 14111.0);\n\tTri(tricount,18183.0, 23297.0,22797.0, 60387.0, 14945.0);\n\tTri(tricount,190.0, 387.0,19607.0, 34041.0, 15125.0);\n\tTri(tricount,102477.0, 108392.0,141311.0, 768.0, 10240.0);\n\tTri(tricount,336.0, 99672.0,195.0, 51707.0, 15211.0);\n\tTri(tricount,115342.0, 125113.0,112338.0, 8461.0, 14081.0);\n\tTri(tricount,5101.0, 64220.0,5101.0, 27380.0, 14229.0);\n\tTri(tricount,71244.0, 16384.0,68608.0, 5399.0, 15122.0);\n\tTri(tricount,3577.0, 3577.0,147329.0, 48643.0, 8866.0);\n\tTri(tricount,133079.0, 84392.0,133079.0, 61058.0, 13261.0);\n\tTri(tricount,2818.0, 8549.0,383.0, 13092.0, 7972.0);\n\tTri(tricount,193.0, 263.0,12995.0, 65277.0, 15296.0);\n\tTri(tricount,50370.0, 50953.0,24828.0, 257.0, 15104.0);\n\tTri(tricount,180.0, 35981.0,325.0, 53246.0, 15183.0);\n\tTri(tricount,125091.0, 66008.0,94531.0, 22277.0, 8327.0);\n\tTri(tricount,147191.0, 116408.0,134016.0, 50424.0, 12659.0);\n\tTri(tricount,79065.0, 98055.0,79111.0, 36056.0, 14597.0);\n\tTri(tricount,95635.0, 119702.0,53090.0, 23931.0, 15104.0);\n\tTri(tricount,98304.0, 147382.0,146944.0, 51452.0, 7815.0);\n\tTri(tricount,75221.0, 3786.0,120769.0, 5420.0, 10501.0);\n\tTri(tricount,115257.0, 91682.0,87621.0, 54498.0, 15236.0);\n\tTri(tricount,75369.0, 78893.0,59489.0, 13897.0, 9043.0);\n\tTri(tricount,191.0, 58505.0,1931.0, 41982.0, 11299.0);\n\tTri(tricount,125069.0, 137084.0,147263.0, 46304.0, 15224.0);\n\tTri(tricount,16535.0, 16683.0,31574.0, 48377.0, 14699.0);\n\tTri(tricount,16961.0, 6706.0,20021.0, 30397.0, 3981.0);\n\tTri(tricount,109942.0, 112412.0,100146.0, 2.0, 14861.0);\n\tTri(tricount,73983.0, 37151.0,112010.0, 61180.0, 10690.0);\n\tTri(tricount,78220.0, 372.0,117062.0, 23172.0, 10764.0);\n\tTri(tricount,75436.0, 58017.0,77471.0, 31511.0, 10129.0);\n\tTri(tricount,44749.0, 54964.0,99540.0, 4700.0, 14593.0);\n\tTri(tricount,112808.0, 13992.0,84595.0, 42212.0, 15203.0);\n\tTri(tricount,86777.0, 46809.0,92277.0, 59357.0, 13533.0);\n\tTri(tricount,10575.0, 14682.0,18771.0, 45270.0, 14638.0);\n\tTri(tricount,68259.0, 33013.0,44239.0, 7491.0, 15106.0);\n\tTri(tricount,143105.0, 123636.0,129806.0, 49145.0, 14924.0);\n\tTri(tricount,46105.0, 94873.0,147045.0, 512.0, 15108.0);\n\tTri(tricount,22159.0, 103838.0,101493.0, 49150.0, 13906.0);\n\tTri(tricount,29065.0, 306.0,397.0, 8205.0, 15124.0);\n\tTri(tricount,2569.0, 24595.0,2586.0, 9751.0, 14879.0);\n\tTri(tricount,185.0, 107133.0,254.0, 54269.0, 14209.0);\n\tTri(tricount,33070.0, 25363.0,24092.0, 20.0, 14338.0);\n\tTri(tricount,104569.0, 11929.0,87848.0, 43258.0, 10804.0);\n\tTri(tricount,76852.0, 74794.0,129044.0, 53455.0, 9612.0);\n\tTri(tricount,133864.0, 53333.0,134377.0, 57334.0, 13716.0);\n\tTri(tricount,147337.0, 147106.0,108950.0, 52989.0, 12618.0);\n\tTri(tricount,54969.0, 52911.0,60594.0, 21099.0, 7704.0);\n\tTri(tricount,79907.0, 145989.0,67146.0, 33431.0, 12596.0);\n\tTri(tricount,84708.0, 65249.0,48886.0, 4703.0, 8456.0);\n\tTri(tricount,129716.0, 127202.0,103560.0, 34504.0, 13389.0);\n\tTri(tricount,54.0, 1.0,21014.0, 65011.0, 6000.0);\n\tTri(tricount,102436.0, 60928.0,75304.0, 19523.0, 14884.0);\n\tTri(tricount,143001.0, 136360.0,135310.0, 25483.0, 14450.0);\n\tTri(tricount,74981.0, 51470.0,74000.0, 29111.0, 13612.0);\n\tTri(tricount,106240.0, 101177.0,94475.0, 58110.0, 14991.0);\n\tTri(tricount,102533.0, 147057.0,105528.0, 258.0, 15108.0);\n\tTri(tricount,99844.0, 43583.0,55409.0, 5148.0, 12043.0);\n\tTri(tricount,0.0, 55829.0,300.0, 41722.0, 3012.0);\n\tTri(tricount,43344.0, 36027.0,24283.0, 41460.0, 14390.0);\n\tTri(tricount,51615.0, 108543.0,62463.0, 10287.0, 7971.0);\n\tTri(tricount,52347.0, 51937.0,147063.0, 46331.0, 11085.0);\n\tTri(tricount,147189.0, 77544.0,147124.0, 60414.0, 12946.0);\n\tTri(tricount,60248.0, 92525.0,29426.0, 39387.0, 14458.0);\n\tTri(tricount,122243.0, 59178.0,67472.0, 43260.0, 9779.0);\n\tTri(tricount,15507.0, 32959.0,185.0, 15717.0, 13575.0);\n\tTri(tricount,59276.0, 318.0,896.0, 9283.0, 14861.0);\n\tTri(tricount,57228.0, 95860.0,54399.0, 51959.0, 8071.0);\n\tTri(tricount,109906.0, 115477.0,117569.0, 65264.0, 15283.0);\n\tTri(tricount,191.0, 11530.0,274.0, 61182.0, 15245.0);\n\tTri(tricount,59644.0, 133898.0,103655.0, 9027.0, 12032.0);\n\tTri(tricount,61217.0, 50939.0,62169.0, 42489.0, 14912.0);\n\tTri(tricount,69757.0, 41607.0,65707.0, 33500.0, 14662.0);\n\tTri(tricount,204.0, 5796.0,94836.0, 32712.0, 14906.0);\n\tTri(tricount,60661.0, 62223.0,82687.0, 42697.0, 8725.0);\n\tTri(tricount,42230.0, 9496.0,39137.0, 19309.0, 13845.0);\n\tTri(tricount,8435.0, 68983.0,11472.0, 8765.0, 14337.0);\n\tTri(tricount,116625.0, 111023.0,376.0, 7473.0, 15122.0);\n\tTri(tricount,22735.0, 25947.0,2870.0, 47612.0, 13391.0);\n\tTri(tricount,3886.0, 76033.0,114564.0, 54269.0, 9876.0);\n\tTri(tricount,119777.0, 82328.0,114647.0, 43132.0, 10468.0);\n\tTri(tricount,107015.0, 70183.0,92672.0, 18753.0, 11271.0);\n\tTri(tricount,44743.0, 43623.0,43599.0, 31650.0, 14599.0);\n\tTri(tricount,37096.0, 11481.0,9961.0, 18843.0, 11264.0);\n\tTri(tricount,276.0, 36998.0,69240.0, 11901.0, 8195.0);\n\tTri(tricount,98757.0, 147337.0,93061.0, 10824.0, 11310.0);\n\tTri(tricount,24989.0, 43911.0,6028.0, 29401.0, 4411.0);\n\tTri(tricount,64773.0, 301.0,113064.0, 40683.0, 7994.0);\n\tTri(tricount,90947.0, 98659.0,134957.0, 10856.0, 12550.0);\n\tTri(tricount,32768.0, 0.0,86.0, 39556.0, 11080.0);\n\tTri(tricount,115886.0, 109709.0,110278.0, 65277.0, 15313.0);\n\tTri(tricount,97838.0, 23734.0,54300.0, 23764.0, 2736.0);\n\tTri(tricount,61603.0, 147344.0,147068.0, 55548.0, 7782.0);\n\tTri(tricount,103642.0, 147251.0,147083.0, 57597.0, 13199.0);\n\tTri(tricount,96944.0, 89735.0,107680.0, 55549.0, 15234.0);\n\tTri(tricount,81028.0, 68256.0,82078.0, 19292.0, 6475.0);\n\tTri(tricount,130923.0, 35701.0,32158.0, 36306.0, 3909.0);\n\tTri(tricount,42355.0, 42355.0,135795.0, 1513.0, 12776.0);\n\tTri(tricount,82408.0, 119798.0,125707.0, 2310.0, 3081.0);\n\tTri(tricount,94351.0, 99023.0,87734.0, 10340.0, 13313.0);\n\tTri(tricount,137850.0, 135541.0,124062.0, 48869.0, 12655.0);\n\tTri(tricount,130927.0, 119589.0,142081.0, 44782.0, 13661.0);\n\tTri(tricount,98941.0, 107403.0,16751.0, 49657.0, 11594.0);\n\tTri(tricount,143147.0, 127287.0,135450.0, 54012.0, 14990.0);\n\tTri(tricount,114251.0, 126570.0,147027.0, 7747.0, 14623.0);\n\tTri(tricount,12957.0, 62670.0,38535.0, 28576.0, 11816.0);\n\tTri(tricount,8458.0, 133390.0,88802.0, 1080.0, 8707.0);\n\n\tfragColor = vec4(col, 1.0 );\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tXSXDz",
    "date": "1745962928",
    "viewed": 42,
    "name": "Fork of cycle stop and rotate",
    "description": "I don't know why but I prefer it so that the shapes always match up. I've made the shapes bigger too.",
    "likes": 4,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "cycle",
     "animation",
     "tiles"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"cycle stop and rotate\" by werls. https://shadertoy.com/view/w32Xzm\n// 2025-04-29 21:39:07\n\n#define s smoothstep\n\nmat2 rotate( float a ) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat tile (vec2 p, int odd)  // fork edit\n{\n    float segmentDuration = 2.;\n    float totalDuration = segmentDuration * 4.;\n    float cycleTime = mod(iTime, totalDuration);\n    float phase = floor(cycleTime / segmentDuration);\n    float localTime = mod(cycleTime, segmentDuration);\n    \n    if(odd==1){phase += 2.;} // fork edit\n        \n    float startAngle = phase * radians(90.);\n    float endAngle = (phase + 1.) * radians(90.);\n        \n    float angle;\n    if (localTime < 1.)\n    {\n        angle = mix(startAngle, endAngle, localTime / 1.);\n    }\n    else\n    {\n        angle = endAngle;\n    }        \n    \n    p *= rotate(angle);\n    \n    float eSize = .1;        // fork edit\n    float margin = eSize/2.; // fork edit\n\n    float O = 1.;\n\n    float a = length(vec2(p.x - .5 + eSize + margin, p.y)) - eSize;\n    float b = abs(length(vec2(p.x + .5 - eSize - margin, p.y)) - eSize) - .01;\n    O *= min(a, b);\n\n    vec2 dist = abs(vec2(p.x, p.y - .5 + eSize + margin)) - vec2(eSize);\n    float c = length(max(dist, .0)) + min(max(dist.x, dist.y), 0.);\n\n    dist = abs(vec2(p.x, p.y + .5 - eSize - margin)) - vec2(eSize);\n    float d = abs(length(max(dist, .0)) + min(max(dist.x, dist.y), 0.)) - .01;\n\n    O *= min(c, d);\n    return O;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 gv = fract(uv * 5.);\n    ivec2 cv = ivec2(floor(uv * 5.));  // fork edit\n    int odd = (cv.x+cv.y)%2;           // fork edit\n    \n    float sf = fwidth(uv.x);\n    vec3 col = vec3(s(sf, -sf, tile(gv - .5, odd))); // fork edit\n    \n    if (gv.x > .98 || gv.y > .98) col = vec3(.3);\n\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WX2SWz",
    "date": "1745983631",
    "viewed": 56,
    "name": "Max Drekker Paint effect",
    "description": "first attempt",
    "likes": 3,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "test",
     "reproduction"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float rx = floor(uv.x *11.);\n    float ry = floor(iTime/3. + (uv.y * (3. + rx)));\n    float smudge = 1.2-fract(uv.x *11.);\n    float smudgeB = -0.2-fract(uv.x *11.);\n    smudge=smudge*smudge;\n    ry+=smudgeB;\n    rx+=smudge;\n    vec3 col = vec3(abs(sin((rx+ry)/11.)), abs(sin((rx+ry)/9.))/1.7, abs(sin((rx+ry)/3.))/1.2);\n\n    fragColor = mix(vec4(col,1.0), texture(iChannel0, fragCoord/iResolution.xy+vec2(0,smudge/100.), 0.), 0.15+ smudge/2.);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "33SSDm",
    "date": "1746146194",
    "viewed": 133,
    "name": "Max Drekker Paint effect v2",
    "description": "Second attempt",
    "likes": 9,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "test",
     "reproduction"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Max Drekker Paint effect\" by Cotterzz. https://shadertoy.com/view/WX2SWz\n// 2025-05-02 00:30:10\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float xdiv = 11.; // number fo horizontal cells\n    float ydiv = 7.; // number of vertical cells\n    if(iMouse.z>0.){xdiv = 3.+iMouse.x/30.;ydiv = 2.+iMouse.y/30.;}\n    // curve - value for curvature to be used as reciprocal for values that get very high close to the edge, see below.\n    float curve = 0.01;\n    // rx - this is the horizontal cell number x divided by xdiv. 0-11 or whatever the count is.\n    float rx = floor(uv.x * xdiv);\n    // rix - this is how far along the horizontal cell we are: 0-1 continuous.\n    float rix = fract(uv.x * xdiv);\n    // rixl - this is inverse of how close we are to the left of the horizontal cell, using a reciprocal so the number tends to infinity as we get to it.\n    // (using the reciprocal of the curve variable)\n    float rixl = (curve/rix)-curve;\n    // rixr - this is the same only for the right hand side.\n    float rixr = (curve/(1.0-rix))-curve;\n    // so now we have numbers that start at zero on one side and get very big as we get to the other edge\n    // I would have used a single variable for this, but we want to curve in opposite directions, so separate is best.\n    \n    // ry - this is the vertical equivalent of rx, only we want the vertical space to veer upwards on the right, and downwards on the left\n    float ry = floor((uv.y+rx/10./* diagonal pattern */) *ydiv+rixl-rixr); // ydiv for number of cells, plus rixl and minus rixr for curve\n    \n    // and this is the equivalent of rix, only again we use rixl and rixr to add curve\n    float riy = fract((uv.y+rx/10.) *ydiv+rixl-rixr)-0.5;\n    // NOTE here - rix is 0-1, but riy is 0-1-0, with 1 in the middle, and 0 at top and bottom\n    // so riy now gives us 0-1-0 progression up the cell, so we can do this:\n    riy=riy*riy*riy;\n    // cubing riy like this gives us another curve, from top to bottom, so it's kinda doing a similar job to rixl/rixr\n    \n    // so now when we take the texture sample we can take pixels evenly spaced across with rx/xdiv\n    // and up with ry/ydiv,  rx/10 is to match the diagonal pattern, and riy/iResolution.y*100 samples pixels up and down from the main pixel sampled for this cell\n    fragColor = textureLod(iChannel0,vec2(rx/xdiv,(riy/iResolution.y*200.)+(ry/ydiv)-rx/10.),0.0);\n    // (Thanks to IQ for this, fixes the awful effect you get from mipmap)\n    \n    if(abs(riy)>0.1||rix>0.9||rix<0.1){fragColor.a = 0.;}\n}\n\n// Try this with different textures.\n// Switch to 'nearest' in the channel settings below for a vector banding look.\n// Also look at the AA in the Common tab.\n// And don't forget to change cell size with the mouse.\n\n// For some crazy image transitions change line 9 to:\n// if(iMouse.z>0.){xdiv = 1.5+iMouse.x/4.;ydiv = 1.+iMouse.y/3.;}\n\n\n\n\n\n\n\n\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// from \"Weyl Supersample Any Shader\" by spalmer https://www.shadertoy.com/view/WXjXRt\n// (forked from from \"postprocess existing shaders\" by FabriceNeyret2 https://www.shadertoy.com/view/NdyfRz )\n// This is what makes it smooth\n// s is number of samples per pixel\n// 64 or more is very high, but it looks good.\n// Change to 1 to see original shader\n\n#define mainImage mainImage0(out vec4 O, vec2 U); \\\nvoid mainImage(out vec4 o, vec2 u) \\\n{ \\\n    float s = 64., k; \\\n    vec2 j = vec2(.5); \\\n    o = vec4(0); \\\n    vec4 c; \\\n    mainImage0(c, u); \\\n    if(c.a==0.){ \\\n    for (k = s; k-- > .5; ) { \\\n        mainImage0(c, u + j - .5); \\\n        o += c; \\\n        j = fract(j + vec2(.754877669, .569840296).yx); \\\n        \\\n    };o /= s;o.a==1.; }else {o+=c;}\\\n    \\\n} \\\nvoid mainImage0",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "w3jSzd",
    "date": "1746464267",
    "viewed": 155,
    "name": "The Monolith at Sunset [283]",
    "description": "I couldn't resist trying to put these two together.\nAll credit to Xor and keaganladds\n    ",
    "likes": 9,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "sunset",
     "clouds",
     "remix",
     "fork",
     "art",
     "golf",
     "300",
     "forkup"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"The Monolith at Sunset\" by keaganladds. https://shadertoy.com/view/3X2Szt\n// And     \"Sunset [283]\"           by Xor.          https://shadertoy.com/view/wXjSRt\n// 2025-05-05 16:01:36\n\n// as suggested by diatribes\nvec4 altNoise(out vec4 O, vec2 I) {\n    float t = iTime*.15,i,z,d,s;\n    for(O*=i; i++<1e2; ) {\n        vec3 p = z * normalize(vec3(I+I,0) - iResolution.xyy );\n        for (d = .2; d < 2.;\n            p += abs(dot(sin(t+p * d * 32.), vec3(.008))) / d,\n            d += d);\n        z += d = .005 + max(s=.3-abs(p.y), -s)*.2;\n        O += cos(d) / d;\n    }\n    O *= 0.1 + (I.x/iResolution.x/1.4);\n    return O / 1e4;\n}\n\n// \"Sunset\" by @XorDev Based on my tweet shader: https://x.com/XorDev/status/1918764164153049480\nvec4 sunset283(vec4 O, vec2 I)\n{\n    //Time for animation\n    //Raymarch iterator\n    float t = iTime/5.;\n    float aTime = 5.;\n    if(t<aTime){\n        \n        float i,//Raymarch depth\n        z,//Step distance\n        d,//Signed distance\n        s;//Clear fragcolor and raymarch with 100 iterations\n        for(O*=i; i++<1e2; )\n        {\n            //Compute raymarch sample point\n            vec3 p = z * normalize( vec3(I+I,0) - iResolution.xyy );\n            //Turbulence loop\n            //https://www.shadertoy.com/view/3XXSWS\n            for(d=5.; d<2e2; d+=d)\n                p += .6*sin(p.yzx*d - .2*t) / d;    \n            //Compute distance (smaller steps in clouds when s is negative)\n            z += d = .005 + max(s=.3-abs(p.y), -s*.2)/4.;\n            //Coloring with sine wave using cloud depth and x-coordinate\n            O += (cos(s/.07+p.x+.5*-((min(t,20.)-20.)/2.)-vec4(0,1,2,3)-3.) + 1.5) * exp(s/.1) / d;\n            O/=1.+min(t,20.)/1000.;\n        }\n        //Tanh tonemapping: https://www.shadertoy.com/view/ms3BD7\n        O = tanh(O*O / 4e8);\n    \n        return mix(O, altNoise(O,I), t/aTime);\n    } else {\n        return altNoise(O,I);\n    }\n    \n}\n\n\n\n// \"The Monolith at Sunset\"\n#define MAX_DIST 100.0\n#define MIN_DIST 0.001\n\nfloat hash(vec3 p)\n{\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return fract(sin(n)*753.5453123);\n}\n\n\nstruct SdfObject {\n\tfloat d;\n\tint index;\n};\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nSdfObject opU(SdfObject a, SdfObject b) {\n    if (a.d < b.d) return a;\n    \n    return b;\n\n}\n\nmat2 rot2D(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\t\n\treturn mat2(c, -s, s, c);\n}\n\nvec4 noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-1.0)+2.0);\n\n    float a = hash( p+vec3(0,0,0) );\n    float b = hash( p+vec3(1,0,0) );\n    float c = hash( p+vec3(0,1,0) );\n    float d = hash( p+vec3(1,1,0) );\n    float e = hash( p+vec3(0,0,1) );\n    float f = hash( p+vec3(1,0,1) );\n    float g = hash( p+vec3(0,1,1) );\n    float h = hash( p+vec3(1,1,1) );\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z),\n                 2.0*du *vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                               k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                               k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nfloat fbm( in vec3 x, in float H, int numOctaves )\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*noise(f*x).x;\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n    \n    return t;\n}\n\n\nSdfObject Terrain(vec3 p) {\n\tfloat d = fbm(vec3(p.x, 0., p.z), 1., 9)/4.;\n\td = (p.y) + d;\n\t\n    return SdfObject(d , 3);\n}\n\nSdfObject map(vec3 p) {\n\n\tvec3 p1 = p;\n\tp1.xz *= rot2D(radians(27.));\n\t\n\tSdfObject sphere1 = SdfObject(sdBox(p1 + vec3(0,-1,0), vec3(0.5, 1.5, 0.5)), 1) ;\n\tSdfObject ground = SdfObject(Terrain(p).d, 3);\n\tSdfObject water = SdfObject(p.y + 0.25, 4);\n\t\n\t\n\treturn  opU(opU(ground, sphere1), water);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<80 && t<maxt; i++ )\n    {\n        float h = map(ro + t*rd).d;\n        res = min( res, h/(w*t) );\n        t += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>maxt ) break;\n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\nSdfObject raymarch(vec3 ro, vec3 rd) \n{\n\tfloat t = 0.;\n\tint objectId = 0;\n\tfor(int i = 0; i < 80; i++) {\n\t\tvec3 p = ro + rd * t;\n\t\tSdfObject m = map(p);\n\t\tfloat d = m.d;\n\t\n\t\tt += d;\n\t\t\n\t\tobjectId = m.index;\n\t\t\n\t\tif (d < MIN_DIST) break;\n\t\tif (t > MAX_DIST) break;\n\t}\n\t\n\t\n\treturn SdfObject(t, objectId);\n}\n\nvec3 getNormal(vec3 p) {\n  vec3 e = vec3(.001, 0, 0);\n\n  vec3 n = map(p).d - vec3(\n    map(p-e.xyy).d,\n    map(p-e.yxy).d,\n    map(p-e.yyx).d);\n\n  return normalize(n);\n}\n\nfloat phaseMie(float cosTheta, float g)\n{\n    float g2 = g * g;\n    float denom = 1.0 + g2 - 2.0 * g * cosTheta;\n    return (1.0 - g2) / (4.0 * 3.14159 * pow(denom, 1.5));\n}\n\nvec3 getSunColor(vec3 sunDir) {\n\tfloat sunFade = clamp(1.0 - sunDir.y, 0.0, 1.0); // More red when sun is low\n\treturn mix(vec3(1.0, 1.0, 1.0), vec3(1, 0.5, 0.2), pow(sunFade, 6.0));\n}\n\nvec3 getSkyColor(vec3 viewDir, vec3 sunDir, vec4 O, vec2 I, bool clouds)\n{\n    // Normalize inputs\n    viewDir = normalize(viewDir);\n    sunDir = normalize(sunDir);\n    \n    vec3 sunColor = getSunColor(sunDir)*1.2;\n\n    // Rayleigh phase function approximation\n    float mu = dot(viewDir, sunDir); // Cosine of angle between view and sun\n    float rayleigh = 1.0 + mu * mu;\n    \n    // Mie phase function\n    float g = 0.85; // Anisotropy factor, higher = tighter glow\n    float miePhase = phaseMie(mu, g);\n\n    // Rayleigh scattering coefficient (RGB) — blue scatters more\n    vec3 betaRayleigh = vec3(5.8e-6, 13.5e-6, 33.1e-6); // Arbitrary scale for visual use\n\tvec3 betaMie = 0.25f * sunColor; // Almost white, tweak for sunset\n\t\n    // Sun intensity (tweak as needed)\n    float sunIntensity = 35000.;\n\n    // Air density / depth factor — fade to space\n    float viewHeight = clamp(viewDir.y, 0., 1.); // Look up = 1, down = 0\n    float extinction = exp(-viewHeight * 2.);     // More fog/haze near horizon\n    \n \tvec3 color = (rayleigh * betaRayleigh);\n    // Approximate color\n    vec3 sky = (color *sunIntensity );\n    sky *= extinction; // Fade toward horizon\n    sky = clamp(sky, 0.0, 1.0);\n    \n    sky += (betaMie * miePhase );\n    if(clouds){\n        sky = max(sky,sunset283(O, I).rgb*1.5);\n    }\n\n    return sky * sunColor;\n}\n\n\n\nvec3 GetSunDirection(float elevation, float rotation)\n{\n    float y = sin(elevation);\n    float radius = cos(elevation); // radius of the horizontal circle\n\n    float x = sin(rotation) * radius;\n    float z = cos(rotation) * radius;\n\n    return normalize(vec3(x, y, z));\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n    float ao = 0.0;\n    float sca = 1.0;\n\n    const int steps = 5;\n    const float stepSize = 0.05; \n\n    for (int i = 1; i <= steps; i++)\n    {\n        float dist = float(i) * stepSize;\n        vec3 samplePos = p + n * dist;\n\n        float d = map(samplePos).d; \n        ao += (dist - d) * sca;\n\n        sca *= 0.7; \n    }\n\n    return clamp(1.0 - ao, 0., 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0f - iResolution.xy)/iResolution.x;\n\n    \n    vec3 col = vec3(0,0,0);\n    \n    float aspect = 1.0;\n    // Ray origin / camera position\n\n    \n    float fov = radians(90.); // Horizontal FOV in radians\n\tvec3 ro = vec3(0, 1.1, -5); // Camera position\n\n\n\t// Calculate scale based on FOV\n\tfloat z = 1.0 / tan(fov * 0.5); // Vertical focal length\n\tvec3 rd = normalize(vec3(uv.x, uv.y, z * aspect));\n    \n    \n    \n    SdfObject rm = raymarch(ro, rd);\n    \n    float d  = rm.d;\n    int objectId = rm.index;\n    \n    float sun = 5.0 * exp(iTime * -0.05f);\n    \n    vec3 viewDir = normalize(rd);\n\tvec3 sunDir = GetSunDirection(radians(sun), radians(40.0-sun));\n    vec3 skyColor = getSkyColor(viewDir, sunDir, fragColor, fragCoord, false);\n\tvec3 lightPos = 1000000.0*sunDir;\n    \n\tif (d < MAX_DIST) {\n\t\tvec3 baseColor = vec3(1,1,1);\n\t\tvec3 sunColor = getSunColor(sunDir);\n\t\tvec3 p = ro + rd * d;\n    \tvec3 normal = getNormal(p);\n    \tvec3 lightDir = normalize(lightPos - p);\n    \tfloat ao = calcAO(p, normal);\n    \t\n    \t\n\t\n\t\tif (objectId ==1) {\n\t\t baseColor = 0.1*vec3(1,1,1);\n\t\t \n\t\t vec3 reflection = rd - 2.0*dot(normal, rd)/length(normal) * (normal);\n\t\t vec3 reflectedColor = getSkyColor(reflection, lightDir, fragColor, fragCoord, false);\n\t\t \n\t\t baseColor += 0.75*reflectedColor;\n\t\t \n\t\t \n\t\t} else if (objectId == 2) {\n\t\t\tbaseColor = vec3(1,1,1);\n\t\t} else if (objectId == 3) {\n\t\t\tbaseColor = 0.1*vec3(0.45,.30,0.15);\n\t\t\tfloat n1 = fbm(p*3.14888555, 0.1, 1);\n\t\t\tfloat n2 = fbm(p*2.2, 0.1, 1);\n\t\t\t\n\t\t\tbaseColor = mix(baseColor, vec3(1.,1.,1.), smoothstep(0.01,0.5, p.y));\n\t\t\tbaseColor = mix(baseColor, baseColor*0.75, n1);\n\t\t\t\n\t\t\tvec3 treecol = 0.05*mix(vec3(0.569, 0.902, 0.231), vec3(0.478, 0.769, 0.047), n2);\n\t\t\tbaseColor = mix(baseColor, treecol, smoothstep(0.1, -0.2, p.y));\n\t\t\t\n\t\t\t// Slope Angle\n\t\t\tfloat a = 1.-dot(normal, vec3(0.,1.,0.));\n\t\t\t\n\t\t\n\t\t\tfloat factorA = smoothstep(0.3,0.6, a);\n\t\t\tfloat factorB = smoothstep(-0.2,0.2, p.y);\n\t\t\t\n\t\t\tbaseColor =mix(baseColor, 0.75*vec3(1,1,1), min(factorA, factorB));\n\t\t} else if (objectId == 4) {\n\t\t\n\t\t\tfloat freq = 250.0;\n\t\t\tvec3 normalOffset =(0.15 * (vec3(fbm(freq*p.xyz, 1.0,2), fbm(freq*p.yxz, 0.5,2), fbm(freq*p.yxz, 0.5,2)) - 0.5));\n\t\t\t\n            \n            vec3 waterNormals = normalize(normal + normalOffset);\n\t\t \tvec3 reflection = rd - 2.0*dot(waterNormals, rd)/length(waterNormals) * (waterNormals);\n\t\t\tvec3 reflectedColor = getSkyColor(reflection, lightDir, fragColor, fragCoord, false);\n\t\t\tbaseColor = 0.01*vec3(0,0,1);\n\t\t\tbaseColor += 0.2*reflectedColor;\n\t\t}\n\t\t\n\t\tfloat diffuse = 5.0*max(dot(normal, lightDir), 0.0) ;\n    \t\n    \tfloat shadow = softshadow(p, lightDir, 0.1, 100.0, 0.1);\n    \t\n    \tfloat ambient = 0.1 * clamp(0.5+0.5*-normal.x,0.0,1.0);\n\t\tvec3 litColor = baseColor * (ambient + diffuse * sunColor * shadow );\n\t\t\n\t\tcol = litColor * ao;\n\t\t\n\t\tfloat fogDistance = d; // Distance along the ray (from raymarching)\n\t\tfloat fogDensity = 0.05; // Controls how thick the fog is\n\n\t\t// Compute fog factor\n\t\tfloat fogFactor = exp(-fogDensity * fogDistance);\n\t\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\n\t\t// Blend with fog color\n\t\tcol = mix(skyColor, col, fogFactor);\n\t\t//col = ao;\n\t} else {\n\t\t\n\t\tcol = getSkyColor(viewDir, sunDir, fragColor, fragCoord, true);\n\t}\n\t\n\t\n\n\tcol = pow( col, vec3(1.2/2.0) );\n    \t\n    fragColor = vec4(col, 1.0f);\n\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WXjSWG",
    "date": "1746504072",
    "viewed": 90,
    "name": "Blue Porcelain CRT",
    "description": "Version 3 CRT\nJust for fun really, I wanted to make her bigger and add some styling post/process that removed the need for AA\nPlus see how much I could fit into one shader..\nIt's now 1k lines/21k chars",
    "likes": 3,
    "published": "Public",
    "usePreview": 1,
    "tags": [
     "sdf",
     "post",
     "tv",
     "crt",
     "painting",
     "face",
     "brush",
     "human",
     "china",
     "reproduction",
     "anatomy",
     "woman",
     "porcelain",
     "asian",
     "vietnamese"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Blue Porcelain v2\" by Cotterzz. https://shadertoy.com/view/3XS3RV\n// 2025-05-06 03:58:14\n\n// Fork of \"Blue Porcelain\" by Cotterzz. https://shadertoy.com/view/W3XGWS\n// 2025-04-10 04:23:43\n\n// This is my first attempt at using SDFs and raymarching\n// It's a bit ambitious, and is still very much a work in progress.\n// There's lots more I want to do with it, but I have some tidying and optimisation to look into before I take it any further.\n// --\n// Based on/inspired by Bao Pham's painting 'Blue Porcelain' https://arthur.io/art/bao-pham/blue-porcelain\n// Uses code and functions from the following shaders:\n//\n// \"CRT and Flicker Effect\" by lucasfturos. https://www.shadertoy.com/view/w3BSDy\n// \"One-Pass Fire\" by Xor.                  https://www.shadertoy.com/view/tf2SWc\n// \"Bottomless depth\" by leon               https://www.shadertoy.com/view/tsBXRh\n// \"Capped torus - distance\" by iq.         https://www.shadertoy.com/view/tl23RK\n// \"Elongation SDF\" by iq.                  https://www.shadertoy.com/view/Ml3fWj\n// \"Vesica Segment\" by iq.                  https://www.shadertoy.com/view/Ds2czG\n// \"Brush Experiment 3\" by 104              https://www.shadertoy.com/view/ltj3Wc\n// \"Magic Fractal\" by dgreensp              https://www.shadertoy.com/view/4ljGDd\n// --\n// 2025-03-31 04:38:41\n// Copyright/licensing of forked code belongs to respective artists/authors.\n// Everything else assembled here is the work of John Cotterell johnmdcotterell@gmail.com\n// and cannot be use outside shadertoy without permission.\n\nconst float CURVATURE = 3.0;\n\nconst float BLUR = 0.031;\n\nconst float CA_AMT = 1.024;\n\n\n\nfloat randInRange(vec2 range, vec2 seed) {\n\n    float r = (rand(seed) + 1.0) / 2.0;\n\n    return range.x + r * (range.y - range.x);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // FLICKER\n    float flickerPeriod = randInRange(vec2(1.5, 3.0), vec2(iTime, iTime));\n    float noiseScale = 0.01;\n    if (fract(iTime / flickerPeriod) > 0.99) {\n        noiseScale = 0.1;\n\n    }\n\n    vec2 flickerSeed = vec2(iTime, uv.y);\n    uv.x += randInRange(vec2(-0.01, 0.01), flickerSeed);\n\n    // CURVATURE\n    vec2 crtUV = uv * 2.0 - 1.0;\n    vec2 offset = crtUV.yx / CURVATURE;\n    crtUV += crtUV * offset * offset;\n    crtUV = crtUV * 0.5 + 0.5;\n\n    // EDGE BLUR\n    vec2 edge = smoothstep(0.0, BLUR, crtUV) *\n                (1.0 - smoothstep(1.0 - BLUR, 1.0, crtUV));\n\n    // CHROMATIC ABERRATION\n    float r = texture(iChannel0, (crtUV - 0.5) * CA_AMT + 0.5).r;\n    float g = texture(iChannel0, crtUV).g;\n    float b = texture(iChannel0, (crtUV - 0.5) / CA_AMT + 0.5).b;\n    vec3 color = vec3(r, g, b) * edge.x * edge.y;\n\n    // SCANLINES\n    if (mod(fragCoord.y, 2.0) < 1.0)\n        color *= 0.7;\n    else if (mod(fragCoord.x, 3.0) < 1.0)\n        color *= 0.7;\n    else\n        color *= 1.2;\n\n    float noise = randInRange(vec2(0.0, noiseScale), flickerSeed);\n    color += vec3(noise);\n    color = (color + sqrt( color )*2.)/3.;\n    fragColor = vec4(color, 1.0);\n    if(r>0.5&&b<0.3&&g<0.3){fragColor = vec4(1,0,0,1);}\n   \n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// todo: implement sweep amt\nvec2 mouse;\n\n////////////////////////////////////////////////////////////////\n// BOILERPLATE UTILITIES...................\nconst float pi = 3.14159;\nconst float pi2 = pi * 2.;\n\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\nfloat opI( float d1, float d2) { return max(d1,d2); }\n\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\nfloat nsin(float a){return .5+.5*sin(a);}\nfloat ncos(float a){return .5+.5*cos(a);}\n\nfloat dtoa(float d, float amount)\n{\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n}\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n    vec2 d = max(tl-uv, uv-br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\n{\n    return length(uv - origin) - radius;\n}\n// 0-1 1-0\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\n{\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\n}\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n// returns -.5 to 1.5. i think.\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\t\n}\nfloat noise01(vec2 p)\n{\n    return clamp((noise(p)+.5)*.5, 0.,1.);\n}\n// debug function to convert distance to color, revealing sign.\nvec3 dtocolor(vec3 inpColor, float dist)\n{\n    vec3 ret;\n    if(dist > 0.)\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\n    else\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\n    return ret;\n}\n\nfloat smoothf(float x)\n{\n    return x*x*x*(x*(x*6. - 15.) + 10.);\n}\n\n////////////////////////////////////////////////////////////////\n// APP CODE ...................\n\n// this function will produce a line with brush strokes. the inputs are such\n// that you can apply it to pretty much any line; the geometry is separated from this function.\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\n{\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\n\n    if(iMouse.z > 0.)\n    {\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\n    \tfloat okthen = 42.;// NOP\n    }\n    \n    // warp the position-in-line, to control the curve of the brush falloff.\n    if(posInLineY > 0.)\n    {\n        float mouseX = 200. == 0. ? 0.2 : (200. / iResolution.x);\n\t   posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\n        //posInLineY = pow(posInLineY, (pow(200.,2.) * 15.) + 1.5);\n        \n    }\n\n    // brush stroke fibers effect.\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\n    float strokeTexture = 0.\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\n        ;\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\n    // fade out the end of the stroke by shifting the noise curve below 0\n    const float strokeAlphaBoost = 1.09;\n    if(posInLineY > 0.)\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.8));// fade out\n    else\n        strokeAlpha *= strokeAlphaBoost;\n\n    strokeAlpha = smoothf(strokeAlpha);\n    \n    // paper bleed effect.\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\n paperBleedAmt = 400.;// disable paper bleed    \n    \n    // blotches (per stroke)\n    //float blotchAmt = smoothstep(2.,28.5,magicBox(vec3(uvPaper, uvLine.x)));\n    //blotchAmt *= (strokeAlpha+0.1);\n    //strokeAlpha += blotchAmt;\n\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\n    alpha = clamp(alpha, 0.,1.);\n    return mix(inpColor, brushColor.rgb, alpha);\n}\n\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\n{\n    // flatten the line to be axis-aligned.\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\n    mat2 rotMat = rot2D(lineAngle);\n\n    float lineLength = distance(p2_, p1_);\n    // make an axis-aligned line from this line.\n    vec2 tl = (p1_ * rotMat);// top left\n    vec2 br = tl + vec2(0,lineLength);// bottom right\n    vec2 uvLine = uv * rotMat;\n\n    // make line slightly narrower at end.\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\n    \n    // wobble it around, humanize\n    float res = min(iResolution.y,iResolution.x);\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\n    uvLine = tl - uvLine;\n    \n    vec2 lineSize = vec2(lineWidth, lineLength);\n    \n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\n                                d, inpColor, brushColor);\n    return ret;\n}\n\n// returns:\n// xy = uvLine\n// z = radius\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\n{\n    vec2 humanizedUVLine = uvLine;\n    \n\t// offsetting the circle along its path creates a twisting effect.\n    float twistAmt = .24;\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\n    humanizedUVLine.x += linePosY * twistAmt;\n    \n    // perturb radius / x\n    float humanizedRadius = radius_;\n    float res = min(iResolution.y,iResolution.x);\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n    \n    return vec3(humanizedUVLine, humanizedRadius);\n}\n\n// there's something about calling an Enso a \"donut\" that makes me giggle.\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\n{\n\tvec2 uvLine = uv - o;\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\n    angle = mod(angle-angleStart+pi, pi2);\n    if(!clockwise)\n        angle = pi2 - angle;\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\n    uvLine = vec2(\n        radius_ - length(uvLine),\n        angle / pi2 * lineLength\n    );\n    \n    // make line slightly narrower at end.\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\n    \n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n    vec2 humanizedUVLine = hu.xy;\n    float humanizedRadius = hu.z;\n\n    float d = opS(sdCircle(uv, o, humanizedRadius),\n                  sdCircle(uv, o, humanizedRadius));\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\n\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\n    \n    // do the same but for before the beginning of the line. distance field is just a single point\n    vec3 ret2 = vec3(1);\n    if(angle > pi)\n    {\n        uvLine.y -= lineLength;\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n        humanizedUVLine = hu.xy;\n        humanizedRadius = hu.z;\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\n        d = distance(uv, strokeStartPos);\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\n\t}\n    return min(ret, ret2);\n}\n\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\n{\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\n    ret *= newSize;// scale up to new dimensions\n    float aspect = iResolution.x / iResolution.y;\n    ret.x *= aspect;// orig aspect ratio\n    float newWidth = newSize.x * aspect;\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\n}\n\n// Blue Porcelain specific code below\nfloat lips(vec2 a , vec2 b, float h, vec2 p){\n    float col = 0.;\n    if(p.x>a.x && p.x<b.x){col = 1.;}\n    float sc = 1./h/(b.x-a.x);\n    float bottom = (a.y - sin((a.x-p.x)/(b.x-a.x)*3.1416)/(sc*2.7)) - p.y;\n    //float f = smoothstep(-1.0, 1000.5, bottom);col = mix(1.,0.5, f);\n    if(col==1. && bottom>0.) {col =1.0;} else {col = 0.;}\n    //col=bottom;\n    float dist = (b.x-a.x)/4.5;\n    a.x+=dist;b.x-=dist;\n    if(col==1. && p.y>(a.y + sin((a.x-p.x)/(b.x-a.x)*9.423)/(sc*20.))) {col = 1.;} else {col = 0.;}\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(1);\n    vec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));\n    // Caching output - if we're on the first frame or the resolution has changed, draw everything.\n    uv.y-=0.5;\n    if(iFrame<2 || texelFetch(iChannel0, ivec2(0), 0).r != iResolution.x){\n\n        \n        float yo = sin(-uv.x*pi*0.5)*0.2;\n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.03,.5),1.),vec2(0.4, -0.35+yo ),vec2(0.25, 0.12+yo), 0.05);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.1, -0.24 ),vec2(0.9, -0.6), 0.01);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.1, -0.1 + (sin((uv.x+0.1) * 25.) * 0.03)),vec2(0.85, -0.6), 0.01);                    \n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.09, -0.12 ),vec2(0.13, -0.17 ), 0.001);\n              \n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.1, -0.24 ),vec2(-0.9, -0.6), 0.02);\n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.1, -0.1 - (sin((uv.x+0.1) * 25.) * 0.03)),vec2(-0.85, -0.5), 0.01);                    \n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.09, -0.12),vec2(-0.13, -0.17 ), 0.001);\n//col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.4),vec2(0.32, .245+yo),vec2(0.2, .205+yo), 0.002);\n        vec2 sps = vec2(0.25,-0.01);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,4.0,6.6,0.0001,true);\n        sps+=vec2(-0.015,-0.015);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,3.0,1.6,0.03,true);\n        sps+=vec2(0.07,0.07);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,5.0,6.6,0.0001,true);\n        sps+=vec2(0.015,-0.0);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,3.0,1.6,0.03,true);\n        \n        sps = vec2(-0.18,0.12);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,1.0,6.6,0.0001,true);\n        sps+=vec2(-0.01,-0.015);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,-3.0,1.6,0.02,true);\n        sps+=vec2(0.05,0.05);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,1.0,6.6,0.0001,true);\n        sps+=vec2(0.01,-0.015);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,-3.0,1.6,0.02,true);\n//colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\n        sps = vec2(-0.23,-0.3);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.3,6.3,5.1,0.02,false);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.2,6.3,5.1,0.02,false);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.15,6.3,5.1,0.015,false);\n        sps+=vec2(-0.05,0.03);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.2,6.3,5.1,0.04,false);\n        //col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.25,6.3,5.1,0.04,false);\n        \n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.24, 0.15 + (sin((uv.x+0.1) * 25.) * 0.06)),vec2(-1.3, -1.3), 0.07);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.2, -0.2 + (sin((uv.x+0.1) * 25.) * 0.06)),vec2(-1.3, -1.0), 0.04);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.25 + sin(uv.y * 25.) * 0.03, -0.0 - (sin(uv.x * 15.) * 0.04)),vec2(0.8, -2.5), 0.03);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.55 + sin(uv.y * 25.) * 0.03, -0.4 - (sin(uv.x * 15.) * 0.04)),vec2(0.8, -2.), 0.06);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.55 + sin(uv.y * 25.) * 0.07, -0.4 - (sin(uv.x * 15.) * 0.06)),vec2(-0.8, -2.), 0.05);\n         col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.4 + sin(uv.y * 25.) * 0.07, -0.1 - (sin(uv.x * 15.) * 0.06)),vec2(1.2, -1.5), 0.06);    \n         col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.0 + sin(uv.y * 25.) * 0.07, -0.9 - (sin(uv.x * 15.) * 0.06)),vec2(0.0, -1.9), 0.12);    \n\ncol = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.0, -0.44),0.44,-2.,5.1,0.06,false);\n        \n        //col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.09,0.0,0.3,0.0002,true);\n        //col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.12,0.0,0.3,0.0002,true);\n\n       // if(lips(vec2(0.27, 0.14), vec2(0.385, 0.15), 0.8, uv)>0.){col = vec3(.0,.1,.7);}\n       float lp = lips(vec2(-0.12, 0.13), vec2(0.12, 0.13), 0.9, uv);\n        if(lp>0.){col = vec3(.0,.1,.7)*lp;}\n\n        \n        //col = colorBrushStroke(vec2(0.1,0.1), vec2(0.1,0.1), vec2(0.1,0.1), sdCircle(uv, vec2(0.1,0.1), 0.1), vec3(1,0,0), vec4(0,1,0,1));\n        \n        if(ivec2(fragCoord.xy) == ivec2(0)){ col.r = iResolution.x;}// Store resolution in 0,0 pixel\n    } else {\n       // We've already drawn everything, use buffer instead\n      col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n  }\n   \n\n\n       \n\n    fragColor = vec4(col, 1.);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "\nfloat magicBox(vec3 p) {\n    const int MAGIC_BOX_ITERS = 13;\n    const float MAGIC_BOX_MAGIC = 0.55;\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\nfloat magicBox(vec2 uv){\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n    // volume along the same axes as the fractal's bounding box.\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    return magicBox(p);\n}\n\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\n\n\n\nfloat sdSphere( in vec3 p, in float r)\n{\n    return length(p)-r;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat dot2(in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    return -opSmoothUnion(d1,-d2,k);\n    \n    //float h = max(k-abs(-d1-d2),0.0);\n    //return max(-d1, d2) + h*h*0.25/k;\n}\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    //vec3 q = abs(p)-h;\n    //return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n// Euclidean distance to a capped torus\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdVerticalVesicaSegment( in vec3 p, in float h, in float w )\n{\n    // shape constants\n    h *= 0.5;\n    w *= 0.5;\n    float d = 0.5*(h*h-w*w)/w;\n    \n    // project to 2D\n    vec2  q = vec2(length(p.xz), abs(p.y-h));\n    \n    // feature selection (vertex or body)\n    vec3  t = (h*q.x < d*(q.y-h)) ? vec3(0.0,h,0.0) : vec3(-d,0.0,d+w);\n    \n    // distance\n    return length(q-t.xy) - t.z;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Bottomless depth https://www.shadertoy.com/view/tsBXRh\n// Exploring procedural painting\n// Licensed under hippie love conspiracy\n// Leon Denise (ponk) 2019.03.17\n// Using code from:\n// Inigo Quilez (shadertoy.com/view/Xds3zN)\n// Morgan McGuire (shadertoy.com/view/4dS3Wd)\n\nconst float zoomSpeed = 0.05;\nconst float noiseScale = 4.;\nconst float noiseSpeed = 0.0;\n\nconst float PI = 3.1415;\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\nfloat fbm (vec3 p) {\n  float amplitude = .5;\n  float result = 0.0;\n  for (float index = 0.0; index <= 5.0; ++index) {\n    result += noise(p / amplitude) * amplitude;\n    amplitude /= 2.;\n  }\n  return result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 color = vec3(1);\n  float timeline = iTime*zoomSpeed;\n  vec2 unit = 1./iResolution.xy;\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  vec2 p = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  float stage = floor(timeline);\n  float ratio = fract(timeline);\n  const float iterations = 3.;\n  float spawn = 1.;\n  float zoom = .5;\n  float scale = noiseScale * iResolution.y / 320.;\n  for (float index = iterations; index > 0.; --index) {\n    ratio = mod(ratio+1./iterations, 1.);\n    vec3 s = vec3(p*scale*(zoom-ratio*zoom), 1. + timeline*noiseSpeed);\n    float salty = fbm(s) * 2. - 1.;\n    float angle = salty * PI * 8.;\n    uv += vec2(cos(angle),sin(angle)) * unit * sin(ratio*PI);\n    spawn *= 1. - abs(sin(angle)) * sin(ratio*PI);\n  }\n  color *= spawn;\n  float blend = (.5+.5*(1.-spawn));\n  fragColor = texture(iChannel0, uv)*blend + (1.-blend)*vec4(color, 1);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if(iFrame<30){\n        fragColor = texture(iChannel0, (uv*1.45));\n        if(fragColor.r>0.25){\n            fragColor.g=0.1; fragColor.b=0.1;fragColor.r*=1.5;\n        } else if(fragColor.r>0.15){fragColor.g=0.1; fragColor.r=0.1;fragColor.b=0.7;}else{fragColor = vec4(1);}\n    } else {fragColor = texture(iChannel1, uv);}\n    }",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "Xsf3zn",
       "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
       "type": "texture",
       "channel": 2,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "\n#define AA 1\n// The porcelain looks better with anti-aliasing, but it tanks the fps on slower machines.\n// 1 is off, 2 is 2x2 AA, 3 is 3x3 AA etc..\n\n#define SAA 1\n// Selective anti-aliasing tries to target edges and doesn't look quite as good, but is faster.\n// 1 is off, 2 is on\n\nint area = 0;\nvec2 facepos = vec2(0);\nbool necka = false;\nbool roses = false;\nfloat sdHead( vec3 p ){\n    // TOP - Cranium\n\n    float cran = sdSphere(p-vec3(0,0,0.03),0.35);\n    // BOTTOM - Jaw/Cheekbones\n    vec2 os = vec2(-0.14,0.05);\n    float ms = 0.127;\n    vec3 ql = p - vec3(ms,os);\n    vec3 qr = p - vec3(-ms,os);\n    ql = ql*rotateZ(0.26);\n    qr = qr*rotateZ(-0.26);\n    ql = ql*rotateX(0.42);\n    qr = qr*rotateX(0.42);\n    vec3 a = vec3(0.,-0.4, 0.0);\n    vec3 b = vec3( 0., 0.4, 0.0);\n    float l = length(b-a);\n    float wv = sqrt(0.105/l);\n    float jaw = opSmoothUnion(sdVerticalVesicaSegment( ql-a, l, wv*0.85 ) - wv*0.15, \n    sdVerticalVesicaSegment( qr-a, l, wv*0.85 ) - wv*0.15, 0.07);\n    cran = opSmoothUnion( cran, jaw, 0.03);\n    // SHAPING - sides\n    float d2 = sdRoundBox(p-vec3(0.74,-0.4,-0.15), vec3(0.4,0.6,0.4), 0.02 ); \n    float d1 = sdRoundBox(p-vec3(-0.74,-0.4,-0.15), vec3(0.4,0.6,0.4), 0.02); \n\n    cran = opSmoothSubtraction(d2,opSmoothSubtraction(d1,cran, .2), .2);\n    // SHAPING - top\n    float d6 = sdRoundBox(p-vec3(0.,0.75,-0.0), vec3(0.4,0.4,0.4), 0.04 ); \n    cran = opSmoothSubtraction(d6,cran,.52);\n    // SHAPING - front\n    float d7 = sdRoundBox(p-vec3(0.,0.25,0.77), vec3(0.4,0.4,0.4), 0.01 ); \n    cran = opSmoothSubtraction(d7,cran,.15);\n    // Eye Sockets\n    float d5 = sdRoundBox(p-vec3(0.0,-0.21,0.385), vec3(0.18,0.001,0.001), 0.06 );\n    cran = opSmoothSubtraction( d5, cran, .04);\n    // nose\n    float nose = sdRoundCone(   p-vec3( 0.0,-0.32, 0.32), vec3(0.0,0.0,0), vec3(0.0,0.2,-0.06), 0.033, 0.01);\n    nose = opSmoothUnion( nose, sdRoundCone(   p-vec3( 0.0,-0.34, 0.3), vec3(-0.026,0,0), vec3(0.026,0,0), 0.015, 0.015), 0.03);\n    float nos = sdSphere(p-vec3(0.,-0.21,0.45), 0.11);\n    nose = opSmoothSubtraction( nos, nose, .08);\n    cran = opSmoothUnion( cran, nose, 0.02);\n    \n    \n    // Eyes\n    float eyel = sdSphere(p-vec3(0.11,-0.22,0.257), 0.035);\n    \n    \n    float eyer = sdVerticalVesicaSegment(p-vec3(-0.15,-0.43,0.2), 0.35, 0.23);\n    \n    eyer+=sin(p.y*70.)/300.;\n    eyer+=sin(p.x*80.)/400.;\n    eyer+=sin(p.z*90.)/500.;\n    if(eyer<0.01){roses = true;}\n    cran = opSmoothUnion( cran, eyer, 0.01);\n    \n    cran = opSmoothUnion( cran, eyel, 0.03);\n\n    float fan = sdRoundBox(p-vec3(0.,0.37,-0.7), vec3(0.8,0.8,0.8), 0.01 ); \n    \n    cran = min(fan,cran);\n\n    if(cran<0.001){area = 1;facepos = p.xy;}\n    if(fan<0.02){area = 2;facepos = p.xy;}\n    \n    return cran;\n}\n\nfloat map( in vec3 pos )\n{\n    float d = 1e10;\n    pos *= 0.9;\n    pos = pos*rotateZ(-0.08);\n    // Shoulders-Arms-Torso\n    vec3 q = pos - vec3(0.0,0.0,0.0);\n    q.z-=0.3;\n    q.y+=1.8 - q.x/20.;\n    q.x+=0.35 + q.y/20.;;\n    q = q*rotateX(1.7);\n    q = q*rotateZ(0.4);\n    q = q*rotateY(0.25);\n    float an = 1.0;\n    vec2 c = vec2(sin(an),cos(an));\n    vec4 w = opElongate( q, vec3(0.13,0.27,0.78) );\n    float shoulder = sdCappedTorus(w.xyz, c, 0.7, 0.2);\n    shoulder = shoulder+ sin((1.75+q.x)*3.)/15.;\n    shoulder = shoulder+0.04;\n    d = min( d, shoulder);\n    // Collar Bones\n    vec3 qt = pos - vec3(-0.8,-1.1,-0.7);\n    float collar = rounding( udTriangle( qt, vec3(0.6,0.0,0.1), vec3(0.4,-0.7,0.2), vec3(-0.1,-0.2,0.03) ), 0.05 );\n    collar = opSmoothUnion(collar, rounding( udTriangle( qt, vec3(0.7,0.0,0.1), vec3(0.8,-0.7,0.2), vec3(1.1,0.2,0.4) ), 0.01 ), 0.1);\n    d = opSmoothUnion(d, collar , 0.13);\n\n    // Neck\n     vec3 qv = pos - vec3(0.2,-1.5,-0.3);\n     vec3 a = vec3(0.,-0.2, 0.0);\n     vec3 b = vec3( 0., 0.3, 0.0);\n   float l = length(b-a);\n    qv = pos - vec3(-0.2,-0.9,-0.55);\n    qv = qv*rotateX(-0.3);\n    float neck = sdCylinder(qv, vec2(0.16, 0.65));\n    \n    d = opSmoothUnion( d, neck, 0.2);\n    if(d<0.01){necka=true;}\n    // Head\n    vec3 qh = pos - vec3(-0.15,-0.12,-0.36);\n    qh = qh*rotateY(-0.9-(0.1*sin(iTime/1.5)));\n    float head = sdHead(qh/1.03);\n    d = opSmoothUnion( d, head , 0.15);\n    return d;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\n// Fork of \"One-Pass Fire\" by Xor. https://shadertoy.com/view/tf2SWc\n// 2025-03-22 17:16:30\n\n/*\n    \"One-Pass Fire\" by @XorDev\n    \n    Here's the continuation of my experiments with fire effects\n    \n    Also see Turbulent Flame:\n    https://www.shadertoy.com/view/wffXDr\n*/\n//Fire ring radius\n#define COLOR vec3(0.03, 0.03, 0.01)\n//Scroll speed\n#define SCROLL 0.6\n\n//Number of turbulence waves\n#define FIRE_NUM 8.0\n//Turbulence wave amplitude\n#define FIRE_AMP 0.8\n//Turbulence wave speed\n#define FIRE_SPEED 2.0\n//Turbulence frequency (inverse of scale)\n#define FIRE_FREQ 6.0\n//Turbulence frequency multiplier\n#define FIRE_EXP 1.2\nfloat nTime = 0.;\n//Bicubic noise texture sample\nvec4 noise(vec2 p)\n{\n    vec2 f = floor(p);\n    vec2 s = p-f;\n    s *= s * (3.0 - 2.0*s);\n    \n    return texture(iChannel2, (f+s+.5) / 256.0);\n}\n\n//https://mini.gmshaders.com/p/turbulence\nvec2 turbulence(vec2 p, float F, float N, float S, float A, float E)\n{\n    //Turbulence starting scale\n    float freq = F;\n    \n    //Turbulence rotation matrix\n    mat2 rot = mat2(0.6, -0.8, 0.8, 0.6);\n    \n    //Loop through turbulence octaves\n    for(float i=0.0; i<N; i++)\n    {\n        //Scroll along the rotated y coordinate\n        float phase = freq * (p * rot).y + S*nTime + i;\n        //Add a perpendicular sine wave offset\n        p += A * rot[0] * sin(phase) / freq;\n        \n        //Rotate for the next octave\n        rot *= mat2(0.6, -0.8, 0.8, 0.6);\n        //Scale down for the next octave\n        freq *= E;\n    }\n    \n    return p;\n}\n\nvec3 blueFire( vec2 fragCoord )\n{\n\n    nTime = iTime/8.;\n    //Screen coordinates, centered and aspect corrected\n    vec2 p = (fragCoord.xy*2.0-iResolution.xy) / iResolution.y;\n    \n    //Expand vertically\n    float xstretch = 2.0 - 1.5*smoothstep(-2.0,2.0,p.y);\n    //Decelerate horizontally\n    float ystretch = 1.0 - 0.3 / (1.0+p.x*p.x);\n    //Combine\n    vec2 stretch = vec2(xstretch, ystretch);\n    //Stretch coordinates\n    p *= stretch;\n    \n    //Scroll upward\n    float scroll = SCROLL*nTime;\n    p.y -= scroll;\n    \n    //Apply turbulence\n    p = turbulence(p, FIRE_FREQ, FIRE_NUM, FIRE_SPEED, FIRE_AMP, FIRE_EXP);\n    \n    //Scrolling coordinates\n    vec2 sp = p;\n   \n    //Reverse the scrolling offset\n    p.y += scroll + 1.1;\n    \n    //Set radius with noise\n    float radius = 0.9 + 0.6*noise(sp/0.1).x;\n    //Distance to fire\n    float dist = length(p) - radius;\n    \n    //Scrolling texture uvs\n    vec2 uv = sp * FIRE_FREQ*1.5;\n    //Sample noise\n    float n = noise(uv).x + noise(uv*0.3).y + noise(uv*0.1).z;\n    //Glow brightness\n    float light = smoothstep(0.3, 0.1, dist) / (0.1 - 0.03*n + dist*dist);\n    \n    //Spark highlights\n    //float spec = 1.0 / noise(sp*3e1).a;\n    //Blend color, intensity and fad edges\n    //vec3 sparks = 0.02 * spec * spec * COLOR / (1.0+20.0*p.x*p.x);\n    \n    //Combine ambient light and fire\n    vec3 col = 1.1 - (n * light * COLOR);// + sparks;\n    \n    //Exponential tonemap\n    //https://mini.gmshaders.com/p/tonemaps\n    //col = 1.5-exp(-col);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float sc = 1./1.5;\n    uv*=sc;\n     // camera movement\t\n\tfloat an = 0.8+(0.2*sin(iTime/1.5));\n    //float an = iMouse.x/100.;\n\tvec3 ro = vec3( 1.8*cos(an), 0.3,1.8*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 edge = ww;\n    float ed = 0.;\n    vec3 ndif = vec3(0);\n    bool close = false;\n    bool miss = false;\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    // render\n    vec3 tot = vec3(0.0);\n    int count = 0;\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    #if SAA<2\n    for( int n=0; n<AA; n++ )\n    #endif\n    {\n        count++;\n        // pixel coordinates\n         #if SAA>1\n        int n = 0;\n        #endif\n        vec2 mn = vec2(float(m),float(n));\n        #if SAA>1\n        if(fragCoord.y>iResolution.y/2.){mn = mn.yx;}\n        #endif\n        vec2 o =  mn/ float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n        p*=sc;\n        p += vec2(0.1, -0.2);\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n                // shading/lighting\t\n        vec3 bg = vec3(-0.3,-0.3,-0.2) + blueFire(fragCoord);\n        vec3 col = bg*1.2;\n        // paint blotches\n        float blotchAmt = smoothstep(30.,44.5, magicBox((p+5.2)*5.));\n        blotchAmt = pow(blotchAmt, 3.);// attenuate\n        blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\n        col *= vec3(1.-blotchAmt,1.-blotchAmt,1.0);\n        // grain\n        col.rgb += (rand(p)-.7)*.1;\n        //col.rg*=1.3;\n       // col.rgb = saturate(col.rgb);\n       float f = smoothstep(-0.3,-1.0, p.y);\n        col = mix(col, vec3(0.2,0.2,0.4), f);\n        vec3 bd = col;\n        \n        // raymarch\n        if(p.x>-0.4 && p.x<0.6 && p.y<0.6){\n        const float tmax = 5.0;\n \n        float cth = 0.01;\n        float mth = 0.02;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            #if SAA>1\n            close = h<cth?true:close;\n            miss = close&&h>mth?true:miss;\n            #endif\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n\n        vec2 hres = vec2(800., 450.)/iResolution.xy;\n       // edge = cross(edge, nor);\n            vec2 tpoz = facepos.xy*370.;tpoz.y+=234.;tpoz.x+=400.; tpoz = abs(tpoz); //350\n            vec2 rpoz = tpoz; rpoz.y += 116.;\n            vec3 alb = vec3(1);\n            if(area>0){alb = textureLod(iChannel0, (tpoz/hres)/iResolution.xy, 0.5).rgb;}\n        if( t<tmax )\n        {\n           \n            \n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            ed = 10.*(dot(nor,rd)+0.3);\n            //ndif = normalize(vec3(0,0,1)-nor);\n            edge = abs(cross(edge, nor));\n            vec3  lig = normalize(vec3(0.5,2.0,1.5));\n            //vec3  lig2 = normalize(vec3(1.0,0.5,1.5));\n            vec3 ref = reflect(rd, nor);\n            ndif = normalize(ref+nor);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            //float dif2 = clamp( dot(nor,lig2), 0.0, 1.0 );\n            \n            \n           // vec2 tpoy = pos.zy*200.;tpoy.y+=300.;tpoy.x-=450.; tpoy = abs(tpoy);\n \n            //if(necka){alb = vec3(0,1,0);}\n            //vec3 alb = texture(iChannel0, (tpoy.xy/hres)/iResolution.xy, 0.).rgb;\n            //alb=alb*alb;\n            //alb = min(alb, texture(iChannel0, (tpoz.xy/hres)/iResolution.xy, 0.).rgb*0.75);\n            //vec3 alb = texelFetch(iChannel0, ivec2(tpoy.xy/hres), 0).rgb*0.75;\n            //alb = min(alb, texelFetch(iChannel0, ivec2(tpoz.xy/hres), 0).rgb*0.75);\n            if(area!=2||pos.y<-0.7) {\n\n                if(necka){\n                  vec2 bpoz = pos.xy*570.;bpoz.y+=400.;bpoz.x+=600.; bpoz = abs(bpoz);\n                  alb = textureLod(iChannel0, (bpoz/hres)/iResolution.xy, 0.5).rgb;\n                  vec2 bpox = pos.xz*370.;bpox.y+=225.;bpox.x+=310.; bpox = abs(bpox);\n                  alb = min(alb,textureLod(iChannel0, (bpox/hres)/iResolution.xy, 0.5).rgb);\n                }\n\n                float spe = pow(max(0.0, dot(lig, ref)),32.0);\n                float sha = 1.;//calcSoftshadow( pos, lig, 0.03,3.0, 8.0 );\n                float amb = 0.8 + 0.3*dot(nor,normalize(vec3(0.0,1.0,0.0)));\n                if(roses){\n                  vec3 rcol = textureLod(iChannel1, (rpoz/hres)/iResolution.xy, 0.5).rgb;\n                  if(rcol.r>0.3&&rcol.g<0.3&&rcol.b<0.3){\n                        alb=rcol;\n                  }\n                  alb = min(alb, rcol);\n                  spe=0.;\n                  dif=0.4;\n                }\n                col =alb*amb + (spe*sha) + vec3(0.4,0.4,0.6)*dif/2.*sha;\n            } else {\n                col=min(col,alb);\n                \n            }\n            \n            if(alb.r>0.3&&alb.g<0.3&&alb.b<0.3){\n                col=alb;\n            }\n        }\n        }\n   \n        //float f = smoothstep(-0.7,-1.0, p.y);\n       // col = mix(col, bg, f);\n        // gamma        \n        //col = (col + sqrt( col ) + sqrt( col ))/3.;\n\t    tot += col;\n    #if AA>1\n        #if SAA>1\n        vec3 edgef = fwidth(edge);\n        float edget = edgef.x+edgef.y+edgef.z;\n        if(edget<0.1&&!miss){m=AA;}//else{tot=vec3(0);}\n        #endif\n    }\n    tot /= float(count);\n    #endif\n    //if(miss){tot=vec3(0);}\n    //if(sqrt((ndif.x*ndif.x) + (ndif.y*ndif.y)+ (ndif.z*ndif.z))>1.){tot=ndif;}\n    \n\tfragColor = vec4( tot, 1.0 );\n}",
     "name": "Buffer D",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3X2XDK",
    "date": "1746561953",
    "viewed": 92,
    "name": "fWidth from two images",
    "description": "Trying out a new way of getting fwidth from two images, from more than 2x2 cell.\nSimilar to this: https://www.shadertoy.com/view/3lt3DN - but using dFdx/dFdy instead of fwidth ",
    "likes": 3,
    "published": "Public",
    "usePreview": 1,
    "tags": [
     "postprocess",
     "derivatives",
     "dfdx",
     "dfdy",
     "aa",
     "fwidth",
     "edges",
     "hardware"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Update - now works with one buffer instead of three. I'm not sure it can be reduced further.\n\n/*\n I wanted to put this together to see if it would work, I still need to test it out properly.\n \n I'm not 100% sure this does what I think it does, or will give us any performance increase, but the output looks nice.\n\n The idea is to get fwidth from two 2x2 cells, using dx/dy in four directions, which might be as good as usign four cells.\n\n The idea being that dx/dy gives us two directions out of four, so we only need to double up to get a complete picture.\n (Fwidth on it's own gives us one direction of four, so we would need four of them for a complete picture.)\n \n Start by getting dFdx and dFdy from two images\n One has a 1,1 diagonal offset, so the retreived dx and dy go up and down and left and right\n the 2x2 fwidth cells are offset from each other. Each pixel is now in two 'fwidth cells'\n But the dx/dy now run in four directions, which I think means we can calculate four fWidth cells for the price of two:\n\n   F3  dy1  F1\n   \n        ^\n  dx2 < P > dx1\n        v\n        \n   F2  dy2  F4\n   \n (There is no F3 or F4, but with dx/dy in four directions it doesn't matter, does it?)\n \n\n*/\n\nfloat myFwidth( float xa, float ya, float xb, float yb  ){\n    return abs(xa) + abs(ya) +  abs(xb) + abs(yb); // same as fwidth calculation fwidth(p) = abs(dFdx(p)) + abs(dFdy(p)) but doubled up\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 imageA = texelFetch(iChannel0,  ivec2(fragCoord), 0); // first image\n    vec4 imageB = texelFetch(iChannel0, ivec2(fragCoord)+ivec2(-1,-1), 0); // second image, adjusted for offset\n\n    float total = myFwidth( imageA.r, imageA.g, imageB.b, imageB.a); //calculate total combined fwidth\n    \n    fragColor = vec4(pow( total/2., 0.45));\n    \n    if(iMouse.z>0.){\n        fragColor = 1.-fragColor;\n    }\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dfGRn",
       "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // this is the first image for dFdx in red and dFdy in green\n    vec4 imageColorA = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    // this is the second image for dFdx in blue and dFdy in alpha, with a 1,1 diagonal offset\n    vec4 imageColorB = texelFetch(iChannel0, ivec2(fragCoord)+ivec2(1,1), 0);\n    \n    fragColor = vec4(dFdx(imageColorA.r), dFdy(imageColorA.r), dFdx(imageColorB.r), dFdy(imageColorB.r));\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "33SXDd",
    "date": "0",
    "viewed": 0,
    "name": "Random Shader Explorer",
    "description": "An attempt to produce a random shader explorer",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "random",
     "chaos"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "float rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\n\nfloat rMath(float a, float s){\n    s = rand(s);\n    return s < 0.8 ? sin(a) : s < 0.7 ? fract(a) : s < 0.6 ? sqrt(a): s < 0.4 ? a*a : s < 0.2 ? atan(a) : abs(a);\n}\n\nfloat rMix(float a, float b, float s){\n    s = rand(s);\n    return s<0.9?atan(a,b):s<0.8?pow(a,b):s<0.7?a+b:s<0.6?a-b:s<0.5?b-a:s<0.4?a*b:s<0.2?a/b:s<0.1?mod(a,b):length(vec2(a,b));\n}\n\nfloat rFunc(float a, float b, float s){\n    s = rand(s);\n    return s < 0.5 ? rMix(a,b,s) : rMath(a,s) ;\n}\n\nfloat rInput(vec2 a, float c, float s){\n    s = rand(s);\n    return s < 0.9 ? c : s < 0.8 ? s : s < 0.4 ? a.x : a.y ;\n}\n\nfloat generate(vec2 a, float c, float s){\n    int iterations = 2 + int(floor(s*3.));\n    float num = rInput(a,c,s);\n    for(int i = 0; i<iterations; i++){\n        num = rFunc(num, rInput(a,c,s), s);    \n    }\n    return num;\n}\n\nfloat generate(float n, vec2 a, float c, float s){\n    int iterations = 2 + int(floor(s*3.));\n    float num = n;\n    for(int i = 0; i<iterations; i++){\n        num = rFunc(num, rInput(a,c,s), s);    \n    }\n    return num;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float seed = iMouse.x * iMouse.y;\n    \n    float red = generate(uv, iTime, seed);\n\n    float green = generate(red, uv, iTime, iMouse.x);\n\n    float blue = generate(red, uv, iTime, iMouse.y);\n\n    fragColor = vec4(red, green, blue ,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "W3BXDd",
    "date": "1746654186",
    "viewed": 37,
    "name": "Random Generative Shader",
    "description": "Attempting to make a random shader generator.\nStill early days, and lots of thing I think could be improved.",
    "likes": 2,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "random",
     "generative",
     "code"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "float rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\n\nfloat rMath(float a, float s){\n    s = rand(s);\n    return s > 0.8 ? sin(a) : s > 0.7 ? a*a : s > 0.6 ? sqrt(a): s > 0.4 ? a*a : s > 0.2 ? a*s : cos(a);\n}\n\nfloat rMix(float a, float b, float s){\n    s = rand(s);\n    return s>0.9?atan(a,b):s>0.8?pow(a,b):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?a*b:s>0.2?a/b:s>0.1?a*b:a+b;\n}\n\nfloat rFunc(float a, float b, float s){\n    s = rand(s);\n    return s < 0.5 ? rMix(a,b,s) : rMath(a,s) ;\n}\n\nfloat rInput(vec2 a, float c, float s){\n    s = rand(s);\n    return s > 0.9 ? c : s > 0.8 ? s*10. : s > 0.4 ? a.x : a.y ;\n}\n\nfloat generate(vec2 a, float c, float s){\n    s = rand(s);\n    int iterations = 15;\n    float num = rInput(a,c,s);\n    for(int i = 0; i<iterations; i++){\n        num = rFunc(num, rInput(a,c,s), s);    \n        \n    }\n    return num;\n}\n\nfloat generate(float n, vec2 a, float c, float s){\n    s = rand(s);\n    int iterations = 15;\n    float num = n;\n    for(int i = 0; i<iterations; i++){\n        num = rFunc(num, rInput(a,c,s), s);   \n        num = rFunc( rInput(a,c,s),num, s);\n    }\n    return num;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    float seed = iMouse.x * iMouse.y;\n    \n    float red = generate(uv, iTime, seed);\n\n    float green = generate(red, uv, iTime, seed+1.);\n\n    float blue = generate(green, uv, iTime, seed+2.);\n\n    fragColor = vec4(fract(abs(red)), fract(abs(green)), fract(abs(blue)) ,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3XjSWd",
    "date": "1746680724",
    "viewed": 53,
    "name": "Random Generative Shader v2",
    "description": "Second attempt, thinking about the maths some more - this is looking better.\nClick on the canvas to change the seed/iterations.",
    "likes": 2,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "random",
     "generative",
     "code"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Random Generative Shader\" by Cotterzz. https://shadertoy.com/view/W3BXDd\n// 2025-05-08 04:36:29\n\n#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))]\n\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\n\nfloat rMix(float a, float b, float s){\n    s = rand(s);\n    return s>0.9?sin(a):s>0.8?sqrt(a):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?b/a:s>0.2?a/b:s>0.1?a*b:cos(a);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float zoom = 13.*(sin(iTime/3.)+2.);\n    vec2 guv = (uv*zoom)-zoom;\n    float x = guv.x;\n    float y = guv.y;\n    \n    float ix = 506.;\n    float iy = 105.;\n    \n    if(iMouse.x>0.||iMouse.y>0.){\n        ix = iMouse.x; iy = iMouse.y;\n    }\n    \n    float seed = ix * iy;\n    \n    const int v = 24;\n    \n    float values[v];\n    \n    values[0] = 1.0;\n    values[1] = iTime;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*x*x*x*x;\n   values[11] = y*y*y*y*y;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = sin(iTime);\n   values[19] = distance(uv, vec2(0.5,0.5));\n   values[20] = 3.14159;\n   values[21] = atan(0.5-uv.x, 0.5-uv.y)/6.283;\n   values[22] = rand(fragCoord.x+fragCoord.y);\n   values[23] = rand(fragCoord.x+fragCoord.y);\n   \n    float total = 0.;\n    float sub = 0.;\n    int iterations = int(floor(1.+(iy/iResolution.y)*20.));\n    \n    for(int i = 0; i<iterations; i++){\n        sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE*(2.+values[18]), seed);\n        \n        if(rand(seed+float(i))>rand(seed)){\n            total = total==0. ? sub : rMix(total, sub, seed);\n            sub = 0.;\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, seed);\n    fragColor = vec4(total, 1./total, (1.+sin(total)/2.) ,1.0);\n    fragColor += (1.+cos(total+vec4(4,2,1,0))) / 2.;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wc33zr",
    "date": "1746718930",
    "viewed": 77,
    "name": "Random Generative Shaders v3",
    "description": "Improved version, I was using the same seed for repeated operations and missing a lot of variety, also added some multisampling.\nPreview grid - Click on the canvas to show/change individual seeds/iterations.",
    "likes": 5,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "random",
     "generative",
     "code"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Random Generative Shader v2\" by Cotterzz. https://shadertoy.com/view/3XjSWd\n// 2025-05-08 15:40:19\n\n// Fork of \"Random Generative Shader\" by Cotterzz. https://shadertoy.com/view/W3BXDd\n// 2025-05-08 04:36:29\n\n#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))]\n\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\n\nfloat rMix(float a, float b, float s){\n    s = rand(s);\n    return s>0.9?sin(a):s>0.8?sqrt(a):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?b/a:s>0.2?a/b:s>0.1?a*b:cos(a);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float zoom = 13.*(sin(iTime/3.)+2.);\n    vec2 guv = (uv*zoom)-zoom;\n    float x = guv.x;\n    float y = guv.y;\n    \n    float ix = 489.;\n    float iy = 144.;\n    \n    if(iMouse.z>0.){\n        ix = iMouse.x; iy = iMouse.y;\n    } else {\n\n        ix = floor(iTime+50.+(uv.x*2.));\n        iy = floor((iTime+50.+(uv.y*2.)));\n        iy = mod(iy, iResolution.y);\n\n    }\n    \n    float seed = ix + (iy/1000.0);\n    \n    const int v = 24;\n    \n    float values[v];\n    \n    values[0] = 1.0;\n    values[1] = iTime;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*x*x*x*x;\n   values[11] = y*y*y*y*y;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = sin(iTime);\n   values[19] = distance(uv, vec2(0.5,0.5));\n   values[20] = 3.14159;\n   values[21] = atan(0.5-uv.x, 0.5-uv.y)/6.283;\n   values[22] = rand(fragCoord.x+fragCoord.y);\n   values[23] = rand(fragCoord.x+fragCoord.y);\n   \n    float total = 0.;\n    float sub = 0.;\n    int iterations = int(floor(2.+(iy/iResolution.y)*20.));\n    \n    for(int i = 0; i<iterations; i++){\n        sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE*(2.+values[18]), seed+float(i));\n        \n        if(rand(seed+float(i))>rand(seed)){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2));\n            sub = 0.;\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, seed);\n    fragColor = vec4(fract(abs(total)), 1./total, 1.-fract(abs(total)) ,1.0);\n    if(rand(seed*2.)>0.5){fragColor = fragColor.gbra;}\n    if(rand(seed*3.)>0.5){fragColor = fragColor.gbra;}\n    if(rand(seed)>0.5){fragColor += (1.+cos(rand(total)+vec4(4,2,1,0))) / 2.;}\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define mainImage mainImage0(out vec4 O, vec2 U); \\\nvoid mainImage(out vec4 o, vec2 u) \\\n{ \\\n    float s =3., k; \\\n    vec2 j = vec2(.5); \\\n    o = vec4(0); \\\n    vec4 c; \\\n    mainImage0(c, u); \\\n    for (k = s; k-- > .5; ) { \\\n        mainImage0(c, u + j - .5); \\\n        o += c; \\\n        j = fract(j + vec2(.754877669, .569840296).yx); \\\n        \\\n    };o /= s;o.a==1.;\\\n    \\\n} \\\nvoid mainImage0",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wcc3RH",
    "date": "1746772534",
    "viewed": 132,
    "name": "Random Generative Shaders v4",
    "description": "I caught most of the exceptions that were giving blank shaders (div by 0, sqrt of negative etc) and continued to improve the equation stitching for optimal visual results - Click on the canvas and drag!",
    "likes": 11,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "random",
     "generative",
     "code"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Random Generative Shaders v3\" by Cotterzz. https://shadertoy.com/view/Wc33zr\n// 2025-05-09 06:01:58\n\n// Fork of \"Random Generative Shader v2\" by Cotterzz. https://shadertoy.com/view/3XjSWd\n// 2025-05-08 15:40:19\n\n// Fork of \"Random Generative Shader\" by Cotterzz. https://shadertoy.com/view/W3BXDd\n// 2025-05-08 04:36:29\n\n#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i)))\n#define NEWVALUE2 values[int(floor(float(v)*rand(seed+float(i+5))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i+5)))\n#define PREVIEW 1\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\n\nfloat rMix(float a, float b, float s){\n    s = rand(s);\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?b/(a==0.?0.01:a):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n}\n\nvec3 addColor(float num, float seed, float alt){\n\n    if(isinf(num)){num = alt * seed;}\n    vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n    if(rand(seed*2.)>0.5){col = col.gbr;}\n    if(rand(seed*3.)>0.5){col = col.gbr;}\n    if(rand(seed)>0.5){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n   float zoom = 1. + (3.*(sin(iTime)+1.));\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    \n    float ix = 489.;\n    float iy = 144.;\n    ix = iMouse.x; iy = iMouse.y;\n    \n    float thumb = 7.+sin((iTime/2.)-1.62)*3.;\n    \n    if(!(iMouse.z>0.)&& bool(PREVIEW)){\n        float pantime = (iTime)+50.;\n\n        ix = floor(pantime+(uv.x*thumb/(iResolution.x/iResolution.y)));\n        iy = floor((pantime+(uv.y*thumb)));\n\n        uv.y*=thumb;\n        uv.x*=thumb/(iResolution.x/iResolution.y);\n        uv+=pantime;\n        uv=fract(uv);\n        uv.x-=0.5;\n        uv.y-=0.5;\n        guv = (uv*zoom);\n        x = guv.x;\n        y = guv.y;\n    }\n    \n    float seed = (ix + (iy*iResolution.x))/iResolution.x;\n    \n    const int v = 24;\n    \n    vec3 col = vec3(0);\n    float cn = 1.;\n    \n    float values[v];\n    \n    values[0] = 1.0;\n    values[1] = 10.0;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = 2.;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = 3.14159;\n   values[21] = atan(x, y)*4.;\n   values[22] = tan(x);\n   values[23] = tan(y);\n   \n    float total = 0.;\n    float sub = 0.;\n    int maxi = 30; int mini = 1;\n    int iterations = min(maxi,mini + int(floor((iy/iResolution.y)*float(maxi-mini))));\n    \n    \n    \n    \n    for(int i = 0; i<iterations; i++){\n        if(rand(seed+float(i+3))>rand(seed)){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)), seed+float(i));\n\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i));\n      \n        }\n        if(rand(seed+float(i))>rand(seed)/2.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2));\n            sub = 0.;\n            col += addColor(total, seed+float(i), values[21]);\n            cn+=1.;\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, seed);\n    col += addColor(total, seed, values[21]);\n    col /=cn*3.* (0.5 + rand(seed+13.));\n    fragColor = vec4(col, 1.);\n    \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wc33RN",
    "date": "1746838921",
    "viewed": 68,
    "name": "Random Audio Shaders v1",
    "description": "First attempt, thx to diatribes for suggestion. It's a bit out there.\nClick/drag to change main shader.",
    "likes": 6,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "random",
     "audio",
     "generative",
     "code",
     "visualisation"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sXGzn",
       "filepath": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Random Generative Shaders v4\" by Cotterzz. https://shadertoy.com/view/Wcc3RH\n// 2025-05-10 00:24:10\n\n// Fork of \"Random Generative Shaders v3\" by Cotterzz. https://shadertoy.com/view/Wc33zr\n// 2025-05-09 06:01:58\n\n// Fork of \"Random Generative Shader v2\" by Cotterzz. https://shadertoy.com/view/3XjSWd\n// 2025-05-08 15:40:19\n\n// Fork of \"Random Generative Shader\" by Cotterzz. https://shadertoy.com/view/W3BXDd\n// 2025-05-08 04:36:29\n\n#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))] * texture(iChannel0, vec2(0.5,1.0)).r\n#define NEWVALUE2 values[int(floor(float(v)*rand(seed+float(i+5))))] * texture(iChannel0, vec2(0.5,0.0)).r\n\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\n\nfloat rMix(float a, float b, float s){\n    s = rand(s);\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?b/(a==0.?0.01:a):s>0.2?texture(iChannel0, vec2(abs(a),0.0)).r:s>0.1?a*b:texture(iChannel0, vec2(abs(a),1.0)).r;\n}\n\nvec3 addColor(float num, float seed, float alt){\n\n    if(isinf(num)){num = alt * seed;}\n    vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n    if(rand(seed*2.)>0.5){col = col.gbr;}\n    if(rand(seed*3.)>0.5){col = col.gbr;}\n    if(rand(seed)>0.5){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    float zoom = 1. + (3.*(sin(iTime)+1.));\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    \n    float ix = 489.;\n    float iy = 144.;\n    ix = iMouse.x; iy = iMouse.y;\n    \n    float thumb = 7.+sin((iTime/2.)-1.62)*3.;\n    float border = 0.4;\n    bool front = true;\n    if(uv.x<(-border*(iResolution.x/iResolution.y)) || uv.x>(border*(iResolution.x/iResolution.y))||uv.y<-border || uv.y>border){\n        front=false;\n        float pantime = (iTime)+50.;\n\n        ix = floor(pantime+(uv.x*thumb/(iResolution.x/iResolution.y)));\n        iy = floor((pantime+(uv.y*thumb)));\n\n        uv.y*=thumb;\n        uv.x*=thumb/(iResolution.x/iResolution.y);\n        uv+=pantime;\n        uv=fract(uv);\n        uv.x-=0.5;\n        uv.y-=0.5;\n        guv = (uv*zoom);\n        x = guv.x;\n        y = guv.y;\n    }\n    \n    float seed = (ix + (iy*iResolution.x))/iResolution.x;\n    \n    const int v = 24;\n    \n    vec3 col = vec3(0);\n    float cn = 1.;\n    \n    float values[v];\n    \n    values[0] = 1.0;\n    values[1] = texture(iChannel0, vec2(atan(x, y),1.0)).r;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = texture(iChannel0, vec2(abs(x),0.0)).r;\n   values[11] = texture(iChannel0, vec2(abs(y),0.0)).r;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = texture(iChannel0, vec2(abs(x),1.0)).r;\n   values[18] = texture(iChannel0, vec2(atan(x, y),0.0)).r;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = texture(iChannel0, vec2(distance(vec2(x,y), vec2(0)),1.0)).r;\n   values[21] = atan(x, y)*4.;\n   values[22] = texture(iChannel0, vec2(abs(x),1.0)).r;\n   values[23] = texture(iChannel0, vec2(abs(y),1.0)).r;\n   \n    float total = 0.;\n    float sub = 0.;\n    int maxi = 30; int mini = 1;\n    int iterations = min(maxi,mini + int(floor((iy/iResolution.y)*float(maxi-mini))));\n    \n    \n    \n    \n    for(int i = 0; i<iterations; i++){\n        if(rand(seed+float(i+3))>rand(seed)){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)), seed+float(i));\n\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i));\n      \n        }\n        if(rand(seed+float(i))>rand(seed)/2.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2));\n            sub = 0.;\n            col += addColor(total, seed+float(i), values[21]);\n            cn+=1.;\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, seed);\n    col += addColor(total, seed, values[21]);\n    col /=cn*5.;\n    if(!front){\n       col =( vec3(1) + col) /4.;\n    }\n    fragColor = vec4(col, 1.);\n    float frame = 0.03;\n    if((abs(abs(uv.x)-border*(iResolution.x/iResolution.y))<frame || abs(abs(uv.y)-border)<frame) && front ){fragColor = vec4(0,0,0, 1.);}\n    \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wf3GRN",
    "date": "1746860067",
    "viewed": 94,
    "name": "Random Generative Shaders v5",
    "description": "Big change to the colour generation. Exploring different options.\nYou can select specific palette modes, 9 is random, set to 8 to compare.\nClick on the canvas and drag!",
    "likes": 4,
    "published": "Public",
    "usePreview": 1,
    "tags": [
     "random",
     "generative",
     "code"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Random Generative Shaders v4\" by Cotterzz. https://shadertoy.com/view/Wcc3RH\n// 2025-05-10 06:21:07\n\n// Fork of \"Random Generative Shaders v3\" by Cotterzz. https://shadertoy.com/view/Wc33zr\n// 2025-05-09 06:01:58\n\n// Fork of \"Random Generative Shader v2\" by Cotterzz. https://shadertoy.com/view/3XjSWd\n// 2025-05-08 15:40:19\n\n// Fork of \"Random Generative Shader\" by Cotterzz. https://shadertoy.com/view/W3BXDd\n// 2025-05-08 04:36:29\n\n\n#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i)))\n#define NEWVALUE2 values[int(floor(float(v)*rand(seed+float(i+5))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i+5)))\n\n#define PREVIEW 1\n\n#define NOISE 0\n\n// PREVIEW 0 to disable preview mode\n// SHOWITER 0 to disable iterations view\n// select palette mode below\n\nint PALETTE = 9;\n\n// 0 = Original\n// 1 = Original with hsl mixed\n// 2 = Original translated to hsl\n// 3 = hsl calculated\n// 4 = hsl enhanced\n// 5 = hsl*2\n// 6 = weird\n// 7 = fhex\n// 8 = Banded.\n// 9 = RANDOMISE!!!\n\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\n\nfloat nz(vec2 nv){\n     if(NOISE == 1){\n     nv.y+=iTime;\n     nv.x/=nv.y;\n        float o = 0.;\n    for (float i = .2; i < 2.;\n        o += abs(dot(sin(nv * i * 32.), vec2(.05))) / i,\n        i *= 1.4142);\n   return o;} else {return nv.x+ abs(dot(sin(nv * nv.y * 32.), vec2(.05))) / nv.y;}\n}\n\nfloat rMix(float a, float b, float s){\n    s = rand(s);\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?nz(vec2(a,b)):s>0.3?b/(a==0.?0.01:a):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n}\nvec3 getPsychedelicColor(float t) {\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 gmc(vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\nvec3 fhexRGB(float fh){\n    return contrast(getPsychedelicColor(fh),1.7);\n}\n\nvec3 addColor(float num, float seed, float alt){\n    if(isinf(num)){num = alt * seed;}\n    if(PALETTE == 7){\n        vec3 col = fhexRGB(num);\n        return col;} else if(PALETTE > 2 || (PALETTE == 1 && rand(seed+19.)>0.3)){\n    \n        float sat = 1.;\n        if(num<0.){sat = 1.-(1./(abs(num)+1.));}\n        float light = 1.0-(1./(abs(num)+1.));\n\n        vec3 col = hsl2rgb(vec3(fract(abs(num)), sat, light));\n        if(PALETTE == 1){col *= 2.;}\n       \n        return col;\n       \n    } else {\n\n        vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n        if(rand(seed*2.)>0.5){col = col.gbr;}\n        if(rand(seed*3.)>0.5){col = col.gbr;}\n        if(PALETTE == 1){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n        // if(PALETTE == 0){col = contrast(col, 1.01); }\n        return col;\n    \n    }\n}\n\nvec3 sanitize(vec3 dc){\n    dc.r = min(1., dc.r);\n    dc.g = min(1., dc.g);\n    dc.b = min(1., dc.b);\n    \n    if(!(dc.r>=0.) && !(dc.r<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.g>=0.) && !(dc.g<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.b>=0.) && !(dc.b<0.)){\n        return vec3(1,0,0);\n    } else {\n        return dc;\n    }\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n         uv.x=abs(uv.x)<0.001?0.01:uv.x;\n     uv.y=abs(uv.y)<0.001?0.01:uv.y;\n    float zoom = 4. + (3.*(sin(iTime)+1.));\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    \n    float ix = 489.;\n    float iy = 144.;\n    ix = iMouse.x; iy = iMouse.y;\n    \n    float thumb = 5.+sin((iTime/2.)-1.62)*2.;\n  \n    \n    if(!(iMouse.z>0.)&& bool(PREVIEW) && iMouse.x==0. && iMouse.y==0. ){\n        float pantime = (iTime)+50.;\n\n        ix = floor(pantime+(uv.x*thumb/(iResolution.x/iResolution.y)));\n        iy = floor((pantime+(uv.y*thumb)));\n\n        uv.y*=thumb;\n        uv.x*=thumb/(iResolution.x/iResolution.y);\n        uv+=pantime;\n        uv=fract(uv);\n        uv.x-=0.5;\n        uv.y-=0.5;\n        guv = (uv*zoom);\n        x = guv.x;\n        y = guv.y;\n    }\n    \n    float seed = (ix + (iy*iResolution.x))/iResolution.x;\n    \n    if(PALETTE == 9){\n        PALETTE = int(floor(float(8)*rand(seed+66.)));\n    }\n\n    if(PALETTE == 8){\n        PALETTE = int(floor(fragCoord.x/iResolution.x * 8.));\n    }\n    \n    const int v = 24;\n\n    vec3 col = vec3(0);\n    float cn = 1.;\n    \n    float values[v];\n    \n    values[0] = 1.0;\n    values[1] = 10.0;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = 2.;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = acos(min(abs(x/y), 0.99));\n   values[21] = atan(x, y)*4.;\n   values[22] = nz(uv);\n   values[23] = nz(uv.yx);\n   \n    float total = 0.;\n    float sub = 0.;\n    int maxi = 30; int mini = 4;\n    int iterations = min(maxi,mini + int(floor(rand(seed*6.6)*float(maxi-mini))));\n    \n    \n    \n    \n    for(int i = 0; i<iterations; i++){\n        if(rand(seed+float(i+3))>rand(seed)){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)), seed+float(i));\n\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i));\n      \n        }\n        if(rand(seed+float(i))>rand(seed)/2.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2));\n            sub = 0.;\n            col += addColor(total, seed+float(i), values[21]);\n            cn+=1.;\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, seed);\n    col += addColor(total, seed, values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + rand(seed+13.)));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(rand(seed+17.)>0.5){col = col.gbr;}\n        if(rand(seed+19.)>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n    fragColor = vec4(col, 1.);\n\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3fc3Dn",
    "date": "1746941915",
    "viewed": 101,
    "name": "Random Volumetric Shader",
    "description": "Added cloud/noise parameter.\nBut also it's filling a volume! See Settings on buffer A.\nClick on the canvas to change shader.",
    "likes": 8,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "random",
     "volumetric",
     "generative",
     "code"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Random Generative Shaders v5\" by Cotterzz. https://shadertoy.com/view/wf3GRN\n// 2025-05-10 22:57:51\n\n// Fork of \"Random Generative Shaders v4\" by Cotterzz. https://shadertoy.com/view/Wcc3RH\n// 2025-05-10 06:21:07\n\n// Fork of \"Random Generative Shaders v3\" by Cotterzz. https://shadertoy.com/view/Wc33zr\n// 2025-05-09 06:01:58\n\n// Fork of \"Random Generative Shader v2\" by Cotterzz. https://shadertoy.com/view/3XjSWd\n// 2025-05-08 15:40:19\n\n// Fork of \"Random Generative Shader\" by Cotterzz. https://shadertoy.com/view/W3BXDd\n// 2025-05-08 04:36:29\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "float hash1(vec2 x)\n{\n    uvec2 t = floatBitsToUint(x);\n    uint h = 0xc2b2ae3du * t.x + 0x165667b9u;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h += 0xc2b2ae3du * t.y;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h ^= h >> 15u;\n    h *= 0x85ebca77u;\n    h ^= h >> 13u;\n    h *= 0xc2b2ae3du;\n    h ^= h >> 16u;\n    return uintBitsToFloat(h >> 9u | 0x3f800000u) - 1.0;\n}\n\nvec2 hash2(vec2 x) // improved hash using xxhash\n{\n    float k = 6.283185307 * hash1(x);\n    return vec2(cos(k), sin(k));\n}\n\nfloat noise2( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*vec3( dot(a,hash2(i+0.0)), dot(b,hash2(i+o)), dot(c,hash2(i+1.0))); // changed to h^3 [1]\n    return dot( n, vec3(32.99) ); // analytic factor (= 2916*sqrt(2)/125)\n}\n\nfloat pnoise (vec2 uv){\n    float f = 0.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2( uv ); uv = m*uv;\n    f += 0.2500*noise2( uv ); uv = m*uv;\n    f += 0.1250*noise2( uv ); uv = m*uv;\n    f += 0.0625*noise2( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n    return f;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i)))\n#define NEWVALUE2 values[int(floor(float(v)*rand(seed+float(i+5))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i+5)))\n#define T (iTime*4.)\n#define rot(a) mat2(cos(a+vec4(0,33,11,0)))\n#define P(z) (vec3(tanh(cos((z) * .15) * 1.) * 8., \\\n                   tanh(cos((z) * .12) * 1.) * 8., (z)))\n\n\n// PREVIEW 0 to disable preview mode\n// SHOWITER 0 to disable iterations view\n// select palette mode below\n\n#define PREVIEW 0\n#define SHOWITER 0\n#define VOLUMETRIC 1\n\nfloat displaytime = 2.5; // seconds between switch\n\nint PALETTE = 9;\n\n// 0 = Original\n// 1 = Original with hsl mixed\n// 2 = Original translated to hsl\n// 3 = hsl calculated\n// 4 = hsl enhanced\n// 5 = hsl*2\n// 6 = weird\n// 7 = fhex\n// 8 = Banded.\n// 9 = RANDOMISE!!!\n\nvec3 p = vec3(0);\n\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\nfloat map(vec3 p) {\n    return 1.5 - length(p - P(p.z));\n}\nfloat rMix(float a, float b, float s){\n    s = rand(s);\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?b/(a==0.?0.01:a):s>0.3?pnoise(vec2(a,b)):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n}\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 gmc(vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\nvec3 fhexRGB(float fh){\n    if(isinf(fh)||fh>100000.){fh = 0.;}\n    fh = abs(fh*10000000.);\n    float r = fract(fh/65536.);\n    float g = fract(fh/256.);\n    float b= fract(fh/16777216.);\n    //return gmc(contrast(hsl2rgb(vec3(r,g,b)), 0.9), 0.9);\n   return hsl2rgb(vec3(r,g,b));\n}\n\nvec3 addColor(float num, float seed, float alt){\n    if(isinf(num)){num = alt * seed;}\n    if(PALETTE == 7){\n        vec3 col = fhexRGB(num);\n        return col;} else if(PALETTE > 2 || (PALETTE == 1 && rand(seed+19.)>0.3)){\n    \n        float sat = 1.;\n        if(num<0.){sat = 1.-(1./(abs(num)+1.));}\n        float light = 1.0-(1./(abs(num)+1.));\n\n        vec3 col = hsl2rgb(vec3(fract(abs(num)), sat, light));\n        if(PALETTE == 1){col *= 2.;}\n       \n        return col;\n       \n    } else {\n\n        vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n        if(rand(seed*2.)>0.5){col = col.gbr;}\n        if(rand(seed*3.)>0.5){col = col.gbr;}\n        if(PALETTE == 1){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n        // if(PALETTE == 0){col = contrast(col, 1.01); }\n        return col;\n    \n    }\n}\n\nvec3 sanitize(vec3 dc){\n    dc.r = min(1., abs(dc.r));\n    dc.g = min(1., abs(dc.g));\n    dc.b = min(1., abs(dc.b));\n    \n    if(!(dc.r>=0.) && !(dc.r<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.g>=0.) && !(dc.g<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.b>=0.) && !(dc.b<0.)){\n        return vec3(1,0,0);\n    } else {\n        return dc;\n    }\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n     vec3  r = iResolution;\n    vec2 u = fragCoord;\n    \n        \n        float s=.002,d,i, l;\n\n        u = (u-r.xy/2.)/r.y;\n    \n        vec3  p = P(T),ro=p,q,\n              Z = normalize( P(T+1.)  - p),\n              X = normalize(vec3(Z.z,0,-Z)),\n              D = vec3(rot(tanh(sin(p.z*.03)*8.)*3.)*u, 1)* mat3(-X, cross(X, Z), Z);\n       \n        for(; i++<80. && s > .001; ) {\n    \n            p = ro + D * d,\n            s = map(p)*.8,\n            d += s;\n        }\n        p = ro + D * d;\n        \n    vec2 uv = fragCoord/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    float zoom = 4.;\n    if(VOLUMETRIC == 1 ){ zoom+= (1.5*(sin(iTime)+1.)); } else { zoom+= (3.*(sin(iTime)+1.));}\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    \n    float ix = 468.;\n    float iy = 330.;\n    if(iMouse.x>0.&&iMouse.y>0.){\n    ix = iMouse.x; iy = iMouse.y;}\n    \n    float thumb = 5.+sin((iTime/2.)-1.62)*2.;\n    \n    if(!(iMouse.z>0.)&& bool(PREVIEW)){\n        float pantime = (iTime)+50.;\n\n        ix = floor(pantime+(uv.x*thumb/(iResolution.x/iResolution.y)));\n        iy = floor((pantime+(uv.y*thumb)));\n\n        uv.y*=thumb;\n        uv.x*=thumb/(iResolution.x/iResolution.y);\n        uv+=pantime;\n        uv=fract(uv);\n        uv.x-=0.5;\n        uv.y-=0.5;\n        guv = (uv*zoom);\n        x = guv.x;\n        y = guv.y;\n    }\n    \n    float seed = (ix + (iy*iResolution.x))/iResolution.x;\n    \n    if(!(iMouse.z>0.) && iMouse.x==0. && iMouse.y==0.){\n        seed = floor(iTime+50./displaytime);\n    }\n    \n    if(PALETTE == 9){\n        PALETTE = int(floor(float(8)*rand(seed+66.)));\n    }\n\n    if(PALETTE == 8){\n        PALETTE = int(floor(fragCoord.x/iResolution.x * 8.));\n    }\n    \n    const int v = 24;\n    \n    vec3 col = vec3(0);\n    float cn = 1.;\n    \n    float values[v];\n    \n    values[0] = 1.0;\n    values[1] = p.x;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = p.y;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = p.z;\n   values[21] = atan(x, y)*4.;\n   values[22] = pnoise(vec2(x,y)/2.);\n   values[23] = pnoise(vec2(y,x)*10.);\n   \n    float total = 0.;\n    float sub = 0.;\n    int maxi = 40; int mini = 4;\n    int iterations = min(maxi,mini + int(floor(rand(seed*6.6)*float(maxi-mini))));\n    \n    \n    \n    \n    for(int i = 0; i<iterations; i++){\n        if(rand(seed+float(i+3))>rand(seed)){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)), seed+float(i));\n\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i));\n      \n        }\n        if(rand(seed+float(i))>rand(seed)/2.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2));\n            sub = 0.;\n            if(rand(seed+float(i+30))>rand(seed)){\n                col += addColor(total, seed+float(i), values[21]);\n                cn+=1.;\n            }\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, seed);\n    col += addColor(total, seed, values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + rand(seed+13.)));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(rand(seed+17.)>0.5){col = col.gbr;}\n        if(rand(seed+19.)>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n    if(VOLUMETRIC == 1 ) { \n    uv+=vec2(0.25,0.15);\n    if(abs(uv.x)>0.6 || abs(uv.y)>0.32){col=vec3(0);}\n    vec3 old = textureLod(iChannel0, (fragCoord+vec2(-2.,-1.))/iResolution.xy, 0.).rgb;\n    float alph = (col.r+col.g+col.b)/3.;\n    alph = alph<0.5?0.0:alph<0.7?(alph-0.5)*5.:1.0;\n    fragColor = vec4(mix(old, col, alph), 1.);\n    } else {\n    fragColor = vec4(col, 1.);\n    }\n\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tct3Wn",
    "date": "1746994899",
    "viewed": 48,
    "name": "Random Generative Shaders v6",
    "description": "Added tunneling and automatic switching between tunnel, volume and original\nSee settings on buffer A.",
    "likes": 3,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "random",
     "volumetric",
     "generative",
     "code",
     "tunneling"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Random Volumetric Shader\" by Cotterzz. https://shadertoy.com/view/3fc3Dn\n// 2025-05-11 20:14:46\n\n// Fork of \"Random Generative Shaders v5\" by Cotterzz. https://shadertoy.com/view/wf3GRN\n// 2025-05-10 22:57:51\n\n// Fork of \"Random Generative Shaders v4\" by Cotterzz. https://shadertoy.com/view/Wcc3RH\n// 2025-05-10 06:21:07\n\n// Fork of \"Random Generative Shaders v3\" by Cotterzz. https://shadertoy.com/view/Wc33zr\n// 2025-05-09 06:01:58\n\n// Fork of \"Random Generative Shader v2\" by Cotterzz. https://shadertoy.com/view/3XjSWd\n// 2025-05-08 15:40:19\n\n// Fork of \"Random Generative Shader\" by Cotterzz. https://shadertoy.com/view/W3BXDd\n// 2025-05-08 04:36:29\n\n#define T (iTime*4.)\n#define rot(a) mat2(cos(a+vec4(0,33,11,0)))\n#define P(z) (vec3(tanh(cos((z) * .15) * 1.) * 8., \\\n                   tanh(cos((z) * .12) * 1.) * 8., (z)))\n\nfloat map(vec3 p) {\n    return 1.5 - length(p - P(p.z));\n}\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec3  r = iResolution;\n    vec2 fragCoord = u;\n    o = texture(iChannel0, u/r.xy,0.); // original or volumne\n    \n    if(o.a<1.){  // tunneling - thanks to diatribes for suggestion/code\n        o.a = 1.;\n        float s=.002,d,i, l;\n\n        u = (u-r.xy/2.)/r.y;\n    \n        vec3  p = P(T),ro=p,q,\n              Z = normalize( P(T+1.)  - p),\n              X = normalize(vec3(Z.z,0,-Z)),\n              D = vec3(rot(tanh(sin(p.z*.03)*8.)*3.)*u, 1)* mat3(-X, cross(X, Z), Z);\n        o -= o;\n        for(; i++<80. && s > .001; ) {\n    \n            p = ro + D * d,\n            s = map(p)*.8,\n            d += s;\n        }\n        p = ro + D * d;\n\n        o.rgb = texture(iChannel0, p.xy/4.,0.).rgb/(d/2.);\n    }\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "float hash1(vec2 x)\n{\n    uvec2 t = floatBitsToUint(x);\n    uint h = 0xc2b2ae3du * t.x + 0x165667b9u;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h += 0xc2b2ae3du * t.y;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h ^= h >> 15u;\n    h *= 0x85ebca77u;\n    h ^= h >> 13u;\n    h *= 0xc2b2ae3du;\n    h ^= h >> 16u;\n    return uintBitsToFloat(h >> 9u | 0x3f800000u) - 1.0;\n}\n\nvec2 hash2(vec2 x) // improved hash using xxhash\n{\n    float k = 6.283185307 * hash1(x);\n    return vec2(cos(k), sin(k));\n}\n\nfloat noise2( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*vec3( dot(a,hash2(i+0.0)), dot(b,hash2(i+o)), dot(c,hash2(i+1.0))); // changed to h^3 [1]\n    return dot( n, vec3(32.99) ); // analytic factor (= 2916*sqrt(2)/125)\n}\n\nfloat pnoise (vec2 uv){\n    float f = 0.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2( uv ); uv = m*uv;\n    f += 0.2500*noise2( uv ); uv = m*uv;\n    f += 0.1250*noise2( uv ); uv = m*uv;\n    f += 0.0625*noise2( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n    return f;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i)))\n#define NEWVALUE2 values[int(floor(float(v)*rand(seed+float(i+5))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i+5)))\n\n// SELECTMODE 0 automatic 1 mouse position 2 preview thumbs\n#define SELECTMODE 0\n\nfloat displaytime = 1.3; // seconds between switch\n\n// DISPLAYMODE 0-original 1-volumetric 2-tunnel 3-random\nint DISPLAYMODE = 3;\n\n// select palette mode below\n\nint PALETTE = 9;\n\n// 0 = Original\n// 1 = Original with hsl mixed\n// 2 = Original translated to hsl\n// 3 = hsl calculated\n// 4 = hsl enhanced\n// 5 = hsl*2\n// 6 = weird\n// 7 = fhex\n// 8 = Banded.\n// 9 = RANDOMISE!!!\n\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\n\nfloat rMix(float a, float b, float s){\n    s = rand(s);\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?b/(a==0.?0.01:a):s>0.3?pnoise(vec2(a,b)):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n}\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 gmc(vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\nvec3 fhexRGB(float fh){\n    if(isinf(fh)||fh>100000.){fh = 0.;}\n    fh = abs(fh*10000000.);\n    float r = fract(fh/65536.);\n    float g = fract(fh/256.);\n    float b= fract(fh/16777216.);\n    //return gmc(contrast(hsl2rgb(vec3(r,g,b)), 0.9), 0.9);\n   return hsl2rgb(vec3(r,g,b));\n}\n\nvec3 addColor(float num, float seed, float alt){\n    if(isinf(num)){num = alt * seed;}\n    if(PALETTE == 7){\n        vec3 col = fhexRGB(num);\n        return col;} else if(PALETTE > 2 || (PALETTE == 1 && rand(seed+19.)>0.3)){\n    \n        float sat = 1.;\n        if(num<0.){sat = 1.-(1./(abs(num)+1.));}\n        float light = 1.0-(1./(abs(num)+1.));\n\n        vec3 col = hsl2rgb(vec3(fract(abs(num)), sat, light));\n        if(PALETTE == 1){col *= 2.;}\n       \n        return col;\n       \n    } else {\n\n        vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n        if(rand(seed*2.)>0.5){col = col.gbr;}\n        if(rand(seed*3.)>0.5){col = col.gbr;}\n        if(PALETTE == 1){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n        // if(PALETTE == 0){col = contrast(col, 1.01); }\n        return col;\n    \n    }\n}\n\nvec3 sanitize(vec3 dc){\n    dc.r = min(1., abs(dc.r));\n    dc.g = min(1., abs(dc.g));\n    dc.b = min(1., abs(dc.b));\n    \n    if(!(dc.r>=0.) && !(dc.r<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.g>=0.) && !(dc.g<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.b>=0.) && !(dc.b<0.)){\n        return vec3(1,0,0);\n    } else {\n        return dc;\n    }\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    float zoom = 4.;\n    if(DISPLAYMODE == 1 ){ zoom+= (1.5*(sin(iTime)+1.)); } else { zoom+= (3.*(sin(iTime)+1.));}\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    \n    float ix = 468.;\n    float iy = 330.;\n    if(iMouse.x>0.&&iMouse.y>0.){\n    ix = iMouse.x; iy = iMouse.y;}\n    \n    float thumb = 5.+sin((iTime/2.)-1.62)*2.;\n    \n    if(!(iMouse.z>0.)&& SELECTMODE == 2){\n        float pantime = (iTime)+50.;\n\n        ix = floor(pantime+(uv.x*thumb/(iResolution.x/iResolution.y)));\n        iy = floor((pantime+(uv.y*thumb)));\n\n        uv.y*=thumb;\n        uv.x*=thumb/(iResolution.x/iResolution.y);\n        uv+=pantime;\n        uv=fract(uv);\n        uv.x-=0.5;\n        uv.y-=0.5;\n        guv = (uv*zoom);\n        x = guv.x;\n        y = guv.y;\n    }\n    \n    float seed = SELECTMODE == 0 ? floor(iTime/displaytime) : (ix + (iy*iResolution.x))/iResolution.x;\n    \n    if(DISPLAYMODE == 3) { DISPLAYMODE = int(floor(float(3)*rand(seed+77.)));}\n    \n    if(PALETTE == 9){\n        PALETTE = int(floor(float(8)*rand(seed+66.)));\n    }\n\n    if(PALETTE == 8){\n        PALETTE = int(floor(fragCoord.x/iResolution.x * 8.));\n    }\n    \n    const int v = 24;\n    \n    vec3 col = vec3(0);\n    float cn = 1.;\n    \n    float values[v];\n    \n    values[0] = 1.0;\n    values[1] = 10.0;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = 2.;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = 3.14159;\n   values[21] = atan(x, y)*4.;\n   values[22] = pnoise(vec2(x,y)/2.);\n   values[23] = pnoise(vec2(y,x)*10.);\n   \n    float total = 0.;\n    float sub = 0.;\n    int maxi = 50; int mini = 1;\n    int iterations = min(maxi,mini + int(floor(rand(seed*6.6)*float(maxi-mini))));\n    \n    \n    \n    \n    for(int i = 0; i<iterations; i++){\n        if(rand(seed+float(i+3))>rand(seed)){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)), seed+float(i));\n\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i));\n      \n        }\n        if(rand(seed+float(i))>rand(seed)/2.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2));\n            sub = 0.;\n            if(rand(seed+float(i+30))>rand(seed)){\n                col += addColor(total, seed+float(i), values[21]);\n                cn+=1.;\n            }\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, seed);\n    col += addColor(total, seed, values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + rand(seed+13.)));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(rand(seed+17.)>0.5){col = col.gbr;}\n        if(rand(seed+19.)>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n    if(DISPLAYMODE == 1 ) { \n    uv+=vec2(0.16,0.1);\n    if(abs(uv.x)>0.6 || abs(uv.y)>0.32){col=vec3(0);}\n    vec3 old = texture(iChannel0, (fragCoord+vec2(-1,-1))/iResolution.xy, 0.).rgb*0.98;\n    float alph = (col.r+col.g+col.b)/3.;\n    alph = alph<0.5?0.0:alph<0.7?(alph-0.5)*5.:1.0;\n    fragColor = vec4(mix(old, col, alph), 1.);\n    } else {\n       fragColor = vec4(col, DISPLAYMODE == 2 ? 0.5 : 1.0);\n    }\n\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wft3Dr",
    "date": "1747011128",
    "viewed": 58,
    "name": "Random Feedback Shader",
    "description": "This one's a bit unpredictable. It's feeding back adjacent pixels from itself on previous frame as terms.\nIt's also changing the structure of the equation depending on value of previously evaluated terms!\nSo it's gone really weird.",
    "likes": 4,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "random",
     "volumetric",
     "generative",
     "code",
     "automata",
     "feedback",
     "chaotic"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Random Volumetric Shader\" by Cotterzz. https://shadertoy.com/view/3fc3Dn\n// 2025-05-11 23:02:25\n\n// Fork of \"Random Generative Shaders v5\" by Cotterzz. https://shadertoy.com/view/wf3GRN\n// 2025-05-10 22:57:51\n\n// Fork of \"Random Generative Shaders v4\" by Cotterzz. https://shadertoy.com/view/Wcc3RH\n// 2025-05-10 06:21:07\n\n// Fork of \"Random Generative Shaders v3\" by Cotterzz. https://shadertoy.com/view/Wc33zr\n// 2025-05-09 06:01:58\n\n// Fork of \"Random Generative Shader v2\" by Cotterzz. https://shadertoy.com/view/3XjSWd\n// 2025-05-08 15:40:19\n\n// Fork of \"Random Generative Shader\" by Cotterzz. https://shadertoy.com/view/W3BXDd\n// 2025-05-08 04:36:29\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "float hash1(vec2 x)\n{\n    uvec2 t = floatBitsToUint(x);\n    uint h = 0xc2b2ae3du * t.x + 0x165667b9u;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h += 0xc2b2ae3du * t.y;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h ^= h >> 15u;\n    h *= 0x85ebca77u;\n    h ^= h >> 13u;\n    h *= 0xc2b2ae3du;\n    h ^= h >> 16u;\n    return uintBitsToFloat(h >> 9u | 0x3f800000u) - 1.0;\n}\n\nvec2 hash2(vec2 x) // improved hash using xxhash\n{\n    float k = 6.283185307 * hash1(x);\n    return vec2(cos(k), sin(k));\n}\n\nfloat noise2( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*vec3( dot(a,hash2(i+0.0)), dot(b,hash2(i+o)), dot(c,hash2(i+1.0))); // changed to h^3 [1]\n    return dot( n, vec3(32.99) ); // analytic factor (= 2916*sqrt(2)/125)\n}\n\nfloat pnoise (vec2 uv){\n    float f = 0.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2( uv ); uv = m*uv;\n    f += 0.2500*noise2( uv ); uv = m*uv;\n    f += 0.1250*noise2( uv ); uv = m*uv;\n    f += 0.0625*noise2( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n    return f;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i)))\n#define NEWVALUE2 values[int(floor(float(v)*rand(seed+float(i+5))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i+5)))\n#define T (iTime*4.)\n#define rot(a) mat2(cos(a+vec4(0,33,11,0)))\n#define P(z) (vec3(tanh(cos((z) * .15) * 1.) * 8., \\\n                   tanh(cos((z) * .12) * 1.) * 8., (z)))\n\n\n// PREVIEW 0 to disable preview mode\n\n\n#define PREVIEW 0\n#define VOLUMETRIC 0\n\nfloat displaytime = 1.2; // seconds between switch\n\n// select palette mode below\nint PALETTE = 9;\n\n// 0 = Original\n// 1 = Original with hsl mixed\n// 2 = Original translated to hsl\n// 3 = hsl calculated\n// 4 = hsl enhanced\n// 5 = hsl*2\n// 6 = weird\n// 7 = fhex\n// 8 = Banded.\n// 9 = RANDOMISE!!!\n\nvec3 p = vec3(0);\n\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\nfloat map(vec3 p) {\n    return 1.5 - length(p - P(p.z));\n}\nfloat rMix(float a, float b, float s, float y){\n    s = rand(s);\n    //if(y>0.){s*=2.;}\n    if(s>1.){\n      return s>1.66?texture(iChannel0, vec2(a,b), 0.).r:s>1.33?texture(iChannel0, vec2(a,b), 0.).g:texture(iChannel0, vec2(a,b), 0.).b;\n    }\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?b/(a==0.?0.01:a):s>0.3?pnoise(vec2(a,b)):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n}\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 gmc(vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\nvec3 fhexRGB(float fh){\n    if(isinf(fh)||fh>100000.){fh = 0.;}\n    fh = abs(fh*10000000.);\n    float r = fract(fh/65536.);\n    float g = fract(fh/256.);\n    float b= fract(fh/16777216.);\n    //return gmc(contrast(hsl2rgb(vec3(r,g,b)), 0.9), 0.9);\n   return hsl2rgb(vec3(r,g,b));\n}\n\nvec3 addColor(float num, float seed, float alt){\n    if(isinf(num)){num = alt * seed;}\n    if(PALETTE == 7){\n        vec3 col = fhexRGB(num);\n        return col;} else if(PALETTE > 2 || (PALETTE == 1 && rand(seed+19.)>0.3)){\n    \n        float sat = 1.;\n        if(num<0.){sat = 1.-(1./(abs(num)+1.));}\n        float light = 1.0-(1./(abs(num)+1.));\n\n        vec3 col = hsl2rgb(vec3(fract(abs(num)), sat, light));\n        if(PALETTE == 1){col *= 2.;}\n       \n        return col;\n       \n    } else {\n\n        vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n        if(rand(seed*2.)>0.5){col = col.gbr;}\n        if(rand(seed*3.)>0.5){col = col.gbr;}\n        if(PALETTE == 1){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n        // if(PALETTE == 0){col = contrast(col, 1.01); }\n        return col;\n    \n    }\n}\n\nvec3 sanitize(vec3 dc){\n    dc.r = min(1., abs(dc.r));\n    dc.g = min(1., abs(dc.g));\n    dc.b = min(1., abs(dc.b));\n    \n    if(!(dc.r>=0.) && !(dc.r<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.g>=0.) && !(dc.g<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.b>=0.) && !(dc.b<0.)){\n        return vec3(1,0,0);\n    } else {\n        return dc;\n    }\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 oldu = texture(iChannel0, (fragCoord+vec2(1,1))/iResolution.xy, 0.).rgb;\n    vec3 oldd = texture(iChannel0, (fragCoord+vec2(-1,-1))/iResolution.xy, 0.).rgb;\n    vec3 oldl = texture(iChannel0, (fragCoord+vec2(1,-1))/iResolution.xy, 0.).rgb;\n    vec3 oldr = texture(iChannel0, (fragCoord+vec2(-1,1))/iResolution.xy, 0.).rgb;\n     vec3  r = iResolution;\n    vec2 u = fragCoord;\n    \n        \n        float s=.002,d,i, l;\n\n        u = (u-r.xy/2.)/r.y;\n    \n        vec3  p = P(T),ro=p,q,\n              Z = normalize( P(T+1.)  - p),\n              X = normalize(vec3(Z.z,0,-Z)),\n              D = vec3(rot(tanh(sin(p.z*.03)*8.)*3.)*u, 1)* mat3(-X, cross(X, Z), Z);\n       \n        for(; i++<80. && s > .001; ) {\n    \n            p = ro + D * d,\n            s = map(p)*.8,\n            d += s;\n        }\n        p = ro + D * d;\n    vec3 old = texture(iChannel0, p.xy, 0.).rgb;\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    float zoom = 4.;\n    if(VOLUMETRIC == 1 ){ zoom+= (1.5*(sin(iTime)+1.)); } else { zoom+= (3.*(sin(iTime)+1.));}\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    \n    float ix = 468.;\n    float iy = 330.;\n    if(iMouse.x>0.&&iMouse.y>0.){\n    ix = iMouse.x; iy = iMouse.y;}\n    \n    float thumb = 5.+sin((iTime/2.)-1.62)*2.;\n    \n    if(!(iMouse.z>0.)&& bool(PREVIEW)){\n        float pantime = (iTime)+50.;\n\n        ix = floor(pantime+(uv.x*thumb/(iResolution.x/iResolution.y)));\n        iy = floor((pantime+(uv.y*thumb)));\n\n        uv.y*=thumb;\n        uv.x*=thumb/(iResolution.x/iResolution.y);\n        uv+=pantime;\n        uv=fract(uv);\n        uv.x-=0.5;\n        uv.y-=0.5;\n        guv = (uv*zoom);\n        x = guv.x;\n        y = guv.y;\n    }\n    \n    float seed = (ix + (iy*iResolution.x))/iResolution.x;\n    \n    if(!(iMouse.z>0.) && iMouse.x==0. && iMouse.y==0.){\n        seed = floor(iTime/displaytime);\n    }\n    \n    bool pfb = false; if(rand(seed*3.4)<0.5){pfb=true;}\n    bool reverseEF = false;  if(rand(seed*5.4)<0.5){reverseEF=true;}\n    \n    if(PALETTE == 9){\n        PALETTE = int(floor(float(8)*rand(seed+66.)));\n    }\n\n    if(PALETTE == 8){\n        PALETTE = int(floor(fragCoord.x/iResolution.x * 8.));\n    }\n    \n    const int v = 31;\n    \n    vec3 col = vec3(0);\n    float cn = 1.;\n    \n    float values[v];\n    \n    values[0] = 1.0;\n    values[1] = p.x;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = p.y;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = p.z;\n   values[21] = atan(x, y)*4.;\n   values[22] = pnoise(vec2(x,y)/2.);\n   values[23] = pnoise(vec2(y,x)*10.);\n   \n   if(pfb){\n   values[24] = old.r;\n   values[25] = old.g;\n   values[26] = old.b;\n    values[27] = (oldu.r+oldu.g+oldu.b)/3.;\n     values[28] = (oldd.r+oldd.g+oldd.b)/3.;\n      values[29] = (oldl.r+oldl.g+oldl.b)/3.;\n       values[30] = (oldr.r+oldr.g+oldr.b)/3.;\n   } else {\n      values[24] = 2.;\n      values[25] = 10.;\n      values[26] = 3.14159;\n          values[27] = 1.;\n     values[28] = 3.;\n      values[29] = 5.;\n       values[30] = 7.;\n   }\n    float total = 0.;\n    float sub = 0.;\n    int maxi = 25; int mini = 3;\n    int iterations = min(maxi,mini + int(floor(rand(seed*6.6)*float(maxi-mini))));\n    \n    \n    \n    \n    for(int i = 0; i<iterations; i++){\n        float dif = rand(seed+float(i+3))-(abs(total));\n        if(reverseEF) {dif = -dif;}\n        if(dif>0.){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4), y) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4), y), seed+float(i), y);\n\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i), y);\n      \n        }\n        dif = rand(seed+float(i))-sub;\n        if(reverseEF) {dif = -dif;}\n        if(dif>0.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2), y);\n            sub = 0.;\n            dif = rand(seed+float(i+30))-total;\n            if(reverseEF) {dif = -dif;}\n            if(dif > 0.){\n                col += addColor(total, seed+float(i), values[21]);\n                cn+=1.;\n            }\n        }\n    }\n    \n    total = sub==0. ? total : rMix(total, sub, seed, y);\n    col += addColor(total, seed, values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + rand(seed+13.)));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(rand(seed+17.)>0.5){col = col.gbr;}\n        if(rand(seed+19.)>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n    if(VOLUMETRIC == 1 ) { \n    uv+=vec2(0.16,0.1);\n    if(abs(uv.x)>0.6 || abs(uv.y)>0.32){col=vec3(0);}\n    \n    float alph = (col.r+col.g+col.b)/3.;\n    alph = alph<0.5?0.0:alph<0.7?(alph-0.5)*5.:1.0;\n    fragColor = vec4(mix(oldd*.98, col, alph), 1.);\n    } else {\n    fragColor = vec4(col, 1.);\n    }\n\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tftGD4",
    "date": "1747116926",
    "viewed": 101,
    "name": "Angry geometry god",
    "description": "Lux in tenebris et lucent.",
    "likes": 6,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "random",
     "generative",
     "code",
     "feedback",
     "geometry",
     "angrygod"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Random Generative Shaders v5\" by Cotterzz. https://shadertoy.com/view/wf3GRN\n// 2025-05-13 06:05:43\n\n// Fork of \"Random Generative Shaders v4\" by Cotterzz. https://shadertoy.com/view/Wcc3RH\n// 2025-05-10 06:21:07\n\n// Fork of \"Random Generative Shaders v3\" by Cotterzz. https://shadertoy.com/view/Wc33zr\n// 2025-05-09 06:01:58\n\n// Fork of \"Random Generative Shader v2\" by Cotterzz. https://shadertoy.com/view/3XjSWd\n// 2025-05-08 15:40:19\n\n// Fork of \"Random Generative Shader\" by Cotterzz. https://shadertoy.com/view/W3BXDd\n// 2025-05-08 04:36:29\n\n#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i)))\n#define NEWVALUE2 values[int(floor(float(v)*rand(seed+float(i+5))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i+5)))\n\nint PALETTE = 9;\n\nfloat rand(float n){return fract(cos(n*89.42)*343.42);}\nvec2 shake() {\n    return vec2(\n        sin(iTime*1e2),\n        cos(iTime*2e2)\n    ) * max(0.,1.2-iTime)/5.;\n}\nfloat nz(vec2 nv){\n    float o = 0.;\n    for (float i = .2; i < 2.;\n    o += abs(dot(sin(nv * i * 64.), vec2(.05))) / i,\n    i *= 1.4142);\n    return mix(o,  distance(vec2(0), nv), 0.5 + (sin(iTime)/2.));\n}\n\nfloat rMix(float a, float b, float s){\n    s = rand(s);\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?nz(vec2(a,b)):s>0.3?b/(a==0.?0.01:a):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n}\n\nvec3 gpc(float t) {\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 contrast(vec3 color, float value) {return 0.5 + value * (color - 0.5);}\n\nvec3 addColor(float num, float seed, float alt){\n    if(isinf(num)){num = alt * seed;}\n    if(PALETTE == 7){\n        vec3 col = contrast(gpc(num),1.7);\n        return col;} else if(PALETTE > 2 || (PALETTE == 1 && rand(seed+19.)>0.3)){\n        float sat = 1.;\n        if(num<0.){sat = 1.-(1./(abs(num)+1.));}\n        float light = 1.0-(1./(abs(num)+1.));\n        vec3 col = hsl2rgb(vec3(fract(abs(num)), sat, light));\n        if(PALETTE == 1){col *= 2.;}\n        return col;\n    } else {\n        vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n        if(rand(seed*2.)>0.5){col = col.gbr;}\n        if(rand(seed*3.)>0.5){col = col.gbr;}\n        if(PALETTE == 1){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n        return col;\n    }\n}\n\nvec3 sanitize(vec3 dc){\n    dc.r = min(1., dc.r);\n    dc.g = min(1., dc.g);\n    dc.b = min(1., dc.b);\n    \n    if(!(dc.r>=0.) && !(dc.r<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.g>=0.) && !(dc.g<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.b>=0.) && !(dc.b<0.)){\n        return vec3(1,0,0);\n    } else {\n        return dc;\n    }\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    uv += shake();\n    float zoom = 4. + (3.*(sin(iTime/1.5)+1.));\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    float o = nz(guv);\n    float seed = floor(iTime/1.0);\n    PALETTE = int(floor(float(8)*rand(seed+66.)));\n    const int v = 24;\n    vec3 col = vec3(0);\n    float cn = 1.;\n    float values[v];\n    values[0] = 1.0;\n    values[1] = 10.0;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = 2.;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = 3.14159;\n   values[21] = atan(x, y)*4.;\n   values[22] = o;\n   values[23] = distance(vec2(x,y), vec2(0))*sin(atan(x, y));\n   \n    float total = 0.;\n    float sub = 0.;\n    int maxi = 30; int mini = 5;\n    int iterations = min(maxi,mini + int(floor(rand(seed*6.6)*float(maxi-mini))));\n    \n    for(int i = 0; i<iterations; i++){\n        if(rand(seed+float(i+3))>rand(seed)){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)), seed+float(i));\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i));\n        }\n        if(abs(sub)<1.){seed+=100.;PALETTE = int(floor(float(8)*rand(seed+66.)));}\n        if(rand(seed+float(i))>rand(seed)/2.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2));\n            sub = 0.;\n            col += addColor(total, seed+float(i), values[21]);\n            cn+=1.;\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, seed);\n    col += addColor(total, seed, values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + rand(seed+13.)));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(rand(seed+17.)>0.5){col = col.gbr;}\n        if(rand(seed+19.)>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n    fragColor = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WctGRB",
    "date": "1747216991",
    "viewed": 68,
    "name": "Alien Hypnotist",
    "description": "Look into my eye\nThanks to chronos for the Herringbone pattern",
    "likes": 3,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "random",
     "kaleidoscope",
     "generative"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Random Generative Shaders v5\" by Cotterzz. https://shadertoy.com/view/wf3GRN\n// 2025-05-14 07:15:59\n\n// Fork of \"Random Generative Shaders v4\" by Cotterzz. https://shadertoy.com/view/Wcc3RH\n// 2025-05-10 06:21:07\n\n// Fork of \"Random Generative Shaders v3\" by Cotterzz. https://shadertoy.com/view/Wc33zr\n// 2025-05-09 06:01:58\n\n// Fork of \"Random Generative Shader v2\" by Cotterzz. https://shadertoy.com/view/3XjSWd\n// 2025-05-08 15:40:19\n\n// Fork of \"Random Generative Shader\" by Cotterzz. https://shadertoy.com/view/W3BXDd\n// 2025-05-08 04:36:29\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    it += iTime*tm;\n    vec3  r = iResolution;\n    vec2 u = fragCoord;\n    vec3 wh = vec3(1); vec3 bl = vec3(0);\n    vec4 A = texture(iChannel0, u/r.xy,0.);\n    vec4 B = texture(iChannel1, u/r.xy,0.);\n    if(A.rgb==wh){A=B;}\n    if(B.rgb==wh){B=A;}\n    float bias = 1. - ((B.r+B.g+B.b)/6.);\n    fragColor = mix(A, B, min(1.,pow(1.-mod(it,displayTime)/displayTime ,bias)*3.) );\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i)))\n#define NEWVALUE2 values[int(floor(float(v)*rand(seed+float(i+5))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i+5)))\n\n#define PREVIEW 0\n\n#define NOISE 1\n\n// PREVIEW 0 to disable preview mode\n// SHOWITER 0 to disable iterations view\n// select palette mode below\n\nint PALETTE = 6;\nfloat tm = 0.4;\nfloat it = 47.5;\nfloat displayTime = 0.5;\n\n// 0 = Original\n// 1 = Original with hsl mixed\n// 2 = Original translated to hsl\n// 3 = hsl calculated\n// 4 = hsl enhanced\n// 5 = hsl*2\n// 6 = weird\n// 7 = fhex\n// 8 = Banded.\n// 9 = RANDOMISE!!!\n\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\n\nfloat nz(vec2 nv){\n     if(NOISE == 1){\n     nv.y+=it;\n     nv.x/=nv.y;\n        float o = 0.;\n    for (float i = .2; i < 2.;\n        o += abs(dot(sin(nv * i * 32.), vec2(.05))) / i,\n        i *= 1.4142);\n   return o;} else {\n   float o = 0.; float i = 0.2;\n   o+= abs(dot(sin(nv * i * 32.), vec2(.05))) / i;i *= 1.4142;\n   o+= abs(dot(sin(nv * i * 32.), vec2(.1))) / i;\n   return o;}\n}\n\nfloat rMix(float a, float b, float s){\n    s = rand(s);\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?nz(vec2(a,b)):s>0.3?b/(a==0.?0.01:a):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n    \n\n\n    \n}\nvec3 getPsychedelicColor(float t) {\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 gmc(vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\nvec3 fhexRGB(float fh){\n    return contrast(getPsychedelicColor(fh),1.7);\n}\n\nvec3 addColor(float num, float seed, float alt){\n    if(isinf(num)){num = alt * seed;}\n    if(PALETTE == 7){\n        vec3 col = fhexRGB(num);\n        return col;} else if(PALETTE > 2 || (PALETTE == 1 && rand(seed+19.)>0.3)){\n    \n        float sat = 1.;\n        if(num<0.){sat = 1.-(1./(abs(num)+1.));}\n        float light = 1.0-(1./(abs(num)+1.));\n\n        vec3 col = hsl2rgb(vec3(fract(abs(num)), sat, light));\n        if(PALETTE == 1){col *= 2.;}\n       \n        return col;\n       \n    } else {\n\n        vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n        if(rand(seed*2.)>0.5){col = col.gbr;}\n        if(rand(seed*3.)>0.5){col = col.gbr;}\n        if(PALETTE == 1){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n        // if(PALETTE == 0){col = contrast(col, 1.01); }\n        return col;\n    \n    }\n}\n\nvec3 sanitize(vec3 dc){\n    dc.r = min(1., dc.r);\n    dc.g = min(1., dc.g);\n    dc.b = min(1., dc.b);\n    \n    if(!(dc.r>=0.) && !(dc.r<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.g>=0.) && !(dc.g<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.b>=0.) && !(dc.b<0.)){\n        return vec3(1,0,0);\n    } else {\n        return dc;\n    }\n\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    it += iTime*tm;\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n         uv.x=abs(uv.x)<0.001?0.01:uv.x;\n     uv.y=abs(uv.y)<0.001?0.01:uv.y;\n    float zoom = 4. + (3.*(sin(it)+1.));\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    \n    float ix = 489.;\n    float iy = 144.;\n    ix = iMouse.x; iy = iMouse.y;\n    \n    float thumb = 5.+sin((it/2.)-1.62)*2.;\n  \n    \n    if(!(iMouse.z>0.)&& bool(PREVIEW) && iMouse.x==0. && iMouse.y==0. ){\n        float pantime = (it)+50.;\n\n        ix = floor(pantime+(uv.x*thumb/(iResolution.x/iResolution.y)));\n        iy = floor((pantime+(uv.y*thumb)));\n\n        uv.y*=thumb;\n        uv.x*=thumb/(iResolution.x/iResolution.y);\n        uv+=pantime;\n        uv=fract(uv);\n        uv.x-=0.5;\n        uv.y-=0.5;\n        guv = (uv*zoom);\n        x = guv.x;\n        y = guv.y;\n    }\n    \n   float seed = floor(it/displayTime)+1.;\n    \n    if(PALETTE == 9){\n        PALETTE = 3 + int(floor(float(4)*rand(seed+66.)));\n    }\n\n    if(PALETTE == 8){\n        PALETTE = int(floor(fragCoord.x/iResolution.x * 8.));\n    }\n    \n    const int v = 24;\n\n    vec3 col = vec3(0);\n    float cn = 1.;\n    \n    float values[v];\n    float xb = x*5.;\n    float yb = y*5.;\n    \n    values[0] = 1.0;\n    values[1] = max(0., .25+.75*cos(xb + sin(yb)) * cos(yb  + sin(xb)));\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = max(0., .25+.75*cos(xb*2. + sin(yb*2.)) * cos(yb*2.  + sin(xb*2.)));   \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = .2+(.4+.4*cos(xb*2. + sin(yb*2.)) * cos(yb*2.  + sin(xb*2.)))/2.;\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = .2+(.4+.4*cos(xb + sin(yb)) * cos(yb  + sin(xb)))/2.;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = acos(min(abs(x/y), 0.99));\n   values[21] = atan(x, y)*4.;\n   values[22] = nz(uv);\n   values[23] = nz(uv.yx);\n   \n    float total = 0.;\n    float sub = 0.;\n    int maxi = 40; int mini = 10;\n    int iterations = min(maxi,mini + int(floor(rand(seed*6.6)*float(maxi-mini))));\n    \n    \n    \n    \n    for(int i = 0; i<iterations; i++){\n        if(rand(seed+float(i+3))>rand(seed)){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)), seed+float(i));\n\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i));\n      \n        }\n        if(rand(seed+float(i))>rand(seed)/2.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2));\n            sub = 0.;\n            col += addColor(total, seed+float(i), values[21]);\n            cn+=1.;\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, seed);\n    col += addColor(total, seed, values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + rand(seed+13.)));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(rand(seed+17.)>0.5){col = col.gbr;}\n        if(rand(seed+19.)>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n    fragColor = vec4(col, 1.);\n\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    it += iTime*tm;\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n         uv.x=abs(uv.x)<0.001?0.01:uv.x;\n     uv.y=abs(uv.y)<0.001?0.01:uv.y;\n    float zoom = 4. + (3.*(sin(it)+1.));\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    \n    float ix = 489.;\n    float iy = 144.;\n    ix = iMouse.x; iy = iMouse.y;\n    \n    float thumb = 5.+sin((it/2.)-1.62)*2.;\n  \n    \n    if(!(iMouse.z>0.)&& bool(PREVIEW) && iMouse.x==0. && iMouse.y==0. ){\n        float pantime = (it)+50.;\n\n        ix = floor(pantime+(uv.x*thumb/(iResolution.x/iResolution.y)));\n        iy = floor((pantime+(uv.y*thumb)));\n\n        uv.y*=thumb;\n        uv.x*=thumb/(iResolution.x/iResolution.y);\n        uv+=pantime;\n        uv=fract(uv);\n        uv.x-=0.5;\n        uv.y-=0.5;\n        guv = (uv*zoom);\n        x = guv.x;\n        y = guv.y;\n    }\n    \n    float seed = floor(it/displayTime);\n    \n    if(PALETTE == 9){\n        PALETTE = 3 + int(floor(float(4)*rand(seed+66.)));\n    }\n\n    if(PALETTE == 8){\n        PALETTE = int(floor(fragCoord.x/iResolution.x * 8.));\n    }\n    \n    const int v = 24;\n\n    vec3 col = vec3(0);\n    float cn = 1.;\n    \n    float values[v];\n    \n    float xb = x*5.;\n    float yb = y*5.;\n    \n    values[0] = 1.0;\n    values[1] = max(0., .25+.75*cos(xb + sin(yb)) * cos(yb  + sin(xb)));\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = max(0., .25+.75*cos(xb*2. + sin(yb*2.)) * cos(yb*2.  + sin(xb*2.)));   \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = .2+(.4+.4*cos(xb*2. + sin(yb*2.)) * cos(yb*2.  + sin(xb*2.)))/2.;\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = .2+(.4+.4*cos(xb + sin(yb)) * cos(yb  + sin(xb)))/2.;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = acos(min(abs(x/y), 0.99));\n   values[21] = atan(x, y)*4.;\n   values[22] = nz(uv);\n   values[23] = nz(uv.yx);\n   \n    float total = 0.;\n    float sub = 0.;\n    int maxi = 40; int mini = 10;\n    int iterations = min(maxi,mini + int(floor(rand(seed*6.6)*float(maxi-mini))));\n    \n    \n    \n    \n    for(int i = 0; i<iterations; i++){\n        if(rand(seed+float(i+3))>rand(seed)){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)), seed+float(i));\n\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i));\n      \n        }\n        if(rand(seed+float(i))>rand(seed)/2.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2));\n            sub = 0.;\n            col += addColor(total, seed+float(i), values[21]);\n            cn+=1.;\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, seed);\n    col += addColor(total, seed, values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + rand(seed+13.)));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(rand(seed+17.)>0.5){col = col.gbr;}\n        if(rand(seed+19.)>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n    fragColor = vec4(col, 1.);\n\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wct3R2",
    "date": "1747271815",
    "viewed": 44,
    "name": "fwidth, dFdx and dFdy example",
    "description": "Demonstration of what fwidth, dFdx and dFdy do.\nNotice how the data returned is half resolution due to the 2x2 pixel limitation.",
    "likes": 1,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "dfdx",
     "dfdy",
     "fwidth",
     "edges",
     "hardwarederivatives"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// fwidth, in red, is draggable.\n// Note that I'm using the full range of dFdx/dFdt, including negative values, uncomment the abs in bufferA to see what I mean.\n// Lower the enhance setting on line 13 in bufferA if you use other textures\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // magnifying glass, wouldn't work in single image mode because it doesn't preserve with the fwidth values\n    // comment out this if statement to remove\n    if(distance(iMouse.xy, fragCoord.xy)<iResolution.x/6.){\n        fragCoord = iMouse.xy - (iMouse.xy-fragCoord.xy)/10.;\n        fragCoord.y+=0.5;\n    }\n\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4sf3Rr",
       "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ir = iResolution;\n    \n    vec3 bounds = vec3(ir.y*0.8, fragCoord.x/(ir.x/ir.y), ir.y - fragCoord.x/(ir.x/ir.y)); // dividing lines\n    \n    if( iMouse.z>0. || iMouse.x>0. || iMouse.y>0.) { bounds.x = iMouse.y;}\n\n    vec3 iA = texture(iChannel0, fragCoord/iResolution.xy, 0.).rgb; // image texture\n    \n    float ibw = (iA.r+iA.b+iA.g)/3.; // black and white, so we're only dealing with oen value, but you can use types other than float\n    \n    float enhance = 100.; // This is for very soft images, turn down to under 10 for other textures.\n    \n    vec3 col = vec3(ibw)/enhance; \n    \n    if(fragCoord.y> bounds.x) { col.r+=fwidth(ibw)/2.5; } // set red channel to show fwidth, attenuate the red because it's too bright\n    \n    if(fragCoord.y< bounds.y) { col.g+= /*abs*/(dFdx(ibw)); } // set green channel to show dFdx \n    \n    if(fragCoord.y< bounds.z) { col.b+= /*abs*/(dFdy(ibw)); } // set blue channel to show dFdy\n     \n    col*=enhance;\n    \n    if(floor(fragCoord.y)==floor(bounds.x)){col.r=1.;} \n    if(floor(fragCoord.y)==floor(bounds.y)){col.g=1.;} \n    if(floor(fragCoord.y)==floor(bounds.z)){col.b=1.;} \n     \n    fragColor = vec4(col, 1.);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wfcGRX",
    "date": "1747302048",
    "viewed": 76,
    "name": "Noise Derivative Approximation",
    "description": "Attempting a quick and dirty way of returning derivative of gradient noise",
    "likes": 7,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "noise",
     "gradient",
     "polar",
     "angle",
     "derivates"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Code in Buffer A is \"Gradient Noise 3D\" by im_sky. https://shadertoy.com/view/WsjBW1\n\n// Note: I am not using the buffer for multisampling in the original method, just keeping the original code separate from mine.\n// Added second approach using three samples. Still trying to figure out if it can be done with two and an offset.\n// I did something similar here: https://www.shadertoy.com/view/3X2XDK\n// But that was sampling in a seprate buffer and combining to create an fwidth, which is easier \n\n#define PI 3.14159265359\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   float bounds = iResolution.y/2.;\n    \n   if( iMouse.z>0. || iMouse.x>0. || iMouse.y>0.) { bounds = iMouse.y;}\n    \n   vec2 co = fragCoord;\n   \n   vec3 col = vec3(0);\n    \n   if( co.y>bounds ) {\n    // three sample plus dxdy\n    int pos = int(co.x)%2 + (int(co.y)%2 * 2);\n    float ra = texture(iChannel0, co/iResolution.xy, 0.).r;\n    float rb = texture(iChannel0, (co+vec2(1,0))/iResolution.xy, 0.).r;\n    float rc = texture(iChannel0, (co+vec2(0,1))/iResolution.xy, 0.).r;\n    float dx = dFdx(ra);\n    float dy = dFdy(ra);\n    if(pos == 1 || pos == 3){ dx = rb-ra; }\n    if(pos == 2 || pos == 3){ dy = rc-ra; }\n    float dz = sqrt((dx*dx) + (dy*dy));\n    float a = (PI + atan(dx,dy))/(PI*2.);\n    col = hsl2rgb(vec3(a,1., ra/2.));\n    \n   } else {\n   // original method dxdy only\n    col = texture(iChannel0, fragCoord/iResolution.xy, 0.).rgb;\n    float r = col.r;  \n    float dx = dFdx(r);\n    float dy = dFdy(r);\n    float a = (PI + atan(dx,dy))/(PI*2.);\n    col = hsl2rgb(vec3(a, 1., r/2.)); \n   \n   }\n   \n   if(floor(co.y)==floor(bounds)){col = vec3(0);}\n    \n   fragColor = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Gradient Noise 3D\" by im_sky. https://shadertoy.com/view/WsjBW1\n// 2025-05-15 09:11:33\n\n#define PI 3.14159265359\n\n#define CosineCurve 0\n#define PerlinSmoothCurve 1\n\nconst vec3 dirs[] = vec3[26]\n(\n    vec3(0.57735, 0.57735, -0.57735),                                                                                                                                                                                                                 \n    vec3(0.57735, 0.57735, 0.57735),                                                                                                                                                                                                                  \n    vec3(0.70711, 0.70711, 0),                                                                                                                                                                                                                        \n    vec3(0.70711, 0, -0.70711),                                                                                                                                                                                                                       \n    vec3(0.70711, 0, 0.70711),                                                                                                                                                                                                                        \n    vec3(1, 0, 0),                                                                                                                                                                                                                                    \n    vec3(0.57735, -0.57735, -0.57735),                                                                                                                                                                                                                \n    vec3(0.57735, -0.57735, 0.57735),                                                                                                                                                                                                                 \n    vec3(0.70711, -0.70711, 0),                                                                                                                                                                                                                       \n    vec3(0, 0.70711, -0.70711),                                                                                                                                                                                                                       \n    vec3(0, 0.70711, 0.70711),                                                                                                                                                                                                                        \n    vec3(0, 1, 0),                                                                                                                                                                                                                                    \n    vec3(0, 0, -1),                                                                                                                                                                                                                                   \n    vec3(0, 0, 1),                                                                                                                                                                                                                                    \n    //vec3(0,0,0),                                                                                                                                                                                                                           \n    vec3(0, -0.70711, -0.70711),                                                                                                                                                                                                                      \n    vec3(0, -0.70711, 0.70711),                                                                                                                                                                                                                       \n    vec3(0, -1, 0),                                                                                                                                                                                                                                   \n    vec3(-0.57735, 0.57735, -0.57735),                                                                                                                                                                                                                \n    vec3(-0.57735, 0.57735, 0.57735),                                                                                                                                                                                                                 \n    vec3(-0.70711, 0.70711, 0),                                                                                                                                                                                                                       \n    vec3(-0.70711, 0, -0.70711),                                                                                                                                                                                                                      \n    vec3(-0.70711, 0, 0.70711),                                                                                                                                                                                                                       \n    vec3(-1, 0, 0),                                                                                                                                                                                                                                   \n    vec3(-0.57735, -0.57735, -0.57735),                                                                                                                                                                                                               \n    vec3(-0.57735, -0.57735, 0.57735),                                                                                                                                                                                                                \n    vec3(-0.70711, -0.70711, 0)         \n);\n\nconst int tableSize = 512;\nconst int permutationMask = 512/2 - 1;\nconst int permutationTable[512] = int[]\n(                                                                                                                                                                                                                                          \n    180, 3, 121, 17, 22, 7, 69, 202, 72, 172,                                                                                                                                                                                                         \n    56, 94, 92, 254, 122, 139, 118, 127, 76, 2,                                                                                                                                                                                                       \n    46, 74, 169, 147, 228, 196, 47, 110, 138, 217,                                                                                                                                                                                                    \n    155, 39, 91, 61, 45, 238, 242, 229, 251, 207,                                                                                                                                                                                                     \n    192, 198, 175, 222, 176, 75, 234, 10, 25, 63,                                                                                                                                                                                                     \n    250, 135, 159, 183, 253, 96, 68, 153, 87, 50,                                                                                                                                                                                                     \n    226, 241, 114, 188, 13, 112, 21, 66, 249, 144,                                                                                                                                                                                                    \n    126, 1, 233, 124, 148, 43, 199, 156, 208, 223,                                                                                                                                                                                                    \n    164, 213, 18, 219, 59, 209, 108, 134, 27, 100,                                                                                                                                                                                                    \n    197, 90, 53, 140, 168, 29, 165, 19, 65, 161,                                                                                                                                                                                                      \n    141, 52, 195, 128, 151, 37, 117, 150, 36, 105,                                                                                                                                                                                                    \n    49, 6, 187, 116, 235, 216, 201, 119, 182, 204,                                                                                                                                                                                                    \n    221, 136, 0, 113, 24, 111, 158, 131, 212, 58,                                                                                                                                                                                                     \n    41, 85, 102, 166, 77, 157, 64, 103, 184, 83,                                                                                                                                                                                                      \n    237, 220, 23, 149, 84, 171, 99, 230, 152, 178,                                                                                                                                                                                                    \n    190, 215, 38, 34, 163, 93, 14, 244, 79, 31,                                                                                                                                                                                                       \n    9, 142, 240, 132, 145, 231, 95, 236, 8, 167,                                                                                                                                                                                                      \n    82, 80, 133, 137, 252, 211, 57, 248, 89, 20,                                                                                                                                                                                                      \n    30, 154, 32, 174, 205, 42, 98, 11, 15, 243,                                                                                                                                                                                                       \n    78, 203, 146, 185, 107, 51, 224, 54, 70, 106,                                                                                                                                                                                                     \n    194, 35, 177, 160, 255, 16, 104, 189, 12, 67,                                                                                                                                                                                                     \n    125, 33, 123, 55, 120, 186, 40, 143, 181, 239,                                                                                                                                                                                                    \n    193, 214, 115, 81, 4, 44, 200, 101, 206, 71,                                                                                                                                                                                                      \n    73, 28, 86, 130, 48, 225, 210, 227, 245, 109,                                                                                                                                                                                                     \n    232, 162, 129, 179, 218, 88, 247, 173, 191, 97,                                                                                                                                                                                                   \n    62, 60, 246, 5, 26, 170,\n    180, 3, 121, 17, 22, 7, 69, 202, 72, 172,                                                                                                                                                                                                         \n    56, 94, 92, 254, 122, 139, 118, 127, 76, 2,                                                                                                                                                                                                       \n    46, 74, 169, 147, 228, 196, 47, 110, 138, 217,                                                                                                                                                                                                    \n    155, 39, 91, 61, 45, 238, 242, 229, 251, 207,                                                                                                                                                                                                     \n    192, 198, 175, 222, 176, 75, 234, 10, 25, 63,                                                                                                                                                                                                     \n    250, 135, 159, 183, 253, 96, 68, 153, 87, 50,                                                                                                                                                                                                     \n    226, 241, 114, 188, 13, 112, 21, 66, 249, 144,                                                                                                                                                                                                    \n    126, 1, 233, 124, 148, 43, 199, 156, 208, 223,                                                                                                                                                                                                    \n    164, 213, 18, 219, 59, 209, 108, 134, 27, 100,                                                                                                                                                                                                    \n    197, 90, 53, 140, 168, 29, 165, 19, 65, 161,                                                                                                                                                                                                      \n    141, 52, 195, 128, 151, 37, 117, 150, 36, 105,                                                                                                                                                                                                    \n    49, 6, 187, 116, 235, 216, 201, 119, 182, 204,                                                                                                                                                                                                    \n    221, 136, 0, 113, 24, 111, 158, 131, 212, 58,                                                                                                                                                                                                     \n    41, 85, 102, 166, 77, 157, 64, 103, 184, 83,                                                                                                                                                                                                      \n    237, 220, 23, 149, 84, 171, 99, 230, 152, 178,                                                                                                                                                                                                    \n    190, 215, 38, 34, 163, 93, 14, 244, 79, 31,                                                                                                                                                                                                       \n    9, 142, 240, 132, 145, 231, 95, 236, 8, 167,                                                                                                                                                                                                      \n    82, 80, 133, 137, 252, 211, 57, 248, 89, 20,                                                                                                                                                                                                      \n    30, 154, 32, 174, 205, 42, 98, 11, 15, 243,                                                                                                                                                                                                       \n    78, 203, 146, 185, 107, 51, 224, 54, 70, 106,                                                                                                                                                                                                     \n    194, 35, 177, 160, 255, 16, 104, 189, 12, 67,                                                                                                                                                                                                     \n    125, 33, 123, 55, 120, 186, 40, 143, 181, 239,                                                                                                                                                                                                    \n    193, 214, 115, 81, 4, 44, 200, 101, 206, 71,                                                                                                                                                                                                      \n    73, 28, 86, 130, 48, 225, 210, 227, 245, 109,                                                                                                                                                                                                     \n    232, 162, 129, 179, 218, 88, 247, 173, 191, 97,                                                                                                                                                                                                   \n    62, 60, 246, 5, 26, 170\n);\n\nint Hash(vec3 x)\n{\n    // using ampersand to calculate modulus because-\n    // mod() for negative integers gives \"wrong\" results, for instance mod(-3, 4) = 1 and not 3\n    // the ampersand trick works only if the divisor is a power of two minus 1\n    // less operatons compared to x - y * floor(x/y)\n    return permutationTable[permutationTable[permutationTable[int(x.x) & permutationMask] + int(x.z) & permutationMask] + int(x.y) & permutationMask];\n}\n\nfloat SmoothCurve(float t)\n{\n#if CosineCurve\n    return (1.0 - cos(t * PI)) * 0.5;\n#elif PerlinSmoothCurve\n    return t * t * (3.0 - 2.0 * t);\n#else\n    return t;\n#endif\n}\n\nfloat GetIntegerNoise(vec2 p)  // replace this by something better, p is essentially ivec2\n{\n    p  = 53.7 * fract( (p*0.3183099) + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nvec3 GetGradient(vec3 x)\n{\n    // using % instead of & operator, below, because the divisor is not a power of two minus 1, and the divisor will never be negative here.\n    int i = Hash(x) % 26;\n    return dirs[i];\n}\n\nfloat Get3DNoise(vec3 uvw)\n{\n    float noise = 0.0;\n    \n    vec3 p = floor(uvw);\n    vec3 f = fract(uvw);\n    \n    vec3 p1 = p + vec3(0.0, 0.0, 0.0);\n    vec3 p2 = p + vec3(1.0, 0.0, 0.0);\n    vec3 p3 = p + vec3(0.0, 1.0, 0.0);\n    vec3 p4 = p + vec3(1.0, 1.0, 0.0);\n    vec3 p5 = p + vec3(0.0, 0.0, 1.0);\n    vec3 p6 = p + vec3(1.0, 0.0, 1.0);\n    vec3 p7 = p + vec3(0.0, 1.0, 1.0);\n    vec3 p8 = p + vec3(1.0, 1.0, 1.0);\n    \n    vec3 g1 = GetGradient(p1);\n    vec3 g2 = GetGradient(p2);\n    vec3 g3 = GetGradient(p3);\n    vec3 g4 = GetGradient(p4);\n    vec3 g5 = GetGradient(p5);\n    vec3 g6 = GetGradient(p6);\n    vec3 g7 = GetGradient(p7);\n    vec3 g8 = GetGradient(p8);\n    \n    float dot1 = dot(g1, uvw - p1);\n    float dot2 = dot(g2, uvw - p2);\n    float dot3 = dot(g3, uvw - p3);\n    float dot4 = dot(g4, uvw - p4);\n    float dot5 = dot(g5, uvw - p5);\n    float dot6 = dot(g6, uvw - p6);\n    float dot7 = dot(g7, uvw - p7);\n    float dot8 = dot(g8, uvw - p8);\n    \n    float wX = SmoothCurve(f.x);\n    float noiseY1 = mix(dot1, dot2, wX);\n    float noiseY2 = mix(dot3, dot4, wX);\n    float noiseY3 = mix(dot5, dot6, wX);\n    float noiseY4 = mix(dot7, dot8, wX);\n    \n    float wY = SmoothCurve(f.y);\n    float noiseZ1 = mix(noiseY1, noiseY2, wY);\n    float noiseZ2 = mix(noiseY3, noiseY4, wY);\n    \n    float wZ = SmoothCurve(f.z);\n    noise = mix(noiseZ1, noiseZ2, wZ);\n    \n    return noise;\n}\n\n//https://iquilezles.org/articles/fbm\n// H: Hurst Exponent, affects the integration of noise partially\nfloat fBM(vec3 x, float H, int numOctaves)\n{\n    float total = 0.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        float frequency = pow(2.0, float(i));\n        float amplitude = pow(frequency, -H);\n        total += amplitude * Get3DNoise(x * frequency);\n    }\n\t\n    return total;\n}\n\n// https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/procedural-patterns-noise-part-1/simple-pattern-examples\n// output range -1.0 to 1.0\nfloat fBM(vec3 x, float lacunarity, float gain, int numOctaves)\n{\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        total += amplitude * Get3DNoise(x * frequency);\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return total;\n}\n\nfloat Turbulence(vec3 x, float lacunarity, float gain, int numOctaves)\n{\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        total += amplitude * abs(Get3DNoise(x * frequency));\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n\t\n    return total;\n}\n\nfloat HighPassFilter(float x, float threshold)\n{\n    x = max(x, threshold);\n    x -= threshold;\n    x /= (1.0 - threshold);\n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 2.0;\n    vec3 uvw = vec3(uv, iTime * 0.1);\n\n    \n\t//float noise = fBM(uvw, 2.0, 0.4, 4);\n    //noise = 0.5 * noise + 0.5;\n    \n    float noise = 0.0;\n    {\n        float windowWidth = iResolution.x / 4.0; \n\n        if(fragCoord.x < windowWidth)\t\n        {\n            // brown noise\n            noise = fBM(uvw, 2.0, 0.5, 7);\n            noise = 0.5 * noise + 0.5;  \n        }\n        else if(fragCoord.x < 2.0 * windowWidth)\t\n        {\n            // turbulence\n            noise = Turbulence(uvw, 2.0, 0.5, 7);\n            //noise = pow(noise, 2.2);\n        }\n        else if(fragCoord.x < 3.0 * windowWidth)\n        {\n            uvw *= 3.0;\n            uvw.y *= 0.8; \n            // wood grain\n            noise = fBM(uvw, 0.02, 0.35, 2);\n            noise = noise - floor(noise);\n            noise = noise>0.95?mix(1.,0., (noise-0.95)*20.):noise;\n        } else {\n            uvw *= 3.0;\n            uvw.y *= 0.8; \n            // wood grain\n            noise = fBM(uvw, 0.02, 0.35, 2) ;\n            noise = (sin((5.0 * noise * 100.0) * 2.0 * PI / 200.0) + 1.0) / 2.0;\n                  \n        }\n    }\n    \n    //noise = pow(noise, 2.2);\n    fragColor = vec4(noise, noise, noise, 1.0);\n}\n\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tftGDS",
    "date": "1747468297",
    "viewed": 100,
    "name": "Liquid sportscar.",
    "description": "Using the derivative of fbm noise along with magnitude as x/y values to feedback into itself.\nClick and drag to change parameters.",
    "likes": 9,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "noise",
     "fbm",
     "gradient",
     "feedback",
     "polar",
     "angle",
     "derivates"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Noise Derivative Approximation\" by Cotterzz. https://shadertoy.com/view/wfcGRX\n// 2025-05-17 07:21:41\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n   \n   fragColor.rgb = pow(fragColor.rgb, vec3(0.6));\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Gradient Noise 3D\" by im_sky. https://shadertoy.com/view/WsjBW1\n// 2025-05-15 09:11:33\n\n#define PI 3.14159265359\n\n#define CosineCurve 0\n#define PerlinSmoothCurve 1\n\nconst vec3 dirs[] = vec3[26]\n(\n    vec3(0.57735, 0.57735, -0.57735),                                                                                                                                                                                                                 \n    vec3(0.57735, 0.57735, 0.57735),                                                                                                                                                                                                                  \n    vec3(0.70711, 0.70711, 0),                                                                                                                                                                                                                        \n    vec3(0.70711, 0, -0.70711),                                                                                                                                                                                                                       \n    vec3(0.70711, 0, 0.70711),                                                                                                                                                                                                                        \n    vec3(1, 0, 0),                                                                                                                                                                                                                                    \n    vec3(0.57735, -0.57735, -0.57735),                                                                                                                                                                                                                \n    vec3(0.57735, -0.57735, 0.57735),                                                                                                                                                                                                                 \n    vec3(0.70711, -0.70711, 0),                                                                                                                                                                                                                       \n    vec3(0, 0.70711, -0.70711),                                                                                                                                                                                                                       \n    vec3(0, 0.70711, 0.70711),                                                                                                                                                                                                                        \n    vec3(0, 1, 0),                                                                                                                                                                                                                                    \n    vec3(0, 0, -1),                                                                                                                                                                                                                                   \n    vec3(0, 0, 1),                                                                                                                                                                                                                                    \n    //vec3(0,0,0),                                                                                                                                                                                                                           \n    vec3(0, -0.70711, -0.70711),                                                                                                                                                                                                                      \n    vec3(0, -0.70711, 0.70711),                                                                                                                                                                                                                       \n    vec3(0, -1, 0),                                                                                                                                                                                                                                   \n    vec3(-0.57735, 0.57735, -0.57735),                                                                                                                                                                                                                \n    vec3(-0.57735, 0.57735, 0.57735),                                                                                                                                                                                                                 \n    vec3(-0.70711, 0.70711, 0),                                                                                                                                                                                                                       \n    vec3(-0.70711, 0, -0.70711),                                                                                                                                                                                                                      \n    vec3(-0.70711, 0, 0.70711),                                                                                                                                                                                                                       \n    vec3(-1, 0, 0),                                                                                                                                                                                                                                   \n    vec3(-0.57735, -0.57735, -0.57735),                                                                                                                                                                                                               \n    vec3(-0.57735, -0.57735, 0.57735),                                                                                                                                                                                                                \n    vec3(-0.70711, -0.70711, 0)         \n);\n\nconst int tableSize = 512;\nconst int permutationMask = 512/2 - 1;\nconst int permutationTable[512] = int[]\n(                                                                                                                                                                                                                                          \n    180, 3, 121, 17, 22, 7, 69, 202, 72, 172,                                                                                                                                                                                                         \n    56, 94, 92, 254, 122, 139, 118, 127, 76, 2,                                                                                                                                                                                                       \n    46, 74, 169, 147, 228, 196, 47, 110, 138, 217,                                                                                                                                                                                                    \n    155, 39, 91, 61, 45, 238, 242, 229, 251, 207,                                                                                                                                                                                                     \n    192, 198, 175, 222, 176, 75, 234, 10, 25, 63,                                                                                                                                                                                                     \n    250, 135, 159, 183, 253, 96, 68, 153, 87, 50,                                                                                                                                                                                                     \n    226, 241, 114, 188, 13, 112, 21, 66, 249, 144,                                                                                                                                                                                                    \n    126, 1, 233, 124, 148, 43, 199, 156, 208, 223,                                                                                                                                                                                                    \n    164, 213, 18, 219, 59, 209, 108, 134, 27, 100,                                                                                                                                                                                                    \n    197, 90, 53, 140, 168, 29, 165, 19, 65, 161,                                                                                                                                                                                                      \n    141, 52, 195, 128, 151, 37, 117, 150, 36, 105,                                                                                                                                                                                                    \n    49, 6, 187, 116, 235, 216, 201, 119, 182, 204,                                                                                                                                                                                                    \n    221, 136, 0, 113, 24, 111, 158, 131, 212, 58,                                                                                                                                                                                                     \n    41, 85, 102, 166, 77, 157, 64, 103, 184, 83,                                                                                                                                                                                                      \n    237, 220, 23, 149, 84, 171, 99, 230, 152, 178,                                                                                                                                                                                                    \n    190, 215, 38, 34, 163, 93, 14, 244, 79, 31,                                                                                                                                                                                                       \n    9, 142, 240, 132, 145, 231, 95, 236, 8, 167,                                                                                                                                                                                                      \n    82, 80, 133, 137, 252, 211, 57, 248, 89, 20,                                                                                                                                                                                                      \n    30, 154, 32, 174, 205, 42, 98, 11, 15, 243,                                                                                                                                                                                                       \n    78, 203, 146, 185, 107, 51, 224, 54, 70, 106,                                                                                                                                                                                                     \n    194, 35, 177, 160, 255, 16, 104, 189, 12, 67,                                                                                                                                                                                                     \n    125, 33, 123, 55, 120, 186, 40, 143, 181, 239,                                                                                                                                                                                                    \n    193, 214, 115, 81, 4, 44, 200, 101, 206, 71,                                                                                                                                                                                                      \n    73, 28, 86, 130, 48, 225, 210, 227, 245, 109,                                                                                                                                                                                                     \n    232, 162, 129, 179, 218, 88, 247, 173, 191, 97,                                                                                                                                                                                                   \n    62, 60, 246, 5, 26, 170,\n    180, 3, 121, 17, 22, 7, 69, 202, 72, 172,                                                                                                                                                                                                         \n    56, 94, 92, 254, 122, 139, 118, 127, 76, 2,                                                                                                                                                                                                       \n    46, 74, 169, 147, 228, 196, 47, 110, 138, 217,                                                                                                                                                                                                    \n    155, 39, 91, 61, 45, 238, 242, 229, 251, 207,                                                                                                                                                                                                     \n    192, 198, 175, 222, 176, 75, 234, 10, 25, 63,                                                                                                                                                                                                     \n    250, 135, 159, 183, 253, 96, 68, 153, 87, 50,                                                                                                                                                                                                     \n    226, 241, 114, 188, 13, 112, 21, 66, 249, 144,                                                                                                                                                                                                    \n    126, 1, 233, 124, 148, 43, 199, 156, 208, 223,                                                                                                                                                                                                    \n    164, 213, 18, 219, 59, 209, 108, 134, 27, 100,                                                                                                                                                                                                    \n    197, 90, 53, 140, 168, 29, 165, 19, 65, 161,                                                                                                                                                                                                      \n    141, 52, 195, 128, 151, 37, 117, 150, 36, 105,                                                                                                                                                                                                    \n    49, 6, 187, 116, 235, 216, 201, 119, 182, 204,                                                                                                                                                                                                    \n    221, 136, 0, 113, 24, 111, 158, 131, 212, 58,                                                                                                                                                                                                     \n    41, 85, 102, 166, 77, 157, 64, 103, 184, 83,                                                                                                                                                                                                      \n    237, 220, 23, 149, 84, 171, 99, 230, 152, 178,                                                                                                                                                                                                    \n    190, 215, 38, 34, 163, 93, 14, 244, 79, 31,                                                                                                                                                                                                       \n    9, 142, 240, 132, 145, 231, 95, 236, 8, 167,                                                                                                                                                                                                      \n    82, 80, 133, 137, 252, 211, 57, 248, 89, 20,                                                                                                                                                                                                      \n    30, 154, 32, 174, 205, 42, 98, 11, 15, 243,                                                                                                                                                                                                       \n    78, 203, 146, 185, 107, 51, 224, 54, 70, 106,                                                                                                                                                                                                     \n    194, 35, 177, 160, 255, 16, 104, 189, 12, 67,                                                                                                                                                                                                     \n    125, 33, 123, 55, 120, 186, 40, 143, 181, 239,                                                                                                                                                                                                    \n    193, 214, 115, 81, 4, 44, 200, 101, 206, 71,                                                                                                                                                                                                      \n    73, 28, 86, 130, 48, 225, 210, 227, 245, 109,                                                                                                                                                                                                     \n    232, 162, 129, 179, 218, 88, 247, 173, 191, 97,                                                                                                                                                                                                   \n    62, 60, 246, 5, 26, 170\n);\n\nint Hash(vec3 x)\n{\n    // using ampersand to calculate modulus because-\n    // mod() for negative integers gives \"wrong\" results, for instance mod(-3, 4) = 1 and not 3\n    // the ampersand trick works only if the divisor is a power of two minus 1\n    // less operatons compared to x - y * floor(x/y)\n    return permutationTable[permutationTable[permutationTable[int(x.x) & permutationMask] + int(x.z) & permutationMask] + int(x.y) & permutationMask];\n}\n\nfloat SmoothCurve(float t)\n{\n#if CosineCurve\n    return (1.0 - cos(t * PI)) * 0.5;\n#elif PerlinSmoothCurve\n    return t * t * (3.0 - 2.0 * t);\n#else\n    return t;\n#endif\n}\n\nfloat GetIntegerNoise(vec2 p)  // replace this by something better, p is essentially ivec2\n{\n    p  = 53.7 * fract( (p*0.3183099) + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nvec3 GetGradient(vec3 x)\n{\n    // using % instead of & operator, below, because the divisor is not a power of two minus 1, and the divisor will never be negative here.\n    int i = Hash(x) % 26;\n    return dirs[i];\n}\n\nfloat Get3DNoise(vec3 uvw)\n{\n    float noise = 0.0;\n    \n    vec3 p = floor(uvw);\n    vec3 f = fract(uvw);\n    \n    vec3 p1 = p + vec3(0.0, 0.0, 0.0);\n    vec3 p2 = p + vec3(1.0, 0.0, 0.0);\n    vec3 p3 = p + vec3(0.0, 1.0, 0.0);\n    vec3 p4 = p + vec3(1.0, 1.0, 0.0);\n    vec3 p5 = p + vec3(0.0, 0.0, 1.0);\n    vec3 p6 = p + vec3(1.0, 0.0, 1.0);\n    vec3 p7 = p + vec3(0.0, 1.0, 1.0);\n    vec3 p8 = p + vec3(1.0, 1.0, 1.0);\n    \n    vec3 g1 = GetGradient(p1);\n    vec3 g2 = GetGradient(p2);\n    vec3 g3 = GetGradient(p3);\n    vec3 g4 = GetGradient(p4);\n    vec3 g5 = GetGradient(p5);\n    vec3 g6 = GetGradient(p6);\n    vec3 g7 = GetGradient(p7);\n    vec3 g8 = GetGradient(p8);\n    \n    float dot1 = dot(g1, uvw - p1);\n    float dot2 = dot(g2, uvw - p2);\n    float dot3 = dot(g3, uvw - p3);\n    float dot4 = dot(g4, uvw - p4);\n    float dot5 = dot(g5, uvw - p5);\n    float dot6 = dot(g6, uvw - p6);\n    float dot7 = dot(g7, uvw - p7);\n    float dot8 = dot(g8, uvw - p8);\n    \n    float wX = SmoothCurve(f.x);\n    float noiseY1 = mix(dot1, dot2, wX);\n    float noiseY2 = mix(dot3, dot4, wX);\n    float noiseY3 = mix(dot5, dot6, wX);\n    float noiseY4 = mix(dot7, dot8, wX);\n    \n    float wY = SmoothCurve(f.y);\n    float noiseZ1 = mix(noiseY1, noiseY2, wY);\n    float noiseZ2 = mix(noiseY3, noiseY4, wY);\n    \n    float wZ = SmoothCurve(f.z);\n    noise = mix(noiseZ1, noiseZ2, wZ);\n    \n    return noise;\n}\n\n//https://iquilezles.org/articles/fbm\n// H: Hurst Exponent, affects the integration of noise partially\nfloat fBM(vec3 x, float H, int numOctaves)\n{\n    float total = 0.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        float frequency = pow(2.0, float(i));\n        float amplitude = pow(frequency, -H);\n        total += amplitude * Get3DNoise(x * frequency);\n    }\n\t\n    return total;\n}\n\n// https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/procedural-patterns-noise-part-1/simple-pattern-examples\n// output range -1.0 to 1.0\nfloat fBM(vec3 x, float lacunarity, float gain, int numOctaves)\n{\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        total += amplitude * Get3DNoise(x * frequency);\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return total;\n}\n\nfloat Turbulence(vec3 x, float lacunarity, float gain, int numOctaves)\n{\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        total += amplitude * abs(Get3DNoise(x * frequency));\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n\t\n    return total;\n}\n\nfloat HighPassFilter(float x, float threshold)\n{\n    x = max(x, threshold);\n    x -= threshold;\n    x /= (1.0 - threshold);\n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 2.0;\n    vec3 uvw = vec3(uv, iTime * 0.1);\n\n    float ix = 0.3; if(iMouse.x>0.){ix = iMouse.x/iResolution.x;}\n    float iy = 0.7; if(iMouse.y>0.){iy = iMouse.y/iResolution.y;}\n\t//float noise = fBM(uvw, 2.0, 0.4, 4);\n    //noise = 0.5 * noise + 0.5;\n    \n    float noise = 0.0;\n    {\n\n            uvw *= 0.4 + ix*2.;\n\n            noise = fBM(uvw, 0.02,0.35 , 2);\n            noise = fract(noise*(0.5 + iy*5.));\n            noise = noise>0.8?mix(1.,0., (noise-0.8)*5.):noise;\n        \n    }\n    \n    //noise = pow(noise, 2.2);\n    fragColor = vec4(noise, noise, noise, 1.0);\n}\n\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265359\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   vec2 co = fragCoord;\n   float ix = 0.3; if(iMouse.x>0.){ix = iMouse.x/iResolution.x;}\n   float iy = 0.7; if(iMouse.y>0.){iy = iMouse.y/iResolution.y;}\n   vec3 col = vec3(0);\n    \n    // three sample plus dxdy\n    int pos = int(co.x)%2 + (int(co.y)%2 * 2);\n    float ra = texture(iChannel0, co/iResolution.xy, 0.).r;\n    float rb = texture(iChannel0, (co+vec2(1,0))/iResolution.xy, 0.).r;\n    float rc = texture(iChannel0, (co+vec2(0,1))/iResolution.xy, 0.).r;\n    float dx = dFdx(ra);\n    float dy = dFdy(ra);\n    if(pos == 1 || pos == 3){ dx = rb-ra; }\n    if(pos == 2 || pos == 3){ dy = rc-ra; }\n    float dz = sqrt((dx*dx) + (dy*dy));\n    float a = (PI + atan(dx,dy))/(PI*2.);\n    \n    col = hsl2rgb(vec3(a,1., ra/2.5));\n    \n\n   fragColor = (vec4(col, 1.) + texture(iChannel1, vec2(a*(1.05-ix), ra*(1.05-iy)), 0.))/1.5;\n   \n   \n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wft3W2",
    "date": "1747549412",
    "viewed": 67,
    "name": "Liquid sportscar v2",
    "description": "Some playing around to make it smoother\nClick and drag to change parameters.",
    "likes": 4,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "noise",
     "fbm",
     "gradient",
     "feedback",
     "polar",
     "angle",
     "derivates"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Liquid sportscar\" by Cotterzz. https://www.shadertoy.com/view/tftGDS\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265359\n\nvec4 getFBM( vec2 fragCoord , vec4 iMouse, vec3 iResolution, float iTime)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 2.0;\n    vec3 uvw = vec3(uv, iTime * 0.1);\n\n    float ix = 0.3; if(iMouse.x>0.){ix = iMouse.x/iResolution.x;}\n    float iy = 0.7; if(iMouse.y>0.){iy = iMouse.y/iResolution.y;}\n\t//float noise = fBM(uvw, 2.0, 0.4, 4);\n    //noise = 0.5 * noise + 0.5;\n    \n    float noise = 0.0;\n    {\n\n            uvw *= 0.4 + ix*2.;\n\n            noise = fBM(uvw, 0.02,0.35 , 2);\n            noise = fract(noise*(0.5 + iy*5.));\n            noise = noise>0.8?mix(1.,0., (noise-0.8)*5.):noise;\n        \n    }\n    \n    //noise = pow(noise, 2.2);\n    return vec4(noise, noise, noise, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   vec2 co = fragCoord;\n   float ix = 0.3; if(iMouse.x>0.){ix = iMouse.x/iResolution.x;}\n   float iy = 0.7; if(iMouse.y>0.){iy = iMouse.y/iResolution.y;}\n   vec3 col = vec3(0);\n   int AA = 1;\n   float ao, rao;\n   for(int i = 0; i<AA; i++){\n   for(int j = 0; j<AA; j++){\n    co.x += float(i)/float(AA);\n    co.y += float(j)/float(AA);\n    // three sample plus dxdy\n    int pos = int(co.x)%2 + (int(co.y)%2 * 2);\n    float ra = getFBM(co, iMouse, iResolution, iTime).r;\n    rao=ra;\n    //ra=min(0.7,ra);\n    float rb = getFBM((co+vec2(1,0)), iMouse, iResolution, iTime).r;\n    float rc = getFBM((co+vec2(0,1)), iMouse, iResolution, iTime).r;\n    float dx = dFdx(ra);\n    float dy = dFdy(ra);\n    //dx = abs(dx)<0.001 ? 0.001 : dx;\n    //dy = abs(dy)<0.001 ? 0.001 : dy;\n    if(pos == 1 || pos == 3){ dx = rb-ra; }\n    if(pos == 2 || pos == 3){ dy = rc-ra; }\n    float dz = sqrt((dx*dx) + (dy*dy));\n    float a = (PI + atan(dx,dy))/(PI*2.);\n    ao = a;\n    col += hsl2rgb(vec3(a*2.,1.5-ra*1.5, ra));\n    \n    }}\n    \n   col/=float(AA)*float(AA);\n   fragColor = (vec4(col, 1.)+ texture(iChannel0, vec2(ao*(1.05-ix), rao*(1.05-iy)), 0.))/2.;\n   \n   \n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Fork of \"Gradient Noise 3D\" by im_sky. https://shadertoy.com/view/WsjBW1\n// 2025-05-15 09:11:33\n\n#define PI 3.14159265359\n\n#define CosineCurve 0\n#define PerlinSmoothCurve 1\n\n\n\nconst vec3 dirs[] = vec3[26]\n(\n    vec3(0.57735, 0.57735, -0.57735),                                                                                                                                                                                                                 \n    vec3(0.57735, 0.57735, 0.57735),                                                                                                                                                                                                                  \n    vec3(0.70711, 0.70711, 0),                                                                                                                                                                                                                        \n    vec3(0.70711, 0, -0.70711),                                                                                                                                                                                                                       \n    vec3(0.70711, 0, 0.70711),                                                                                                                                                                                                                        \n    vec3(1, 0, 0),                                                                                                                                                                                                                                    \n    vec3(0.57735, -0.57735, -0.57735),                                                                                                                                                                                                                \n    vec3(0.57735, -0.57735, 0.57735),                                                                                                                                                                                                                 \n    vec3(0.70711, -0.70711, 0),                                                                                                                                                                                                                       \n    vec3(0, 0.70711, -0.70711),                                                                                                                                                                                                                       \n    vec3(0, 0.70711, 0.70711),                                                                                                                                                                                                                        \n    vec3(0, 1, 0),                                                                                                                                                                                                                                    \n    vec3(0, 0, -1),                                                                                                                                                                                                                                   \n    vec3(0, 0, 1),                                                                                                                                                                                                                                    \n    //vec3(0,0,0),                                                                                                                                                                                                                           \n    vec3(0, -0.70711, -0.70711),                                                                                                                                                                                                                      \n    vec3(0, -0.70711, 0.70711),                                                                                                                                                                                                                       \n    vec3(0, -1, 0),                                                                                                                                                                                                                                   \n    vec3(-0.57735, 0.57735, -0.57735),                                                                                                                                                                                                                \n    vec3(-0.57735, 0.57735, 0.57735),                                                                                                                                                                                                                 \n    vec3(-0.70711, 0.70711, 0),                                                                                                                                                                                                                       \n    vec3(-0.70711, 0, -0.70711),                                                                                                                                                                                                                      \n    vec3(-0.70711, 0, 0.70711),                                                                                                                                                                                                                       \n    vec3(-1, 0, 0),                                                                                                                                                                                                                                   \n    vec3(-0.57735, -0.57735, -0.57735),                                                                                                                                                                                                               \n    vec3(-0.57735, -0.57735, 0.57735),                                                                                                                                                                                                                \n    vec3(-0.70711, -0.70711, 0)         \n);\n\nconst int tableSize = 512;\nconst int permutationMask = 512/2 - 1;\nconst int permutationTable[512] = int[]\n(                                                                                                                                                                                                                                          \n    180, 3, 121, 17, 22, 7, 69, 202, 72, 172,                                                                                                                                                                                                         \n    56, 94, 92, 254, 122, 139, 118, 127, 76, 2,                                                                                                                                                                                                       \n    46, 74, 169, 147, 228, 196, 47, 110, 138, 217,                                                                                                                                                                                                    \n    155, 39, 91, 61, 45, 238, 242, 229, 251, 207,                                                                                                                                                                                                     \n    192, 198, 175, 222, 176, 75, 234, 10, 25, 63,                                                                                                                                                                                                     \n    250, 135, 159, 183, 253, 96, 68, 153, 87, 50,                                                                                                                                                                                                     \n    226, 241, 114, 188, 13, 112, 21, 66, 249, 144,                                                                                                                                                                                                    \n    126, 1, 233, 124, 148, 43, 199, 156, 208, 223,                                                                                                                                                                                                    \n    164, 213, 18, 219, 59, 209, 108, 134, 27, 100,                                                                                                                                                                                                    \n    197, 90, 53, 140, 168, 29, 165, 19, 65, 161,                                                                                                                                                                                                      \n    141, 52, 195, 128, 151, 37, 117, 150, 36, 105,                                                                                                                                                                                                    \n    49, 6, 187, 116, 235, 216, 201, 119, 182, 204,                                                                                                                                                                                                    \n    221, 136, 0, 113, 24, 111, 158, 131, 212, 58,                                                                                                                                                                                                     \n    41, 85, 102, 166, 77, 157, 64, 103, 184, 83,                                                                                                                                                                                                      \n    237, 220, 23, 149, 84, 171, 99, 230, 152, 178,                                                                                                                                                                                                    \n    190, 215, 38, 34, 163, 93, 14, 244, 79, 31,                                                                                                                                                                                                       \n    9, 142, 240, 132, 145, 231, 95, 236, 8, 167,                                                                                                                                                                                                      \n    82, 80, 133, 137, 252, 211, 57, 248, 89, 20,                                                                                                                                                                                                      \n    30, 154, 32, 174, 205, 42, 98, 11, 15, 243,                                                                                                                                                                                                       \n    78, 203, 146, 185, 107, 51, 224, 54, 70, 106,                                                                                                                                                                                                     \n    194, 35, 177, 160, 255, 16, 104, 189, 12, 67,                                                                                                                                                                                                     \n    125, 33, 123, 55, 120, 186, 40, 143, 181, 239,                                                                                                                                                                                                    \n    193, 214, 115, 81, 4, 44, 200, 101, 206, 71,                                                                                                                                                                                                      \n    73, 28, 86, 130, 48, 225, 210, 227, 245, 109,                                                                                                                                                                                                     \n    232, 162, 129, 179, 218, 88, 247, 173, 191, 97,                                                                                                                                                                                                   \n    62, 60, 246, 5, 26, 170,\n    180, 3, 121, 17, 22, 7, 69, 202, 72, 172,                                                                                                                                                                                                         \n    56, 94, 92, 254, 122, 139, 118, 127, 76, 2,                                                                                                                                                                                                       \n    46, 74, 169, 147, 228, 196, 47, 110, 138, 217,                                                                                                                                                                                                    \n    155, 39, 91, 61, 45, 238, 242, 229, 251, 207,                                                                                                                                                                                                     \n    192, 198, 175, 222, 176, 75, 234, 10, 25, 63,                                                                                                                                                                                                     \n    250, 135, 159, 183, 253, 96, 68, 153, 87, 50,                                                                                                                                                                                                     \n    226, 241, 114, 188, 13, 112, 21, 66, 249, 144,                                                                                                                                                                                                    \n    126, 1, 233, 124, 148, 43, 199, 156, 208, 223,                                                                                                                                                                                                    \n    164, 213, 18, 219, 59, 209, 108, 134, 27, 100,                                                                                                                                                                                                    \n    197, 90, 53, 140, 168, 29, 165, 19, 65, 161,                                                                                                                                                                                                      \n    141, 52, 195, 128, 151, 37, 117, 150, 36, 105,                                                                                                                                                                                                    \n    49, 6, 187, 116, 235, 216, 201, 119, 182, 204,                                                                                                                                                                                                    \n    221, 136, 0, 113, 24, 111, 158, 131, 212, 58,                                                                                                                                                                                                     \n    41, 85, 102, 166, 77, 157, 64, 103, 184, 83,                                                                                                                                                                                                      \n    237, 220, 23, 149, 84, 171, 99, 230, 152, 178,                                                                                                                                                                                                    \n    190, 215, 38, 34, 163, 93, 14, 244, 79, 31,                                                                                                                                                                                                       \n    9, 142, 240, 132, 145, 231, 95, 236, 8, 167,                                                                                                                                                                                                      \n    82, 80, 133, 137, 252, 211, 57, 248, 89, 20,                                                                                                                                                                                                      \n    30, 154, 32, 174, 205, 42, 98, 11, 15, 243,                                                                                                                                                                                                       \n    78, 203, 146, 185, 107, 51, 224, 54, 70, 106,                                                                                                                                                                                                     \n    194, 35, 177, 160, 255, 16, 104, 189, 12, 67,                                                                                                                                                                                                     \n    125, 33, 123, 55, 120, 186, 40, 143, 181, 239,                                                                                                                                                                                                    \n    193, 214, 115, 81, 4, 44, 200, 101, 206, 71,                                                                                                                                                                                                      \n    73, 28, 86, 130, 48, 225, 210, 227, 245, 109,                                                                                                                                                                                                     \n    232, 162, 129, 179, 218, 88, 247, 173, 191, 97,                                                                                                                                                                                                   \n    62, 60, 246, 5, 26, 170\n);\n\nint Hash(vec3 x)\n{\n    // using ampersand to calculate modulus because-\n    // mod() for negative integers gives \"wrong\" results, for instance mod(-3, 4) = 1 and not 3\n    // the ampersand trick works only if the divisor is a power of two minus 1\n    // less operatons compared to x - y * floor(x/y)\n    return permutationTable[permutationTable[permutationTable[int(x.x) & permutationMask] + int(x.z) & permutationMask] + int(x.y) & permutationMask];\n}\n\nfloat SmoothCurve(float t)\n{\n#if CosineCurve\n    return (1.0 - cos(t * PI)) * 0.5;\n#elif PerlinSmoothCurve\n    return t * t * (3.0 - 2.0 * t);\n#else\n    return t;\n#endif\n}\n\nfloat GetIntegerNoise(vec2 p)  // replace this by something better, p is essentially ivec2\n{\n    p  = 53.7 * fract( (p*0.3183099) + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nvec3 GetGradient(vec3 x)\n{\n    // using % instead of & operator, below, because the divisor is not a power of two minus 1, and the divisor will never be negative here.\n    int i = Hash(x) % 26;\n    return dirs[i];\n}\n\nfloat Get3DNoise(vec3 uvw)\n{\n    float noise = 0.0;\n    \n    vec3 p = floor(uvw);\n    vec3 f = fract(uvw);\n    \n    vec3 p1 = p + vec3(0.0, 0.0, 0.0);\n    vec3 p2 = p + vec3(1.0, 0.0, 0.0);\n    vec3 p3 = p + vec3(0.0, 1.0, 0.0);\n    vec3 p4 = p + vec3(1.0, 1.0, 0.0);\n    vec3 p5 = p + vec3(0.0, 0.0, 1.0);\n    vec3 p6 = p + vec3(1.0, 0.0, 1.0);\n    vec3 p7 = p + vec3(0.0, 1.0, 1.0);\n    vec3 p8 = p + vec3(1.0, 1.0, 1.0);\n    \n    vec3 g1 = GetGradient(p1);\n    vec3 g2 = GetGradient(p2);\n    vec3 g3 = GetGradient(p3);\n    vec3 g4 = GetGradient(p4);\n    vec3 g5 = GetGradient(p5);\n    vec3 g6 = GetGradient(p6);\n    vec3 g7 = GetGradient(p7);\n    vec3 g8 = GetGradient(p8);\n    \n    float dot1 = dot(g1, uvw - p1);\n    float dot2 = dot(g2, uvw - p2);\n    float dot3 = dot(g3, uvw - p3);\n    float dot4 = dot(g4, uvw - p4);\n    float dot5 = dot(g5, uvw - p5);\n    float dot6 = dot(g6, uvw - p6);\n    float dot7 = dot(g7, uvw - p7);\n    float dot8 = dot(g8, uvw - p8);\n    \n    float wX = SmoothCurve(f.x);\n    float noiseY1 = mix(dot1, dot2, wX);\n    float noiseY2 = mix(dot3, dot4, wX);\n    float noiseY3 = mix(dot5, dot6, wX);\n    float noiseY4 = mix(dot7, dot8, wX);\n    \n    float wY = SmoothCurve(f.y);\n    float noiseZ1 = mix(noiseY1, noiseY2, wY);\n    float noiseZ2 = mix(noiseY3, noiseY4, wY);\n    \n    float wZ = SmoothCurve(f.z);\n    noise = mix(noiseZ1, noiseZ2, wZ);\n    \n    return noise;\n}\n\n//https://iquilezles.org/articles/fbm\n// H: Hurst Exponent, affects the integration of noise partially\nfloat fBM(vec3 x, float H, int numOctaves)\n{\n    float total = 0.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        float frequency = pow(2.0, float(i));\n        float amplitude = pow(frequency, -H);\n        total += amplitude * Get3DNoise(x * frequency);\n    }\n\t\n    return total;\n}\n\n// https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/procedural-patterns-noise-part-1/simple-pattern-examples\n// output range -1.0 to 1.0\nfloat fBM(vec3 x, float lacunarity, float gain, int numOctaves)\n{\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        total += amplitude * Get3DNoise(x * frequency);\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return total;\n}\n\nfloat Turbulence(vec3 x, float lacunarity, float gain, int numOctaves)\n{\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        total += amplitude * abs(Get3DNoise(x * frequency));\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n\t\n    return total;\n}\n\nfloat HighPassFilter(float x, float threshold)\n{\n    x = max(x, threshold);\n    x -= threshold;\n    x /= (1.0 - threshold);\n    return x;\n}\n\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tccGWX",
    "date": "1747579802",
    "viewed": 57,
    "name": "Visualising Buffer Feedback",
    "description": "Top - with colour, bottom without\nLeft - with feedback, right without",
    "likes": 6,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "noise",
     "fbm",
     "gradient",
     "feedback",
     "polar",
     "angle",
     "derivates"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Liquid sportscar v2\" by Cotterzz. https://shadertoy.com/view/Wft3W2\n// 2025-05-18 14:28:34\n\n// Fork of \"Liquid sportscar\" by Cotterzz. https://www.shadertoy.com/view/tftGDS\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265359\n\nvec4 getFBM( vec2 fragCoord , vec4 iMouse, vec3 iResolution, float iTime)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 2.0;\n    vec3 uvw = vec3(uv, iTime * 0.1);\n\n    float ix = 0.3; if(iMouse.x>0.){ix = iMouse.x/iResolution.x;}\n    float iy = 0.7; if(iMouse.y>0.){iy = iMouse.y/iResolution.y;}\n\t//float noise = fBM(uvw, 2.0, 0.4, 4);\n    //noise = 0.5 * noise + 0.5;\n    \n    float noise = 0.0;\n    {\n\n            uvw *= 0.4 + ix*2.;\n\n            noise = fBM(uvw, 0.02,0.35 , 2);\n            noise = fract(noise*(0.5 + iy*5.));\n            noise = noise>0.8?mix(1.,0., (noise-0.8)*5.):noise;\n        \n    }\n    \n    //noise = pow(noise, 2.2);\n    return vec4(noise, noise, noise, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 bounds = vec2(iResolution.x/2.,iResolution.y/2.);\n    \n   if( iMouse.z>0. || iMouse.x>0. || iMouse.y>0.) { bounds.x = iMouse.x;bounds.y = iMouse.y;}\n   vec2 co = fragCoord;\n   float ix = 0.3; if(iMouse.x>0.){ix = iMouse.x/iResolution.x;}\n   float iy = 0.7; if(iMouse.y>0.){iy = iMouse.y/iResolution.y;}\n   vec3 col = vec3(0);\n\n    // three sample plus dxdy\n    int pos = int(co.x)%2 + (int(co.y)%2 * 2);\n    float ra = getFBM(co, iMouse, iResolution, iTime).r;\n\n    //ra=min(0.7,ra);\n    float rb = getFBM((co+vec2(1,0)), iMouse, iResolution, iTime).r;\n    float rc = getFBM((co+vec2(0,1)), iMouse, iResolution, iTime).r;\n    float dx = dFdx(ra);\n    float dy = dFdy(ra);\n    //dx = abs(dx)<0.001 ? 0.001 : dx;\n    //dy = abs(dy)<0.001 ? 0.001 : dy;\n    if(pos == 1 || pos == 3){ dx = rb-ra; }\n    if(pos == 2 || pos == 3){ dy = rc-ra; }\n    float dz = sqrt((dx*dx) + (dy*dy));\n    float a = (PI + atan(dx,dy))/(PI*2.);\n    if(fragCoord.y<bounds.y){\n        col += vec3(ra);} else {col += hsl2rgb(vec3(a*2.,1.5-ra*1.5, ra));}\n    \n\n   \n   fragColor = vec4(col, 1.);\n   \n   if(fragCoord.x<bounds.x){\n       fragColor =( fragColor + texture(iChannel0, vec2(a*(1.05-ix), ra*(1.05-iy)), 0.))/2.;\n   }\n   if(abs(floor(fragCoord.x)-floor(bounds.x))<5.){fragColor = vec4(0,1,0,1);}\n   if(abs(floor(fragCoord.y)-floor(bounds.y))<5.){fragColor = vec4(1,0,0,1);}\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Fork of \"Gradient Noise 3D\" by im_sky. https://shadertoy.com/view/WsjBW1\n// 2025-05-15 09:11:33\n\n#define PI 3.14159265359\n\n#define CosineCurve 0\n#define PerlinSmoothCurve 1\n\n\n\nconst vec3 dirs[] = vec3[26]\n(\n    vec3(0.57735, 0.57735, -0.57735),                                                                                                                                                                                                                 \n    vec3(0.57735, 0.57735, 0.57735),                                                                                                                                                                                                                  \n    vec3(0.70711, 0.70711, 0),                                                                                                                                                                                                                        \n    vec3(0.70711, 0, -0.70711),                                                                                                                                                                                                                       \n    vec3(0.70711, 0, 0.70711),                                                                                                                                                                                                                        \n    vec3(1, 0, 0),                                                                                                                                                                                                                                    \n    vec3(0.57735, -0.57735, -0.57735),                                                                                                                                                                                                                \n    vec3(0.57735, -0.57735, 0.57735),                                                                                                                                                                                                                 \n    vec3(0.70711, -0.70711, 0),                                                                                                                                                                                                                       \n    vec3(0, 0.70711, -0.70711),                                                                                                                                                                                                                       \n    vec3(0, 0.70711, 0.70711),                                                                                                                                                                                                                        \n    vec3(0, 1, 0),                                                                                                                                                                                                                                    \n    vec3(0, 0, -1),                                                                                                                                                                                                                                   \n    vec3(0, 0, 1),                                                                                                                                                                                                                                    \n    //vec3(0,0,0),                                                                                                                                                                                                                           \n    vec3(0, -0.70711, -0.70711),                                                                                                                                                                                                                      \n    vec3(0, -0.70711, 0.70711),                                                                                                                                                                                                                       \n    vec3(0, -1, 0),                                                                                                                                                                                                                                   \n    vec3(-0.57735, 0.57735, -0.57735),                                                                                                                                                                                                                \n    vec3(-0.57735, 0.57735, 0.57735),                                                                                                                                                                                                                 \n    vec3(-0.70711, 0.70711, 0),                                                                                                                                                                                                                       \n    vec3(-0.70711, 0, -0.70711),                                                                                                                                                                                                                      \n    vec3(-0.70711, 0, 0.70711),                                                                                                                                                                                                                       \n    vec3(-1, 0, 0),                                                                                                                                                                                                                                   \n    vec3(-0.57735, -0.57735, -0.57735),                                                                                                                                                                                                               \n    vec3(-0.57735, -0.57735, 0.57735),                                                                                                                                                                                                                \n    vec3(-0.70711, -0.70711, 0)         \n);\n\nconst int tableSize = 512;\nconst int permutationMask = 512/2 - 1;\nconst int permutationTable[512] = int[]\n(                                                                                                                                                                                                                                          \n    180, 3, 121, 17, 22, 7, 69, 202, 72, 172,                                                                                                                                                                                                         \n    56, 94, 92, 254, 122, 139, 118, 127, 76, 2,                                                                                                                                                                                                       \n    46, 74, 169, 147, 228, 196, 47, 110, 138, 217,                                                                                                                                                                                                    \n    155, 39, 91, 61, 45, 238, 242, 229, 251, 207,                                                                                                                                                                                                     \n    192, 198, 175, 222, 176, 75, 234, 10, 25, 63,                                                                                                                                                                                                     \n    250, 135, 159, 183, 253, 96, 68, 153, 87, 50,                                                                                                                                                                                                     \n    226, 241, 114, 188, 13, 112, 21, 66, 249, 144,                                                                                                                                                                                                    \n    126, 1, 233, 124, 148, 43, 199, 156, 208, 223,                                                                                                                                                                                                    \n    164, 213, 18, 219, 59, 209, 108, 134, 27, 100,                                                                                                                                                                                                    \n    197, 90, 53, 140, 168, 29, 165, 19, 65, 161,                                                                                                                                                                                                      \n    141, 52, 195, 128, 151, 37, 117, 150, 36, 105,                                                                                                                                                                                                    \n    49, 6, 187, 116, 235, 216, 201, 119, 182, 204,                                                                                                                                                                                                    \n    221, 136, 0, 113, 24, 111, 158, 131, 212, 58,                                                                                                                                                                                                     \n    41, 85, 102, 166, 77, 157, 64, 103, 184, 83,                                                                                                                                                                                                      \n    237, 220, 23, 149, 84, 171, 99, 230, 152, 178,                                                                                                                                                                                                    \n    190, 215, 38, 34, 163, 93, 14, 244, 79, 31,                                                                                                                                                                                                       \n    9, 142, 240, 132, 145, 231, 95, 236, 8, 167,                                                                                                                                                                                                      \n    82, 80, 133, 137, 252, 211, 57, 248, 89, 20,                                                                                                                                                                                                      \n    30, 154, 32, 174, 205, 42, 98, 11, 15, 243,                                                                                                                                                                                                       \n    78, 203, 146, 185, 107, 51, 224, 54, 70, 106,                                                                                                                                                                                                     \n    194, 35, 177, 160, 255, 16, 104, 189, 12, 67,                                                                                                                                                                                                     \n    125, 33, 123, 55, 120, 186, 40, 143, 181, 239,                                                                                                                                                                                                    \n    193, 214, 115, 81, 4, 44, 200, 101, 206, 71,                                                                                                                                                                                                      \n    73, 28, 86, 130, 48, 225, 210, 227, 245, 109,                                                                                                                                                                                                     \n    232, 162, 129, 179, 218, 88, 247, 173, 191, 97,                                                                                                                                                                                                   \n    62, 60, 246, 5, 26, 170,\n    180, 3, 121, 17, 22, 7, 69, 202, 72, 172,                                                                                                                                                                                                         \n    56, 94, 92, 254, 122, 139, 118, 127, 76, 2,                                                                                                                                                                                                       \n    46, 74, 169, 147, 228, 196, 47, 110, 138, 217,                                                                                                                                                                                                    \n    155, 39, 91, 61, 45, 238, 242, 229, 251, 207,                                                                                                                                                                                                     \n    192, 198, 175, 222, 176, 75, 234, 10, 25, 63,                                                                                                                                                                                                     \n    250, 135, 159, 183, 253, 96, 68, 153, 87, 50,                                                                                                                                                                                                     \n    226, 241, 114, 188, 13, 112, 21, 66, 249, 144,                                                                                                                                                                                                    \n    126, 1, 233, 124, 148, 43, 199, 156, 208, 223,                                                                                                                                                                                                    \n    164, 213, 18, 219, 59, 209, 108, 134, 27, 100,                                                                                                                                                                                                    \n    197, 90, 53, 140, 168, 29, 165, 19, 65, 161,                                                                                                                                                                                                      \n    141, 52, 195, 128, 151, 37, 117, 150, 36, 105,                                                                                                                                                                                                    \n    49, 6, 187, 116, 235, 216, 201, 119, 182, 204,                                                                                                                                                                                                    \n    221, 136, 0, 113, 24, 111, 158, 131, 212, 58,                                                                                                                                                                                                     \n    41, 85, 102, 166, 77, 157, 64, 103, 184, 83,                                                                                                                                                                                                      \n    237, 220, 23, 149, 84, 171, 99, 230, 152, 178,                                                                                                                                                                                                    \n    190, 215, 38, 34, 163, 93, 14, 244, 79, 31,                                                                                                                                                                                                       \n    9, 142, 240, 132, 145, 231, 95, 236, 8, 167,                                                                                                                                                                                                      \n    82, 80, 133, 137, 252, 211, 57, 248, 89, 20,                                                                                                                                                                                                      \n    30, 154, 32, 174, 205, 42, 98, 11, 15, 243,                                                                                                                                                                                                       \n    78, 203, 146, 185, 107, 51, 224, 54, 70, 106,                                                                                                                                                                                                     \n    194, 35, 177, 160, 255, 16, 104, 189, 12, 67,                                                                                                                                                                                                     \n    125, 33, 123, 55, 120, 186, 40, 143, 181, 239,                                                                                                                                                                                                    \n    193, 214, 115, 81, 4, 44, 200, 101, 206, 71,                                                                                                                                                                                                      \n    73, 28, 86, 130, 48, 225, 210, 227, 245, 109,                                                                                                                                                                                                     \n    232, 162, 129, 179, 218, 88, 247, 173, 191, 97,                                                                                                                                                                                                   \n    62, 60, 246, 5, 26, 170\n);\n\nint Hash(vec3 x)\n{\n    // using ampersand to calculate modulus because-\n    // mod() for negative integers gives \"wrong\" results, for instance mod(-3, 4) = 1 and not 3\n    // the ampersand trick works only if the divisor is a power of two minus 1\n    // less operatons compared to x - y * floor(x/y)\n    return permutationTable[permutationTable[permutationTable[int(x.x) & permutationMask] + int(x.z) & permutationMask] + int(x.y) & permutationMask];\n}\n\nfloat SmoothCurve(float t)\n{\n#if CosineCurve\n    return (1.0 - cos(t * PI)) * 0.5;\n#elif PerlinSmoothCurve\n    return t * t * (3.0 - 2.0 * t);\n#else\n    return t;\n#endif\n}\n\nfloat GetIntegerNoise(vec2 p)  // replace this by something better, p is essentially ivec2\n{\n    p  = 53.7 * fract( (p*0.3183099) + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nvec3 GetGradient(vec3 x)\n{\n    // using % instead of & operator, below, because the divisor is not a power of two minus 1, and the divisor will never be negative here.\n    int i = Hash(x) % 26;\n    return dirs[i];\n}\n\nfloat Get3DNoise(vec3 uvw)\n{\n    float noise = 0.0;\n    \n    vec3 p = floor(uvw);\n    vec3 f = fract(uvw);\n    \n    vec3 p1 = p + vec3(0.0, 0.0, 0.0);\n    vec3 p2 = p + vec3(1.0, 0.0, 0.0);\n    vec3 p3 = p + vec3(0.0, 1.0, 0.0);\n    vec3 p4 = p + vec3(1.0, 1.0, 0.0);\n    vec3 p5 = p + vec3(0.0, 0.0, 1.0);\n    vec3 p6 = p + vec3(1.0, 0.0, 1.0);\n    vec3 p7 = p + vec3(0.0, 1.0, 1.0);\n    vec3 p8 = p + vec3(1.0, 1.0, 1.0);\n    \n    vec3 g1 = GetGradient(p1);\n    vec3 g2 = GetGradient(p2);\n    vec3 g3 = GetGradient(p3);\n    vec3 g4 = GetGradient(p4);\n    vec3 g5 = GetGradient(p5);\n    vec3 g6 = GetGradient(p6);\n    vec3 g7 = GetGradient(p7);\n    vec3 g8 = GetGradient(p8);\n    \n    float dot1 = dot(g1, uvw - p1);\n    float dot2 = dot(g2, uvw - p2);\n    float dot3 = dot(g3, uvw - p3);\n    float dot4 = dot(g4, uvw - p4);\n    float dot5 = dot(g5, uvw - p5);\n    float dot6 = dot(g6, uvw - p6);\n    float dot7 = dot(g7, uvw - p7);\n    float dot8 = dot(g8, uvw - p8);\n    \n    float wX = SmoothCurve(f.x);\n    float noiseY1 = mix(dot1, dot2, wX);\n    float noiseY2 = mix(dot3, dot4, wX);\n    float noiseY3 = mix(dot5, dot6, wX);\n    float noiseY4 = mix(dot7, dot8, wX);\n    \n    float wY = SmoothCurve(f.y);\n    float noiseZ1 = mix(noiseY1, noiseY2, wY);\n    float noiseZ2 = mix(noiseY3, noiseY4, wY);\n    \n    float wZ = SmoothCurve(f.z);\n    noise = mix(noiseZ1, noiseZ2, wZ);\n    \n    return noise;\n}\n\n//https://iquilezles.org/articles/fbm\n// H: Hurst Exponent, affects the integration of noise partially\nfloat fBM(vec3 x, float H, int numOctaves)\n{\n    float total = 0.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        float frequency = pow(2.0, float(i));\n        float amplitude = pow(frequency, -H);\n        total += amplitude * Get3DNoise(x * frequency);\n    }\n\t\n    return total;\n}\n\n// https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/procedural-patterns-noise-part-1/simple-pattern-examples\n// output range -1.0 to 1.0\nfloat fBM(vec3 x, float lacunarity, float gain, int numOctaves)\n{\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        total += amplitude * Get3DNoise(x * frequency);\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return total;\n}\n\nfloat Turbulence(vec3 x, float lacunarity, float gain, int numOctaves)\n{\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        total += amplitude * abs(Get3DNoise(x * frequency));\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n\t\n    return total;\n}\n\nfloat HighPassFilter(float x, float threshold)\n{\n    x = max(x, threshold);\n    x -= threshold;\n    x /= (1.0 - threshold);\n    return x;\n}\n\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wf3GDX",
    "date": "1747583911",
    "viewed": 112,
    "name": "Koch Snowflake using buffer",
    "description": "Using the buffer for feedback to create koch snowflake\nRed dots to show how the buffer is being copied - six times, to create infinite pattern.",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "recursive",
     "rectangle",
     "feedback",
     "buffer"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float fEquilateralTriangle(  in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    return -p.y + 0.5*k*max(abs(p.x)+k*p.y,0.0) - r*(1.0/k);\n}\n\nvec4 compare(vec4 new, vec4 old){\n    return old.r > old.g*2. ? old : min(new , old);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 nuv = fragCoord/iResolution.xy;\n   vec2 uv = fragCoord/iResolution.y;\n   float ar = iResolution.x/iResolution.y;\n   vec3 col = vec3(1);\n   \n   if(fEquilateralTriangle(uv-vec2(0.5*ar, 0.5), .1)<0.1){col = vec3(0);} // Draw a triangle\n   \n   if(distance(uv, vec2(ar/2.,0.5))<.05){col = vec3(1,0,0);} \n   \n   fragColor = vec4(col, 1.); // output  to screen\n   \n    if(iFrame%60 == 0){\n   vec2 newCoords2 = vec2(uv.x/ar , uv.y-1.00);\n   vec2 newCoords = vec2(uv.x/ar , -uv.y);\n   \n   float mult = 3.;\n   float y1 = -2.315;\n   float y2 = -1.375;\n   float x1 = 1.0;\n   float xw = .307;\n   float x2 = x1+ xw;\n   float x3 = x1- xw;\n   fragColor = compare(fragColor , texture(iChannel0, (newCoords*mult)-vec2(x3,y1), 0.));\n   fragColor = compare(fragColor , texture(iChannel0, (newCoords*mult)-vec2(x2,y1), 0.));\n   fragColor = compare(fragColor , texture(iChannel0, (newCoords*mult)-vec2(x1,y2), 0.));\n   fragColor = compare(fragColor , texture(iChannel0, (newCoords2*mult)-vec2(x3,y1), 0.));\n   fragColor = compare(fragColor , texture(iChannel0, (newCoords2*mult)-vec2(x2,y1), 0.));\n   fragColor = compare(fragColor , texture(iChannel0, (newCoords2*mult)-vec2(x1,y2), 0.));\n  } else {\n  \n   fragColor = texture(iChannel0, nuv, 0.);\n  }\n   if(iFrame<2){fragColor = vec4(col, 1.);} \n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wf33Wl",
    "date": "1747645630",
    "viewed": 106,
    "name": "Koch with buffer rotation",
    "description": "Using the buffer for feedback to create koch snowflake, blue dots to show how the buffer is being copied - six times, rotated, to create infinite pattern.\nMuch better version with precise rotation and rotated addition.",
    "likes": 1,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "recursive",
     "rectangle",
     "feedback",
     "buffer"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float fEquilateralTriangle(  in vec2 p, in float r ){const float k = sqrt(3.0);return -p.y + 0.5*k*max(abs(p.x)+k*p.y,0.0) - r*(1.0/k);}\n\nvec4 compare(vec4 new, vec4 old){return old.b > old.g*2. ? old : min(new , old);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 nuv = fragCoord/iResolution.xy;\n   vec2 uv = fragCoord/iResolution.y;\n   float ar = iResolution.x/iResolution.y;\n   int freq = 14;\n   fragColor = texture(iChannel0, nuv, 0.);\n   if(iFrame<2){\n       vec3 col = vec3(1);\n       if(fEquilateralTriangle(uv-vec2(0.5*ar, 0.5), .1)<0.1){col = vec3(0);}\n       if(distance(uv, vec2(ar/2.,0.5))<.05){col = vec3(0,0,1);}\n       fragColor = vec4(col, 1.);\n   } else if(iFrame%freq == 0){\n       vec2 nc = uv-vec2(0.5*ar, 0.5); \n       float rad = distance(nc,vec2(0,0));\n       float angle = 0.52359877 + float((iFrame/freq)%6)*1.04703 + atan(nc.x,nc.y);\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=.207; nc*= 3.; nc.x/=ar; nc+=0.5;\n       fragColor = compare(fragColor , texture(iChannel0, nc, 0.));\n   }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tfcGDs",
    "date": "1747659422",
    "viewed": 80,
    "name": "Koch Squareflake?",
    "description": "Not strictly a type of Koch curve, notice the bare corners of the square, you can't actually fit the required geometry without making the squares much smaller.\nLike the triangle requires six directions of self similarity, the square needs eight.",
    "likes": 2,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "recursive",
     "square",
     "feedback",
     "buffer",
     "koch"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 12:07:11\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float square(  in vec2 p, in float r ){ return max( abs(p.x)-r, abs(p.y)-r ); }\n\nvec4 compare(vec4 new, vec4 old){return old.g > old.r*2. ? old : min(new , old);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 nuv = fragCoord/iResolution.xy;\n   vec2 uv = fragCoord/iResolution.y;\n   float ar = iResolution.x/iResolution.y;\n   int freq = 14;\n   fragColor = texture(iChannel0, nuv, 0.);\n   if(iFrame<2){\n       vec3 col = vec3(1);\n       if(square(uv-vec2(0.5*ar, 0.5), .1)<0.1){col = vec3(0);}\n       if(distance(uv, vec2(ar/2.,0.5))<.05){col = vec3(0,1,0);}\n       fragColor = vec4(col, 1.);\n   } else if(iFrame%freq == 0){\n       vec2 nc = uv-vec2(0.5*ar, 0.5); \n       float rad = distance(nc,vec2(0,0));\n       float angle = float((iFrame/freq)%4)*1.5707963 + atan(nc.x,nc.y);\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=.275; nc*= 2.5; nc.x/=ar; nc+=0.5;\n       fragColor = compare(fragColor , texture(iChannel0, nc, 0.));\n   }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wf33Ds",
    "date": "1747661753",
    "viewed": 88,
    "name": "Koch Squareflake 2",
    "description": "True equivalent of the Koch snowflake for a square (as in constructed the same way)\nThis is why it's not a famous Koch curve. You just end up with another square!\nI've moved the other one to it's own shader now: https://www.shadertoy.com/view/Wfd3Wl",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "recursive",
     "square",
     "feedback",
     "buffer",
     "koch"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Koch Squareflake?\" by Cotterzz. https://shadertoy.com/view/tfcGDs\n// 2025-05-19 13:27:17\n\n// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 12:07:11\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, (fragCoord/iResolution.xy), 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float square(  in vec2 p, in float r ){ return max( abs(p.x)-r, abs(p.y)-r ); }\n\nvec4 compare(vec4 new, vec4 old){return old.r > old.b*2. ? old : min(new , old);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 nuv = fragCoord/iResolution.xy;\n   vec2 uv = fragCoord/iResolution.y;\n   float ar = iResolution.x/iResolution.y;\n   int freq = 20;\n   fragColor = texture(iChannel0, nuv, 0.);\n   if(iFrame<2){\n       vec3 col = vec3(1);\n       if(square(uv-vec2(0.5*ar, 0.5), .1)<0.1){col = vec3(0);}\n       if(distance(uv, vec2(ar/2.,0.5))<.05){col = vec3(1,1,0);}\n       fragColor = vec4(col, 1.);\n   } else if(iFrame%freq == 0){\n       int count = (iFrame/freq)%4;\n       vec2 nc = uv-vec2(0.5*ar, 0.5); \n       float rad = distance(nc,vec2(0,0));\n       float angle = float(count)*1.5707963 + atan(nc.x,nc.y);\n       vec2 nc2 = nc;\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=.266; nc*= 3.; nc.x/=ar; nc+=0.5;\n       nc2.y-=.266; nc2*= 3.; nc2.x/=ar; nc2+=0.5;\n       nc2 -= count==0?vec2(.225, -.4):count==1?vec2(-.225, -.4):count==2?vec2(-.225, -1.2):vec2(.225, -1.2);\n       fragColor = compare(fragColor , texture(iChannel0, nc, 0.));\n       fragColor = compare(fragColor , texture(iChannel0, nc2, 0.));\n   }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wfd3Wl",
    "date": "1749294083",
    "viewed": 85,
    "name": "Koch Fraccident",
    "description": "I couldnt publish this one by itself before because of posting restrictions.\nThis was an accident, or a fraccident I guess.\n",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "recursive",
     "square",
     "feedback",
     "buffer",
     "koch"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Koch Squareflake 2\" by Cotterzz. https://shadertoy.com/view/wf33Ds\n// 2025-05-19 14:08:04\n\n// Fork of \"Koch Squareflake?\" by Cotterzz. https://shadertoy.com/view/tfcGDs\n// 2025-05-19 13:27:17\n\n// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 12:07:11\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float square(  in vec2 p, in float r ){ return max( abs(p.x)-r, abs(p.y)-r ); }\n\nvec4 compare(vec4 new, vec4 old){return old.b > old.r*2. ? old : min(new , old);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 nuv = fragCoord/iResolution.xy;\n   vec2 uv = fragCoord/iResolution.y;\n   float ar = iResolution.x/iResolution.y;\n   int freq = 10;\n   fragColor = texture(iChannel0, nuv, 0.);\n   if(iFrame<2){\n       vec3 col = vec3(1);\n       if(square(uv-vec2(0.5*ar, 0.5), .1)<0.075){col = vec3(0);}\n       if(distance(uv, vec2(ar/2.,0.5))<.05){col = vec3(0,1,1);}\n       fragColor = vec4(col, 1.);\n   } else if(iFrame%freq == 0){\n       vec2 nc = uv-vec2(0.5*ar, 0.5); \n       float rad = distance(nc,vec2(0,0));\n       float angle = float((iFrame/freq)%4)*1.5707963 + atan(nc.x,nc.y);\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=.245; nc.x-=.13; nc*= 2.1; nc.x/=ar; nc+=0.5;\n       fragColor = compare(fragColor , texture(iChannel0, nc, 0.));\n   }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tfd3Ds",
    "date": "1747679473",
    "viewed": 45,
    "name": "Koch with hexagons",
    "description": "Trying this with hexagons, and you get.. a regular Koch snowflake!\n\nWeird.",
    "likes": 2,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "recursive",
     "rectangle",
     "feedback",
     "buffer"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 18:21:33\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float fEquilateralTriangle(  in vec2 p, in float r ){const float k = sqrt(3.0);return -p.y + 0.5*k*max(abs(p.x)+k*p.y,0.0) - r*(1.0/k);}\n\nvec4 compare(vec4 new, vec4 old){return old.b > old.g*2. ? old : min(new , old);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 nuv = fragCoord/iResolution.xy;\n   vec2 uv = fragCoord/iResolution.y;\n   float ar = iResolution.x/iResolution.y;\n   int freq = 20;\n   fragColor = texture(iChannel0, nuv, 0.);\n   if(iFrame<2){\n       vec2 R = iResolution.xy, U = abs(fragCoord+fragCoord - R);// from \"shortest hexagon (88 chars)\"\n       fragColor = 1.-vec4 ( U.x < min( .5*R ,R - U*1.7 ).y ); // by FabriceNeyret2 https://www.shadertoy.com/view/4scXWS\n       \n       if(distance(uv, vec2(ar/2.,0.5))<.05){fragColor = vec4(0,0,1,1);}\n\n   } else if(iFrame%freq == 0){\n       vec2 nc = uv-vec2(0.5*ar, 0.5); \n       float rad = distance(nc,vec2(0,0));\n       float angle = 0.523598775598298873 + float((iFrame/freq)%6)*1.04703 + atan(nc.x,nc.y);\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=.288; nc.x-=.167;nc*= 3.; nc.x/=ar; nc+=0.5;\n       fragColor = compare(fragColor , texture(iChannel0, nc, 0.));\n   }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WfK3Rz",
    "date": "0",
    "viewed": 0,
    "name": "Caustics with feedback",
    "description": "Simple Caustic",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "3d",
     "caustic"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Simple Caustic (world space)\" by ZeroSkyline. https://shadertoy.com/view/WccGWl\n// 2025-05-20 06:45:44\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n   //fragColor.rgb = pow(fragColor.rgb, vec3(0.6));\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float Caustic(vec3 p)\n{\n    mat3 r = mat3(-0.6,-0.3,0.6, 0.9,-0.6,0.3, 0.3,0.6,0.6);\n    float d = 1.0;\n    for (int i = 0; i < 3; i++)\n    {\n    \tp *= r;\n    \td = min(d,length(fract(p)-0.5));\n    }\n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv *= 1.5 + (iMouse.x/iResolution.x*10.);\n    uv -= iMouse.x/iResolution.x*5.;\n    \n    vec3 p = vec3(uv.x, uv.y, 0.0) + iTime;\n    \n    float c = pow(Caustic(p), 2.0);\n    \n    fragColor = vec4(c,c,c,1.0);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265359\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   vec2 co = fragCoord;\n   //float ix = 0.3; if(iMouse.x>0.){ix = iMouse.x/iResolution.x;}\n   //float iy = 0.7; if(iMouse.y>0.){iy = iMouse.y/iResolution.y;}\n   float scale  = 0.2 + iMouse.x/iResolution.x*16.;\n   vec3 col = vec3(0);\n    \n    // three sample plus dxdy\n    int pos = int(co.x)%2 + (int(co.y)%2 * 2);\n    float ra = texture(iChannel0, co/iResolution.xy, 0.).r;\n    float rb = texture(iChannel0, (co+vec2(1,0))/iResolution.xy, 0.).r;\n    float rc = texture(iChannel0, (co+vec2(0,1))/iResolution.xy, 0.).r;\n    float dx = dFdx(ra);\n    float dy = dFdy(ra);\n    if(pos == 1 || pos == 3){ dx = rb-ra; }\n    if(pos == 2 || pos == 3){ dy = rc-ra; }\n    float dz = sqrt((dx*dx) + (dy*dy));\n    float a = (PI + atan(dx,dy))/(PI*2.);\n    \n    col = vec3(ra);//hsl2rgb(vec3(a,1., ra/2.5));\n    col *= hsl2rgb(vec3(a/2.5+0.85,1., ra/2.5));\n    \n    vec2 nc = vec2(0.5);\n    \n    nc.x -= cos(a*6.28318)*sqrt(ra);\n    nc.y -= sin(a*6.28318)*sqrt(ra);\n    \n    nc/=1.5 - scale/40.;\n\n   // fragColor = (vec4(col, 1.) + texture(iChannel1, vec2(a*(1.05-ix), ra*(1.05-iy)), 0.))/1.5;\n   fragColor = (vec4(col, 1.) + texture(iChannel1, nc, 0.))/1.1;\n   //fragColor = vec4(a,-a,0, 1.);\n   \n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tfG3zW",
    "date": "1747841336",
    "viewed": 286,
    "name": "Massive alien orgy",
    "description": "I was playing with voronoi, and one thing led to another...",
    "likes": 9,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "voronoi",
     "anatomy"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// based on iq's voronoi at https://thebookofshaders.com/edit.php#12/2d-voronoi.frag\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x , float tm) {\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    float it = iTime*tm;\n    // first pass: regular voronoi\n    vec2 mg, mr;\n    float md = 8.0;\n    for (int j= -1; j <= 1; j++) {\n        for (int i= -1; i <= 1; i++) {\n            vec2 g = vec2(float(i),float(j));\n            vec2 o = random2( n + g );\n            o = 0.5 + 0.5*sin( it + 6.2831*o );\n\n            vec2 r = g + o - f;\n            float d = dot(r,r);\n\n            if( d<md ) {\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n\n    // second pass: distance to borders\n    md = 8.0;\n    for (int j= -2; j <= 2; j++) {\n        for (int i= -2; i <= 2; i++) {\n            vec2 g = mg + vec2(float(i),float(j));\n            vec2 o = random2( n + g );\n            o = 0.5 + 0.5*sin( it + 6.2831*o );\n\n            vec2 r = g + o - f;\n\n            if ( dot(mr-r,mr-r)>0.00001 ) {\n                md = min(md, dot( 0.5*(mr+r), normalize(r-mr) ));\n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvec3 vcell(vec2 st, float tm){\n    vec3 c = voronoi(st, tm);\n    vec3 color = vec3(0.);\n    // isolines\n    color = c.x*(0.5 + 0.5*sin(64.0*c.x))*vec3(1.0);\n    // borders\n    color = mix( vec3(1.0), color, smoothstep( 0.01, 0.02, c.x ) );\n    // feature points\n    float dd = length( c.yz );\n    color += vec3(1.)*(1.0-smoothstep( 0.0, 0.04, dd));\n    float bounds = iResolution.y*0.8;\n    \n    if( iMouse.z>0. || iMouse.x>0. || iMouse.y>0.) { bounds = iMouse.y;}\n    \n    float mixd = (0.5-dd)*(0.5-c.x);\n    return vec3(pow(mixd,0.7-(bounds/iResolution.y/1.7)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   float bounds = iResolution.x/1.6;\n    \n   if( iMouse.z>0. || iMouse.x>0. || iMouse.y>0.) { bounds = iMouse.x;}\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 st = uv-0.5; st.x *= iResolution.x/iResolution.y;\n    st*=0.7 + (3.5*bounds/iResolution.x);\n    float it = 0.4;\n    vec3 col = vec3(0);\n    for(float i = 4.0; i<17.; i*=1.3){\n        st+=i;\n        col = max(col, vcell(st*i*it, i)/(i/3.5));\n    }\n\n\n    fragColor = vec4(col,1.0);\n    \n   // fragColor = (fragColor+texture(iChannel0, uv, 0.))/1.55;\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265359\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 addLight(vec3 position, vec3 normal, vec3 colour, vec3 lcol, vec3 lpos){\n    vec3 ref = reflect(vec3(0.0, 0.0, -1.0), normal);\n    vec3 diff = lpos - position;\n    float ldist = length(diff);\n    diff = diff/ldist;\n    float specular = pow(max(0.0, dot(diff, ref)), 64.0);\n    float diffuse = max(0.0, dot(diff,normal));\n    vec3 col1 = colour*0.7;\n    vec3 col2 = colour*0.4*(lcol*diffuse);\n    col2 = col2+(lcol*specular);\n    return col1+col2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   vec2 co = fragCoord;\n   float scale  = 0.2 + iMouse.x/iResolution.x*16.;\n   vec3 col = vec3(0);\n    \n    // three sample plus dxdy\n    int pos = int(co.x)%2 + (int(co.y)%2 * 2);\n    float ra = texture(iChannel0, co/iResolution.xy, 0.).r;\n    float rb = texture(iChannel0, (co+vec2(1,0))/iResolution.xy, 0.).r;\n    float rc = texture(iChannel0, (co+vec2(0,1))/iResolution.xy, 0.).r;\n    float dx = dFdx(ra);\n    float dy = dFdy(ra);\n    if(pos == 1 || pos == 3){ dx = rb-ra; }\n    if(pos == 2 || pos == 3){ dy = rc-ra; }\n    float dz = sqrt((dx*dx) + (dy*dy));\n    float a = (PI + atan(dx,dy))/(PI*2.);\n    \n    float bounds = iResolution.y/1.6;\n    \n    if( iMouse.z>0. || iMouse.x>0. || iMouse.y>0.) { bounds = iMouse.y;}\n    float dvh = 10. + (bounds/iResolution.y)*120.;\n    vec3 normal = normalize(vec3(dx*dvh, dy*dvh, ra));\n    \n    col = vec3(0.8,0.5+(ra/3.),0.4+(ra/3.));\n    \n    col*=(0.3+(ra*1.5));\n    \n    vec3 position = vec3(co/iResolution.xy, ra);\n    \n    vec3 lcol = vec3(1);\n    vec3 lpos = vec3(-0.5,-0.5,2);\n    \n    vec3 rend = addLight(position, normal, col, lcol, lpos);\n    \n    \n    fragColor =vec4(rend, 1.);\n    \n    //fragColor =vec4(vec3(ra), 1.); // uncomment to see raw height data from buffer A\n\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tcG3Rm",
    "date": "1747915397",
    "viewed": 197,
    "name": "Visualiser - Picking out notes.",
    "description": "I revisited a very old shader with some new ideas....\nThis will form the basis of some very interesting visualisations I think.\nVery basic proof of concept but its already doing what I was going for...",
    "likes": 10,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fft",
     "spectrum",
     "music",
     "audio",
     "rgb",
     "visualiser",
     "notes",
     "tones"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4df3Rn",
       "filepath": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Visualiser 203\" by Cotterzz. https://shadertoy.com/view/tsGGRy\n// 2025-05-22 11:51:47\n\n// If you want to change tune, click on the iChannel0 audio display below, then on music tab and select different track\n//                                                              Electronebulae and X'TrackTure are both good.\n\n#define TWO_PI 6.28318530718\n\n#define C9 8372.02\n#define Db9 8870.\n#define D9 9398.\n#define Eb9 9974.\n#define E9 10548.\n#define F9 11176.\n#define Gb9 11840.\n#define G9 12544.\n#define Ab9 13290.\n#define A9 14080.\n#define Bb9 14918.\n#define B9 15804.\n\nfloat notes[] = float[](C9, Db9, D9,Eb9,E9,F9,Gb9,G9,Ab9,A9,Bb9,B9);\n\nfloat flats[] = float[](1., 0.5, 1., 0.5, 1.,1.,0.5, 1., 0.5, 1., 0.5, 1.);\n\nvec3 cols[] = vec3[](vec3(1,1,0),      vec3(0.5,1,0.1),vec3(0,0.8,0),  vec3(0,.8,0.6),vec3(0,0.8,1), vec3(0,0.2,1),\n                     vec3(0.35,0,0.75),vec3(0.5,0,1),  vec3(0.8,0,0.7),vec3(0.8,0,0), vec3(1,0.1,0), vec3(1,0.5,0));\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u / iResolution.xy,\n        to = U * vec2(12,10),\n        TO = floor(to),\n        D  =  abs(fract(to) - .5);\n       vec3 col = cols[int(TO.x)]; float flt = flats[int(TO.x)];\n       \n    float dist = max(D.x, D.y),\n     frequency = notes[int(TO.x)] / exp2(9.-TO.y),\n        f = texture(iChannel0, vec2(frequency/11025.,0)).r,\n        fa = texture(iChannel0, vec2((frequency*1.13)/11025.,0)).r,\n        fb = texture(iChannel0, vec2((frequency*0.87)/11025.,0)).r,\n        fc = texture(iChannel0, vec2((frequency*1.2)/11025.,0)).r,\n        fd = texture(iChannel0, vec2((frequency*0.8)/11025.,0)).r;\n        float av = (f+fa+fb+fc+fd)/5.;\n        float ff = (f-av)*8.*f;\n        f=(f+f+f+ff+ff)/4.;\n\t\tfloat bright = smoothstep(.0, .01 , (f*f*f*f)-dist*2. );\n\t\n    O = bright * vec4(col*flt, 1);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3cVGzm",
    "date": "1747928722",
    "viewed": 168,
    "name": "Another feedback fractal",
    "description": "One simple curve, repeated four times with feedback.",
    "likes": 14,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "tree",
     "recursive",
     "rectangle",
     "feedback",
     "buffer"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Koch with hexagons\" by Cotterzz. https://shadertoy.com/view/tfd3Ds\n// 2025-05-22 15:34:19\n\n// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 18:21:33\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "vec4 compare(vec4 new, vec4 old){return old.b > old.g*2. ? old : min(new , old);}\nvec4 getTex(vec2 nc){\n   if(nc.x>0.&&nc.x<1.&&nc.y>0.&&nc.y<1.){return texture(iChannel0, nc, 0.); } else {return vec4(1);}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 nuv = fragCoord/iResolution.xy;\n   vec2 uv = fragCoord/iResolution.y;\n   float ar = iResolution.x/iResolution.y;\n   int freq = 50;\n   fragColor = texture(iChannel0, nuv, 0.);\n   if(iFrame<2){\n       fragColor = vec4(1);\n       if(uv.x>0.5 && abs(distance(uv, vec2(0.5,-0.05))-(ar/3.))<(0.003/(uv.y+0.2))){fragColor = vec4(0,0,0,1);}\n\n   } else if(iFrame%freq == 0){\n   \n       vec2 nc = uv-vec2(0.5*ar, 0);\n       //nc.x = -nc.x;\n       float rad = distance(nc,vec2(0,0));\n       float angle = .55 + atan(nc.x,nc.y);\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=.48; nc.x-=.03;nc*= 2.; nc.x/=ar; nc+=0.5;\n       fragColor = compare(fragColor , getTex(nc));\n       \n       nc = uv-vec2(0.5*ar, 0);\n       nc.x = -nc.x;\n       rad = distance(nc,vec2(0,0));\n       angle = -.25 + atan(nc.x,nc.y);\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=.03; nc.x-=.25;nc*= 3.; nc.x/=ar; nc+=0.5;\n       fragColor = compare(fragColor , getTex(nc));\n       \n       nc = uv-vec2(0.5*ar, 0);\n       //nc.x = -nc.x;\n       rad = distance(nc,vec2(0,0));\n       angle = 1.29 + atan(nc.x,nc.y);\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=0.7; nc.x-=.13;nc*= 1.8; nc.x/=ar; nc+=0.5;\n       fragColor = compare(fragColor , getTex(nc));\n       \n       nc = uv-vec2(0.5*ar, 0);\n       //nc.x = -nc.x;\n       rad = distance(nc,vec2(0,0));\n       angle = 3.1 + atan(nc.x,nc.y);\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=.56; nc.x+=.59;nc*= 3.; nc.x/=ar; nc+=0.5;\n       fragColor = compare(fragColor , getTex(nc));\n   }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tfKGDR",
    "date": "0",
    "viewed": 0,
    "name": "Random image with linear sort",
    "description": "Instructions - drag the canvas until you see something funky.\nWhen you get to an image you like, let go and let the pixel sorting voodoo happen",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "random",
     "volumetric",
     "generative",
     "code",
     "automata",
     "feedback",
     "chaotic"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Parallel Linear Assignment Sort\" by michael0884. https://shadertoy.com/view/wfK3Rw\n// Fork of \"Random Feedback Shader\" by Cotterzz. https://shadertoy.com/view/wft3Dr\n// 2025-05-23 08:51:41\n\nvec4 absGradient(sampler2D tex, vec2 uv)\n{\n    vec2 o = 0.5 / iResolution.xy;\n    vec4 dX = texture(tex, uv + vec2(o.x, 0.0)) - texture(tex, uv - vec2(o.x, 0.0));\n    vec4 dY = texture(tex, uv + vec2(0.0, o.y)) - texture(tex, uv - vec2(0.0, o.y));\n    return 20.0*sqrt(dX * dX + dY * dY);\n}\n\nvoid mainImage( out vec4 U, in vec2 p )\n{\n    float line = iResolution.x*1.0;\n    p = floor(p);\n    if(iMouse.z > 0.0  && texture(iChannel1, vec2(0), 0.).g>1.5) line = iMouse.x;\n    vec4 color = texelFetch(iChannel0, ivec2(p), 0);\n    vec4 grad = absGradient(iChannel0, p / iResolution.xy);\n    U = (p.x < line) ? color : grad;\n    U.xyz = 1.5*tanh(pow(U.xyz, vec3(2.2)));\n    U.w = 1.0;\n    \n    if(p.x<40. && p.y<40.){U = texture(iChannel1, vec2(0), 0.)/2.;}\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))] * (sin(mTime*rand(seed+float(i)))*rand(seed+float(i)))\n#define NEWVALUE2 values[int(floor(float(v)*rand(seed+float(i+5))))] * (sin(mTime*rand(seed+float(i)))*rand(seed+float(i+5)))\n#define T (mTime*4.)\n#define rot(a) mat2(cos(a+vec4(0,33,11,0)))\n#define P(z) (vec3(tanh(cos((z) * .15) * 1.) * 8., \\\n                   tanh(cos((z) * .12) * 1.) * 8., (z)))\n\n\n// PREVIEW 0 to disable preview mode\n\n\n#define PREVIEW 0\n#define VOLUMETRIC 0\n\nfloat displaytime = 1.2; // seconds between switch\n\n// select palette mode below\nint PALETTE = 9;\n\n// 0 = Original\n// 1 = Original with hsl mixed\n// 2 = Original translated to hsl\n// 3 = hsl calculated\n// 4 = hsl enhanced\n// 5 = hsl*2\n// 6 = weird\n// 7 = fhex\n// 8 = Banded.\n// 9 = RANDOMISE!!!\n\nfloat hash1(vec2 x)\n{\n    uvec2 t = floatBitsToUint(x);\n    uint h = 0xc2b2ae3du * t.x + 0x165667b9u;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h += 0xc2b2ae3du * t.y;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h ^= h >> 15u;\n    h *= 0x85ebca77u;\n    h ^= h >> 13u;\n    h *= 0xc2b2ae3du;\n    h ^= h >> 16u;\n    return uintBitsToFloat(h >> 9u | 0x3f800000u) - 1.0;\n}\n\nvec2 hash2(vec2 x) // improved hash using xxhash\n{\n    float k = 6.283185307 * hash1(x);\n    return vec2(cos(k), sin(k));\n}\n\nfloat noise2( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*vec3( dot(a,hash2(i+0.0)), dot(b,hash2(i+o)), dot(c,hash2(i+1.0))); // changed to h^3 [1]\n    return dot( n, vec3(32.99) ); // analytic factor (= 2916*sqrt(2)/125)\n}\n\nfloat pnoise (vec2 uv){\n    float f = 0.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2( uv ); uv = m*uv;\n    f += 0.2500*noise2( uv ); uv = m*uv;\n    f += 0.1250*noise2( uv ); uv = m*uv;\n    f += 0.0625*noise2( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n    return f;\n}\n\nvec3 p = vec3(0);\n\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\nfloat map(vec3 p) {\n    return 1.5 - length(p - P(p.z));\n}\nfloat rMix(float a, float b, float s, float y){\n    s = rand(s);\n    //if(y>0.){s*=2.;}\n    if(s>1.){\n      return s>1.66?texture(iChannel0, vec2(a,b), 0.).r:s>1.33?texture(iChannel0, vec2(a,b), 0.).g:texture(iChannel0, vec2(a,b), 0.).b;\n    }\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?b/(a==0.?0.01:a):s>0.3?pnoise(vec2(a,b)):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n}\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 gmc(vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\nvec3 fhexRGB(float fh){\n    if(isinf(fh)||fh>100000.){fh = 0.;}\n    fh = abs(fh*10000000.);\n    float r = fract(fh/65536.);\n    float g = fract(fh/256.);\n    float b= fract(fh/16777216.);\n    //return gmc(contrast(hsl2rgb(vec3(r,g,b)), 0.9), 0.9);\n   return hsl2rgb(vec3(r,g,b));\n}\n\nvec3 addColor(float num, float seed, float alt){\n    if(isinf(num)){num = alt * seed;}\n    if(PALETTE == 7){\n        vec3 col = fhexRGB(num);\n        return col;} else if(PALETTE > 2 || (PALETTE == 1 && rand(seed+19.)>0.3)){\n    \n        float sat = 1.;\n        if(num<0.){sat = 1.-(1./(abs(num)+1.));}\n        float light = 1.0-(1./(abs(num)+1.));\n\n        vec3 col = hsl2rgb(vec3(fract(abs(num)), sat, light));\n        if(PALETTE == 1){col *= 2.;}\n       \n        return col;\n       \n    } else {\n\n        vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n        if(rand(seed*2.)>0.5){col = col.gbr;}\n        if(rand(seed*3.)>0.5){col = col.gbr;}\n        if(PALETTE == 1){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n        // if(PALETTE == 0){col = contrast(col, 1.01); }\n        return col;\n    \n    }\n}\n\nvec3 sanitize(vec3 dc){\n    dc.r = min(1., abs(dc.r));\n    dc.g = min(1., abs(dc.g));\n    dc.b = min(1., abs(dc.b));\n    \n    if(!(dc.r>=0.) && !(dc.r<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.g>=0.) && !(dc.g<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.b>=0.) && !(dc.b<0.)){\n        return vec3(1,0,0);\n    } else {\n        return dc;\n    }\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   int smode = int(texture(iChannel0, vec2(0), 0.).g);\n   if(iFrame<2){\n       smode = 0;\n   } else if(smode<2&&iMouse.z>0.) { smode = 1; } else if ( (iMouse.x>0. || iMouse.y > 0.) && smode==1 && iMouse.z<=0. ){smode = 2;} \n   \n    float mTime = iTime;\n    vec3 old = texture(iChannel0, fragCoord/iResolution.xy, 0.).rgb;\n    if(smode < 2){\n    \n    vec3 oldu = texture(iChannel0, (fragCoord+vec2(1,1))/iResolution.xy, 0.).rgb;\n    vec3 oldd = texture(iChannel0, (fragCoord+vec2(-1,-1))/iResolution.xy, 0.).rgb;\n    vec3 oldl = texture(iChannel0, (fragCoord+vec2(1,-1))/iResolution.xy, 0.).rgb;\n    vec3 oldr = texture(iChannel0, (fragCoord+vec2(-1,1))/iResolution.xy, 0.).rgb;\n     vec3  r = iResolution;\n    vec2 u = fragCoord;\n    \n        \n        float s=.002,d,i, l;\n\n        u = (u-r.xy/2.)/r.y;\n    \n        vec3  p = P(T),ro=p,q,\n              Z = normalize( P(T+1.)  - p),\n              X = normalize(vec3(Z.z,0,-Z)),\n              D = vec3(rot(tanh(sin(p.z*.03)*8.)*3.)*u, 1)* mat3(-X, cross(X, Z), Z);\n       \n        for(; i++<80. && s > .001; ) {\n    \n            p = ro + D * d,\n            s = map(p)*.8,\n            d += s;\n        }\n        p = ro + D * d;\n    \n    vec2 uv = fragCoord/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    float zoom = 4.;\n    if(VOLUMETRIC == 1 ){ zoom+= (1.5*(sin(mTime)+1.)); } else { zoom+= (3.*(sin(mTime)+1.));}\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    \n    float ix = 468.;\n    float iy = 330.;\n    if(iMouse.x>0.&&iMouse.y>0.){\n    ix = iMouse.x; iy = iMouse.y;}\n    \n    float seed = (ix + (iy*iResolution.x))/iResolution.x;\n    \n    if(!(iMouse.z>0.) && iMouse.x==0. && iMouse.y==0.){\n        seed = floor(mTime/displaytime);\n    }\n    \n    bool pfb = false; if(rand(seed*3.4)<0.5){pfb=true;}\n    bool reverseEF = false;  if(rand(seed*5.4)<0.5){reverseEF=true;}\n    \n    if(PALETTE == 9){\n        PALETTE = int(floor(float(8)*rand(seed+66.)));\n    }\n\n    if(PALETTE == 8){\n        PALETTE = int(floor(fragCoord.x/iResolution.x * 8.));\n    }\n    \n    const int v = 31;\n    \n    vec3 col = vec3(0);\n    float cn = 1.;\n    \n    float values[v];\n    \n    values[0] = 1.0;\n    values[1] = p.x;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = p.y;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = p.z;\n   values[21] = atan(x, y)*4.;\n   values[22] = pnoise(vec2(x,y)/2.);\n   values[23] = pnoise(vec2(y,x)*10.);\n   \n   if(pfb){\n   values[24] = old.r;\n   values[25] = old.g;\n   values[26] = old.b;\n    values[27] = (oldu.r+oldu.g+oldu.b)/3.;\n     values[28] = (oldd.r+oldd.g+oldd.b)/3.;\n      values[29] = (oldl.r+oldl.g+oldl.b)/3.;\n       values[30] = (oldr.r+oldr.g+oldr.b)/3.;\n   } else {\n      values[24] = 2.;\n      values[25] = 10.;\n      values[26] = 3.14159;\n          values[27] = 1.;\n     values[28] = 3.;\n      values[29] = 5.;\n       values[30] = 7.;\n   }\n    float total = 0.;\n    float sub = 0.;\n    int maxi = 25; int mini = 3;\n    int iterations = min(maxi,mini + int(floor(rand(seed*6.6)*float(maxi-mini))));\n    \n    \n    \n    \n    for(int i = 0; i<iterations; i++){\n        float dif = rand(seed+float(i+3))-(abs(total));\n        if(reverseEF) {dif = -dif;}\n        if(dif>0.){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4), y) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4), y), seed+float(i), y);\n\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i), y);\n      \n        }\n        dif = rand(seed+float(i))-sub;\n        if(reverseEF) {dif = -dif;}\n        if(dif>0.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2), y);\n            sub = 0.;\n            dif = rand(seed+float(i+30))-total;\n            if(reverseEF) {dif = -dif;}\n            if(dif > 0.){\n                col += addColor(total, seed+float(i), values[21]);\n                cn+=1.;\n            }\n        }\n    }\n    \n    total = sub==0. ? total : rMix(total, sub, seed, y);\n    col += addColor(total, seed, values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + rand(seed+13.)));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(rand(seed+17.)>0.5){col = col.gbr;}\n        if(rand(seed+19.)>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n    if(VOLUMETRIC == 1 ) { \n    uv+=vec2(0.16,0.1);\n    if(abs(uv.x)>0.6 || abs(uv.y)>0.32){col=vec3(0);}\n    \n    float alph = (col.r+col.g+col.b)/3.;\n    alph = alph<0.5?0.0:alph<0.7?(alph-0.5)*5.:1.0;\n    fragColor = vec4(mix(oldd*.98, col, alph), 1.);\n    } else {\n    fragColor = vec4(col, 1.);\n    }\n    if(floor(fragCoord) == vec2(0)){fragColor = vec4(float(iFrame), float(smode), 0, 1.);}\n\n    } else {\n    fragColor = vec4(old, 1.);\n    if(floor(fragCoord) == vec2(0)){fragColor = vec4(old.r, float(smode), 0, 1.);}\n    }\n   // if(fragCoord.x> (iResolution.x -  (float(smode+1)*50.))){ fragColor = vec4(0,1,0, 1.);}\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "//pause between reset\n#define PAUSE 8192\n\n#define STEP 128\n#define MAX_STEPS 8\n#define PERIOD (MAX_STEPS * STEP)\n#define LOD_OFFSET 0.0\n#define MIN_BLOCK_SIZE 8u\n\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n\n//flip lowest n bits\nint xor_n(int x, int n)\n{\n    return x ^ ( (1<<(n+1)) - 1 );\n}\n\nint imod(int a, float b)\n{\n    return a - int(b*floor(float(a)/b));\n}\n\nuint pcg(uint v)\n{\n    uint state = v * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\nuint rand_int(uint seed, uint max_value)\n{\n    return pcg(seed) % max_value;\n}\n\nuint xor_swap(uint idx, uint n, uint seed)\n{\n    uint xor_seed = rand_int(seed, n);\n    uint xor_idx = idx ^ xor_seed;\n    uint max_idx = max(idx, xor_idx);\n    uint min_idx = min(idx, xor_idx);\n    bool swap = rand_int(min_idx * 451u + seed, 2u) == 0u;\n    return (swap && (max_idx < n)) ? xor_idx : idx;\n}\n\nuint reverse(uint idx, uint n)\n{\n    return n - 1u - idx;\n}\n\nuint shuffle(uint idx, uint n, uint seed, uint iters)\n{\n    for(uint i = 0u; i < iters; i++)\n    {\n        idx = xor_swap(idx, n, seed + i);\n        idx = reverse(idx, n);\n    }\n    return idx;\n}\n\nuint unshuffle(uint idx, uint n, uint seed, uint iters)\n{\n    for (uint i = iters; i-- > 0u; )\n    {\n        idx = reverse(idx, n);                 \n        idx = xor_swap(idx, n, seed + i);\n    }\n    return idx;\n}\n\nuint getcompanion(uint idx, uint n, uint seed, uint iters)\n{\n    uint shuffled = shuffle(idx, n, seed, iters);\n    uint shuffled_companion = clamp(shuffled ^ 1u, 0u, n - 1u);\n    return unshuffle(shuffled_companion, n, seed, iters);\n}\n\nuvec2 blockSize;\nuvec2 blockOffset;\n\nuvec2 i2xy(uint id)\n{\n    return uvec2(id %blockSize.x, id/blockSize.x);\n}\n\nuint xy2i(uvec2 xy)\n{\n    return xy.x + xy.y*blockSize.x;\n}\n\n\nvec4 gaussianBlur5x5Lod(sampler2D image, vec2 uv, float lod)\n{\n    const float w[5] = float[5](1.0, 4.0, 6.0, 4.0, 1.0);\n    vec2 stepSize = exp2(lod) / iResolution.xy;\n    vec4 sum = vec4(0.0);\n    float weightSum = 0.0;\n    for(int y = 0; y < 5; ++y)\n    {\n        float wy = w[y];\n        for(int x = 0; x < 5; ++x)\n        {\n            vec2 offset = vec2(float(x) - 1.5, float(y) - 1.5) * stepSize;\n            float weight = wy * w[x];\n            weightSum += weight;\n            sum += textureLod(image, uv + offset, lod) * weight;\n        }\n    }\n    return sum / weightSum;\n}\n\nvoid mainImage( out vec4 U, in vec2 p )\n{  \n    int smode = int(texture(iChannel1, vec2(0), 0.).g);\n    vec2 fragCoord = p;\n    if(smode == 2 ){\n    int sFrame = int(texture(iChannel1, vec2(0), 0.).r);\n    int iter0 = (iFrame-sFrame) % (PERIOD + PAUSE);\n    uint iter1 = uint(MAX_STEPS) - (uint(clamp(iter0, 0, PERIOD)) / uint(STEP));\n    blockSize = min(uvec2(MIN_BLOCK_SIZE << iter1), uvec2(iResolution.xy));\n    blockOffset = (((iFrame-sFrame) & 1) == 0) ? blockSize/2u : uvec2(0u);\n    float LOD = float(iter1) + LOD_OFFSET;\n    p = floor(p);\n    \n    //reset state\n    if(iter0 == 0)\n    {\n        U = texture(iChannel1, p / iResolution.xy);\n        return;\n    }\n    \n    //select blocks of pixels\n    uvec2 pu = uvec2(p);\n    uvec2 block = ((pu + blockOffset) / blockSize) * blockSize - blockOffset;\n    uvec2 bPos = pu - block;\n    \n    //random pair of 2 unique pixels, this pixel and its random partner (symmetric)\n    uint bid0 = xy2i(bPos);\n    uint bid1 = getcompanion(bid0, blockSize.x*blockSize.y, uint((iFrame-sFrame)), 12u); \n\n    //the pair positions \n    uvec2 p0 = block + i2xy(bid0);\n    uvec2 p1 = block + i2xy(bid1);\n    \n    //current values\n    vec4 c0 = texel(ch0, vec2(p0));\n    vec4 c1 = texel(ch0, vec2(p1));\n    \n    if(any(greaterThan(p1, uvec2(iResolution.xy - 1.0)))) { U = c0; return; } //invalid pair\n    \n    //target blurred values\n    vec4 bc0 = gaussianBlur5x5Lod(iChannel0, vec2(p0)/iResolution.xy, LOD);\n    vec4 bc1 = gaussianBlur5x5Lod(iChannel0, vec2(p1)/iResolution.xy, LOD);\n\n    //flip the pixels so that its closer to blurred \n    float score0 = distance(c0, bc0) + distance(c1, bc1);\n    float score1 = distance(c1, bc0) + distance(c0, bc1);\n    U = (score0 < score1) ? c0 : c1;\n    \n    } else {\n        U = texture(iChannel1, fragCoord/iResolution.xy, 0.);\n    }\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WcG3D1",
    "date": "1748012964",
    "viewed": 145,
    "name": "Random image pixel sort",
    "description": "Instructions:\nDrag the canvas until you see an image you like, let go and watch the pixel sorting happen.\nScrub across canvas again to see result and derivative, let go to see height map.\nRewind to try again with new image",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "random",
     "generative",
     "linear",
     "sort",
     "assignment"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* Fork of \"Parallel Linear Assignment Sort\" by michael0884. https://shadertoy.com/view/wfK3Rw\n   Fork of \"Random Feedback Shader\" by Cotterzz. https://shadertoy.com/view/wft3Dr\n   2025-05-23 08:51:41\n---\nInstructions:\nDrag the canvas until you see an image you like, let go and watch the pixel sorting happen.\nScrub across canvas again to see result and derivative, let go to see height map.\nRewind to try again with new image\n---\nThis was two shaders thrown together quite quickly, so the code is a mess, and a bit slow at high res.\nI need to turn the image generation into an easy to use function, plus the whole thing could be optimised a lot\n---\nI loved the unpredictable but deterministic results of michael0884's pixel sort shader,\nSo I used my random image genearator as input to explore different images.\nThe result feels very random & truly generative.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))] * (sin(mTime*rand(seed+float(i)))*rand(seed+float(i)))\n#define NEWVALUE2 values[int(floor(float(v)*rand(seed+float(i+5))))] * (sin(mTime*rand(seed+float(i)))*rand(seed+float(i+5)))\n#define T (mTime*4.)\n#define rot(a) mat2(cos(a+vec4(0,33,11,0)))\n#define P(z) (vec3(tanh(cos((z) * .15) * 1.) * 8., \\\n                   tanh(cos((z) * .12) * 1.) * 8., (z)))\n\n\n// PREVIEW 0 to disable preview mode\n\n\n#define PREVIEW 0\n#define VOLUMETRIC 0\n\nfloat displaytime = 1.2; // seconds between switch\n\n// select palette mode below\nint PALETTE = 9;\n\n// 0 = Original\n// 1 = Original with hsl mixed\n// 2 = Original translated to hsl\n// 3 = hsl calculated\n// 4 = hsl enhanced\n// 5 = hsl*2\n// 6 = weird\n// 7 = fhex\n// 8 = Banded.\n// 9 = RANDOMISE!!!\n\nfloat hash1(vec2 x)\n{\n    uvec2 t = floatBitsToUint(x);\n    uint h = 0xc2b2ae3du * t.x + 0x165667b9u;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h += 0xc2b2ae3du * t.y;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h ^= h >> 15u;\n    h *= 0x85ebca77u;\n    h ^= h >> 13u;\n    h *= 0xc2b2ae3du;\n    h ^= h >> 16u;\n    return uintBitsToFloat(h >> 9u | 0x3f800000u) - 1.0;\n}\n\nvec2 hash2(vec2 x) // improved hash using xxhash\n{\n    float k = 6.283185307 * hash1(x);\n    return vec2(cos(k), sin(k));\n}\n\nfloat noise2( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*vec3( dot(a,hash2(i+0.0)), dot(b,hash2(i+o)), dot(c,hash2(i+1.0))); // changed to h^3 [1]\n    return dot( n, vec3(32.99) ); // analytic factor (= 2916*sqrt(2)/125)\n}\n\nfloat pnoise (vec2 uv){\n    float f = 0.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2( uv ); uv = m*uv;\n    f += 0.2500*noise2( uv ); uv = m*uv;\n    f += 0.1250*noise2( uv ); uv = m*uv;\n    f += 0.0625*noise2( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n    return f;\n}\n\nvec3 p = vec3(0);\n\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\nfloat map(vec3 p) {\n    return 1.5 - length(p - P(p.z));\n}\nfloat rMix(float a, float b, float s, float y){\n    s = rand(s);\n    //if(y>0.){s*=2.;}\n    if(s>1.){\n      return s>1.66?texture(iChannel0, vec2(a,b), 0.).r:s>1.33?texture(iChannel0, vec2(a,b), 0.).g:texture(iChannel0, vec2(a,b), 0.).b;\n    }\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?b/(a==0.?0.01:a):s>0.3?pnoise(vec2(a,b)):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n}\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 gmc(vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\nvec3 fhexRGB(float fh){\n    if(isinf(fh)||fh>100000.){fh = 0.;}\n    fh = abs(fh*10000000.);\n    float r = fract(fh/65536.);\n    float g = fract(fh/256.);\n    float b= fract(fh/16777216.);\n    //return gmc(contrast(hsl2rgb(vec3(r,g,b)), 0.9), 0.9);\n   return hsl2rgb(vec3(r,g,b));\n}\n\nvec3 addColor(float num, float seed, float alt){\n    if(isinf(num)){num = alt * seed;}\n    if(PALETTE == 7){\n        vec3 col = fhexRGB(num);\n        return col;} else if(PALETTE > 2 || (PALETTE == 1 && rand(seed+19.)>0.3)){\n    \n        float sat = 1.;\n        if(num<0.){sat = 1.-(1./(abs(num)+1.));}\n        float light = 1.0-(1./(abs(num)+1.));\n\n        vec3 col = hsl2rgb(vec3(fract(abs(num)), sat, light));\n        if(PALETTE == 1){col *= 2.;}\n       \n        return col;\n       \n    } else {\n\n        vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n        if(rand(seed*2.)>0.5){col = col.gbr;}\n        if(rand(seed*3.)>0.5){col = col.gbr;}\n        if(PALETTE == 1){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n        // if(PALETTE == 0){col = contrast(col, 1.01); }\n        return col;\n    \n    }\n}\n\nvec3 sanitize(vec3 dc){\n    dc.r = min(1., abs(dc.r));\n    dc.g = min(1., abs(dc.g));\n    dc.b = min(1., abs(dc.b));\n    \n    if(!(dc.r>=0.) && !(dc.r<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.g>=0.) && !(dc.g<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.b>=0.) && !(dc.b<0.)){\n        return vec3(1,0,0);\n    } else {\n        return dc;\n    }\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   int smode = int(texture(iChannel0, vec2(0), 0.).g);\n   if(iFrame<2){\n       smode = 0;\n   } else if(smode<2&&iMouse.z>0.) { smode = 1; } else if ( (iMouse.x>0. || iMouse.y > 0.) && smode==1 && iMouse.z<=0. ){smode = 2;} \n   \n    float mTime = iTime;\n    vec3 old = texture(iChannel0, fragCoord/iResolution.xy, 0.).rgb;\n    if(smode < 2){\n    \n    vec3 oldu = texture(iChannel0, (fragCoord+vec2(1,1))/iResolution.xy, 0.).rgb;\n    vec3 oldd = texture(iChannel0, (fragCoord+vec2(-1,-1))/iResolution.xy, 0.).rgb;\n    vec3 oldl = texture(iChannel0, (fragCoord+vec2(1,-1))/iResolution.xy, 0.).rgb;\n    vec3 oldr = texture(iChannel0, (fragCoord+vec2(-1,1))/iResolution.xy, 0.).rgb;\n     vec3  r = iResolution;\n    vec2 u = fragCoord;\n    \n        \n        float s=.002,d,i, l;\n\n        u = (u-r.xy/2.)/r.y;\n    \n        vec3  p = P(T),ro=p,q,\n              Z = normalize( P(T+1.)  - p),\n              X = normalize(vec3(Z.z,0,-Z)),\n              D = vec3(rot(tanh(sin(p.z*.03)*8.)*3.)*u, 1)* mat3(-X, cross(X, Z), Z);\n       \n        for(; i++<80. && s > .001; ) {\n    \n            p = ro + D * d,\n            s = map(p)*.8,\n            d += s;\n        }\n        p = ro + D * d;\n    \n    vec2 uv = fragCoord/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    float zoom = 4.;\n    if(VOLUMETRIC == 1 ){ zoom+= (1.5*(sin(mTime)+1.)); } else { zoom+= (3.*(sin(mTime)+1.));}\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    \n    float ix = 468.;\n    float iy = 330.;\n    if(iMouse.x>0.&&iMouse.y>0.){\n    ix = iMouse.x; iy = iMouse.y;}\n    \n    float seed = (ix + (iy*iResolution.x))/iResolution.x;\n    \n    if(!(iMouse.z>0.) && iMouse.x==0. && iMouse.y==0.){\n        seed = floor(mTime/displaytime);\n    }\n    \n    bool pfb = false; if(rand(seed*3.4)<0.5){pfb=true;}\n    bool reverseEF = false;  if(rand(seed*5.4)<0.5){reverseEF=true;}\n    \n    if(PALETTE == 9){\n        PALETTE = int(floor(float(8)*rand(seed+66.)));\n    }\n\n    if(PALETTE == 8){\n        PALETTE = int(floor(fragCoord.x/iResolution.x * 8.));\n    }\n    \n    const int v = 31;\n    \n    vec3 col = vec3(0);\n    float cn = 1.;\n    \n    float values[v];\n    \n    values[0] = 1.0;\n    values[1] = p.x;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = p.y;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = p.z;\n   values[21] = atan(x, y)*4.;\n   values[22] = pnoise(vec2(x,y)/2.);\n   values[23] = pnoise(vec2(y,x)*10.);\n   \n   if(pfb){\n   values[24] = old.r;\n   values[25] = old.g;\n   values[26] = old.b;\n    values[27] = (oldu.r+oldu.g+oldu.b)/3.;\n     values[28] = (oldd.r+oldd.g+oldd.b)/3.;\n      values[29] = (oldl.r+oldl.g+oldl.b)/3.;\n       values[30] = (oldr.r+oldr.g+oldr.b)/3.;\n   } else {\n      values[24] = 2.;\n      values[25] = 10.;\n      values[26] = 3.14159;\n          values[27] = 1.;\n     values[28] = 3.;\n      values[29] = 5.;\n       values[30] = 7.;\n   }\n    float total = 0.;\n    float sub = 0.;\n    int maxi = 25; int mini = 3;\n    int iterations = min(maxi,mini + int(floor(rand(seed*6.6)*float(maxi-mini))));\n    \n    \n    \n    \n    for(int i = 0; i<iterations; i++){\n        float dif = rand(seed+float(i+3))-(abs(total));\n        if(reverseEF) {dif = -dif;}\n        if(dif>0.){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4), y) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4), y), seed+float(i), y);\n\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i), y);\n      \n        }\n        dif = rand(seed+float(i))-sub;\n        if(reverseEF) {dif = -dif;}\n        if(dif>0.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2), y);\n            sub = 0.;\n            dif = rand(seed+float(i+30))-total;\n            if(reverseEF) {dif = -dif;}\n            if(dif > 0.){\n                col += addColor(total, seed+float(i), values[21]);\n                cn+=1.;\n            }\n        }\n    }\n    \n    total = sub==0. ? total : rMix(total, sub, seed, y);\n    col += addColor(total, seed, values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + rand(seed+13.)));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(rand(seed+17.)>0.5){col = col.gbr;}\n        if(rand(seed+19.)>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n    if(VOLUMETRIC == 1 ) { \n    uv+=vec2(0.16,0.1);\n    if(abs(uv.x)>0.6 || abs(uv.y)>0.32){col=vec3(0);}\n    \n    float alph = (col.r+col.g+col.b)/3.;\n    alph = alph<0.5?0.0:alph<0.7?(alph-0.5)*5.:1.0;\n    fragColor = vec4(mix(oldd*.98, col, alph), 1.);\n    } else {\n    fragColor = vec4(col, 1.);\n    }\n    if(floor(fragCoord) == vec2(0)){fragColor = vec4(float(iFrame), float(smode), 0, 1.);}\n\n    } else {\n    fragColor = vec4(old, 1.);\n    if(floor(fragCoord) == vec2(0)){fragColor = vec4(old.r, float(smode), 0, 1.);}\n    }\n   // if(fragCoord.x> (iResolution.x -  (float(smode+1)*50.))){ fragColor = vec4(0,1,0, 1.);}\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "//pause between reset\n#define PAUSE 8192\n\n#define STEP 128\n#define MAX_STEPS 8\n#define PERIOD (MAX_STEPS * STEP)\n#define LOD_OFFSET 0.0\n#define MIN_BLOCK_SIZE 8u\n\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n\n//flip lowest n bits\nint xor_n(int x, int n)\n{\n    return x ^ ( (1<<(n+1)) - 1 );\n}\n\nint imod(int a, float b)\n{\n    return a - int(b*floor(float(a)/b));\n}\n\nuint pcg(uint v)\n{\n    uint state = v * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\nuint rand_int(uint seed, uint max_value)\n{\n    return pcg(seed) % max_value;\n}\n\nuint xor_swap(uint idx, uint n, uint seed)\n{\n    uint xor_seed = rand_int(seed, n);\n    uint xor_idx = idx ^ xor_seed;\n    uint max_idx = max(idx, xor_idx);\n    uint min_idx = min(idx, xor_idx);\n    bool swap = rand_int(min_idx * 451u + seed, 2u) == 0u;\n    return (swap && (max_idx < n)) ? xor_idx : idx;\n}\n\nuint reverse(uint idx, uint n)\n{\n    return n - 1u - idx;\n}\n\nuint shuffle(uint idx, uint n, uint seed, uint iters)\n{\n    for(uint i = 0u; i < iters; i++)\n    {\n        idx = xor_swap(idx, n, seed + i);\n        idx = reverse(idx, n);\n    }\n    return idx;\n}\n\nuint unshuffle(uint idx, uint n, uint seed, uint iters)\n{\n    for (uint i = iters; i-- > 0u; )\n    {\n        idx = reverse(idx, n);                 \n        idx = xor_swap(idx, n, seed + i);\n    }\n    return idx;\n}\n\nuint getcompanion(uint idx, uint n, uint seed, uint iters)\n{\n    uint shuffled = shuffle(idx, n, seed, iters);\n    uint shuffled_companion = clamp(shuffled ^ 1u, 0u, n - 1u);\n    return unshuffle(shuffled_companion, n, seed, iters);\n}\n\nuvec2 blockSize;\nuvec2 blockOffset;\n\nuvec2 i2xy(uint id)\n{\n    return uvec2(id %blockSize.x, id/blockSize.x);\n}\n\nuint xy2i(uvec2 xy)\n{\n    return xy.x + xy.y*blockSize.x;\n}\n\n\nvec4 gaussianBlur5x5Lod(sampler2D image, vec2 uv, float lod)\n{\n    const float w[5] = float[5](1.0, 4.0, 6.0, 4.0, 1.0);\n    vec2 stepSize = exp2(lod) / iResolution.xy;\n    vec4 sum = vec4(0.0);\n    float weightSum = 0.0;\n    for(int y = 0; y < 5; ++y)\n    {\n        float wy = w[y];\n        for(int x = 0; x < 5; ++x)\n        {\n            vec2 offset = vec2(float(x) - 1.5, float(y) - 1.5) * stepSize;\n            float weight = wy * w[x];\n            weightSum += weight;\n            sum += textureLod(image, uv + offset, lod) * weight;\n        }\n    }\n    return sum / weightSum;\n}\n\nvoid mainImage( out vec4 U, in vec2 p )\n{  \n    int smode = int(texture(iChannel1, vec2(0), 0.).g);\n    vec2 fragCoord = p;\n    if(smode == 2 ){\n    int sFrame = int(texture(iChannel1, vec2(0), 0.).r);\n    int iter0 = (iFrame-sFrame) % (PERIOD + PAUSE);\n    uint iter1 = uint(MAX_STEPS) - (uint(clamp(iter0, 0, PERIOD)) / uint(STEP));\n    blockSize = min(uvec2(MIN_BLOCK_SIZE << iter1), uvec2(iResolution.xy));\n    blockOffset = (((iFrame-sFrame) & 1) == 0) ? blockSize/2u : uvec2(0u);\n    float LOD = float(iter1) + LOD_OFFSET;\n    p = floor(p);\n    \n    //reset state\n    if(iter0 == 0)\n    {\n        U = texture(iChannel1, p / iResolution.xy);\n        return;\n    }\n    \n    //select blocks of pixels\n    uvec2 pu = uvec2(p);\n    uvec2 block = ((pu + blockOffset) / blockSize) * blockSize - blockOffset;\n    uvec2 bPos = pu - block;\n    \n    //random pair of 2 unique pixels, this pixel and its random partner (symmetric)\n    uint bid0 = xy2i(bPos);\n    uint bid1 = getcompanion(bid0, blockSize.x*blockSize.y, uint((iFrame-sFrame)), 12u); \n\n    //the pair positions \n    uvec2 p0 = block + i2xy(bid0);\n    uvec2 p1 = block + i2xy(bid1);\n    \n    //current values\n    vec4 c0 = texel(ch0, vec2(p0));\n    vec4 c1 = texel(ch0, vec2(p1));\n    \n    if(any(greaterThan(p1, uvec2(iResolution.xy - 1.0)))) { U = c0; return; } //invalid pair\n    \n    //target blurred values\n    vec4 bc0 = gaussianBlur5x5Lod(iChannel0, vec2(p0)/iResolution.xy, LOD);\n    vec4 bc1 = gaussianBlur5x5Lod(iChannel0, vec2(p1)/iResolution.xy, LOD);\n\n    //flip the pixels so that its closer to blurred \n    float score0 = distance(c0, bc0) + distance(c1, bc1);\n    float score1 = distance(c1, bc0) + distance(c0, bc1);\n    U = (score0 < score1) ? c0 : c1;\n    \n    } else {\n        U = texture(iChannel1, fragCoord/iResolution.xy, 0.);\n    }\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "vec4 absGradient(sampler2D tex, vec2 uv)\n{\n    vec2 o = 0.5 / iResolution.xy;\n    vec4 dX = texture(tex, uv + vec2(o.x, 0.0)) - texture(tex, uv - vec2(o.x, 0.0));\n    vec4 dY = texture(tex, uv + vec2(0.0, o.y)) - texture(tex, uv - vec2(0.0, o.y));\n    return 20.0*sqrt(dX * dX + dY * dY);\n}\n\nvoid mainImage( out vec4 U, in vec2 p )\n{\n    float line = iResolution.x*1.0;\n    p = floor(p);\n    if(iMouse.z > 0.0  && texture(iChannel1, vec2(0), 0.).g>1.5) line = iMouse.x;\n    vec4 color = texelFetch(iChannel0, ivec2(p), 0);\n    vec4 grad = absGradient(iChannel0, p / iResolution.xy);\n    U = (p.x < line) ? color : grad;\n    U.xyz = 1.5*tanh(pow(U.xyz, vec3(2.2)));\n    U.w = 1.0;\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    int h = 200;\n    float el = float(iFrame%h)*(1./iResolution.y);\n    vec2 huv = uv-vec2(0,el);\n    vec2 nuv = huv;\n\n    nuv.y*=3.3;\n\n\n    nuv.x -= 0.24-huv.y;\n    nuv.y += 0.2-huv.x;\n    \n    vec3 col = vec3(0);\n    \n    if(nuv.x>0.&&nuv.x<1.&&nuv.y>0.&&nuv.y<1.){col = texture(iChannel0, nuv, 0.).rgb; } else {col =  vec3(0);}\n    \n    if(((col.r+col.g+col.b)/10.) < el) { col = texture(iChannel1, uv, 0.).rgb;}\n    \n    if(iMouse.z>0. || texture(iChannel2, vec2(0), 0.).g<1.5){col = texture(iChannel0, uv, 0.).rgb;}\n    fragColor = vec4(col,1);\n\n}",
     "name": "Buffer D",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WcV3Dh",
    "date": "1748036352",
    "viewed": 187,
    "name": "simple heightmap from texture",
    "description": "Something I needed for another shader. It scans in so it's not too expensive.",
    "likes": 10,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "terrain",
     "heightmap",
     "height",
     "relief"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "M O = T; }\n\n//old\n//void mainImage( out vec4 fragColor, in vec2 fragCoord ){fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "M\n    vec2 N = iResolution.xy,\n         U = u/N;\n         \n    float e = float( iFrame % 200 ) / N.y;\n    \n    N = mat2(1,-1., 1,  3.3) * ( U - vec2(0,e) ) + vec2(-.24,.2);\n    \n    O = clamp(N,0.,1.) == N ? texture(iChannel1, N, 0.) : O*0.;\n        \n    O.r+O.g+O.b < e*15. ? O = T : O;\n}\n\n\n//old\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 2.;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    int h = 300;\n    float el = float(iFrame%h)*(1./iResolution.y);\n    vec2 huv = uv-vec2(0,el);\n    vec2 nuv = huv;\n    nuv.y*=3.3;\n    nuv.x -= 0.24-huv.y;\n    nuv.y += 0.2-huv.x;\n    vec3 col = vec3(0);\n    \n    if(nuv.x>0.&&nuv.x<1.&&nuv.y>0.&&nuv.y<1.){col = texture(iChannel0, nuv, 0.).rgb; } else {col =  vec3(0);}\n    if((col.r+col.g+col.b)/3. < (el*10.)/scale) { col = texture(iChannel1, uv, 0.).rgb;}\n    \n    fragColor = vec4(col,1);\n\n}\n*/\n\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define M   void mainImage( out vec4 O, vec2 u ) { // \n#define T   texelFetch(iChannel0, ivec2(u), 0)",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WcyGWD",
    "date": "0",
    "viewed": 0,
    "name": "Julialienorgymouth",
    "description": "I realised that i didn't have a regular fractal shader because i deleted my old one.\nNow this one has a colour palette.\nAlso you can use the mouse",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "2d",
     "fractal"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"the Julia Set\" by ProfessorPixels. https://shadertoy.com/view/XcyyRy\n// 2025-05-24 10:19:32\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Fork of \"my fwactal :)\" by ProfessorPixels. https://shadertoy.com/view/4cVcWD\n// 2024-11-19 05:25:24\n\n// Fork of \"2.5d ball\" by ProfessorPixels. https://shadertoy.com/view/MXXcDX\n// 2024-11-18 02:11:47\n\n// Fork of \"wondering light\" by ProfessorPixels. https://shadertoy.com/view/l3yGRV\n// 2024-09-19 03:32:07\n#define R iResolution.xy\n#define mi 50.\nconst float sssamples = 4.;\nvec2 f(vec2 p)\n{\n    return vec2(p.x*p.x-p.y*p.y,2.*p.x*p.y);\n}\nvec2 h(vec3 p)\n{\n    return fract(p.z*p.yx*sin(p.z*dot(p.xy,vec2(.923,1489.34)))*234.21);\n}\nvec3 iter(vec2 z, vec2 c)\n{\n    for (float i; i<mi;i++)\n    {\n        z=f(z)+c;\n        if (dot(z,z)>4.) return vec3(i,z);\n    }\n    return vec3(mi,z);\n}\nvec3 palette(float p)\n{\n    return cos(6.2*(clamp(p,0.,1.)+vec3(.5,.8,.3)))*.5+.5;\n}\nvec2 Unify(vec2 p)\n{\n    return (p-R*.5)/min(R.x,R.y)*3.;\n}\nvoid mainImage(out vec4 O,vec2 F)\n{\n    vec2 C;\n    if (iMouse.z<.5) C = sin(iTime*vec2(1,.95)+vec2(0,1.5707));\n    else {C = Unify(iMouse.xy);}\n    O=vec4(0);\n    for (float i=0.; i<sssamples;i++)\n    {\n        \n        vec3 rslt=iter(Unify(F+h(vec3(F,i))),C);\n        float lr = length(rslt.yz);\n        O+=vec4((rslt.x-log(log(pow(abs(lr),2.))/log(2.))/log(2.))/mi);\n    }\n    O/=sssamples;\n    //O=vec4(palette(iter(Unify(F),C)/mi),1);\n    if (length(F-vec2(0,-.35))<.02) O=vec4(1,0,0,1);\n    if (F.y<-1.5) O=vec4(palette(F.x),1);\n    O.r = clamp(O.r,-1.,1.);\n    vec2 NF = F/1.5;\n    NF=NF+(iResolution.xy/6.);\n    O = (O+O+texture(iChannel0, NF/iResolution.xy, 0.))/3.;\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265359\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 addLight(vec3 position, vec3 normal, vec3 colour, vec3 lcol, vec3 lpos){\n    vec3 ref = reflect(vec3(0.0, 0.0, -1.0), normal);\n    vec3 diff = lpos - position;\n    float ldist = length(diff);\n    diff = diff/ldist;\n    float specular = pow(max(0.0, dot(diff, ref)), 64.0);\n    float diffuse = max(0.0, dot(diff,normal));\n    vec3 col1 = colour*0.7;\n    vec3 col2 = colour*0.4*(lcol*diffuse);\n    col2 = col2+(lcol*specular);\n    return col1+col2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   vec2 co = fragCoord;\n   //float ix = 0.3; if(iMouse.x>0.){ix = iMouse.x/iResolution.x;}\n   //float iy = 0.7; if(iMouse.y>0.){iy = iMouse.y/iResolution.y;}\n   float scale  = 0.2 + iMouse.x/iResolution.x*16.;\n   vec3 col = vec3(0);\n    \n    // three sample plus dxdy\n    int pos = int(co.x)%2 + (int(co.y)%2 * 2);\n    float ra = texture(iChannel0, co/iResolution.xy, 0.).r;\n\n    float rb = texture(iChannel0, (co+vec2(1,0))/iResolution.xy, 0.).r;\n    float rc = texture(iChannel0, (co+vec2(0,1))/iResolution.xy, 0.).r;\n    if(ra<-0.06 || ra >=0.95){\n        ra = texture(iChannel1, co/iResolution.xy, 0.).r;\n        rb = texture(iChannel1, (co+vec2(1,0))/iResolution.xy, 0.).r;\n        rc = texture(iChannel1, (co+vec2(0,1))/iResolution.xy, 0.).r;\n    }\n    float dx = dFdx(ra);\n    float dy = dFdy(ra);\n    if(pos == 1 || pos == 3){ dx = rb-ra; }\n    if(pos == 2 || pos == 3){ dy = rc-ra; }\n    float dz = sqrt((dx*dx) + (dy*dy));\n    float a = (PI + atan(dx,dy))/(PI*2.);\n    \n    float bounds = iResolution.y/1.6;\n    \n  // if( iMouse.z>0. || iMouse.x>0. || iMouse.y>0.) { bounds = iMouse.y;}\n    float dvh = 50.;\n    vec3 normal = normalize(vec3(dx*dvh, dy*dvh, 1.-ra));\n    \n    //col = vec3(0.8,0.5+(ra/3.),0.4+(ra/3.));//hsl2rgb(vec3(a,1., 0.5));\n    \n    //\n\n    col = hsl2rgb(vec3(a,1., 1.-ra));col*=(0.3+(ra*1.5));\n    \n    vec3 position = vec3(co/iResolution.xy, 1.-ra);\n    \n    vec3 lcol = vec3(1);\n    vec3 lpos = vec3(-3.1,3.1,5.5);\n    \n    vec3 rend = addLight(position, normal, col, lcol, lpos);\n    \n    \n    //fragColor =vec4(rend, 1.);\n    fragColor = vec4(rend, 1.);// + texture(iChannel0, vec2(dx,dy), 0.))/1.1;\n   //if(ra*ra > ra){fragColor =vec4(vec3(0,1,0), 1.);}\n    \n    /*\n    vec2 nc = vec2(0.5);\n    \n    nc.x -= cos(a*6.28318)*sqrt(ra);\n    nc.y -= sin(a*6.28318)*sqrt(ra);\n    \n    nc/=1.5 - scale/40.;\n\n   // fragColor = (vec4(col, 1.) + texture(iChannel1, vec2(a*(1.05-ix), ra*(1.05-iy)), 0.))/1.5;\n   fragColor = (vec4(col, 1.) + texture(iChannel1, nc, 0.))/1.1;\n   //fragColor = vec4(a,-a,0, 1.);\n   */\n   \n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// based on iq's voronoi at https://thebookofshaders.com/edit.php#12/2d-voronoi.frag\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x , float tm) {\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    float it = iTime*tm;\n    // first pass: regular voronoi\n    vec2 mg, mr;\n    float md = 8.0;\n    for (int j= -1; j <= 1; j++) {\n        for (int i= -1; i <= 1; i++) {\n            vec2 g = vec2(float(i),float(j));\n            vec2 o = random2( n + g );\n            o = 0.5 + 0.5*sin( it + 6.2831*o );\n\n            vec2 r = g + o - f;\n            float d = dot(r,r);\n\n            if( d<md ) {\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n\n    // second pass: distance to borders\n    md = 8.0;\n    for (int j= -2; j <= 2; j++) {\n        for (int i= -2; i <= 2; i++) {\n            vec2 g = mg + vec2(float(i),float(j));\n            vec2 o = random2( n + g );\n            o = 0.5 + 0.5*sin( it + 6.2831*o );\n\n            vec2 r = g + o - f;\n\n            if ( dot(mr-r,mr-r)>0.00001 ) {\n                md = min(md, dot( 0.5*(mr+r), normalize(r-mr) ));\n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvec3 vcell(vec2 st, float tm){\n    vec3 c = voronoi(st, tm);\n    vec3 color = vec3(0.);\n    // isolines\n    color = c.x*(0.5 + 0.5*sin(64.0*c.x))*vec3(1.0);\n    // borders\n    color = mix( vec3(1.0), color, smoothstep( 0.01, 0.02, c.x ) );\n    // feature points\n    float dd = length( c.yz );\n    color += vec3(1.)*(1.0-smoothstep( 0.0, 0.04, dd));\n    //float bounds = iResolution.y*0.8;\n    \n    //if( iMouse.z>0. || iMouse.x>0. || iMouse.y>0.) { bounds = iMouse.y;}\n    \n    float mixd = (0.5-dd)*(0.5-c.x);\n    return vec3(pow(mixd,0.7-(1./1.7)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   float bounds = iResolution.x/1.6;\n    \n   if( iMouse.z>0. || iMouse.x>0. || iMouse.y>0.) { bounds = iMouse.x;}\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 st = uv-0.5; st.x *= iResolution.x/iResolution.y;\n    st*=0.7 + (3.5);\n    float it = 0.4;\n    vec3 col = vec3(0);\n    for(float i = 4.0; i<17.; i*=1.3){\n        st+=i;\n        col = max(col, vcell(st*i*it, i)/(i/3.5));\n    }\n\n\n    fragColor = vec4(col,1.0);\n\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tcGGz3",
    "date": "1748327113",
    "viewed": 134,
    "name": "How iMouse.zw works",
    "description": "I tried using iMouse.zw's actual numbers, this is what you get.\nYou need to get the negative of iMouse.zw, if you're still dragging, and just the negative w when mouse is up.\nOr use abs values and sign for state (probably what was intended)",
    "likes": 2,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "mouseclick",
     "shadertoy",
     "input",
     "click",
     "imouse",
     "uniforms",
     "mouseevent",
     "mousedown"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Update - I just found out IQ did a better version of this here: https://www.shadertoy.com/view/Mss3zH\n// Also see Fabrice's link in the comments\n//\n// Still it's useful for people to know\n//\n// iMouse.xy is BLACK\n// iMouse.zw is RED\n// -iMouse.zw is BLUE\n// iMouse.zw with -w is GREEN\n\n// So, if you want the location of where the mouse down occurred, while mouse is still down, use negative w value\n\n// If you want the location of where the mouse down occurred, after mouse up, use negative z and w value\n\n// Regular iMouse.zw will give you the position of the click only on the first frame after the mouse was clicked. (you can see it flash red)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 pointA = iMouse.xy/iResolution.xy;   // BLACK\n    vec2 pointB = iMouse.zw/iResolution.xy;  // RED\n    vec2 pointC = pointB*vec2(1,-1);        // GREEN\n    vec2 pointD = pointB*vec2(-1,-1);       // BLUE\n    \n    float distA = distance(uv,pointA);\n    float distB = distance(uv,pointB);\n    float distC = distance(uv,pointC);\n    float distD = distance(uv,pointD);\n    \n    float size = 0.05;\n    vec3 col = vec3(1);\n    \n    col =distB<size?vec3(1,0,0):distC<size?vec3(0,1,0):distD<size?vec3(0,0,1): distA<size?vec3(0):col;\n    \n    fragColor = vec4(vec3(col),1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tcy3Rd",
    "date": "1748401067",
    "viewed": 237,
    "name": "Picture evolver v1",
    "description": "After seeing a video by the guy that made picbreeder, I decided to put this together.\nThis is very rudimentary and is just a proof of concept - I wanted to get the interactivity and state figured out first.\nOnly 12 options and no parameters atm.",
    "likes": 24,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "random",
     "generative",
     "interaction",
     "evolution",
     "art",
     "user"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// See comments for instructions, video and link\n\n/*\nInstructions:\nThe small thumbnails are the different options for mutating the image, click on one to transform the image and see the next set of choices.\nIt goes on forever.\nBackground\nThe idea is simple, an evolving image with user selected mutation, with the user picking each iteration based on how interesting they think the image is.\n(As opposed to my other attempts at random images that applied a series of transformations automatically based on a random seed,\nthis felt like a great way to follow that up) The current steps are very limited,\nI just wanted to get the basic interaction working and see if it was as fun as it sounded before creating a balanced and varied selection of mutations.\nReferences\nThis is the picbreeder site https://nbenko1.github.io/#/\nThey're doing this but at scale, with a user base, and collaborative evolution of pictures, gallery etc.\nI think they're using the process of selecting interesting images to train AI as well.\nAnd this is the interview that prompted me to try this out\nhttps://www.youtube.com/watch?v=5zg_5hg8Ydo&t=778s\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "vec3 hsl2rgb( in vec3 c )\n{\n    float  ct = c.r+c.g+c.b; c.r = ct;c.g=ct;c.b=ct;\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec4 absGradient(sampler2D tex, vec2 uv) // from michael0884. https://shadertoy.com/view/wfK3Rw\n{\n    vec2 o = 0.5 / iResolution.xy;\n    vec4 dX = texture(tex, uv + vec2(o.x, 0.0)) - texture(tex, uv - vec2(o.x, 0.0));\n    vec4 dY = texture(tex, uv + vec2(0.0, o.y)) - texture(tex, uv - vec2(0.0, o.y));\n    return 20.0*sqrt(dX * dX + dY * dY);\n}\n\nvec3 getPC(vec3 c) {\n    float t =c.r+c.b+c.g;\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\n\nvec3 drawSomething2(vec2 uv, vec3 col){ float d = abs(0.5-uv.x) + abs(0.5-uv.y) -0.2; if(d<0.){return col;}else{return mix(col, vec3(1), d*15.) ;} }\nvec3 drawSomething(vec2 uv, vec3 col){ float d = distance(uv, vec2(0.5, 0.5)) - 0.2718; if(d<0.){return col;}else{return mix(col, vec3(1), d*15.) ;} }\n\nvec2 getOUV(vec2 suv, vec4 sq){ \n    vec2 nuv = vec2(sq.x + ((sq.z-sq.x)*suv.x), sq.y + ((sq.w-sq.y)*suv.y));\n    nuv.x = clamp(nuv.x,sq.x+0.003,sq.z-0.003);\n    nuv.y = clamp(nuv.y,sq.y+0.003,sq.w-0.003);\n    \n    return nuv;\n}\n\nvec2 getSUV(vec2 uv, vec4 sq){  return vec2 ( (uv.x-sq.x) / (sq.z-sq.x) , (uv.y-sq.y) / (sq.w-sq.y) ); }\n\nvec3 getTX(vec2 uv){ return texture(iChannel0, uv, 0.).rgb; }\n\nbool isin(vec2 co, vec4 sq){ return ( co.x >= sq.x && co.x <= sq.z && co.y >= sq.y && co.y <= sq.w ); }\n\nvec3 warp(int wt, float wp, vec2 suv, vec4 sq){\n float rad, angle; vec2 auv;\n    switch (wt) {\n    case 0:\n    return getTX(getOUV(suv, sq)).gbr;\n    case 1:\n    return getPC(getTX(getOUV(suv, sq)));\n    case 2:\n    return hsl2rgb(getTX(getOUV(suv, sq)));\n    case 3:\n    return getTX(getOUV(suv+vec2(0,cos(suv.x*15.)/15.), sq));\n    case 4:\n    return getTX(getOUV(suv+vec2(sin(suv.y*10.)/10.,0), sq));\n    case 5:\n    return getTX(getOUV(suv+vec2(sin(suv.y*8.)/8.,sin(suv.x*9.)/9.), sq));\n    case 6:\n    suv-=vec2(0,0.5);rad = distance(suv, vec2(0))*3.;angle = (atan(suv.x,suv.y)/3.141);\n    auv = vec2(rad*cos(angle),rad*sin(angle))-vec2(1,0.3);;return getTX(getOUV(auv, sq));\n    case 7:\n    suv+=vec2(0.5,0);rad = distance(suv, vec2(0.5,0))*2.;angle = (atan(suv.x,suv.y)/3.141);\n    auv = vec2(rad*cos(angle),rad*sin(angle))-vec2(1.,0);return getTX(getOUV(auv, sq));\n    case 8:\n    return getTX(getOUV(suv, sq))*drawSomething2(suv, vec3(1,0,0));\n    case 9:\n    return mix(getTX(getOUV(suv, sq)),drawSomething(suv, vec3(0,1,0)), suv.x);\n    case 10:\n    return absGradient(iChannel0, getOUV(suv, sq)).rgb;\n    case 11:\n    suv*=2.;\n    suv.x = fract(suv.x);suv.y = fract(suv.y);\n    return getTX(getOUV(suv, sq));\n    }\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int smode = iFrame<2?0:int(ceil(texture(iChannel0, vec2(0), 0.).b));\n    int wmode = iFrame<2?-1:int(ceil(texture(iChannel0, vec2(0), 0.).r));\n\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float vb = 0.02;\n    float hb = vb/ar;\n    vec4 sc = vec4(hb,vb, (1./ar)-hb, 1.-vb);\n    vec2 ss = vec2( -hb+(1.-((1./ar)))/3., (1.-(vb*5.))/4. );\n    vec4  sc1 = vec4(sc.z+hb, vb, sc.z+hb+ss.x, vb+ss.y);\n    vec4  sc2 = sc1;  sc2.xz+= (hb+ss.x);\n    vec4  sc3 = sc2;  sc3.xz+= (hb+ss.x);\n    vec4  sc4 = sc1;  sc4.yw+= (vb+ss.y);\n    vec4  sc5 = sc2;  sc5.yw+= (vb+ss.y);\n    vec4  sc6 = sc3;  sc6.yw+= (vb+ss.y);\n    vec4  sc7 = sc4;  sc7.yw+= (vb+ss.y);\n    vec4  sc8 = sc5;  sc8.yw+= (vb+ss.y);\n    vec4  sc9 = sc6;  sc9.yw+= (vb+ss.y);\n    vec4 sc10 = sc7; sc10.yw+= (vb+ss.y);\n    vec4 sc11 = sc8; sc11.yw+= (vb+ss.y);\n    vec4 sc12 = sc9; sc12.yw+= (vb+ss.y);\n    fragColor = vec4(0.8);\n    int wm = -1;\n    vec4 scc = sc1;\n    if (isin(uv,  sc1)) { wm=0;scc=sc1; }\n    if (isin(uv,  sc2)) { wm=1;scc=sc2; }\n    if (isin(uv,  sc3)) { wm=2;scc=sc3; }\n    if (isin(uv,  sc4)) { wm=3;scc=sc4; }\n    if (isin(uv,  sc5)) { wm=4;scc=sc5; }\n    if (isin(uv,  sc6)) { wm=5;scc=sc6; }\n    if (isin(uv,  sc7)) { wm=6;scc=sc7; }\n    if (isin(uv,  sc8)) { wm=7;scc=sc8; }\n    if (isin(uv,  sc9)) { wm=8;scc=sc9; }\n    if (isin(uv, sc10)) { wm=9;scc=sc10; }\n    if (isin(uv, sc11)) { wm=10;scc=sc11; }\n    if (isin(uv, sc12)) { wm=11;scc=sc12; }\n    if(wm>-1){fragColor = vec4( warp(wm,0.,getSUV(uv, scc), sc) ,1); }\n    \n    if(iMouse.z>0.){\n    \n    if (isin(iMouse.xy/iResolution.xy,  sc1)) { wmode=0; }\n    if (isin(iMouse.xy/iResolution.xy,  sc2)) { wmode=1; }\n    if (isin(iMouse.xy/iResolution.xy,  sc3)) { wmode=2; }\n    if (isin(iMouse.xy/iResolution.xy,  sc4)) { wmode=3; }\n    if (isin(iMouse.xy/iResolution.xy,  sc5)) { wmode=4; }\n    if (isin(iMouse.xy/iResolution.xy,  sc6)) { wmode=5; }\n    if (isin(iMouse.xy/iResolution.xy,  sc7)) { wmode=6; }\n    if (isin(iMouse.xy/iResolution.xy,  sc8)) { wmode=7; }\n    if (isin(iMouse.xy/iResolution.xy,  sc9)) { wmode=8; }\n    if (isin(iMouse.xy/iResolution.xy, sc10)) { wmode=9; }\n    if (isin(iMouse.xy/iResolution.xy, sc11)) { wmode=10; }\n    if (isin(iMouse.xy/iResolution.xy, sc12)) { wmode=11; }\n    \n    if(smode==0 && wmode>-1){smode=1;}\n    if(smode==3 && wmode>-1){smode=1;}\n    }\n\n    if (isin(uv, sc)) {\n        if(smode==0) {\n            fragColor = vec4(drawSomething(getSUV(uv,sc), vec3(0,0.5,1)), 1);\n        } else if(smode==1){ \n            fragColor = vec4( warp(wmode,0.,getSUV(uv, sc), sc) ,1);\n        } else if(smode>1){ \n            fragColor = vec4(getTX(getOUV(getSUV(uv, sc), sc)),1);\n        }\n    }\n    if(smode==1){smode=2;wmode=-1;}\n    if(smode==2 && iMouse.z<0.){smode=3;}\n    if(floor(fragCoord) == vec2(0)){fragColor = vec4(float(wmode), 0, float(smode), 1);}\n\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WcV3WV",
    "date": "1748540355",
    "viewed": 122,
    "name": "Buffer View Example 2",
    "description": "Use this code on your image tab to view the four different buffers as thumbnails.\nClick on thumbnail to see it in main window\nUsing michael0884's paint streams as an example",
    "likes": 8,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "debug",
     "buffer",
     "buffers"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* Use this code on your image tab to view the four different buffers as thumbnails.\nRemember to set up the four buffers in the iChannel screens at the bottom.\nClick on thumbnail to see it in main window\nUsing \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj as an example\n*/\n\n// set this to 0 to only show thumbs on mouse down\n\n#define ALWAYSSHOW 1  \nvec2 getOUV(vec2 suv, vec4 sq){ vec2 nuv = vec2(sq.x + ((sq.z-sq.x)*suv.x), sq.y + ((sq.w-sq.y)*suv.y)); return nuv;}\nvec2 getSUV(vec2 uv, vec4 sq){  return vec2 ( (uv.x-sq.x) / (sq.z-sq.x) , (uv.y-sq.y) / (sq.w-sq.y) ); }\nbool isin(vec2 co, vec4 sq){ return ( co.x >= sq.x && co.x <= sq.z && co.y >= sq.y && co.y <= sq.w ); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float vb = 0.02;\n    float hb = vb/ar;\n    float th = (1. - (vb*5.))/4.;\n    float tw = th*ar/2.;\n    vec4  sc1 = vec4(1.-(tw+hb), vb, 1.-hb, vb+th);\n    \n    vec4  sc2 = sc1;  sc2.yw += (vb+th);\n    vec4  sc3 = sc2;  sc3.yw += (vb+th);\n    vec4  sc4 = sc3;  sc4.yw += (vb+th);\n    \n  \n   \n   if(isin(muv, sc1)){fragColor = texture(iChannel0, uv, 0.);}\n   else if(isin(muv, sc2)){fragColor = texture(iChannel1, uv, 0.);}\n   else if(isin(muv, sc3)){fragColor = texture(iChannel2, uv, 0.);}\n   else if(isin(muv, sc4)){fragColor = texture(iChannel3, uv, 0.);}\n    else {\n    \n         // just copy Buffer D\n         fragColor = texture(iChannel3, fragCoord/iResolution.xy, 0.);\n           \n         /*\n         Alternatively, if you wanted to do more processing in the Image tab for a fifth final image, do it here.\n         And if you already have a mainImage function in the Image tab, you can just rename it mainImage0\n         And call it with:\n         mainImage0(fragColor, fragCoord);\n         */\n         \n        }\n   \n   if(iMouse.z>0. || ALWAYSSHOW ==1){\n       if(isin(uv, sc1)){fragColor = texture(iChannel0, getSUV(uv,sc1), 0.);}\n       if(isin(uv, sc2)){fragColor = texture(iChannel1, getSUV(uv,sc2), 0.);}\n       if(isin(uv, sc3)){fragColor = texture(iChannel2, getSUV(uv,sc3), 0.);}\n       if(isin(uv, sc4)){fragColor = texture(iChannel3, getSUV(uv,sc4), 0.);}\n   }\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 1.\n\n#define fluid_rho 0.5\n\nfloat Pf(vec2 rho)\n{\n    //return 0.2*rho.x; //gas\n    float GF = 1.;//smoothstep(0.49, 0.5, 1. - rho.y);\n    return mix(0.5*rho.x,0.04*rho.x*(rho.x/fluid_rho - 1.), GF); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(1.5, 0.5));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 1.12\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec2 omin = clamp(x - K*0.5, p - 0.5, p + 0.5);\n    vec2 omax = clamp(x + K*0.5, p - 0.5, p + 0.5); \n    return vec3(0.5*(omin + omax), (omax.x - omin.x)*(omax.y - omin.y)/(K*K));\n}\n\n/*\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}*/\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        float difR = 0.9 + 0.21*smoothstep(fluid_rho*0., fluid_rho*0.333, P0.M.x);\n        vec3 D = distribution(P0.X, pos, difR);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        P.M.y += P0.M.y*m;\n        \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n        P.M.y /= P.M.x;\n    }\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n    //viscosity\n    F += 0.*P.M.x*(avgV.xy - P.V);\n    \n    //gravity\n    F += P.M.x*vec2(0., -0.0004);\n\n     if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw*vec2(1.0,-1.0))/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.001*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    \n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?v:1.;\n}\n\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + vec2(0., 0.);\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    if(length(P.X - R*vec2(0.8, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 - PI*0.5 + 0.3*sin(0.4*time));\n        P.M = mix(P.M, vec2(fluid_rho, 1.), 0.4);\n    }\n\n    if(length(P.X - R*vec2(0.2, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 + 0.3*sin(0.3*time));\n        P.M = mix(P.M, vec2(fluid_rho, 0.), 0.4);\n    }\n    \n    U = saveParticle(P, pos);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    fragColor = rho;\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-2., 0., 2.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.5, 0.);\n    vec3 col1 = vec3(0.1, 0.4, 1.);\n\tvec3 fcol = mixN(col0, col1, tanh(3.*(rho.w - 0.7))*0.5 + 0.5);\n    // Output to screen\n    col = vec4(3.);\n    col.xyz = mixN(col.xyz, fcol.xyz*(1.5*b + specular*5.), a);\n    col.xyz = mixN(col.xyz, 0.*vec3(0.5,0.5,1.), bord);\n    col.xyz = tanh(col.xyz);\n}",
     "name": "Buffer D",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3fV3WV",
    "date": "1748540377",
    "viewed": 263,
    "name": "Buffer View Example",
    "description": "Use this code on your image tab to view the four different buffers as thumbnails.\nClick on thumbnail to see it in main window",
    "likes": 13,
    "published": "Public API",
    "usePreview": 1,
    "tags": [
     "debug",
     "buffer",
     "buffers"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* Use this code on your image tab to view the four different buffers as thumbnails.\nRemember to set up the four buffers in the iChannel screens at the bottom.\nClick on thumbnail to see it in main window\nUsing \"Blue Porcelain v2\" https://shadertoy.com/view/3XS3RV as an example\n*/\n\n// set this to 0 to only show thumbs on mouse down\n#define ALWAYSSHOW 1  \nvec2 getOUV(vec2 suv, vec4 sq){ vec2 nuv = vec2(sq.x + ((sq.z-sq.x)*suv.x), sq.y + ((sq.w-sq.y)*suv.y)); return nuv;}\nvec2 getSUV(vec2 uv, vec4 sq){  return vec2 ( (uv.x-sq.x) / (sq.z-sq.x) , (uv.y-sq.y) / (sq.w-sq.y) ); }\nbool isin(vec2 co, vec4 sq){ return ( co.x >= sq.x && co.x <= sq.z && co.y >= sq.y && co.y <= sq.w ); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float vb = 0.02;\n    float hb = vb/ar;\n    float th = (1. - (vb*5.))/4.;\n    float tw = th*ar/2.;\n    vec4  sc1 = vec4(1.-(tw+hb), vb, 1.-hb, vb+th);\n    \n    vec4  sc2 = sc1;  sc2.yw += (vb+th);\n    vec4  sc3 = sc2;  sc3.yw += (vb+th);\n    vec4  sc4 = sc3;  sc4.yw += (vb+th);\n    \n   if(isin(muv, sc1)){fragColor = texture(iChannel0, uv, 0.);}\n   else if(isin(muv, sc2)){fragColor = texture(iChannel1, uv, 0.);}\n   else if(isin(muv, sc3)){fragColor = texture(iChannel2, uv, 0.);}\n   else if(isin(muv, sc4)){fragColor = texture(iChannel3, uv, 0.);}\n   else {\n       \n         //If you want to do more processing in the Image tab for a fifth final image, do it here.\n         vec3 col = sqrt( texture(iChannel3, uv, 0.).rgb );\n         fragColor = vec4(col, 1.);\n         \n         //And if you already have a mainImage function in the Image tab, you can just rename it mainImage0\n         //And call it with:\n         //mainImage0(fragColor, fragCoord);\n       \n         // Otherwise just copy the buffer:\n         // fragColor = texture(iChannel3, uv, 0.)\n       \n   }\n   \n   if(iMouse.z>0. || ALWAYSSHOW ==1){\n       if(isin(uv, sc1)){fragColor = texture(iChannel0, getSUV(uv,sc1), 0.);}\n       if(isin(uv, sc2)){fragColor = texture(iChannel1, getSUV(uv,sc2), 0.);}\n       if(isin(uv, sc3)){fragColor = texture(iChannel2, getSUV(uv,sc3), 0.);}\n       if(isin(uv, sc4)){fragColor = texture(iChannel3, getSUV(uv,sc4), 0.);}\n   }\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// todo: implement sweep amt\nvec2 mouse;\n\n////////////////////////////////////////////////////////////////\n// BOILERPLATE UTILITIES...................\nconst float pi = 3.14159;\nconst float pi2 = pi * 2.;\n\nfloat opU( float d1, float d2 ){ return min(d1,d2); }\nfloat opS( float d2, float d1 ){ return max(-d1,d2); }\nfloat opI( float d1, float d2) { return max(d1,d2); }\n\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\nfloat nsin(float a){return .5+.5*sin(a);}\nfloat ncos(float a){return .5+.5*cos(a);}\n\nfloat dtoa(float d, float amount)\n{\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n}\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n    vec2 d = max(tl-uv, uv-br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\nfloat sdCircle(vec2 uv, vec2 origin, float radius)\n{\n    return length(uv - origin) - radius;\n}\n// 0-1 1-0\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\n{\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\n}\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n// returns -.5 to 1.5. i think.\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\t\n}\nfloat noise01(vec2 p)\n{\n    return clamp((noise(p)+.5)*.5, 0.,1.);\n}\n// debug function to convert distance to color, revealing sign.\nvec3 dtocolor(vec3 inpColor, float dist)\n{\n    vec3 ret;\n    if(dist > 0.)\n        ret = mix(vec3(0,0,.5), vec3(.5,.5,1), sin(dist * pi2 * 50.));// red = negative / inside geometry.\n    else\n\t    ret = mix(vec3(1.,.5,.5), vec3(.5,0,0), sin(dist * pi2 * 50.));// blue = positive, of of geometry.\n    ret = mix(ret, vec3(0), clamp(abs(dist),0.,1.));// falloff\n    return ret;\n}\n\nfloat smoothf(float x)\n{\n    return x*x*x*(x*(x*6. - 15.) + 10.);\n}\n\n////////////////////////////////////////////////////////////////\n// APP CODE ...................\n\n// this function will produce a line with brush strokes. the inputs are such\n// that you can apply it to pretty much any line; the geometry is separated from this function.\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor)\n{\n    float posInLineY = (uvLine.y / lineSize.y);// position along the line. in the line is 0-1.\n\n    if(iMouse.z > 0.)\n    {\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\n    \tfloat okthen = 42.;// NOP\n    }\n    \n    // warp the position-in-line, to control the curve of the brush falloff.\n    if(posInLineY > 0.)\n    {\n        float mouseX = 200. == 0. ? 0.2 : (200. / iResolution.x);\n\t   posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5);\n        //posInLineY = pow(posInLineY, (pow(200.,2.) * 15.) + 1.5);\n        \n    }\n\n    // brush stroke fibers effect.\n    float strokeBoundary = dtoa(sdGeometry, 300.);// keeps stroke texture inside the geometry.\n    float strokeTexture = 0.\n        + noise01(uvLine * vec2(min(iResolution.y,iResolution.x)*0.2, 1.))// high freq fibers\n        + noise01(uvLine * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\n        + noise01(uvLine * vec2(14., 1.))// low freq noise, gives more variation\n        ;\n    strokeTexture *= 0.333 * strokeBoundary;// 0 to 1 (take average of above)\n    strokeTexture = max(0.008, strokeTexture);// avoid 0; it will be ugly to modulate\n  \t// fade it from very dark to almost nonexistent by manipulating the curve along Y\n\tfloat strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+0.09);// add allows bleeding\n    // fade out the end of the stroke by shifting the noise curve below 0\n    const float strokeAlphaBoost = 1.09;\n    if(posInLineY > 0.)\n        strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.8));// fade out\n    else\n        strokeAlpha *= strokeAlphaBoost;\n\n    strokeAlpha = smoothf(strokeAlpha);\n    \n    // paper bleed effect.\n    float paperBleedAmt = 60. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\n paperBleedAmt = 400.;// disable paper bleed    \n    \n    // blotches (per stroke)\n    //float blotchAmt = smoothstep(2.,28.5,magicBox(vec3(uvPaper, uvLine.x)));\n    //blotchAmt *= (strokeAlpha+0.1);\n    //strokeAlpha += blotchAmt;\n\n    float alpha = strokeAlpha * brushColor.a * dtoa(sdGeometry, paperBleedAmt);\n    alpha = clamp(alpha, 0.,1.);\n    return mix(inpColor, brushColor.rgb, alpha);\n}\n\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth)\n{\n    // flatten the line to be axis-aligned.\n    float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y);\n    mat2 rotMat = rot2D(lineAngle);\n\n    float lineLength = distance(p2_, p1_);\n    // make an axis-aligned line from this line.\n    vec2 tl = (p1_ * rotMat);// top left\n    vec2 br = tl + vec2(0,lineLength);// bottom right\n    vec2 uvLine = uv * rotMat;\n\n    // make line slightly narrower at end.\n    lineWidth *= mix(1., .9, smoothstep(tl.y,br.y,uvLine.y));\n    \n    // wobble it around, humanize\n    float res = min(iResolution.y,iResolution.x);\n    uvLine.x += (noise01(uvLine * 1.)-0.5) * 0.02;\n    uvLine.x += cos(uvLine.y * 3.) * 0.009;// smooth lp wave\n    uvLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\n//    uvLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n\n    // calc distance to geometry. actually just do a straight line, then we will round it out to create the line width.\n    float d = sdAxisAlignedRect(uvLine, tl, br) - lineWidth / 2.;\n    uvLine = tl - uvLine;\n    \n    vec2 lineSize = vec2(lineWidth, lineLength);\n    \n    vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,\n                                d, inpColor, brushColor);\n    return ret;\n}\n\n// returns:\n// xy = uvLine\n// z = radius\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength)\n{\n    vec2 humanizedUVLine = uvLine;\n    \n\t// offsetting the circle along its path creates a twisting effect.\n    float twistAmt = .24;\n    float linePosY = humanizedUVLine.y / lineLength;// 0 to 1 scale\n    humanizedUVLine.x += linePosY * twistAmt;\n    \n    // perturb radius / x\n    float humanizedRadius = radius_;\n    float res = min(iResolution.y,iResolution.x);\n    humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04;\n    humanizedRadius += sin(uvLine.y * 3.) * 0.019;// smooth lp wave\n    humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02;// more messin\n    humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005;// a sort of random waviness like individual strands are moving around\n//    humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n    \n    return vec3(humanizedUVLine, humanizedRadius);\n}\n\n// there's something about calling an Enso a \"donut\" that makes me giggle.\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\n{\n\tvec2 uvLine = uv - o;\n    float angle = atan(uvLine.x, uvLine.y) + pi;// 0-2pi\n    angle = mod(angle-angleStart+pi, pi2);\n    if(!clockwise)\n        angle = pi2 - angle;\n    float lineLength = radius_ * pi2;// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\n    uvLine = vec2(\n        radius_ - length(uvLine),\n        angle / pi2 * lineLength\n    );\n    \n    // make line slightly narrower at end.\n    float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y));\n    \n    vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n    vec2 humanizedUVLine = hu.xy;\n    float humanizedRadius = hu.z;\n\n    float d = opS(sdCircle(uv, o, humanizedRadius),\n                  sdCircle(uv, o, humanizedRadius));\n    d -= lineWidth1 * 0.5;// round off things just like in the line routine.\n\n    vec3 ret = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor);\n    \n    // do the same but for before the beginning of the line. distance field is just a single point\n    vec3 ret2 = vec3(1);\n    if(angle > pi)\n    {\n        uvLine.y -= lineLength;\n        hu = humanizeBrushStrokeDonut(uvLine, radius_, clockwise, lineLength);\n        humanizedUVLine = hu.xy;\n        humanizedRadius = hu.z;\n        vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius;\n        d = distance(uv, strokeStartPos);\n        d -= lineWidth * 0.5 * 1.;// round off things just like in the line routine.\n        ret2 = colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth, lineLength), d, inpColor, brushColor);\n\t}\n    return min(ret, ret2);\n}\n\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\n{\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\n    ret *= newSize;// scale up to new dimensions\n    float aspect = iResolution.x / iResolution.y;\n    ret.x *= aspect;// orig aspect ratio\n    float newWidth = newSize.x * aspect;\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\n}\n\n// Blue Porcelain specific code below\nfloat lips(vec2 a , vec2 b, float h, vec2 p){\n    float col = 0.;\n    if(p.x>a.x && p.x<b.x){col = 1.;}\n    float sc = 1./h/(b.x-a.x);\n    float bottom = (a.y - sin((a.x-p.x)/(b.x-a.x)*3.1416)/(sc*2.7)) - p.y;\n    //float f = smoothstep(-1.0, 1000.5, bottom);col = mix(1.,0.5, f);\n    if(col==1. && bottom>0.) {col =1.0;} else {col = 0.;}\n    //col=bottom;\n    float dist = (b.x-a.x)/4.5;\n    a.x+=dist;b.x-=dist;\n    if(col==1. && p.y>(a.y + sin((a.x-p.x)/(b.x-a.x)*9.423)/(sc*20.))) {col = 1.;} else {col = 0.;}\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(1);\n    vec2 uv = getuv_centerX(fragCoord, vec2(-1,-1), vec2(2,2));\n    // Caching output - if we're on the first frame or the resolution has changed, draw everything.\n    uv.y-=0.5;\n    if(iFrame<2 || texelFetch(iChannel0, ivec2(0), 0).r != iResolution.x){\n\n        \n        float yo = sin(-uv.x*pi*0.5)*0.2;\n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.03,.5),1.),vec2(0.4, -0.35+yo ),vec2(0.25, 0.12+yo), 0.05);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.1, -0.24 ),vec2(0.9, -0.6), 0.01);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.1, -0.1 + (sin((uv.x+0.1) * 25.) * 0.03)),vec2(0.85, -0.6), 0.01);                    \n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.09, -0.12 ),vec2(0.13, -0.17 ), 0.001);\n              \n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.1, -0.24 ),vec2(-0.9, -0.6), 0.02);\n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.1, -0.1 - (sin((uv.x+0.1) * 25.) * 0.03)),vec2(-0.85, -0.5), 0.01);                    \n        //col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.09, -0.12),vec2(-0.13, -0.17 ), 0.001);\n//col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.4),vec2(0.32, .245+yo),vec2(0.2, .205+yo), 0.002);\n        vec2 sps = vec2(0.25,-0.01);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,4.0,6.6,0.0001,true);\n        sps+=vec2(-0.015,-0.015);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,3.0,1.6,0.03,true);\n        sps+=vec2(0.07,0.07);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,5.0,6.6,0.0001,true);\n        sps+=vec2(0.015,-0.0);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,3.0,1.6,0.03,true);\n        \n        sps = vec2(-0.18,0.12);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,1.0,6.6,0.0001,true);\n        sps+=vec2(-0.01,-0.015);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,-3.0,1.6,0.02,true);\n        sps+=vec2(0.05,0.05);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.06,1.0,6.6,0.0001,true);\n        sps+=vec2(0.01,-0.015);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.02,-3.0,1.6,0.02,true);\n//colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth, bool clockwise)\n        sps = vec2(-0.23,-0.3);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.3,6.3,5.1,0.02,false);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.2,6.3,5.1,0.02,false);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.15,6.3,5.1,0.015,false);\n        sps+=vec2(-0.05,0.03);\n        col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.2,6.3,5.1,0.04,false);\n        //col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.25,6.3,5.1,0.04,false);\n        \n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.24, 0.15 + (sin((uv.x+0.1) * 25.) * 0.06)),vec2(-1.3, -1.3), 0.07);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.2, -0.2 + (sin((uv.x+0.1) * 25.) * 0.06)),vec2(-1.3, -1.0), 0.04);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.25 + sin(uv.y * 25.) * 0.03, -0.0 - (sin(uv.x * 15.) * 0.04)),vec2(0.8, -2.5), 0.03);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(-0.55 + sin(uv.y * 25.) * 0.03, -0.4 - (sin(uv.x * 15.) * 0.04)),vec2(0.8, -2.), 0.06);\n        col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.55 + sin(uv.y * 25.) * 0.07, -0.4 - (sin(uv.x * 15.) * 0.06)),vec2(-0.8, -2.), 0.05);\n         col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.4 + sin(uv.y * 25.) * 0.07, -0.1 - (sin(uv.x * 15.) * 0.06)),vec2(1.2, -1.5), 0.06);    \n         col = colorBrushStrokeLine(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.0 + sin(uv.y * 25.) * 0.07, -0.9 - (sin(uv.x * 15.) * 0.06)),vec2(0.0, -1.9), 0.12);    \n\ncol = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),vec2(0.0, -0.44),0.44,-2.,5.1,0.06,false);\n        \n        //col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.09,0.0,0.3,0.0002,true);\n        //col = colorBrushStrokeDonut(uv, col, vec4(vec3(.0,.1,.7),1.),sps,0.12,0.0,0.3,0.0002,true);\n\n       // if(lips(vec2(0.27, 0.14), vec2(0.385, 0.15), 0.8, uv)>0.){col = vec3(.0,.1,.7);}\n       float lp = lips(vec2(-0.12, 0.13), vec2(0.12, 0.13), 0.9, uv);\n        if(lp>0.){col = vec3(.0,.1,.7)*lp;}\n\n        \n        //col = colorBrushStroke(vec2(0.1,0.1), vec2(0.1,0.1), vec2(0.1,0.1), sdCircle(uv, vec2(0.1,0.1), 0.1), vec3(1,0,0), vec4(0,1,0,1));\n        \n        if(ivec2(fragCoord.xy) == ivec2(0)){ col.r = iResolution.x;}// Store resolution in 0,0 pixel\n    } else {\n       // We've already drawn everything, use buffer instead\n      col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n  }\n   \n\n\n       \n\n    fragColor = vec4(col, 1.);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "\nfloat magicBox(vec3 p) {\n    const int MAGIC_BOX_ITERS = 13;\n    const float MAGIC_BOX_MAGIC = 0.55;\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\nfloat magicBox(vec2 uv){\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n    // volume along the same axes as the fractal's bounding box.\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    return magicBox(p);\n}\n\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\n\n\n\nfloat sdSphere( in vec3 p, in float r)\n{\n    return length(p)-r;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat dot2(in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    return -opSmoothUnion(d1,-d2,k);\n    \n    //float h = max(k-abs(-d1-d2),0.0);\n    //return max(-d1, d2) + h*h*0.25/k;\n}\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    //vec3 q = abs(p)-h;\n    //return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n// Euclidean distance to a capped torus\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdVerticalVesicaSegment( in vec3 p, in float h, in float w )\n{\n    // shape constants\n    h *= 0.5;\n    w *= 0.5;\n    float d = 0.5*(h*h-w*w)/w;\n    \n    // project to 2D\n    vec2  q = vec2(length(p.xz), abs(p.y-h));\n    \n    // feature selection (vertex or body)\n    vec3  t = (h*q.x < d*(q.y-h)) ? vec3(0.0,h,0.0) : vec3(-d,0.0,d+w);\n    \n    // distance\n    return length(q-t.xy) - t.z;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Bottomless depth https://www.shadertoy.com/view/tsBXRh\n// Exploring procedural painting\n// Licensed under hippie love conspiracy\n// Leon Denise (ponk) 2019.03.17\n// Using code from:\n// Inigo Quilez (shadertoy.com/view/Xds3zN)\n// Morgan McGuire (shadertoy.com/view/4dS3Wd)\n\nconst float zoomSpeed = 0.05;\nconst float noiseScale = 4.;\nconst float noiseSpeed = 0.0;\n\nconst float PI = 3.1415;\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\nfloat fbm (vec3 p) {\n  float amplitude = .5;\n  float result = 0.0;\n  for (float index = 0.0; index <= 5.0; ++index) {\n    result += noise(p / amplitude) * amplitude;\n    amplitude /= 2.;\n  }\n  return result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\nvec2 uv = fragCoord.xy/iResolution.xy;\nif(iFrame<30){\n  vec3 color = vec3(1);\n  float timeline = iTime*zoomSpeed;\n  vec2 unit = 1./iResolution.xy;\n  \n  vec2 p = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  float stage = floor(timeline);\n  float ratio = fract(timeline);\n  const float iterations = 3.;\n  float spawn = 1.;\n  float zoom = .5;\n  float scale = noiseScale * iResolution.y / 320.;\n  for (float index = iterations; index > 0.; --index) {\n    ratio = mod(ratio+1./iterations, 1.);\n    vec3 s = vec3(p*scale*(zoom-ratio*zoom), 1. + timeline*noiseSpeed);\n    float salty = fbm(s) * 2. - 1.;\n    float angle = salty * PI * 8.;\n    uv += vec2(cos(angle),sin(angle)) * unit * sin(ratio*PI);\n    spawn *= 1. - abs(sin(angle)) * sin(ratio*PI);\n  }\n  color *= spawn;\n  float blend = (.5+.5*(1.-spawn));\n  fragColor = texture(iChannel0, uv)*blend + (1.-blend)*vec4(color, 1);\n  }\nelse{fragColor = texture(iChannel0, uv);}\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if(iFrame<30){\n        fragColor = texture(iChannel0, (uv*1.45));\n        if(fragColor.r>0.25){\n            fragColor.g=0.1; fragColor.b=0.1;fragColor.r*=1.5;\n        } else if(fragColor.r>0.15){fragColor.g=0.1; fragColor.r=0.1;fragColor.b=0.7;}else{fragColor = vec4(1);}\n    } else {fragColor = texture(iChannel1, uv);}\n    }",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Blue Porcelain\" by Cotterzz. https://shadertoy.com/view/W3XGWS\n// 2025-04-10 04:23:43\n\n// This is my first attempt at using SDFs and raymarching\n// It's a bit ambitious, and is still very much a work in progress.\n// There's lots more I want to do with it, but I have some tidying and optimisation to look into before I take it any further.\n// --\n// Based on/inspired by Bao Pham's painting 'Blue Porcelain' https://arthur.io/art/bao-pham/blue-porcelain\n// Uses code and functions from the following shaders:\n// \"Bottomless depth\" by leon       https://www.shadertoy.com/view/tsBXRh\n// \"Capped torus - distance\" by iq. https://www.shadertoy.com/view/tl23RK\n// \"Elongation SDF\" by iq.          https://www.shadertoy.com/view/Ml3fWj\n// \"Vesica Segment\" by iq.          https://www.shadertoy.com/view/Ds2czG\n// \"Brush Experiment 3\" by 104      https://www.shadertoy.com/view/ltj3Wc\n// \"Magic Fractal\" by dgreensp      https://www.shadertoy.com/view/4ljGDd\n// --\n// 2025-03-31 04:38:41\n// Copyright/licensing of forked code belongs to respective artists/authors.\n// Everything else assembled here is the work of John Cotterell johnmdcotterell@gmail.com\n// and cannot be use outside shadertoy without permission.\n\n#define AA 2\n// The porcelain looks better with anti-aliasing, but it tanks the fps on slower machines.\n// 1 is off, 2 is 2x2 AA, 3 is 3x3 AA etc..\n\n#define SAA 1\n// Selective anti-aliasing tries to target edges and doesn't look quite as good, but is faster.\n// 1 is off, 2 is on\n\nint area = 0;\nvec2 facepos = vec2(0);\nbool necka = false;\nbool roses = false;\nfloat sdHead( vec3 p ){\n    // TOP - Cranium\n\n    float cran = sdSphere(p-vec3(0,0,0.03),0.35);\n    // BOTTOM - Jaw/Cheekbones\n    vec2 os = vec2(-0.14,0.05);\n    float ms = 0.127;\n    vec3 ql = p - vec3(ms,os);\n    vec3 qr = p - vec3(-ms,os);\n    ql = ql*rotateZ(0.26);\n    qr = qr*rotateZ(-0.26);\n    ql = ql*rotateX(0.42);\n    qr = qr*rotateX(0.42);\n    vec3 a = vec3(0.,-0.4, 0.0);\n    vec3 b = vec3( 0., 0.4, 0.0);\n    float l = length(b-a);\n    float wv = sqrt(0.105/l);\n    float jaw = opSmoothUnion(sdVerticalVesicaSegment( ql-a, l, wv*0.85 ) - wv*0.15, \n    sdVerticalVesicaSegment( qr-a, l, wv*0.85 ) - wv*0.15, 0.07);\n    cran = opSmoothUnion( cran, jaw, 0.03);\n    // SHAPING - sides\n    float d2 = sdRoundBox(p-vec3(0.74,-0.4,-0.15), vec3(0.4,0.6,0.4), 0.02 ); \n    float d1 = sdRoundBox(p-vec3(-0.74,-0.4,-0.15), vec3(0.4,0.6,0.4), 0.02); \n\n    cran = opSmoothSubtraction(d2,opSmoothSubtraction(d1,cran, .2), .2);\n    // SHAPING - top\n    float d6 = sdRoundBox(p-vec3(0.,0.75,-0.0), vec3(0.4,0.4,0.4), 0.04 ); \n    cran = opSmoothSubtraction(d6,cran,.52);\n    // SHAPING - front\n    float d7 = sdRoundBox(p-vec3(0.,0.25,0.77), vec3(0.4,0.4,0.4), 0.01 ); \n    cran = opSmoothSubtraction(d7,cran,.15);\n    // Eye Sockets\n    float d5 = sdRoundBox(p-vec3(0.0,-0.21,0.385), vec3(0.18,0.001,0.001), 0.06 );\n    cran = opSmoothSubtraction( d5, cran, .04);\n    // nose\n    float nose = sdRoundCone(   p-vec3( 0.0,-0.32, 0.32), vec3(0.0,0.0,0), vec3(0.0,0.2,-0.06), 0.033, 0.01);\n    nose = opSmoothUnion( nose, sdRoundCone(   p-vec3( 0.0,-0.34, 0.3), vec3(-0.026,0,0), vec3(0.026,0,0), 0.015, 0.015), 0.03);\n    float nos = sdSphere(p-vec3(0.,-0.21,0.45), 0.11);\n    nose = opSmoothSubtraction( nos, nose, .08);\n    cran = opSmoothUnion( cran, nose, 0.02);\n    \n    \n    // Eyes\n    float eyel = sdSphere(p-vec3(0.11,-0.22,0.257), 0.035);\n    \n    \n    float eyer = sdVerticalVesicaSegment(p-vec3(-0.15,-0.43,0.2), 0.35, 0.23);\n    \n    eyer+=sin(p.y*70.)/300.;\n    eyer+=sin(p.x*80.)/400.;\n    eyer+=sin(p.z*90.)/500.;\n    if(eyer<0.01){roses = true;}\n    cran = opSmoothUnion( cran, eyer, 0.01);\n    \n    cran = opSmoothUnion( cran, eyel, 0.03);\n\n    float fan = sdRoundBox(p-vec3(0.,0.37,-0.7), vec3(0.8,0.8,0.8), 0.01 ); \n    \n    cran = min(fan,cran);\n\n    if(cran<0.001){area = 1;facepos = p.xy;}\n    if(fan<0.02){area = 2;facepos = p.xy;}\n    \n    return cran;\n}\n\nfloat map( in vec3 pos )\n{\n    float d = 1e10;\n    pos *= 0.9;\n    pos = pos*rotateZ(-0.08);\n    // Shoulders-Arms-Torso\n    vec3 q = pos - vec3(0.0,0.0,0.0);\n    q.z-=0.3;\n    q.y+=1.8 - q.x/20.;\n    q.x+=0.35 + q.y/20.;;\n    q = q*rotateX(1.7);\n    q = q*rotateZ(0.4);\n    q = q*rotateY(0.25);\n    float an = 1.0;\n    vec2 c = vec2(sin(an),cos(an));\n    vec4 w = opElongate( q, vec3(0.13,0.27,0.78) );\n    float shoulder = sdCappedTorus(w.xyz, c, 0.7, 0.2);\n    shoulder = shoulder+ sin((1.75+q.x)*3.)/15.;\n    shoulder = shoulder+0.04;\n    d = min( d, shoulder);\n    // Collar Bones\n    vec3 qt = pos - vec3(-0.8,-1.1,-0.7);\n    float collar = rounding( udTriangle( qt, vec3(0.6,0.0,0.1), vec3(0.4,-0.7,0.2), vec3(-0.1,-0.2,0.03) ), 0.05 );\n    collar = opSmoothUnion(collar, rounding( udTriangle( qt, vec3(0.7,0.0,0.1), vec3(0.8,-0.7,0.2), vec3(1.1,0.2,0.4) ), 0.01 ), 0.1);\n    d = opSmoothUnion(d, collar , 0.13);\n\n    // Neck\n     vec3 qv = pos - vec3(0.2,-1.5,-0.3);\n     vec3 a = vec3(0.,-0.2, 0.0);\n     vec3 b = vec3( 0., 0.3, 0.0);\n   float l = length(b-a);\n    qv = pos - vec3(-0.2,-0.9,-0.55);\n    qv = qv*rotateX(-0.3);\n    float neck = sdCylinder(qv, vec2(0.16, 0.65));\n    \n    d = opSmoothUnion( d, neck, 0.2);\n    if(d<0.01){necka=true;}\n    // Head\n    vec3 qh = pos - vec3(-0.15,-0.12,-0.36);\n    qh = qh*rotateY(-0.9-(0.1*sin(iTime/1.5)));\n    float head = sdHead(qh/1.03);\n    d = opSmoothUnion( d, head , 0.15);\n    return d;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n     // camera movement\t\n\tfloat an = 0.8+(0.2*sin(iTime/1.5));\n    //float an = iMouse.x/100.;\n\tvec3 ro = vec3( 1.8*cos(an), 0.3,1.8*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 edge = ww;\n    float ed = 0.;\n    vec3 ndif = vec3(0);\n    bool close = false;\n    bool miss = false;\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    // render\n    vec3 tot = vec3(0.0);\n    int count = 0;\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    #if SAA<2\n    for( int n=0; n<AA; n++ )\n    #endif\n    {\n        count++;\n        // pixel coordinates\n         #if SAA>1\n        int n = 0;\n        #endif\n        vec2 mn = vec2(float(m),float(n));\n        #if SAA>1\n        if(fragCoord.y>iResolution.y/2.){mn = mn.yx;}\n        #endif\n        vec2 o =  mn/ float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n                // shading/lighting\t\n        vec3 bg = vec3(0.6,0.65,0.8);\n        vec3 col = bg;\n        // paint blotches\n        float blotchAmt = smoothstep(30.,44.5, magicBox((p+5.2)*5.));\n        blotchAmt = pow(blotchAmt, 3.);// attenuate\n        blotchAmt = .7*smoothstep(.2,.4,blotchAmt);// sharpen\n        col *= vec3(1.-blotchAmt,1.-blotchAmt,1.0);\n        // grain\n        col.rgb += (rand(p)-.5)*.08;\n        col.rgb = saturate(col.rgb);\n        vec3 bd = col;\n        // raymarch\n        if(uv.x>0.4 && uv.x<0.7 && uv.y<0.7){\n        const float tmax = 5.0;\n \n        float cth = 0.01;\n        float mth = 0.02;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            #if SAA>1\n            close = h<cth?true:close;\n            miss = close&&h>mth?true:miss;\n            #endif\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n\n        vec2 hres = vec2(800., 450.)/iResolution.xy;\n       // edge = cross(edge, nor);\n            vec2 tpoz = facepos.xy*370.;tpoz.y+=234.;tpoz.x+=400.; tpoz = abs(tpoz); //350\n            vec2 rpoz = tpoz; rpoz.y += 116.;\n            vec3 alb = vec3(1);\n            if(area>0){alb = textureLod(iChannel0, (tpoz/hres)/iResolution.xy, 0.5).rgb;}\n        if( t<tmax )\n        {\n           \n            \n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            ed = 10.*(dot(nor,rd)+0.3);\n            //ndif = normalize(vec3(0,0,1)-nor);\n            edge = abs(cross(edge, nor));\n            vec3  lig = normalize(vec3(0.5,2.0,1.5));\n            //vec3  lig2 = normalize(vec3(1.0,0.5,1.5));\n            vec3 ref = reflect(rd, nor);\n            ndif = normalize(ref+nor);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            //float dif2 = clamp( dot(nor,lig2), 0.0, 1.0 );\n            \n            \n           // vec2 tpoy = pos.zy*200.;tpoy.y+=300.;tpoy.x-=450.; tpoy = abs(tpoy);\n \n            //if(necka){alb = vec3(0,1,0);}\n            //vec3 alb = texture(iChannel0, (tpoy.xy/hres)/iResolution.xy, 0.).rgb;\n            //alb=alb*alb;\n            //alb = min(alb, texture(iChannel0, (tpoz.xy/hres)/iResolution.xy, 0.).rgb*0.75);\n            //vec3 alb = texelFetch(iChannel0, ivec2(tpoy.xy/hres), 0).rgb*0.75;\n            //alb = min(alb, texelFetch(iChannel0, ivec2(tpoz.xy/hres), 0).rgb*0.75);\n            if(area!=2||pos.y<-0.7) {\n\n                if(necka){\n                  vec2 bpoz = pos.xy*570.;bpoz.y+=400.;bpoz.x+=600.; bpoz = abs(bpoz);\n                  alb = textureLod(iChannel0, (bpoz/hres)/iResolution.xy, 0.5).rgb;\n                  vec2 bpox = pos.xz*370.;bpox.y+=225.;bpox.x+=310.; bpox = abs(bpox);\n                  alb = min(alb,textureLod(iChannel0, (bpox/hres)/iResolution.xy, 0.5).rgb);\n                }\n\n                float spe = pow(max(0.0, dot(lig, ref)),32.0);\n                float sha = 1.;//calcSoftshadow( pos, lig, 0.03,3.0, 8.0 );\n                float amb = 0.55 + 0.2*dot(nor,normalize(vec3(0.0,1.0,0.0)));\n                if(roses){\n                  vec3 rcol = textureLod(iChannel1, (rpoz/hres)/iResolution.xy, 0.5).rgb;\n                  if(rcol.r>0.3&&rcol.g<0.3&&rcol.b<0.3){\n                        alb=rcol;\n                  }\n                  alb = min(alb, rcol);\n                  spe=0.;\n                  dif=0.4;\n                }\n                col =alb*amb + (spe*sha) + vec3(0.4,0.4,0.6)*dif/2.*sha;\n            } else {\n                col=min(col,alb);\n                \n            }\n            \n            if(alb.r>0.3&&alb.g<0.3&&alb.b<0.3){\n                col=alb;\n            }\n        }\n        }\n   \n        float f = smoothstep(-0.7,-1.0, p.y);\n        col = mix(col, bg, f);\n        // gamma        \n        \n\t    tot += col;\n    #if AA>1\n        #if SAA>1\n        vec3 edgef = fwidth(edge);\n        float edget = edgef.x+edgef.y+edgef.z;\n        if(edget<0.1&&!miss){m=AA;}//else{tot=vec3(0);}\n        #endif\n    }\n    tot /= float(count);\n    #endif\n    //if(miss){tot=vec3(0);}\n    //if(sqrt((ndif.x*ndif.x) + (ndif.y*ndif.y)+ (ndif.z*ndif.z))>1.){tot=ndif;}\n    \n\tfragColor = vec4( tot, 1.0 );\n}",
     "name": "Buffer D",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tfGGWc",
    "date": "1748580855",
    "viewed": 115,
    "name": "Equation Clock",
    "description": "A different equation every second, well the same equation, with the digits of the clock used as coefficients and exponents\n\nYou can scrub to different hours/minutes by dragging the canvas. Based on 24hr clock.",
    "likes": 10,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "time",
     "quadratic",
     "equation",
     "challenge",
     "date",
     "maths",
     "hyperbolic",
     "parabolic",
     "unofficial",
     "byt3m3chanic"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// so if the time is 10:23:42\n// it plots the graph of z=(10x⁴y²)-(23x¹y⁰)+(42x²y³)\n// (Or similar - I had to mix the exponents around for best results)\n// ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    int sec = int(mod(iDate.w,60.));\n    int minute = int(mod(iDate.w/60.,60.));\n    int hour = int(mod(iDate.w/3600.,24.));\n    \n    if(iMouse.z>0.){\n       minute = int(floor((iMouse.y/iResolution.y) * 60.));\n       hour = int(floor((iMouse.x/iResolution.x) * 24.));\n    }\n    \n    float num = float(hour);\n    int h1 = int(mod(num / pow(10.0,1.),10.0));\n    int h2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(minute);\n    int m1 = int(mod(num / pow(10.0,1.),10.0));\n    int m2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(sec);\n    int s1 = int(mod(num / pow(10.0,1.),10.0));\n    int s2 = int(mod(num / pow(10.0,0.),10.0));\n\n\n    float hours =float(hour);\n    float minutes = float(minute);\n    float secs = float(sec);\n    float zoom = 10.;\n    \n    int MS = 6;\n    float xp = 1./iResolution.x;\n    float yp = 1./iResolution.y;\n    int count = 0;\n    float result = 0.;float result2 = 0.;\n    vec3 rf = vec3(0);\n    for( int m=0; m<MS; m++ ){\n        for( int n=0; n<MS; n++ ){\n            vec2 nuv = uv;\n            nuv.x +=( xp/float(MS))*float(n);\n            nuv.y += (yp/float(MS))*float(m);\n            vec2 guv = (nuv*zoom)-(zoom/2.);\n            float x = guv.x;\n            float y = guv.y;\n            result = -( p(x,m1) * p(y,s2) *hours )-( p(x,h1) * p(y,s1) * minutes)+( secs * p(x,h2) * p(y,m2) ) ;\n            count+=1;\n            rf+=getPC(result);\n        }\n    }\n    \n    rf /= float(count);\n\n    fragColor = vec4(rf,1.0);\n    \n    ivec2 letters = ivec2(34,10);\n    vec2 letterp = vec2(fract(uv.x * float(letters.x)), fract(uv.y * float(letters.y)));\n    int letter = int(floor(uv.x * float(letters.x)));\n    if(uv.y<1./float(letters.y)){ fragColor = texture(iChannel0, getLetter(letterp, letter, h1,h2,m1,m2,s1,s2), .0).rrra; }\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define lbracket letterpos = vec2(8.,13.); break;\n#define rbracket letterpos = vec2(9.,13.); break;\n#define times letterpos = vec2(10.,13.); break;\n#define minus letterpos = vec2(29.,29.); break;\n#define plus letterpos = vec2(27.,29.); break;\n#define X letterpos = vec2(8.,10.); break;\n#define Y letterpos = vec2(9.,10.); break;\n#define m1super letterpos = vec2(float(m1+1),12.); super=true; break;\n#define m2super letterpos = vec2(float(m2+1),12.); super=true; break;\n#define s1super letterpos = vec2(float(s1+1),12.); super=true; break;\n#define s2super letterpos = vec2(float(s2+1),12.); super=true; break;\n#define h1super letterpos = vec2(float(h1+1),12.); super=true; break;\n#define h2super letterpos = vec2(float(h2+1),12.); super=true; break;\n#define h1reg letterpos = vec2(float(h1),12.); break;\n#define h2reg letterpos = vec2(float(h2),12.); break;\n#define m1reg letterpos = vec2(float(m1),12.); break;\n#define m2reg letterpos = vec2(float(m2),12.); break;\n#define s1reg letterpos = vec2(float(s1),12.); break;\n#define s2reg letterpos = vec2(float(s2),12.); break;\n\nfloat p(in float a, in int b){float r = a;for(int i = 2; i<10; i++){ r = r*a; if(i>=b){ break;} }return r;}\nvec3 getPC(float t) {\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\n\nvec2 getLetter(vec2 p , int n, int h1, int h2, int m1, int m2, int s1, int s2){\n\n    vec2 letterpos = vec2(0);\n    \n    bool super = false;\n    \n    switch (n) {\n    case 0: letterpos = vec2(10.,10.); break;\n    case 1: letterpos = vec2(13.,12.); break;\n    case 2: lbracket\n    case 3: h1reg\n    case 4: h2reg\n    case 5: times\n    case 6: X\n    case 7: m1super\n    case 8: times\n    case 9: Y\n    case 10: s2super\n    case 11: rbracket\n    case 12: minus\n    case 13: lbracket\n    case 14: m1reg\n    case 15: m2reg\n    case 16: times\n    case 17: X\n    case 18: h1super\n    case 19: times\n    case 20: Y\n    case 21: s1super\n    case 22: rbracket\n    case 23: plus\n    case 24: lbracket\n    case 25: s1reg\n    case 26: s2reg\n    case 27: times\n    case 28: X\n    case 29: h2super\n    case 30: times\n    case 31: Y\n    case 32: m2super\n    case 33: rbracket\n    }\n    letterpos/=16.;\n    \n    if(super){if(p.x>0.25 && p.x<0.75 &&p.y>0.5){letterpos += -(1./16.) + p/8.; letterpos.x-=1./32.;} } else {letterpos+=p/16.;}\n\n    return letterpos;\n\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wcy3Wd",
    "date": "1748626164",
    "viewed": 88,
    "name": "Polynomial Clock v2",
    "description": "Version 2 - much better name, colour translation and improved text\nA different result every second, with the digits of the clock used as coefficients and exponents\nYou can scrub to different hours/minutes by dragging the canvas.",
    "likes": 3,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "time",
     "equation",
     "challenge",
     "polynomial",
     "date",
     "maths",
     "bivariate",
     "unofficial",
     "byt3m3chanic"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Equation Clock\" by Cotterzz. https://shadertoy.com/view/tfGGWc\n// 2025-05-30 17:11:06\n\n// so if the time is 10:23:42\n// it plots the graph of z=(10x⁴y²)-(23x¹y⁰)+(42x²y³)\n// (Or similar - I had to mix the exponents around for best results)\n// ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = fragCoord/iResolution.y;\n    cuv.x += 0.5 - (iResolution.x/iResolution.y)*0.5;\n    int sec = int(mod(iDate.w,60.));\n    int minute = int(mod(iDate.w/60.,60.));\n    int hour = int(mod(iDate.w/3600.,24.));\n    \n    if(iMouse.z>0.){\n       minute = int(floor((iMouse.y/iResolution.y) * 60.));\n       hour = int(floor((iMouse.x/iResolution.x) * 24.));\n    }\n    \n    float num = float(hour);\n    int h1 = int(mod(num / pow(10.0,1.),10.0));\n    int h2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(minute);\n    int m1 = int(mod(num / pow(10.0,1.),10.0));\n    int m2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(sec);\n    int s1 = int(mod(num / pow(10.0,1.),10.0));\n    int s2 = int(mod(num / pow(10.0,0.),10.0));\n\n\n    float hours =float(hour);\n    float minutes = float(minute);\n    float secs = float(sec);\n    float zoom = 8.; // use this to zoom\n    \n    int MS = 7;  // -------------------------------------- If performance is bad, lower this number\n    float xp = 1./iResolution.x;\n    float yp = 1./iResolution.y;\n    int count = 0;\n    float result = 0.;float result2 = 0.;\n    vec3 rf = vec3(0);\n    for( int m=0; m<MS; m++ ){\n        for( int n=0; n<MS; n++ ){\n            vec2 nuv = cuv;\n            nuv.x +=( xp/float(MS))*float(n);\n            nuv.y += (yp/float(MS))*float(m);\n            vec2 guv = (nuv*zoom)-(zoom/2.);\n            float x = guv.x;\n            float y = guv.y;\n            result = -( p(x,m1) * p(y,s2) *hours )-( p(x,h1) * p(y,s1) * minutes)+( secs * p(x,h2) * p(y,m2) ) ;\n            count+=1;\n            rf+=getPC(result);\n        }\n    }\n    \n    rf /= float(count);\n\n    fragColor = vec4(rf,1.0); vec4 fc = fragColor;\n    \n    float fdiff = (abs(fc.r-fc.g) + abs(fc.r-fc.b) + abs(fc.g-fc.b))/3.;\n    \n    fragColor = mix(vec4(0), fragColor, sqrt(fdiff));\n    //fragColor = sqrt(fragColor);\n    ivec2 letters = ivec2(34,13);\n    vec2 letterp = vec2(fract(uv.x * float(letters.x)), fract(uv.y * float(letters.y)));\n    int letter = int(floor(uv.x * float(letters.x)));\n    fragColor = mix(vec4(0), fragColor, min( 1. , (uv.y * float(letters.y)*0.8)-0.));\n    if(uv.y<1./float(letters.y)){\n        vec4 texColor = texture(iChannel0, getLetter(letterp, letter, h1,h2,m1,m2,s1,s2), .0);\n        if(texColor.a<0.55){fragColor = texColor.rrrr;}\n    }\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define lbracket letterpos = vec2(8.,13.); break;\n#define rbracket letterpos = vec2(9.,13.); break;\n#define times letterpos = vec2(10.,13.); break;\n#define minus letterpos = vec2(29.,29.); break;\n#define plus letterpos = vec2(27.,29.); break;\n#define X letterpos = vec2(8.,10.); break;\n#define Y letterpos = vec2(9.,10.); break;\n#define m1super letterpos = vec2(float(m1+1),12.); super=true; break;\n#define m2super letterpos = vec2(float(m2+1),12.); super=true; break;\n#define s1super letterpos = vec2(float(s1+1),12.); super=true; break;\n#define s2super letterpos = vec2(float(s2+1),12.); super=true; break;\n#define h1super letterpos = vec2(float(h1+1),12.); super=true; break;\n#define h2super letterpos = vec2(float(h2+1),12.); super=true; break;\n#define h1reg letterpos = vec2(float(h1),12.); break;\n#define h2reg letterpos = vec2(float(h2),12.); break;\n#define m1reg letterpos = vec2(float(m1),12.); break;\n#define m2reg letterpos = vec2(float(m2),12.); break;\n#define s1reg letterpos = vec2(float(s1),12.); break;\n#define s2reg letterpos = vec2(float(s2),12.); break;\n\nfloat p(in float a, in int b){float r = a;for(int i = 2; i<10; i++){ r = r*a; if(i>=b){ break;} }return r;}\nvec3 getPC(float t) {\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\n\nvec2 getLetter(vec2 p , int n, int h1, int h2, int m1, int m2, int s1, int s2){\n\n    vec2 letterpos = vec2(0);\n    \n    bool super = false;\n    \n    switch (n) {\n    case 0: letterpos = vec2(10.,10.); break;\n    case 1: letterpos = vec2(13.,12.); break;\n    case 2: lbracket\n    case 3: h1reg\n    case 4: h2reg\n    case 5: times\n    case 6: X\n    case 7: m1super\n    case 8: times\n    case 9: Y\n    case 10: s2super\n    case 11: rbracket\n    case 12: minus\n    case 13: lbracket\n    case 14: m1reg\n    case 15: m2reg\n    case 16: times\n    case 17: X\n    case 18: h1super\n    case 19: times\n    case 20: Y\n    case 21: s1super\n    case 22: rbracket\n    case 23: plus\n    case 24: lbracket\n    case 25: s1reg\n    case 26: s2reg\n    case 27: times\n    case 28: X\n    case 29: h2super\n    case 30: times\n    case 31: Y\n    case 32: m2super\n    case 33: rbracket\n    }\n    letterpos/=16.;\n    \n    if(super){if(p.x>0.25 && p.x<0.75 &&p.y>0.5){letterpos += -(1./16.) + p/8.; letterpos.x-=1./32.;} } else {letterpos+=p/16.;}\n\n    return letterpos;\n\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wfGGWt",
    "date": "0",
    "viewed": 0,
    "name": "Polynomial Clock v3",
    "description": "Version 2 - much better name, colour translation and improved text\nA different result every second, with the digits of the clock used as coefficients and exponents\nYou can scrub to different hours/minutes by dragging the canvas.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "time",
     "equation",
     "challenge",
     "polynomial",
     "date",
     "maths",
     "bivariate",
     "unofficial",
     "byt3m3chanic"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Polynomial Clock v2\" by Cotterzz. https://shadertoy.com/view/Wcy3Wd\n// 2025-05-30 18:24:31\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define lbracket letterpos = vec2(8.,13.); break;\n#define rbracket letterpos = vec2(9.,13.); break;\n#define times letterpos = vec2(10.,13.); break;\n#define minus letterpos = vec2(29.,29.); break;\n#define colon letterpos = vec2(10.,12.); break;\n#define plus letterpos = vec2(27.,29.); break;\n#define X letterpos = vec2(8.,10.); break;\n#define Y letterpos = vec2(9.,10.); break;\n#define m1super letterpos = vec2(float(m1+1),12.); super=true; break;\n#define m2super letterpos = vec2(float(m2+1),12.); super=true; break;\n#define s1super letterpos = vec2(float(s1+1),12.); super=true; break;\n#define s2super letterpos = vec2(float(s2+1),12.); super=true; break;\n#define h1super letterpos = vec2(float(h1+1),12.); super=true; break;\n#define h2super letterpos = vec2(float(h2+1),12.); super=true; break;\n#define h1reg letterpos = vec2(float(h1),12.); break;\n#define h2reg letterpos = vec2(float(h2),12.); break;\n#define m1reg letterpos = vec2(float(m1),12.); break;\n#define m2reg letterpos = vec2(float(m2),12.); break;\n#define s1reg letterpos = vec2(float(s1),12.); break;\n#define s2reg letterpos = vec2(float(s2),12.); break;\n\nfloat p(in float a, in int b){float r = a;for(int i = 2; i<10; i++){ r = r*a; if(i>=b){ break;} }return r;}\nvec3 getPC(float t) {\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\n\nvec3 getHC( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nvec2 getLetter(vec2 p , int n, int h1, int h2, int m1, int m2, int s1, int s2){\n\n    vec2 letterpos = vec2(0);\n    \n    bool super = false;\n    \n    switch (n) {\n    case 0: letterpos = vec2(10.,10.); break;\n    case 1: letterpos = vec2(13.,12.); break;\n    case 2: lbracket\n    case 3: h1reg\n    case 4: h2reg\n    case 5: times\n    case 6: X\n    case 7: m1super\n    case 8: times\n    case 9: Y\n    case 10: s2super\n    case 11: rbracket\n    case 12: minus\n    case 13: lbracket\n    case 14: m1reg\n    case 15: m2reg\n    case 16: times\n    case 17: X\n    case 18: h1super\n    case 19: times\n    case 20: Y\n    case 21: s1super\n    case 22: rbracket\n    case 23: plus\n    case 24: lbracket\n    case 25: s1reg\n    case 26: s2reg\n    case 27: times\n    case 28: X\n    case 29: h2super\n    case 30: times\n    case 31: Y\n    case 32: m2super\n    case 33: rbracket\n    }\n    letterpos/=16.;\n    \n    if(super){if(p.x>0.25 && p.x<0.75 &&p.y>0.5){letterpos += -(1./16.) + p/8.; letterpos.x-=1./32.;} } else {letterpos+=p/16.;}\n\n    return letterpos;\n\n}\n\nvec3 getLCol(int n){\n\n    vec3 lettercol = vec3(1);\n    \n    switch (n) {\n    case 3: lettercol = vec3(0,1,0); break;\n    case 4: lettercol = vec3(0,1,0); break;\n    case 18: lettercol = vec3(0,1,0); break;\n    case 29: lettercol = vec3(0,1,0); break;\n    case 14: lettercol = vec3(1,0.6,0); break;\n    case 15: lettercol = vec3(1,0.6,0); break;\n    case 7: lettercol = vec3(1,0.6,0); break;\n    case 32: lettercol = vec3(1,0.6,0); break;\n    case 25: lettercol = vec3(0,0.8,1); break;\n    case 26: lettercol = vec3(0,0.8,1); break;\n    case 10: lettercol = vec3(0,0.8,1); break;\n    case 21: lettercol = vec3(0,0.8,1); break;\n    }\n\n    return lettercol;\n\n}\n\nvec2 getCLetter(vec2 p , int n, int h1, int h2, int m1, int m2, int s1, int s2){\n\n    vec2 letterpos = vec2(0);\n    \n    bool super = false;\n    \n    switch (n) {\n    case 0: h1reg\n    case 1: h2reg\n    case 2: colon\n    case 3: m1reg\n    case 4: m2reg\n    case 5: colon\n    case 6: s1reg\n    case 7: s2reg\n\n    }\n    letterpos/=16.;\n    \n    if(super){if(p.x>0.25 && p.x<0.75 &&p.y>0.5){letterpos += -(1./16.) + p/8.; letterpos.x-=1./32.;} } else {letterpos+=p/16.;}\n\n    return letterpos;\n\n}\n\nvec3 getCLCol(int n){\n\n    vec3 lettercol = vec3(1);\n    \n    switch (n) {\n    case 0: lettercol = vec3(0,1,0); break;\n    case 1: lettercol = vec3(0,1,0); break;\n    case 2: lettercol = vec3(1); break;\n    case 3: lettercol = vec3(1,0.6,0); break;\n    case 4: lettercol = vec3(1,0.6,0); break;\n    case 5: lettercol = vec3(1); break;\n    case 6: lettercol = vec3(0,0.8,1); break;\n    case 7: lettercol = vec3(0,0.8,1); break;\n    }\n\n    return lettercol;\n\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Equation Clock\" by Cotterzz. https://shadertoy.com/view/tfGGWc\n// 2025-05-30 17:11:06\n\n// so if the time is 10:23:42\n// it plots the graph of z=(10x⁴y²)-(23x¹y⁰)+(42x²y³)\n// (Or similar - I had to mix the exponents around for best results)\n// ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = fragCoord/iResolution.y;\n    cuv.x += 0.5 - (iResolution.x/iResolution.y)*0.5;\n    \n    int sec = int(mod(iDate.w,60.));\n    int minute = int(mod(iDate.w/60.,60.));\n    int hour = int(mod(iDate.w/3600.,24.));\n    \n    if(iMouse.z>0.){\n       minute = int(floor((iMouse.y/iResolution.y) * 60.));\n       hour = int(floor((iMouse.x/iResolution.x) * 24.));\n    }\n    \n    float num = float(hour);\n    int h1 = int(mod(num / pow(10.0,1.),10.0));\n    int h2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(minute);\n    int m1 = int(mod(num / pow(10.0,1.),10.0));\n    int m2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(sec);\n    int s1 = int(mod(num / pow(10.0,1.),10.0));\n    int s2 = int(mod(num / pow(10.0,0.),10.0));\n\n\n    float hours =float(hour);\n    float minutes = float(minute);\n    float secs = float(sec);\n    float dc = 0.5 + distance(uv, vec2(0.5))/3.;\n    \n    float zoom = dc / pow(1.0 - dc*dc, 5.5); // use this to zoom\n    //zoom = pow(zoom,1.5);\n    //zoom = 6.;\n    int MS = 6;  // -------------------------------------- If performance is bad, lower this number\n    float xp = 1./iResolution.x;\n    float yp = 1./iResolution.y;\n    int count = 0;\n    float result = 0.;float result2 = 0.;\n    vec3 rf = vec3(0);\n    for( int m=0; m<MS; m++ ){\n        for( int n=0; n<MS; n++ ){\n            vec2 nuv = cuv;\n            nuv.x +=( xp/float(MS))*float(n);\n            nuv.y += (yp/float(MS))*float(m);\n            vec2 guv = (nuv*zoom)-(zoom/2.);\n            float x = guv.x;\n            float y = guv.y;\n            result = -( p(x,m1) * p(y,s2) *hours )-( p(x,h1) * p(y,s1) * minutes)+( secs * p(x,h2) * p(y,m2) ) ;\n//result = -( p(x,m1) * cos(p(y,s2)) *hours )-sin( p(x,h1) * p(y,s1) * minutes)+( secs * cos(p(x,h2)) * sin(p(y,m2)) ) - p(atan( x/y ), s2)+atan(p(x, s1)/p(y,m2)); // :D\n            count+=1;\n            vec3 col = mix(getPC(result), getHC(vec3(result, 1.0, 0.5)), 0.35);\n            rf+=col;\n        }\n    }\n    \n    rf /= float(count);\n\n    fragColor = vec4(rf,1.0); vec4 fc = fragColor;\n    \n    float fdiff = (abs(fc.r-fc.g) + abs(fc.r-fc.b) + abs(fc.g-fc.b))/3.;\n    \n    fragColor = mix(vec4(0), fragColor, sqrt(fdiff));\n   \n\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265359\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 addLight(vec3 position, vec3 normal, vec3 colour, vec3 lcol, vec3 lpos){\n    vec3 ref = reflect(vec3(0.0, 0.0, -1.0), normal);\n    vec3 diff = lpos - position;\n    float ldist = length(diff);\n    diff = diff/ldist;\n    float specular = pow(max(0.0, dot(diff, ref)), 16.0);\n    float diffuse = max(0.0, dot(diff,normal));\n    vec3 col1 = colour*0.7;\n    vec3 col2 = colour*0.4*(lcol*diffuse);\n    col2 = col2+(lcol*specular);\n    return col1+col2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec2 uv = fragCoord/iResolution.xy;\n   vec2 co = fragCoord;\n   float scale  = 0.2 + iMouse.x/iResolution.x*16.;\n   vec3 col = vec3(0);\n    //-------------- find a better way to retrieve these values\n    int sec = int(mod(iDate.w,60.));\n    int minute = int(mod(iDate.w/60.,60.));\n    int hour = int(mod(iDate.w/3600.,24.));\n    \n    if(iMouse.z>0.){\n       minute = int(floor((iMouse.y/iResolution.y) * 60.));\n       hour = int(floor((iMouse.x/iResolution.x) * 24.));\n    }\n    \n    float num = float(hour);\n    int h1 = int(mod(num / pow(10.0,1.),10.0));\n    int h2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(minute);\n    int m1 = int(mod(num / pow(10.0,1.),10.0));\n    int m2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(sec);\n    int s1 = int(mod(num / pow(10.0,1.),10.0));\n    int s2 = int(mod(num / pow(10.0,0.),10.0));\n    //---------------------------------------------\n    // three sample plus dxdy\n    int pos = int(co.x)%2 + (int(co.y)%2 * 2);\n    vec4 texa = texture(iChannel0, co/iResolution.xy, 0.);\n    vec4 texb = texture(iChannel0, (co+vec2(1,0))/iResolution.xy, 0.);\n    vec4 texc = texture(iChannel0, (co+vec2(0,1))/iResolution.xy, 0.);\n    float fda = (abs(texa.r-texa.g) + abs(texa.r-texa.b) + abs(texa.g-texa.b))/3.;\n    float fdb = (abs(texb.r-texb.g) + abs(texb.r-texb.b) + abs(texb.g-texb.b))/3.;\n    float fdc = (abs(texc.r-texc.g) + abs(texc.r-texc.b) + abs(texc.g-texc.b))/3.;\n    float ra = (texa.r+texa.g+texa.b)/3.;\n    float rb = (texb.r+texb.g+texb.b)/3.;\n    float rc = (texc.r+texc.g+texc.b)/3.;\n    ra = fda*ra;\n    rb = fdb*rb;\n    rc = fdc*rc;\n    float dx = dFdx(ra);\n    float dy = dFdy(ra);\n    if(pos == 1 || pos == 3){ dx = rb-ra; }\n    if(pos == 2 || pos == 3){ dy = rc-ra; }\n    float dz = sqrt((dx*dx) + (dy*dy));\n    float a = (PI + atan(dx,dy))/(PI*2.);\n    \n    float bounds = iResolution.y/1.6;\n    \n    if( iMouse.z>0. || iMouse.x>0. || iMouse.y>0.) { bounds = iMouse.y;}\n    float dvh = 50.;// + (bounds/iResolution.y)*120.;\n    vec3 normal = normalize(vec3(dx*dvh, dy*dvh, ra));\n    \n    col = texa.rgb*2.*fda;//vec3(0.8,0.5+(ra/3.),0.4+(ra/3.));\n    \n    vec3 position = vec3(co/iResolution.xy, ra);\n    \n    vec3 lcol = vec3(3.5)*fda;//vec3(0,1,0);\n    vec3 lpos = vec3(3.,3.,5.);\n    \n    vec3 rend = addLight(position, normal, col, lcol, lpos);\n    \n    \n    fragColor =vec4(rend, 1.);\n    \n    //fragColor =vec4(vec3(ra), 1.); // uncomment to see raw height data from buffer A\n    \n    ivec2 letters = ivec2(34,13);\n    vec2 letterp = vec2(fract(uv.x * float(letters.x)), fract(uv.y * float(letters.y)));\n    int letter = int(floor(uv.x * float(letters.x)));\n    fragColor = mix(vec4(0), fragColor, min( 1. , (uv.y * float(letters.y)*0.8)));\n    if(uv.y<1./float(letters.y)){\n        vec4 texColor = texture(iChannel1, getLetter(letterp, letter, h1,h2,m1,m2,s1,s2), .0);\n        if(texColor.a<0.55){fragColor = texColor.rrrr; fragColor.rgb *= getLCol(letter);}\n    }\n    ivec2 cletters = ivec2(16,8);\n    int loffset = 4;\n    vec2 cletterp = vec2(fract(uv.x * float(cletters.x)), fract(uv.y * float(cletters.y)));\n    int cletter = int(floor(uv.x * float(cletters.x)));\n    if(uv.y>(1./float(cletters.y))*float(cletters.y-1) && cletter>=loffset && cletter<8+loffset){\n        vec4 texColor = texture(iChannel1, getCLetter(cletterp, cletter-loffset, h1,h2,m1,m2,s1,s2), .0);\n        if(texColor.a<0.55){fragColor = texColor.rrrr; fragColor.rgb *= getCLCol(cletter-loffset);}\n    }\n     fragColor = sqrt(fragColor);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wctXzr",
    "date": "1748730899",
    "viewed": 99,
    "name": "Polynomial Clock 3.0",
    "description": "Constructs a polynomial from the digits in the time\nV3, lots more visual improvements. I think this is the final version\nClick on the canvas to see how it looks at other times.",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "math",
     "time",
     "graph",
     "equation",
     "challenge",
     "polynomial",
     "date",
     "maths",
     "bivariate",
     "unofficial",
     "byt3m3chanic"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Version 3.\n// Plots the graph to very high numbers as it gets near the edge, so most details are visible.\n// Added lighting effects.\n// Improved text with time at the top and colour coded numbers.\n\n\n// Fork of \"Polynomial Clock v2\" by Cotterzz. https://shadertoy.com/view/Wcy3Wd\n// 2025-05-30 18:24:31\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define lbracket letterpos = vec2(8.,13.); break;\n#define rbracket letterpos = vec2(9.,13.); break;\n#define times letterpos = vec2(10.,13.); break;\n#define minus letterpos = vec2(29.,29.); break;\n#define colon letterpos = vec2(10.,12.); break;\n#define plus letterpos = vec2(27.,29.); break;\n#define X letterpos = vec2(8.,10.); break;\n#define Y letterpos = vec2(9.,10.); break;\n#define m1super letterpos = vec2(float(m1+1),12.); super=true; break;\n#define m2super letterpos = vec2(float(m2+1),12.); super=true; break;\n#define s1super letterpos = vec2(float(s1+1),12.); super=true; break;\n#define s2super letterpos = vec2(float(s2+1),12.); super=true; break;\n#define h1super letterpos = vec2(float(h1+1),12.); super=true; break;\n#define h2super letterpos = vec2(float(h2+1),12.); super=true; break;\n#define h1reg letterpos = vec2(float(h1),12.); break;\n#define h2reg letterpos = vec2(float(h2),12.); break;\n#define m1reg letterpos = vec2(float(m1),12.); break;\n#define m2reg letterpos = vec2(float(m2),12.); break;\n#define s1reg letterpos = vec2(float(s1),12.); break;\n#define s2reg letterpos = vec2(float(s2),12.); break;\n\nfloat p(in float a, in int b){float r = a;for(int i = 2; i<10; i++){ r = r*a; if(i>=b){ break;} }return r;}\nvec3 getPC(float t) {\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\n\nvec3 getHC( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nvec2 getLetter(vec2 p , int n, int h1, int h2, int m1, int m2, int s1, int s2){\n\n    vec2 letterpos = vec2(0);\n    \n    bool super = false;\n    \n    switch (n) {\n    case 0: letterpos = vec2(10.,10.); break;\n    case 1: letterpos = vec2(13.,12.); break;\n    case 2: lbracket\n    case 3: h1reg\n    case 4: h2reg\n    case 5: times\n    case 6: X\n    case 7: m1super\n    case 8: times\n    case 9: Y\n    case 10: s2super\n    case 11: rbracket\n    case 12: minus\n    case 13: lbracket\n    case 14: m1reg\n    case 15: m2reg\n    case 16: times\n    case 17: X\n    case 18: h1super\n    case 19: times\n    case 20: Y\n    case 21: s1super\n    case 22: rbracket\n    case 23: plus\n    case 24: lbracket\n    case 25: s1reg\n    case 26: s2reg\n    case 27: times\n    case 28: X\n    case 29: h2super\n    case 30: times\n    case 31: Y\n    case 32: m2super\n    case 33: rbracket\n    }\n    letterpos/=16.;\n    \n    if(super){if(p.x>0.25 && p.x<0.75 &&p.y>0.5){letterpos += -(1./16.) + p/8.; letterpos.x-=1./32.;} } else {letterpos+=p/16.;}\n\n    return letterpos;\n\n}\n\nvec3 getLCol(int n){\n\n    vec3 lettercol = vec3(1);\n    \n    switch (n) {\n    case 3: lettercol = vec3(0,1,0); break;\n    case 4: lettercol = vec3(0,1,0); break;\n    case 18: lettercol = vec3(0,1,0); break;\n    case 29: lettercol = vec3(0,1,0); break;\n    case 14: lettercol = vec3(1,0.6,0); break;\n    case 15: lettercol = vec3(1,0.6,0); break;\n    case 7: lettercol = vec3(1,0.6,0); break;\n    case 32: lettercol = vec3(1,0.6,0); break;\n    case 25: lettercol = vec3(0,0.8,1); break;\n    case 26: lettercol = vec3(0,0.8,1); break;\n    case 10: lettercol = vec3(0,0.8,1); break;\n    case 21: lettercol = vec3(0,0.8,1); break;\n    }\n\n    return lettercol;\n\n}\n\nvec2 getCLetter(vec2 p , int n, int h1, int h2, int m1, int m2, int s1, int s2){\n\n    vec2 letterpos = vec2(0);\n    \n    bool super = false;\n    \n    switch (n) {\n    case 0: h1reg\n    case 1: h2reg\n    case 2: colon\n    case 3: m1reg\n    case 4: m2reg\n    case 5: colon\n    case 6: s1reg\n    case 7: s2reg\n\n    }\n    letterpos/=16.;\n    \n    if(super){if(p.x>0.25 && p.x<0.75 &&p.y>0.5){letterpos += -(1./16.) + p/8.; letterpos.x-=1./32.;} } else {letterpos+=p/16.;}\n\n    return letterpos;\n\n}\n\nvec3 getCLCol(int n){\n\n    vec3 lettercol = vec3(1);\n    \n    switch (n) {\n    case 0: lettercol = vec3(0,1,0); break;\n    case 1: lettercol = vec3(0,1,0); break;\n    case 2: lettercol = vec3(1); break;\n    case 3: lettercol = vec3(1,0.6,0); break;\n    case 4: lettercol = vec3(1,0.6,0); break;\n    case 5: lettercol = vec3(1); break;\n    case 6: lettercol = vec3(0,0.8,1); break;\n    case 7: lettercol = vec3(0,0.8,1); break;\n    }\n\n    return lettercol;\n\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Equation Clock\" by Cotterzz. https://shadertoy.com/view/tfGGWc\n// 2025-05-30 17:11:06\n\n// so if the time is 10:23:42\n// it plots the graph of z=(10x⁴y²)-(23x¹y⁰)+(42x²y³)\n// (Or similar - I had to mix the exponents around for best results)\n// ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = fragCoord/iResolution.y;\n    cuv.x += 0.5 - (iResolution.x/iResolution.y)*0.5;\n    \n    int sec = int(mod(iDate.w,60.));\n    int minute = int(mod(iDate.w/60.,60.));\n    int hour = int(mod(iDate.w/3600.,24.));\n    \n    if(iMouse.z>0.){\n       minute = int(floor((iMouse.y/iResolution.y) * 60.));\n       hour = int(floor((iMouse.x/iResolution.x) * 24.));\n    }\n    \n    float num = float(hour);\n    int h1 = int(mod(num / pow(10.0,1.),10.0));\n    int h2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(minute);\n    int m1 = int(mod(num / pow(10.0,1.),10.0));\n    int m2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(sec);\n    int s1 = int(mod(num / pow(10.0,1.),10.0));\n    int s2 = int(mod(num / pow(10.0,0.),10.0));\n\n\n    float hours =float(hour);\n    float minutes = float(minute);\n    float secs = float(sec);\n    float dc = 0.5 + distance(uv, vec2(0.5))/3.;\n    \n    float zoom = dc / pow(1.0 - dc*dc, 5.5); \n\n    //zoom = 3.;\n    int MS = 8;  // -------------------------------------- If performance is bad, lower this number\n    float xp = 1./iResolution.x;\n    float yp = 1./iResolution.y;\n    int count = 0;\n    float result = 0.;float result2 = 0.;\n    vec3 rf = vec3(0);\n    for( int m=0; m<MS; m++ ){\n        for( int n=0; n<MS; n++ ){\n            vec2 nuv = cuv;\n            nuv.x +=( xp/float(MS))*float(n);\n            nuv.y += (yp/float(MS))*float(m);\n            vec2 guv = (nuv*zoom)-(zoom/2.);\n            float x = guv.x;\n            float y = guv.y;\n            result = -( p(x,m1) * p(y,s2) *hours )-( p(x,h1) * p(y,s1) * minutes)+( secs * p(x,h2) * p(y,m2) ) ;\n            //result = -( p(x,m1) * cos(p(y,s2)) *hours )-sin( p(x,h1) * p(y,s1) * minutes)+( secs * cos(p(x,h2)) * sin(p(y,m2)) ) - p(atan( x/y ), s2)+atan(p(x, s1)/p(y,m2)); // :D\n            count+=1;\n            vec3 col = mix(getPC(result), getHC(vec3(result, 1.0, 0.5)), 0.35);\n            rf+=col;\n        }\n    }\n    \n    rf /= float(count);\n\n    fragColor = vec4(rf,1.0); vec4 fc = fragColor;\n    \n    float fdiff = (abs(fc.r-fc.g) + abs(fc.r-fc.b) + abs(fc.g-fc.b))/3.;\n    \n    fragColor = mix(vec4(0), fragColor, sqrt(fdiff));\n   \n\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265359\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 addLight(vec3 position, vec3 normal, vec3 colour, vec3 lcol, vec3 lpos){\n    vec3 ref = reflect(vec3(0.0, 0.0, -1.0), normal);\n    vec3 diff = lpos - position;\n    float ldist = length(diff);\n    diff = diff/ldist;\n    float specular = pow(max(0.0, dot(diff, ref)), 16.0);\n    float diffuse = max(0.0, dot(diff,normal));\n    vec3 col1 = colour*0.7;\n    vec3 col2 = colour*0.4*(lcol*diffuse);\n    col2 = col2+(lcol*specular);\n    return col1+col2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec2 uv = fragCoord/iResolution.xy;\n   vec2 co = fragCoord;\n   float scale  = 0.2 + iMouse.x/iResolution.x*16.;\n   vec3 col = vec3(0);\n    //-------------- find a better way to retrieve these values\n    int sec = int(mod(iDate.w,60.));\n    int minute = int(mod(iDate.w/60.,60.));\n    int hour = int(mod(iDate.w/3600.,24.));\n    \n    if(iMouse.z>0.){\n       minute = int(floor((iMouse.y/iResolution.y) * 60.));\n       hour = int(floor((iMouse.x/iResolution.x) * 24.));\n    }\n    \n    float num = float(hour);\n    int h1 = int(mod(num / pow(10.0,1.),10.0));\n    int h2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(minute);\n    int m1 = int(mod(num / pow(10.0,1.),10.0));\n    int m2 = int(mod(num / pow(10.0,0.),10.0));\n    num = float(sec);\n    int s1 = int(mod(num / pow(10.0,1.),10.0));\n    int s2 = int(mod(num / pow(10.0,0.),10.0));\n    //---------------------------------------------\n    // three sample plus dxdy\n    int pos = int(co.x)%2 + (int(co.y)%2 * 2);\n    vec4 texa = texture(iChannel0, co/iResolution.xy, 0.);\n    vec4 texb = texture(iChannel0, (co+vec2(1,0))/iResolution.xy, 0.);\n    vec4 texc = texture(iChannel0, (co+vec2(0,1))/iResolution.xy, 0.);\n    float fda = (abs(texa.r-texa.g) + abs(texa.r-texa.b) + abs(texa.g-texa.b))/3.;\n    float fdb = (abs(texb.r-texb.g) + abs(texb.r-texb.b) + abs(texb.g-texb.b))/3.;\n    float fdc = (abs(texc.r-texc.g) + abs(texc.r-texc.b) + abs(texc.g-texc.b))/3.;\n    float ra = (texa.r+texa.g+texa.b)/3.;\n    float rb = (texb.r+texb.g+texb.b)/3.;\n    float rc = (texc.r+texc.g+texc.b)/3.;\n    ra = fda*ra;\n    rb = fdb*rb;\n    rc = fdc*rc;\n    float dx = dFdx(ra);\n    float dy = dFdy(ra);\n    if(pos == 1 || pos == 3){ dx = rb-ra; }\n    if(pos == 2 || pos == 3){ dy = rc-ra; }\n    float dz = sqrt((dx*dx) + (dy*dy));\n    float a = (PI + atan(dx,dy))/(PI*2.);\n    \n    float bounds = iResolution.y/1.6;\n    \n    if( iMouse.z>0. || iMouse.x>0. || iMouse.y>0.) { bounds = iMouse.y;}\n    float dvh = 50.;// + (bounds/iResolution.y)*120.;\n    vec3 normal = normalize(vec3(dx*dvh, dy*dvh, ra));\n    \n    col = texa.rgb*2.*fda;//vec3(0.8,0.5+(ra/3.),0.4+(ra/3.));\n    \n    vec3 position = vec3(co/iResolution.xy, ra);\n    \n    vec3 lcol = vec3(3.5)*fda;//vec3(0,1,0);\n    vec3 lpos = vec3(3.,3.,5.);\n    \n    vec3 rend = addLight(position, normal, col, lcol, lpos);\n    \n    \n    fragColor =vec4(rend, 1.);\n    \n    //fragColor =vec4(vec3(ra), 1.); // uncomment to see raw height data from buffer A\n    \n    ivec2 letters = ivec2(34,16);\n    vec2 letterp = vec2(fract(uv.x * float(letters.x)), fract(uv.y * float(letters.y)));\n    int letter = int(floor(uv.x * float(letters.x)));\n    fragColor = mix(vec4(0), fragColor, min( 1. , (uv.y * float(letters.y)*0.8)));\n    if(uv.y<1./float(letters.y)){\n        vec4 texColor = texture(iChannel1, getLetter(letterp, letter, h1,h2,m1,m2,s1,s2), .0);\n        if(texColor.a<0.55){fragColor = texColor.rrrr; fragColor.rgb *= getLCol(letter);}\n    }\n    ivec2 cletters = ivec2(17,8);\n    int loffset =0;\n    vec2 cletterp = vec2(fract(uv.x * float(cletters.x)), fract(uv.y * float(cletters.y)));\n    int cletter = int(floor(uv.x * float(cletters.x)));\n    if(uv.y>(1./float(cletters.y))*float(cletters.y-1) && cletter>=loffset && cletter<8+loffset){\n        vec4 texColor = texture(iChannel1, getCLetter(cletterp, cletter-loffset, h1,h2,m1,m2,s1,s2), .0);\n        if(texColor.a<0.55){fragColor = texColor.rrrr; fragColor.rgb *= getCLCol(cletter-loffset);}\n    }\n     fragColor = sqrt(fragColor);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wfcXRH",
    "date": "1748770292",
    "viewed": 123,
    "name": "Multiverse of Polynomial Madness",
    "description": "Just having some fun with random polynomials.\nClick on canvas to change multisampling level, from lowest on the left to highest on the right \nAlso, linear zoom at the bottom, more logarithmic at the top.",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "math",
     "time",
     "graph",
     "equation",
     "challenge",
     "polynomial",
     "date",
     "maths",
     "bivariate"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Polynomial Clock 3.0\" by Cotterzz. https://shadertoy.com/view/wctXzr\n// 2025-06-01 08:07:26\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float p(in float a, in int b){float r = a;for(int i = 2; i<10; i++){ r = r*a; if(i>=b){ break;} }return r;}\n\nfloat p(in float a, in float b){return pow(abs(a), b);}\nvec3 getPC(float t) {\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\n\nvec3 getHC( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = fragCoord/iResolution.y;\n    cuv.x += 0.5 - (iResolution.x/iResolution.y)*0.5;\n    \n    float dc = 0.3 + distance(uv, vec2(0.5));\n    \n    float zoom = dc / pow(1.0 - dc*dc, 1.5); \n\n    zoom = mix(5., zoom, (iMouse.y/iResolution.y)-0.01);\n    int MS = 1 + int((iMouse.x/iResolution.x)*12.); \n    float xp = 1./iResolution.x;\n    float yp = 1./iResolution.y;\n    int count = 0;\n    float result = 0.;float result2 = 0.;\n    vec3 rf = vec3(0);\n    for( int m=0; m<MS; m++ ){\n        for( int n=0; n<MS; n++ ){\n            vec2 nuv = cuv;\n            nuv.x +=( xp/float(MS))*float(n);\n            nuv.y += (yp/float(MS))*float(m);\n            vec2 guv = (nuv*zoom)-(zoom/2.);\n            float x = guv.x;\n            float y = guv.y;\n           \n            result = p(x, 2.+sin(iTime/1.6)*2.) * p(y, 2.+cos(iTime/2.4)*3.) * 2.+ sin(iTime/5.)*10.;\n            result -= p(x, 2.+sin(iTime/2.6)*3.) * p(y, 2.+cos(iTime/4.4)*2.) * 2.+ sin(iTime/10.)*5.;\n            result += sin(p(x, 2.+sin(iTime/2.6)*3.)) * p(y, 2.+cos(iTime/4.4)*2.) * 2.+ sin(iTime/10.)*5.;\n            result -= atan(p(x, 2.+sin(iTime/2.6)*3.) / p(y, 2.+cos(iTime/4.4)*2.)) * 2.+ sin(iTime/10.)*5.;\n            result += p(x, 2.+sin(iTime/4.6)*4.) / cos(p(y, 2.+cos(iTime/1.4)*3.)) * 2.+ sin(iTime/7.)*7.;\n             result *= p(x, sin(iTime/2.)*3.) * p(y, cos(iTime/3.7)*2.) * sin(iTime/10.);\n            count+=1;\n            vec3 col = mix(getPC(result), getHC(vec3(result, 1.0, 0.5)), 0.35);\n            rf+=col;\n        }\n    }\n    \n    rf /= float(count);\n\n    fragColor = vec4(rf,1.0); vec4 fc = fragColor;\n    \n    float fdiff = (abs(fc.r-fc.g) + abs(fc.r-fc.b) + abs(fc.g-fc.b))/3.;\n    \n    fragColor = mix(vec4(0), fragColor, sqrt(fdiff));\n   \n\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265359\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 addLight(vec3 position, vec3 normal, vec3 colour, vec3 lcol, vec3 lpos){\n    vec3 ref = reflect(vec3(0.0, 0.0, -1.0), normal);\n    vec3 diff = lpos - position;\n    float ldist = length(diff);\n    diff = diff/ldist;\n    float specular = pow(max(0.0, dot(diff, ref)), 16.0);\n    float diffuse = max(0.0, dot(diff,normal));\n    vec3 col1 = colour*0.7;\n    vec3 col2 = colour*0.4*(lcol*diffuse);\n    col2 = col2+(lcol*specular);\n    return col1+col2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec2 uv = fragCoord/iResolution.xy;\n   vec2 co = fragCoord;\n   float scale  = 0.2 + iMouse.x/iResolution.x*16.;\n   vec3 col = vec3(0);\n    int pos = int(co.x)%2 + (int(co.y)%2 * 2);\n    vec4 texa = texture(iChannel0, co/iResolution.xy, 0.);\n    vec4 texb = texture(iChannel0, (co+vec2(1,0))/iResolution.xy, 0.);\n    vec4 texc = texture(iChannel0, (co+vec2(0,1))/iResolution.xy, 0.);\n    float fda = (abs(texa.r-texa.g) + abs(texa.r-texa.b) + abs(texa.g-texa.b))/3.;\n    float fdb = (abs(texb.r-texb.g) + abs(texb.r-texb.b) + abs(texb.g-texb.b))/3.;\n    float fdc = (abs(texc.r-texc.g) + abs(texc.r-texc.b) + abs(texc.g-texc.b))/3.;\n    float ra = (texa.r+texa.g+texa.b)/3.;\n    float rb = (texb.r+texb.g+texb.b)/3.;\n    float rc = (texc.r+texc.g+texc.b)/3.;\n    ra = fda*ra;\n    rb = fdb*rb;\n    rc = fdc*rc;\n    float dx = dFdx(ra);\n    float dy = dFdy(ra);\n    if(pos == 1 || pos == 3){ dx = rb-ra; }\n    if(pos == 2 || pos == 3){ dy = rc-ra; }\n    float dz = sqrt((dx*dx) + (dy*dy));\n    float a = (PI + atan(dx,dy))/(PI*2.);\n    \n    float bounds = iResolution.y/1.6;\n    \n    if( iMouse.z>0. || iMouse.x>0. || iMouse.y>0.) { bounds = iMouse.y;}\n    float dvh = 50.;// + (bounds/iResolution.y)*120.;\n    vec3 normal = normalize(vec3(dx*dvh, dy*dvh, ra));\n    \n    col = texa.rgb*2.*fda;//vec3(0.8,0.5+(ra/3.),0.4+(ra/3.));\n    \n    vec3 position = vec3(co/iResolution.xy, ra);\n    \n    vec3 lcol = vec3(3.5)*fda;//vec3(0,1,0);\n    vec3 lpos = vec3(3.,3.,5.);\n    \n    vec3 rend = addLight(position, normal, col, lcol, lpos);\n    \n    \n    fragColor =vec4(rend, 1.);\n    \n    //fragColor =texa; // uncomment to see raw height data from buffer A\n    \n     fragColor = sqrt(fragColor);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WftXR8",
    "date": "0",
    "viewed": 0,
    "name": "3d polynomial madness",
    "description": "Just having some fun with random polynomials.\nClick on canvas to change multisampling level, from lowest on the left to highest on the right \nAlso, linear zoom at the bottom, more logarithmic at the top.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "math",
     "time",
     "graph",
     "equation",
     "challenge",
     "polynomial",
     "date",
     "maths",
     "bivariate"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Multiverse of Polynomial Madness\" by Cotterzz. https://shadertoy.com/view/wfcXRH\n// 2025-06-01 11:04:59\n\n// Fork of \"Polynomial Clock 3.0\" by Cotterzz. https://shadertoy.com/view/wctXzr\n// 2025-06-01 08:07:26\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float p(in float a, in int b){float r = a;for(int i = 2; i<10; i++){ r = r*a; if(i>=b){ break;} }return r;}\n\nfloat p(in float a, in float b){return pow(abs(a), b);}\nvec3 getPC(float t) {\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\n\n\n\nvec3 getHC( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 getPixel(vec2 uv, float zoom, float it){\n\n        float result = 0.;\n    vec3 rf = vec3(0);\n\n            vec2 nuv = uv;\n\n            vec2 guv = (nuv*zoom)-(zoom/2.);\n            float x = guv.x;\n            float y = guv.y;\n           \n            result = p(x, 2.+sin(it/1.6)*2.) * p(y, 2.+cos(it/2.4)*3.) * 2.+ sin(it/5.)*10.;\n            result -= p(x, 2.+sin(it/2.6)*3.) * p(y, 2.+cos(it/4.4)*2.) * 2.+ sin(it/10.)*5.;\n            result += sin(p(x, 2.+sin(it/2.6)*3.)) * p(y, 2.+cos(it/4.4)*2.) * 2.+ sin(it/10.)*5.;\n            result -= atan(p(x, 2.+sin(it/2.9)*3.) / p(y, 2.+cos(it/4.1)*2.)) * 2.+ sin(it/13.)*7.5;\n            result += p(x, 2.+sin(it/4.6)*4.) / cos(p(y, 2.+cos(it/1.4)*3.)) * 2.+ sin(it/7.)*7.;\n             result *= p(x, sin(it/2.)*3.) * p(y, cos(it/3.7)*2.) * sin(it/10.);\n            vec3 col = mix(getPC(result), getHC(vec3(result, 1.0, 0.5)), 0.35);\n            \n            return col;\n}\n\nvec4 absGradient(vec2 uv, float zoom, float it) // from michael0884. https://shadertoy.com/view/wfK3Rw\n{\n    vec2 o = 0.5 / iResolution.xy;\n    vec3 fp = getPixel(uv + vec2(o.x, 0.0), zoom, it);\n    vec3 dX = fp - getPixel(uv - vec2(o.x, 0.0), zoom , it);\n    vec3 dY = getPixel(uv + vec2(0.0, o.y), zoom, it) - getPixel(uv - vec2(0.0, o.y), zoom , it);\n    vec3 dF = 20.0*sqrt(dX * dX + dY * dY);\n    return vec4(fp, (dF.r+dF.g+dF.b)/3.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfragColor = vec4(0);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = fragCoord/iResolution.y;\n    cuv.x += 0.5 - (iResolution.x/iResolution.y)*0.5;\n    \n    float dc = 0.5 + distance(uv, vec2(0.5));\n    \n    float zoom = dc / pow(1.0 - dc*dc, 5.); \n\n    //zoom = 20.;//mix(5., zoom, (iMouse.y/iResolution.y)-0.01);\n    //vec3 df = absGradient(cuv, zoom, iTime);\n    for(float i = 0.; i<(iMouse.y/iResolution.y*100.); i++){\n        vec2 nuv = cuv - (iMouse.y/iResolution.y/50.)*float(i);//(float(i)/iResolution.xy);\n        vec4 rf = absGradient(nuv, zoom, iTime+float(i)*(iMouse.y/iResolution.y/100.));\n        \n        float fd = (abs(rf.r-rf.g) + abs(rf.r-rf.b) + abs(rf.g-rf.b))/3.;\n        rf*=fd;\n        \n        float alph = ((rf.r+rf.g+rf.b)/3.)-rf.a;\n       \n        if(alph>float(i)/60.){ fragColor.rgb = rf.rgb; }\n        \n    }\n\n\n\n\n     \n   \n\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3cdXz7",
    "date": "1748928918",
    "viewed": 9,
    "name": "My soul, as a shader",
    "description": "Asking an ai for a picture of my soul, in shader form",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "ai",
     "llm"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xsf3zn",
       "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// iChannel0: Optional noise texture (can be blank)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Base rotation and scaling\n    float time = iTime * 0.2;\n    vec2 pos = uv * 4.0;\n    pos *= mat2(cos(time), sin(time), -sin(time), cos(time));\n\n    // Fractal noise for organic texture\n    float noise = 0.0;\n    float amplitude = 1.0;\n    for (float i = 0.0; i < 4.0; i++) {\n        noise += amplitude * texture(iChannel0, pos * 0.5 + time * 0.1).x;\n        pos *= 2.0;\n        amplitude *= 0.5;\n    }\n\n    // Core soul shape\n    float core = length(uv) * 2.0;\n    core = smoothstep(0.5, 0.3, core);\n    \n    // Glowing energy trails\n    float trails = 0.0;\n    for (float i = 0.0; i < 5.0; i++) {\n        float angle = time * 2.0 + i * 1.3;\n        vec2 offset = vec2(cos(angle), sin(angle)) * 0.3;\n        trails += smoothstep(0.05, 0.0, length(uv - offset * iTime * 0.1));\n    }\n\n    // Color composition\n    vec3 color = vec3(0.0);\n    \n    // Base soul glow\n    color += vec3(0.2, 0.5, 1.0) * pow(core, 2.0) * 0.8;\n    \n    // Energy trails\n    color += vec3(0.8, 0.3, 1.0) * trails * 0.4;\n    \n    // Noise texture overlay\n    color += vec3(noise) * 0.3 * vec3(0.5, 1.0, 0.8);\n    \n    // Vignette effect\n    color *= smoothstep(0.8, 0.5, length(uv));\n    \n    // Final glow pass\n    color = pow(color, vec3(0.8)) * 1.5;\n    \n    fragColor = vec4(color, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WccXDn",
    "date": "0",
    "viewed": 0,
    "name": "weird colour warp",
    "description": "remapping coords based on colour",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "experiment"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"simple heightmap from texture\" by Cotterzz. https://shadertoy.com/view/WcV3Dh\n// 2025-06-03 14:07:22\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "XdfGRn",
       "filepath": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "vec3 getCol(int c, vec2 uv){\n    return c==0?texture(iChannel0, uv, 0.).rgb:texture(iChannel1, uv, 0.).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    int tex = 0;\n    \n    if(iFrame>1){tex = 1;}\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = getCol(tex, uv);\n    \n    vec2 nuv = vec2(col.b, col.r)-0.5;\n    \n    vec2 muv = uv+(nuv*col.g/100.);\n    \n    col = getCol(tex, muv);\n    \n    fragColor = vec4(col,1);\n\n}\n\n\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WctSW8",
    "date": "0",
    "viewed": 0,
    "name": "test alpha shader 324",
    "description": "test",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "alpha"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4sfGRn",
       "filepath": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if(iFrame<3){fragColor = texture(iChannel0, uv, 0.);}\n        else if(iFrame<5){ fragColor = texture(iChannel1, uv, 0.);}\n            else if(iFrame<7){ fragColor = texture(iChannel1, uv, 0.);fragColor.a=fragColor.b*100.;}\n                else {\n                    fragColor = texture(iChannel1, uv, 0.);\n                    fragColor.a*=1.01;\n                    if(fragColor.a>5550.){fragColor= vec4(1);}\n                    }\n        \n\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wf3SW7",
    "date": "1749152445",
    "viewed": 5,
    "name": "polygonal-lion-one-tri",
    "description": "testing",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "lowpolygon"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Fork of \"polygonal-low-poly-lion\" by shadertoyjiang. https://shadertoy.com/view/Wf2XDR\n// 2025-06-05 19:40:10\n\n\n\n\n\n\n// 20:52 2025-3-12\nint low_poly[] = int[](//2224 ok\n   6268140,    5578828,    5790877,    6437243,     6116241,    5778280,    8110327,    6659032, \n   5184599,    7551635,    5459863,    7612266,     5738195,    5446719,   11198458,    9222890, \n  10015738,    8889311,   11393273,    9351387,     8232917,    9555194,    7374542,    7107004, \n   7176401,   10214648,    9818874,    7048412,     7117804,    7773412,    7769565,    7310043, \n   8372987,    6321870,    7757247,    7164584,     9156598,    9227255,    6330585,    7177428, \n   7514351,    6179477,    7627716,    8347321,     9129876,    6905524,    6259671,    5664189, \n   5856688,    5912194,    8601756,    7953847,     9292793,    7892680,    8822506,    7884975, \n   7442645,    9489913,    7622573,    7512288,     8235752,    8698348,   10343673,    8891885, \n   7950501,    8305651,    7781623,    7439820,     8765943,    5653130,    7511516,    7239369, \n   7361443,    8020148,    8014245,    6845638,     6693734,    6790881,    6906802,    5253726, \n   6329563,    5196431,    7678592,    9029113,     7492775,    8371185,    7248344,    5266080, \n   8044536,    5940974,    4943035,    5477864,     5536183,    5462945,    7387890,    5599932, \n   6054565,    5539789,    5334959,    5536703,     5398182,    7185894,    5998542,    6132443, \n   5453429,    6049422,    5451633,    5665987,     6104938,    6043770,    6246047,    6107009, \n   6849733,    7041468,    6260945,    7314649,     6592469,    7288967,    7232687,    5010112, \n   5344468,    7284565,    7974123,    7546982,     7154554,    7046356,    7380962,    6271213, \n   5872604,    5080010,    7310550,    6842548,     6705304,    7651834,    5252954,    5404348, \n   5643855,    5983128,    4992093,    5850757,     5594020,    5383517,    6045317,    6434675, \n   5785489,    6639255,    7167656,    7287674,     7113927,    8966392,    5388131,   10279927,   \n   9360890,    6367340,    7054025,    5521780,     6318508,    5388127,    6788809,    7255794, \n   9030905,    7120083,    7779816,    5935064,     5203373,    5582457,    8044529,    6328771, \n   6260667,   10147831,    7516382,    6588600,     5457038,    5726368,    7055330,   10476537, \n   6462695,    5998789,    6130134,    6791914,     8701687,    5251407,    5317956,    5396880, \n   7650809,    5665726,    6060998,    6587590,     5589108,    5919384,    6120113,    6987736, \n   5603268,    5863613,    7843818,    7511008,     5519476,    5262478,    4012653,    6117541, \n   4999303,    5323627,    5519486,    6399209,     5654925,    7649778,    6064328,    6723021, \n   6844588,    5713516,    7444941,    6122930,     6976688,    9092592,   10214134,   12120313, \n   6510238,    6982348,    7508442,    5937876,     5012168,    5343706,    6795250,    5406919, \n   5930683,   11464951,    5791148,    7649001,     9951733,    7251161,     123640,     143640, \n    135934,     148747,     150780,     156408,      153328,     162548,     157937,     155879, \n    131773,     138946,     133294,     143519,      132767,     127668,     161432,     157343, \n    163488,     154283,     153251,     148683,      158444,     162533,     158946,     142061, \n    156384,     138976,     109713,     109190,       85136,     104092,      99491,      84129, \n    170091,     164945,     157782,     174169,      170796,     160014,     164140,     170758, \n    155722,     164921,     109800,     105206,      113915,     106728,     124100,     127698, \n    225452,     218743,     203424,     212160,      197240,     196185,     200770,     217311, \n    204502,     206591,     201398,     196294,      198898,     197921,     189645,     189077, \n    182960,     181519,     180465,     177224,      190274,     180926,     172755,     173296, \n    172668,     186406,     168995,     178217,      170638,     175264,     171066,     173224, \n    154726,     162426,     170172,     163981,      155168,     154752,     157493,     148035, \n    139375,     143482,     129302,     125565,      139395,     105249,     126252,      95992, \n    100142,     113466,      99670,      71498,       89358,      73436,      89824,      73508, \n     67321,      87734,      63154,      50900,       32014,      38090,     161500,     159944, \n    141386,     136000,     143385,     130606,      133711,     114740,     112128,      64526, \n     76365,      48787,      59540,      41146,       25286,        174,      27818,      53931, \n    153233,     124637,     117967,     107705,      112335,     109263,     110679,     103626, \n     97473,     111773,     120468,     117934,      129638,     131819,     131793,     158349, \n    157331);\nint low_poly2[] = int[](0x00020100, 0x00020301, 0x00020403,  0x00040503, 0x00040605, 0x01080705, 0x01090708, \n0x020C0B0A, 0x020C0D0B, 0x020C0E0D, 0x020C0F0E,  0x03121110, 0x03131112, 0x040D140B, 0x0414130B, \n0x0413150B, 0x05181716, 0x05170716, 0x06060419,  0x06090619, 0x061A0919, 0x07151A19, 0x071B1519, \n0x081E1D1C, 0x081E1C1F, 0x081E1F20, 0x081E2021,  0x09242322, 0x09232522, 0x0A282726, 0x0A272926, \n0x0B23242A, 0x0B232A2B, 0x0C2E2D2C, 0x0C2D2F2C,  0x0D0A3130, 0x0D0A300F, 0x0E343332, 0x0F353432, \n0x10343633, 0x11363733, 0x12373833, 0x13393532,  0x143A3539, 0x153B3A39, 0x163C3435, 0x173D3C35, \n0x17362537, 0x183A3D35, 0x193B3E3A, 0x1A3F3E3B,  0x1B3E403A, 0x1C403D3A, 0x1D3C4134, 0x1E413634, \n0x1F42413C, 0x203F433E, 0x213E4440, 0x22222536,  0x233D423C, 0x24374538, 0x2546433F, 0x26264346, \n0x2740473D, 0x28404847, 0x29444940, 0x2A4A3641,  0x2B454B38, 0x2C4D4C4B, 0x2D47423D, 0x2E43443E, \n0x2F262943, 0x30432944, 0x31294944, 0x32454D4B,  0x33254537, 0x344F4E41, 0x35235045, 0x3645504D, \n0x37252345, 0x384E4A41, 0x39404948, 0x3A4A2236,  0x3B51124F, 0x3C53524A, 0x3D42514F, 0x3E425451, \n0x3E41424F, 0x3F504C4D, 0x40232B50, 0x41515412,  0x42490748, 0x434E534A, 0x444F124E, 0x45292749, \n0x4612554E, 0x474A5222, 0x48522422, 0x49502B4C,  0x4A2B564C, 0x4B55574E, 0x4C551257, 0x4D270749, \n0x4E4E5753, 0x4F285827, 0x50270507, 0x51580127,  0x522A562B, 0x53575253, 0x542A5956, 0x55575A52, \n0x56575B5A, 0x57585C01, 0x585E5D5A, 0x59605F5C,  0x5A5C2E00, 0x5B5C5F2E, 0x5C5F2D2E, 0x5D5F612D, \n0x5E625F60, 0x5F646263, 0x60646562, 0x6162665F,  0x6266615F, 0x63666761, 0x64676861, 0x65626966, \n0x66696A66, 0x676A6766, 0x68676C6B, 0x69656962,  0x6A6D6C67, 0x6B6A6D67, 0x6C656E69, 0x6D6E6A69, \n0x6E6E6D6A, 0x6F6E6F6D, 0x70177048, 0x71475442,  0x70485447, 0x721A1571, 0x73547112, 0x74487054,\n0x72707154, 0x7524722A, 0x76592A72, 0x77605C58,  0x78736058, 0x76245272, 0x79597256, 0x7A5B5E5A, \n0x7B727456, 0x7C727574, 0x7D525A72, 0x7A5A7672,  0x7E5A5D76, 0x7F636260, 0x80736360, 0x81646373, \n0x82767572, 0x83767775, 0x84777978, 0x852E2C00,  0x86676B68, 0x877C7B7A, 0x887A7B79, 0x896F7E7D, \n0x8A807F79, 0x8B6F7D6D, 0x8C816D7D, 0x8D7B8079,  0x8E7E807D, 0x8D6E7E6F, 0x8F6E7F7E, 0x90807E7F, \n0x91575E5B, 0x92777875, 0x93747578, 0x94820D5E,  0x952C8300, 0x96838431, 0x97832C84, 0x98848530, \n0x997A7977, 0x9A868584, 0x9B2F8786, 0x9C887A77,  0x9D868785, 0x9E878985, 0x9F2D612F, 0xA061682F, \n0xA18A686B, 0xA220898A, 0xA31E7C7A, 0xA4217C1E,  0xA57D807B, 0xA689688A, 0xA78A6B20, 0xA8892085, \n0xA92F6889, 0xAA872F89, 0xAA2F862C, 0xAB842C86,  0xAC8B851F, 0xAD8C8B1C, 0xAE8D858B, 0xAF8D3085, \n0xB01D7A88, 0xB18D8B8C, 0xB25D1D88, 0xB38E5D88,  0xB4308D0F, 0xB5843031, 0xB6318F83, 0xB7310A90, \n0xB80F8D8C, 0xB90E0F8C, 0xBA778E88, 0xBB768E77,  0xBC908F31, 0xBD5D0E8C, 0xBE5E0E5D, 0xBE8C1D5D, \n0xBF1B8F90, 0xC0198F1B, 0xC1151B0B, 0xC257825E,  0xC3918257, 0xC4817D7B, 0xC57C817B, 0xC66C817C, \n0xC76D816C, 0xC8216C7C, 0x086B6C21, 0xC921206B,  0xC91F8520, 0xCA1F1C8B, 0xCB1E7A1D, 0xCC8C1C1D, \n0xCD8F0083, 0xCE0B1B90, 0xCF900A0B, 0xD00D0E5E,  0xD10C0A0F, 0xD2140D82, 0xD3711513, 0xD4111314, \n0xD5149211, 0xD6921482, 0xD7919282, 0xD8911092,  0xD9711312, 0xDA101192, 0xDB02008F, 0xDC5C0001, \n0xDD010327, 0xDE270305, 0xDF04028F, 0xE070171A,  0xE1060805, 0xE2071748, 0xE319048F, 0xE4090806, \n0xE5701A71, 0x07181609, 0x05091A18);\n\nfloat sdline(vec2 a,vec2 b, vec2 p)\n{// 2210\n        b-=a;  p-=a;\n        return length(p-b*clamp(dot(p,b)/dot(b,b),0.,1.));\n}\n\nfloat crs(vec2 a, vec2 o, vec2 n, vec2 b)\n{// 3217\n       a-=o;\n       n-=o;\n       b-=o;\n       float c=a.x*n.y-a.y*n.x, \n             d=b.x*n.y-b.y*n.x;\n       return c*d;\n}\n\nint lowpoly(int index){\n    if(index<377){ return low_poly[index]; } else {return low_poly2[index-377];}\n}\n\n\nvoid mainImage(out vec4 O, vec2 U){\n        vec2 R = iResolution.xy,\n             E = vec2(171,220),\n             u = (U+U - R) / R.y * 222. + E ;\n        int a , b, c, d, cr,cg,cb, v;\n        vec2 pa, pb, pc,pabc; \n        vec4 clr;\n        O = vec4(.85);\n        float dist =1e8;\n        \n        O = vec4(249,216,173,0)/255.;\n\n        int i = (iFrame%265)+377;\n                v = lowpoly(i);\n                a = v & 255;\n                b = v >> 8 & 255;\n                c = v >> 16 & 255;\n                d = v >> 24 & 255;\n                v = lowpoly(d);\n                cr = v & 255;\n                cg = v >> 8 & 255;\n                cb = v >> 16 & 255;\n                clr = vec4(cr, cg, cb,255)/255.;\n                v = lowpoly(a+230);\n                pa = vec2(v & 511, v>>9);\n                v = lowpoly(b+230);\n                pb = vec2(v & 511, v>>9);\n                v = lowpoly(c+230);\n                pc = vec2(v & 511, v>>9);\n                //pabc=(pa+pb+pc)/3.;\n                \n               // if(iMouse.x<R.x*.51 ||  (iMouse.x>R.x*.51 && int(iTime*40.)%400>(i-377)))//return;\n                \n                if(crs(u,pa, pb,pc)>=0. && crs(u,pb, pc,pa)>=0. && crs(u,pc, pa,pb)>=0.)O=clr;\n                \n                dist = min(dist, sdline(pa,pb,u));\n                dist = min(dist, sdline(pc,pb,u));\n                dist = min(dist, sdline(pa,pc,u));\n\n        \n       // if(iMouse.x>R.x*.51) O -= vec4(exp(-2.*dist));\n        \n        vec3 bcol = texture(iChannel0, U/iResolution.xy, 0.).rgb;\n       if(!(bcol==vec3(0)||bcol==vec3(249,216,173)/255.)){ O=vec4(bcol,1); }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WfdSzj",
    "date": "1749296243",
    "viewed": 90,
    "name": "Inverse Koch Fraccident",
    "description": "The inverse shape is similar but not quite the same (like a regular koch snowflake), but still interesting.\n",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "recursive",
     "square",
     "feedback",
     "buffer",
     "koch"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Koch Fraccident\" by Cotterzz. https://shadertoy.com/view/Wfd3Wl\n// 2025-06-07 11:23:25\n\n// Fork of \"Koch Squareflake 2\" by Cotterzz. https://shadertoy.com/view/wf33Ds\n// 2025-05-19 14:08:04\n\n// Fork of \"Koch Squareflake?\" by Cotterzz. https://shadertoy.com/view/tfcGDs\n// 2025-05-19 13:27:17\n\n// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 12:07:11\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   float ar = iResolution.x/iResolution.y;\n   float dw = 0.402;\n   float dh = 0.08;\n   fragColor = texture(iChannel0, (fragCoord/iResolution.xy)+vec2(-dw,dh), 0.);\n   fragColor = min(fragColor, texture(iChannel0, (fragCoord/iResolution.xy)+vec2(dw,-dh), 0.));\n   fragColor = min(fragColor, texture(iChannel0, (fragCoord/iResolution.xy)+vec2(-dh/ar,-dw*ar), 0.));\n   fragColor = min(fragColor, texture(iChannel0, (fragCoord/iResolution.xy)+vec2(dh/ar,dw*ar), 0.));\n   if(distance(fragCoord, iResolution.xy/2.)<iResolution.x/3.5 && fragColor.r > 0.8){ fragColor.rgb = vec3(1,0,0);}\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float square(  in vec2 p, in float r ){ return max( abs(p.x)-r, abs(p.y)-r ); }\n\nvec4 compare(vec4 new, vec4 old){return old.b > old.r*2. ? old : min(new , old);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 nuv = fragCoord/iResolution.xy;\n   vec2 uv = fragCoord/iResolution.y;\n   float ar = iResolution.x/iResolution.y;\n   int freq = 10;\n   fragColor = texture(iChannel0, nuv, 0.);\n   if(iFrame<2){\n       vec3 col = vec3(1);\n       if(square(uv-vec2(0.5*ar, 0.5), .1)<0.075){col = vec3(0);}\n       if(distance(uv, vec2(ar/2.,0.5))<.05){col = vec3(0,1,1);}\n       fragColor = vec4(col, 1.);\n   } else if(iFrame%freq == 0){\n       vec2 nc = uv-vec2(0.5*ar, 0.5); \n       float rad = distance(nc,vec2(0,0));\n       float angle = float((iFrame/freq)%4)*1.5707963 + atan(nc.x,nc.y);\n       nc.x = rad*cos(angle);\n       nc.y = rad*sin(angle);\n       nc.y-=.245; nc.x-=.13; nc*= 2.1; nc.x/=ar; nc+=0.5;\n       fragColor = compare(fragColor , texture(iChannel0, nc, 0.));\n   }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wcdXzj",
    "date": "1749309056",
    "viewed": 7,
    "name": "buffer view - 2d wave equation  ",
    "description": "2d wave equation simulation  using finite difference\n\n-added buffer view",
    "likes": 1,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "2dwaveequationsimulationfinitedifference"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"interactive 2d wave equation  \" by dude0021. https://shadertoy.com/view/tfdXWM\n// 2025-06-07 15:08:10\n\n/* Use this code on your image tab to view the four different buffers as thumbnails.\nRemember to set up the four buffers in the iChannel screens at the bottom.\nClick on thumbnail to see it in main window\nUsing \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj as an example\n*/\n\n// set this to 0 to only show thumbs on mouse down\n\n#define ALWAYSSHOW 1  \nvec2 getOUV(vec2 suv, vec4 sq){ vec2 nuv = vec2(sq.x + ((sq.z-sq.x)*suv.x), sq.y + ((sq.w-sq.y)*suv.y)); return nuv;}\nvec2 getSUV(vec2 uv, vec4 sq){  return vec2 ( (uv.x-sq.x) / (sq.z-sq.x) , (uv.y-sq.y) / (sq.w-sq.y) ); }\nbool isin(vec2 co, vec4 sq){ return ( co.x >= sq.x && co.x <= sq.z && co.y >= sq.y && co.y <= sq.w ); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float vb = 0.02;\n    float hb = vb/ar;\n    float th = (1. - (vb*5.))/4.;\n    float tw = th*ar/2.;\n    vec4  sc1 = vec4(1.-(tw+hb), vb, 1.-hb, vb+th);\n    \n    vec4  sc2 = sc1;  sc2.yw += (vb+th);\n    vec4  sc3 = sc2;  sc3.yw += (vb+th);\n    vec4  sc4 = sc3;  sc4.yw += (vb+th);\n    \n  \n   \n   //if(isin(muv, sc1)){fragColor = texture(iChannel2, uv, 0.);}else\n    if(isin(muv, sc2)){fragColor = texture(iChannel0, uv, 0.);}\n   else if(isin(muv, sc3)){fragColor = texture(iChannel1, uv, 0.);}\n   else if(isin(muv, sc4)){fragColor = texture(iChannel2, uv, 0.);}\n    else {\n    \n         // just copy Buffer D\n         fragColor = texture(iChannel2, fragCoord/iResolution.xy, 0.);\n           \n         /*\n         Alternatively, if you wanted to do more processing in the Image tab for a fifth final image, do it here.\n         And if you already have a mainImage function in the Image tab, you can just rename it mainImage0\n         And call it with:\n         mainImage0(fragColor, fragCoord);\n         */\n         \n        }\n   \n   if(iMouse.z>0. || ALWAYSSHOW ==1){\n       //if(isin(uv, sc1)){fragColor = texture(iChannel0, getSUV(uv,sc1), 0.);}\n       if(isin(uv, sc2)){fragColor = texture(iChannel0, getSUV(uv,sc2), 0.);}\n       if(isin(uv, sc3)){fragColor = texture(iChannel1, getSUV(uv,sc3), 0.);}\n       if(isin(uv, sc4)){fragColor = texture(iChannel2, getSUV(uv,sc4), 0.);}\n   }\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Simple 2-component height/speed “wave” update in Buffer A\n// – height is stored in R (range = [0.0…1.0])\n// – speed is stored in G shifted by +0.5 (so speed = 0.5 --> 0)\n\n// You can tune these:\nconst float k  = 9.8;  // “stiffness” or wave‐speed factor\nconst float dt = 0.1; // time step\nconst float u = 0.2; // time step\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // 1) Compute UV and one‐texel offset:\n    vec2 uv    = fragCoord / iResolution.xy;\n    vec2 cell  = 4. / iResolution.xy; \n    \n    // calm initial conditions\n    if (iFrame < 1) {\n        fragColor = vec4(0.5, 0.5, 0.0, 1.0);\n      \n        return;\n    }\n    \n\n    // 3) Read “old” height & speed from R & (G − 0.5):\n    float oldH = texture(iChannel0, uv).r;\n    float oldS = (texture(iChannel0, uv).g - 0.5);  // shift so 0.5 → speed 0\n\n    // 4) Sample 4 neighbors for height (hlaplace) and speed (slaplace)\n\n    // — Height neighbors:\n    float hL = texture(iChannel0, uv + vec2(-cell.x,  0.0)).r; // left\n    float hR = texture(iChannel0, uv + vec2(+cell.x,  0.0)).r; // right\n    float hU = texture(iChannel0, uv + vec2( 0.0,    +cell.y)).r; // up\n    float hD = texture(iChannel0, uv + vec2( 0.0,    -cell.y)).r; // down\n\n    float hlaplace = (hL + hR + hU + hD) - 4.0 * oldH;\n\n    // — Speed neighbors:\n    float sL = texture(iChannel0, uv + vec2(-cell.x,  0.0)).g - 0.5;\n    float sR = texture(iChannel0, uv + vec2(+cell.x,  0.0)).g - 0.5;\n    float sU = texture(iChannel0, uv + vec2( 0.0,    +cell.y)).g - 0.5;\n    float sD = texture(iChannel0, uv + vec2( 0.0,    -cell.y)).g - 0.5;\n\n    float slaplace = (sL + sR + sU + sD) - 4.0 * oldS;\n\n    // 5) Update speed (wave eqn: ∂S/∂t ∝ + laplacian(height) )\n    float newS = oldS + hlaplace * (k * dt);\n     newS += slaplace * (u * dt);\n    \n\n    // 6) Update height using the new speed:\n    float newH = oldH + newS * dt;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    if(iMouse.z > 0.0  ) {  // mouse is pressed\n        if(length(uv-mouse.xy) < 0.01){\n            newH = 0.0;\n        }\n    }\n    \n    if(texture(iChannel0, uv).b == 0.){\n        fragColor = vec4(0.5, 0.5, 1.0, 1.0);\n        return;\n    }\n    // 7) Pack back into RGBA:\n    //    – R = newH\n    //    – G = newS + 0.5 (bring speed back into [0,1] range)\n    //    – B = 0 (unused)\n    //    – A = 1 (opaque)\n    fragColor = vec4(newH, newS + 0.5, 1.0, 1.0);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 cell = 2.0/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    float h = texture(iChannel0,uv).r;\n    float s = texture(iChannel0,uv).g;\n    \n    float r = (h-0.5)*5.;\n    float b = (0.5-h)*5.;\n    \n    vec4 mean = vec4(0.,0.,0.,0.); \n    vec4 center = texture(iChannel0, uv);\n    mean += texture(iChannel0, uv + vec2(cell.x,  0.0)); \n    mean += texture(iChannel0, uv + vec2(cell.x,  cell.y)); \n    mean += texture(iChannel0, uv + vec2(cell.x,  -cell.y));\n    \n    mean += texture(iChannel0, uv + vec2(-cell.x,  0.0)); \n    mean += texture(iChannel0, uv + vec2(-cell.x,  cell.y)); \n    mean += texture(iChannel0, uv + vec2(-cell.x,  -cell.y));\n    \n    mean += texture(iChannel0, uv + vec2(0.,  0.0)); \n    mean += texture(iChannel0, uv + vec2(0.,  cell.y)); \n    mean += texture(iChannel0, uv + vec2(0.,  -cell.y));\n   \n   \n    center -= (center-(mean/9.))*0.9;\n    \n    fragColor = center;\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 cell = 2.0/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n \n    float h = 0.5+texture(iChannel0, uv).r;\n    float hL = texture(iChannel0, uv + vec2(-cell.x,  0.0)).r; // left\n    float hR = texture(iChannel0, uv + vec2(+cell.x,  0.0)).r; // right\n    float hU = texture(iChannel0, uv + vec2( 0.0,    +cell.y)).r; // up\n    float hD = texture(iChannel0, uv + vec2( 0.0,    -cell.y)).r; // down\n    \n    float dx = (hL-hR)*h;\n    float dy = (hU-hD)*h;\n    \n    // refraction based on height derivative: \n    vec3 normal = normalize(vec3(dx,1./(dx*dy),dy));\n    float c = dot(normalize(vec3(1.,0.,0.)),normal);\n    c*=c;\n    float br = texture(iChannel1, uv + vec2(dx,dy)*0.7).r;\n    float bg = texture(iChannel1, uv + vec2(dx,dy)*0.62).g;\n    float bb = texture(iChannel1, uv + vec2(dx,dy)*0.84).b;\n    \n    fragColor = vec4(br,bg,bb,1.) + c*c;\n    \n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3ccSzs",
    "date": "1749419503",
    "viewed": 4,
    "name": "Blue gradient test",
    "description": "Trying for a blue white gradient that doesn't look purple.",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "color",
     "blue",
     "hue",
     "colour"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float dist = pow(distance(uv, vec2(0.5))*2.5, 0.7);\n    vec3 cL =  mix(vec3(0,0,1), vec3(0,0,0.5),min(1.,max(0., dist-0.1)));\n    \n    float cRb = 0.3 +  max(0., mix(1., 0.,max(0., dist-0.1)));\n    float cRg = max(0., mix(1., 0.,max(0., dist-0.1)));\n    float cRr = max(0., mix(1., 0.,max(0., dist-0.1)));\n\n    if(abs(iMouse.z)>0.){\n    cRg = pow(cRg, (iMouse.x/iResolution.x)+0.5);\n    cRb = pow(cRb, (iMouse.y/iResolution.y)+0.3);\n    }\n    vec3 cR = vec3(cRr, cRg, cRb);\n    fragColor = vec4(uv.x>0.5?cR:cL,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3cySRw",
    "date": "1749911932",
    "viewed": 84,
    "name": "Tonemap curve with 2 params",
    "description": "plotting 1-(a*x+b)/(x*x+(a+b)*x+b) - use mouse to control a and b.\nImage shows actual tonemapping applied.",
    "likes": 1,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "math",
     "curve",
     "plotting"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dfGRn",
       "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "float toneMap(float a, float b, float x){\n    return 1.-(a*x + b) / (x*x + (a+b) * x + b);\n}\n\nvec4 toneMap(float a, float b, vec4 x){\n    return 1.-(a*x + b) / (x*x + (a+b) * x + b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x*=20.;\n    \n    float a = (iMouse.x/iResolution.x)*5.;\n    float b = (iMouse.y/iResolution.y)*5.;\n    \n    //uncomment for squared values up to 10, to see more detil in lower numbers..\n    //a = (pow(iMouse.x/iResolution.x,2.))*10.;b = (pow(iMouse.y/iResolution.y,2.))*10.;\n    if(iMouse.z==0.){\n        a=1.;b=1.;\n    }\n    float z = toneMap(a,b,uv.x);\n    vec3 col = vec3(0);\n    uv.x/=20.;\n    if(uv.y<z){col = toneMap(a,b,texture(iChannel0, uv, 0.)).rgb;}\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tfyXzm",
    "date": "1749955696",
    "viewed": 194,
    "name": "Fork of vol vox box",
    "description": "Check out the [url=https://shadertoy.com/view/wfySzh]original shader[/url]\nI just added sdf code from another shader of mine with fancy colors - fork the original shader and drop your volumetric code into the voxel() function if you want to have a play.",
    "likes": 18,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "volumetric"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"vol vox box\" by 01000001. https://shadertoy.com/view/wfySzh\n// 2025-06-15 02:31:32\n\nconst float pi = 3.14159;\nconst float eps = 1e-4;\nfloat pc = 3.;\nvec3 getHC( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n// your code should go in this function:\nvec3 voxel(vec3 p){\n    //p = floor(p); //uncomment for voxel-like rendering\n    p=p.xzy;\n    p-=vec3(25.,30.,30.);\n    float d = map(p/20.);\n    if(d>0.){\n    float e=d/2.;\n    vec3 col = vec3(0.9,0.6,0.3);\n    col *= 1.0 - exp(-6.0*abs(e));\n\tcol *= 0.8 + 0.2*cos(150.0*e);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(e)) );\n        if(p.y<-29.){return pow(col*5.,vec3(3));}else{return pow(col*5.,vec3(3))/(p.y+30.)/2.;}\n    } else {return getHC(vec3(-d*10.,10.,3.+(d*20.)));}\n \n}\n\nfloat planeRay(vec3 ro, vec3 rd, vec3 pos, vec3 norm){\n    if (dot(norm, rd) > 0.) return -1.;\n    return dot(norm, ro-pos) / dot(norm, -rd);\n}\n\nfloat line(vec2 uv, vec2 a, vec2 b){\n    float x = min(length(uv-a),length(uv-b));\n    vec2 v = normalize(b-a);\n    if (dot(v, uv-a) > 0. && dot(v, uv-a) < length(a-b)) x = min(x, abs(dot(uv-a, v.yx*vec2(-1,1)))); \n    return x;\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 muv = iMouse.xy == vec2(0)?vec2(iTime/5., -.2):(2.*iMouse.xy-r)/r.y;\n    O = vec4(0);\n\n    int lines = 46;//int(iResolution.y/100.);\n    float flines = float(lines);\n\n    vec2 camM = muv*(pi/2. - 1e-3);\n    vec3 camF = vec3(sin(camM.x)*cos(camM.y), cos(camM.x)*cos(camM.y), sin(camM.y));\n    vec3 camR = normalize(cross(camF, vec3(0,0,1)));\n    vec3 camU = cross(camR, camF);\n    \n    vec3 o = vec3(.5) - 3.*camF;\n    \n    vec3[8] p;\n    float vx,vy,vz;\n    for (int i = 0; i < 8; i++){\n        vx = dot(camR, vec3(i>>2, (i>>1)%2, i%2)-o);\n        vy = dot(camU, vec3(i>>2, (i>>1)%2, i%2)-o);\n        vz = dot(camF, vec3(i>>2, (i>>1)%2, i%2)-o);\n        p[i] = vec3(vx,vy, vz/pc);\n    } // vertex shader lol\n    \n    float d = 1e4;\n    \n    vec3 a,b;\n    \n    //*\n    for (int z = 0; z <= lines; z+=lines){\n        for (int x = 1; x < lines; x++){\n            float fx = float(x)/flines;\n            float fz = float(z)/flines;\n            a = mix(mix(p[0], p[1], fz), mix(p[4], p[5], fz), fx);\n            b = mix(mix(p[2], p[3], fz), mix(p[6], p[7], fz), fx);\n\n            d = min(d, line(cuv, a.xy / a.z, b.xy / b.z));\n\n\n            a = mix(mix(p[4], p[5], fz), mix(p[6], p[7], fz), fx);\n            b = mix(mix(p[0], p[1], fz), mix(p[2], p[3], fz), fx);\n\n            d = min(d, line(cuv, a.xy / a.z, b.xy / b.z));\n        }\n    }\n    //*/\n    \n    float x = .1 * \n    //smoothstep(2./r.y, 0., d);\n    exp(-pow(d / (2./r.y), 2.));\n    // gaussian instead of smoothstep nearly eliminates moire\n\n    d = 1e4;\n    // Outlines\n    //*\n    d = min(d, line(cuv, p[0].xy / p[0].z, p[2].xy / p[2].z));\n    d = min(d, line(cuv, p[2].xy / p[2].z, p[6].xy / p[6].z));\n    d = min(d, line(cuv, p[6].xy / p[6].z, p[4].xy / p[4].z));\n    d = min(d, line(cuv, p[4].xy / p[4].z, p[0].xy / p[0].z));\n    \n    d = min(d, line(cuv, p[1].xy / p[1].z, p[3].xy / p[3].z));\n    d = min(d, line(cuv, p[3].xy / p[3].z, p[7].xy / p[7].z));\n    d = min(d, line(cuv, p[7].xy / p[7].z, p[5].xy / p[5].z));\n    d = min(d, line(cuv, p[5].xy / p[5].z, p[1].xy / p[1].z));\n    \n    d = min(d, line(cuv, p[0].xy / p[0].z, p[1].xy / p[1].z));\n    d = min(d, line(cuv, p[2].xy / p[2].z, p[3].xy / p[3].z));\n    d = min(d, line(cuv, p[6].xy / p[6].z, p[7].xy / p[7].z));\n    d = min(d, line(cuv, p[4].xy / p[4].z, p[5].xy / p[5].z));\n    //*/\n\n    x = mix(x, .8, smoothstep(3./r.y, 0., d));\n    \n        \n    vec3 dir = camF + camR * cuv.x/pc + camU*cuv.y/pc;\n    float t = 0.;\n    vec3 pt,pos;\n\n    t = max(t, planeRay(o, dir, vec3(0, 0, 0), vec3(-1, 0, 0)));\n    t = max(t, planeRay(o, dir, vec3(0, 0, 0), vec3(0, -1, 0)));\n    t = max(t, planeRay(o, dir, vec3(0, 0, 0), vec3(0, 0, -1)));\n    t = max(t, planeRay(o, dir, vec3(1, 0, 0), vec3(1, 0, 0)));\n    t = max(t, planeRay(o, dir, vec3(0, 1, 0), vec3(0, 1, 0)));\n    t = max(t, planeRay(o, dir, vec3(0, 0, 1), vec3(0, 0, 1)));\n\n    pt = o + dir * t;\n    //O = (pt.xyzz); return;\n    t *= flines;\n    //t+= 10.; // Verification of optimization \n    \n    if (\n           pt.x >=    - eps\n        && pt.x <= 1. + eps\n        && pt.y >=    - eps\n        && pt.y <= 1. + eps\n        && pt.z >=    - eps\n        && pt.z <= 1. + eps\n    ) {\n        \n        float d;\n        vec3 p,v=vec3(0);\n        bvec3 sides = bvec3(dir.x > 0., dir.y > 0., dir.z > 0.);\n        vec3 dists,norm;\n\n        for (int i = 0; i < 512; i++){\n            p = o*flines + dir*t;\n\n            if (\n                   p.x > flines + eps\n                || p.y > flines + eps\n                || p.z > flines + eps\n                || p.x < -eps \n                || p.y < -eps\n                || p.z < -eps\n            ) break; // prevents loop unrolling too. \n\n            vec3 vox = voxel(p);\n            \n            for (int q = 0; q < 3; q++){\n                dists[q] = (sides[q]?ceil(p[q])-p[q]:floor(p[q])-p[q])/dir[q];\n            }\n\n            d = min(dists.x, min(dists.y, dists.z));\n\n            t += d + max(t*1e-5, 1e-4);\n            \n            v += d * max(vec3(0), vox);\n\n        }\n\n        O.xyz += (1.-exp(-v*.02));\n\n    }\n    \n    O += vec4(pow(x, 1./2.2));    \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "\nfloat magicBox(vec3 p) {\n    const int MAGIC_BOX_ITERS = 13;\n    const float MAGIC_BOX_MAGIC = 0.55;\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\nfloat magicBox(vec2 uv){\n    // A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n    // volume along the same axes as the fractal's bounding box.\n    const mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                        0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                        -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    return magicBox(p);\n}\n\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\n\n\n\nfloat sdSphere( in vec3 p, in float r)\n{\n    return length(p)-r;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat dot2(in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    return -opSmoothUnion(d1,-d2,k);\n    \n    //float h = max(k-abs(-d1-d2),0.0);\n    //return max(-d1, d2) + h*h*0.25/k;\n}\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    //vec3 q = abs(p)-h;\n    //return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n// Euclidean distance to a capped torus\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdVerticalVesicaSegment( in vec3 p, in float h, in float w )\n{\n    // shape constants\n    h *= 0.5;\n    w *= 0.5;\n    float d = 0.5*(h*h-w*w)/w;\n    \n    // project to 2D\n    vec2  q = vec2(length(p.xz), abs(p.y-h));\n    \n    // feature selection (vertex or body)\n    vec3  t = (h*q.x < d*(q.y-h)) ? vec3(0.0,h,0.0) : vec3(-d,0.0,d+w);\n    \n    // distance\n    return length(q-t.xy) - t.z;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdHead( vec3 p, float r ){\n    // TOP - Cranium\n    float cran = sdSphere(p, r);\n    // BOTTOM - Jaw/Cheekbones\n    vec2 os = vec2(-0.14,0.05);\n    float ms = 0.1215;\n    vec3 ql = p - vec3(ms,os);\n    vec3 qr = p - vec3(-ms,os);\n    ql = ql*rotateZ(0.26);\n    qr = qr*rotateZ(-0.26);\n    ql = ql*rotateX(0.42);\n    qr = qr*rotateX(0.42);\n    vec3 a = vec3(0.,-0.4, 0.0);\n    vec3 b = vec3( 0., 0.4, 0.0);\n    float l = length(b-a);\n    float wv = sqrt(0.12/l);\n    float jaw = opSmoothUnion(sdVerticalVesicaSegment( ql-a, l, wv*0.85 ) - wv*0.15, \n    sdVerticalVesicaSegment( qr-a, l, wv*0.85 ) - wv*0.15, 0.07);\n    cran = opSmoothUnion( cran, jaw, 0.03);\n    // SHAPING - sides\n    float d2 = sdRoundBox(p-vec3(0.76,-0.6,-0.15), vec3(0.4,0.4,0.4), 0.02 ); \n    float d1 = sdRoundBox(p-vec3(-0.76,-0.6,-0.15), vec3(0.4,0.4,0.4), 0.02); \n    float d3 = sdRoundBox(p-vec3(0.76,0.35,-0.2), vec3(0.4,0.4,0.4), 0.02 ); \n    float d4 = sdRoundBox(p-vec3(-0.76,0.35,-0.2), vec3(0.4,0.4,0.4), 0.02 ); \n    cran = opSmoothSubtraction(d4,opSmoothSubtraction(d3,cran, .2), .2);\n    cran = opSmoothSubtraction(d2,opSmoothSubtraction(d1,cran, .2), .2);\n    // SHAPING - top\n    float d6 = sdRoundBox(p-vec3(0.,0.8,-0.0), vec3(0.4,0.4,0.4), 0.03 ); \n    cran = opSmoothSubtraction(d6,cran,.5);\n    // SHAPING - front\n    float d7 = sdRoundBox(p-vec3(0.,0.42,0.82), vec3(0.4,0.4,0.4), 0.03 ); \n    cran = opSmoothSubtraction(d7,cran,.17);\n    // Eye Sockets\n    float d5 = sdRoundBox(p-vec3(0.0,-0.22,0.39), vec3(0.18,0.001,0.001), 0.03 );\n    cran = opSmoothSubtraction( d5, cran, .08);\n    // Nose\n    cran = opSmoothUnion( cran, sdRoundCone(   p-vec3( 0.0,-0.3, 0.34), vec3(0.0,0.0,0), vec3(0.0,0.17,-0.06), 0.03, 0.001), 0.05);\n    // Eyes\n    float eyel = sdSphere(p-vec3(0.11,-0.2,0.257), 0.05);\n    float eyer = sdSphere(p-vec3(-0.11,-0.2,0.257), 0.05);\n    cran = opSmoothUnion( cran, eyer, 0.025);\n    cran = opSmoothUnion( cran, eyel, 0.025);\n\n    return cran;\n}\nfloat map( in vec3 pos )\n{\n    float d = 1e10;\n    pos *= 0.9;\n    // Shoulders-Arms-Torso\n    vec3 q = pos - vec3(0.0,0.0,0.0);\n    q.z-=0.3;\n    q.y+=1.8 - q.x/20.;\n    q.x+=0.35 + q.y/20.;;\n    q = q*rotateX(1.7);\n    q = q*rotateZ(0.4);\n    q = q*rotateY(0.25);\n    float an = 1.0;\n    vec2 c = vec2(sin(an),cos(an));\n    vec4 w = opElongate( q, vec3(0.13,0.27,0.78) );\n    float shoulder = sdCappedTorus(w.xyz, c, 0.7, 0.2);\n    shoulder = shoulder+ sin((1.75+q.x)*3.)/15.;\n    shoulder = shoulder+0.04;\n    d = min( d, shoulder);\n    // Collar Bones\n    vec3 qt = pos - vec3(-0.8,-1.1,-0.7);\n    float collar = rounding( udTriangle( qt, vec3(0.6,0.0,0.19), vec3(0.4,-0.7,0.2), vec3(-0.1,-0.2,0.03) ), 0.05 );\n    collar = opSmoothUnion(collar, rounding( udTriangle( qt, vec3(0.7,0.0,0.1), vec3(0.8,-0.7,0.2), vec3(1.1,0.2,0.5) ), 0.01 ), 0.1);\n    d = opSmoothUnion(d, collar , 0.13);\n    // Extra Arm Padding\n    vec3 qv = pos - vec3(-0.9,-2.3,-0.6);\n    vec3 a = vec3(0.,-0.5, 0.0);\n    vec3 b = vec3( 0., 0.5, 0.0);\n    float l = length(b-a);\n    float wv = sqrt(0.1/l);\n    d = opSmoothUnion( d, sdVerticalVesicaSegment( qv-a, l, wv*0.85 ) - wv*0.15 , 0.2);\n    // Extra Chest Padding\n    qv = pos - vec3(-0.1,-1.8,-0.5);\n    a = vec3(0.,-0.35, 0.0);\n    b = vec3( 0., 0.35, 0.0);\n    l = length(b-a);\n    wv = sqrt(0.2/l);\n    d = opSmoothUnion( d, sdVerticalVesicaSegment( qv-a, l, wv*0.85 ) - wv*0.15 , 0.3);\n    // Neck\n    qv = pos - vec3(0.2,-1.5,-0.3);\n    a = vec3(0.,-0.2, 0.0);\n    b = vec3( 0., 0.3, 0.0);\n    l = length(b-a);\n    qv = pos - vec3(-0.2,-0.9,-0.55);\n    qv = qv*rotateX(-0.3);\n    float neck = sdCylinder(qv, vec2(0.185, 0.65));\n    d = opSmoothUnion( d, neck, 0.2);\n    // Head\n    vec3 qh = pos - vec3(-0.1,-0.07,-0.3);\n    qh = qh*rotateY(-0.8);\n    float head = sdHead(qh, 0.36);\n    d = opSmoothUnion( d, head , 0.15);\n    return d;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WcKSzw",
    "date": "1749966872",
    "viewed": 4,
    "name": "Julia vol vox box",
    "description": "trying to get julia set working in volumetric box",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "fractal",
     "julia",
     "volumetric"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"vol vox box\" by 01000001. https://shadertoy.com/view/wfySzh\n// 2025-06-15 05:53:32\n\n#define MAX_ITER 1000.\n#define R 100.\n#define S(a,b,c) smoothstep(a,b,c)\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\nconst float pi = 3.14159;\nconst float eps = 1e-4;\nfloat pc = 3.;\nint lines = 16;\n#define flines float(lines)\n\nfloat f(float n, vec3 hsl){\n    float k = mod(n+hsl.x*12., 12.);\n    float a = hsl.y*min(hsl.z, 1.-hsl.z);\n    return hsl.z-a*max(min(k-3., min(9.-k, 1.)),-1.);\n}\nvec3 hsl2rgb(vec3 hsl){\n    return vec3(f(0.,hsl), f(8.,hsl), f(4.,hsl));\n}\nvec3 hue2rgb(float hue){\n    \n    float fftc = texture(iChannel0, vec2(hue,0.0)).r;\n    if(hue<1.0){hue=fftc;};\n    //return (hsl2rgb(vec3(fftc, 1., .5))+hsl2rgb(vec3(hue, 1., .5)))/2.;\n    return hsl2rgb(vec3(hue, 1., .5));\n}\n\n\nvec3 julia(float zx, float zy, float cx, float cy){\n    float iter = 0.;\n    for(int i = 0; i<int(MAX_ITER); i++){\n        if(zx * zx + zy * zy < R*R && iter<MAX_ITER){\n\t\t\tfloat xtemp = zx*zx - zy*zy;\n        \tzy = 2. * zx * zy + cy;\n        \tzx = xtemp + cx;\n        \titer+=1.;\n        } else {\n            break;\n        }\n    }\n\n   if(iter>=MAX_ITER)\n        return vec3(1,1,0);\n    float dist = length(vec2(zx,zy));\n    float fracIter = log2(log(dist) / log(R)) - 1.;\n    iter -= fracIter;\n    //return hue2rgb(sqrt(iter/10.));\n   return hue2rgb(sqrt(iter/10.));\n    //return sqrt(abs(iter/10.));\n}\n\n// Feel free to write your own volume functions and put them in the comments :)\n\n//*\nvec3 voxel(vec3 p){\n    //p = floor(p);\n    \n    p-=vec3(25.,30.,30.);\n    p*=0.01;//(iMouse.x/iResolution.x)*10.;\n    //p=p+90.;\n   \n    //p=p-0.5;\n\n    return julia(p.x,p.y,p.z,sin(iTime/2.)*2.).gbg*3.;\n}\n/*/\nvec3 voxel(vec3 p){\n    float scale = .3;\n    float darkness = 8.;\n    return floor(p* abs(1. / dot(cos(iTime + p*scale), vec3(darkness))));\n} // this is an excellent example of what this system is capable of, and the consequences of removing floor(p)\n//*/\n\nfloat planeRay(vec3 ro, vec3 rd, vec3 norm, float d){\n    float a = dot(ro, norm)-d, b = dot(norm, -rd);\n    if (b < 0. && a > 0.) return 1e9;\n    return a / b;\n}\n\nfloat line(vec2 uv, vec2 a, vec2 b){\n    float x = min(length(uv-a),length(uv-b));\n    vec2 v = normalize(b-a);\n    if (dot(v, uv-a) > 0. && dot(v, uv-a) < length(a-b)) x = min(x, abs(dot(uv-a, v.yx*vec2(-1,1)))); \n    return x;\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    vec2 muv = iMouse.xy == vec2(0)?vec2(iTime/5., -.2):(2.*iMouse.xy-r)/r.y;\n    O = vec4(0);\n\n    vec2 camM = muv*(pi/2. - 1e-3);\n    vec3 camF = vec3(sin(camM.x)*cos(camM.y), cos(camM.x)*cos(camM.y), sin(camM.y));\n    vec3 camR = normalize(cross(camF, vec3(0,0,1)));\n    vec3 camU = cross(camR, camF);\n    \n    vec3 o = vec3(.5) - 3.*camF;\n    \n    vec3[8] p;\n    float vx,vy,vz;\n    for (int i = 0; i < 8; i++){\n        vx = dot(camR, vec3(i>>2, (i>>1)%2, i%2)-o);\n        vy = dot(camU, vec3(i>>2, (i>>1)%2, i%2)-o);\n        vz = dot(camF, vec3(i>>2, (i>>1)%2, i%2)-o);\n        p[i] = vec3(vx,vy, vz/pc);\n    } // vertex shader lol\n    \n    float d = 1e4;\n    \n    vec3 a,b;\n    \n    //*\n    for (int z = 0; z <= lines; z+=lines){\n        for (int x = 1; x < lines; x++){\n            float fx = float(x)/flines;\n            float fz = float(z)/flines;\n            a = mix(mix(p[0], p[1], fz), mix(p[4], p[5], fz), fx);\n            b = mix(mix(p[2], p[3], fz), mix(p[6], p[7], fz), fx);\n\n            d = min(d, line(cuv, a.xy / a.z, b.xy / b.z));\n\n\n            a = mix(mix(p[4], p[5], fz), mix(p[6], p[7], fz), fx);\n            b = mix(mix(p[0], p[1], fz), mix(p[2], p[3], fz), fx);\n\n            d = min(d, line(cuv, a.xy / a.z, b.xy / b.z));\n        }\n    }\n    //*/\n    \n    float x = .1 * \n    //smoothstep(2./r.y, 0., d);\n    exp(-pow(d / (2./r.y), 2.));\n    // gaussian instead of smoothstep nearly eliminates moire\n\n    d = 1e4;\n    // Outlines\n    //*\n    d = min(d, line(cuv, p[0].xy / p[0].z, p[2].xy / p[2].z));\n    d = min(d, line(cuv, p[2].xy / p[2].z, p[6].xy / p[6].z));\n    d = min(d, line(cuv, p[6].xy / p[6].z, p[4].xy / p[4].z));\n    d = min(d, line(cuv, p[4].xy / p[4].z, p[0].xy / p[0].z));\n    \n    d = min(d, line(cuv, p[1].xy / p[1].z, p[3].xy / p[3].z));\n    d = min(d, line(cuv, p[3].xy / p[3].z, p[7].xy / p[7].z));\n    d = min(d, line(cuv, p[7].xy / p[7].z, p[5].xy / p[5].z));\n    d = min(d, line(cuv, p[5].xy / p[5].z, p[1].xy / p[1].z));\n    \n    d = min(d, line(cuv, p[0].xy / p[0].z, p[1].xy / p[1].z));\n    d = min(d, line(cuv, p[2].xy / p[2].z, p[3].xy / p[3].z));\n    d = min(d, line(cuv, p[6].xy / p[6].z, p[7].xy / p[7].z));\n    d = min(d, line(cuv, p[4].xy / p[4].z, p[5].xy / p[5].z));\n    //*/\n\n    x = mix(x, .8, smoothstep(3./r.y, 0., d));\n    \n        \n    vec3 norm, dir = camF + camR * cuv.x/pc + camU*cuv.y/pc;\n    float t,dis,tempT,maxT,minT;\n    vec4 v;\n\n    maxT = 0.; minT = 1e9;\n    for (int q = 0; q < 6; q++){\n        norm *= 0.;\n        norm[q%3] = q%6<3?-1.:1.;\n        dis = q<3?0.:1.;\n        tempT = planeRay(o, dir, norm, dis);\n        if (dot(o, norm)-dis > 0.){\n            maxT = max(maxT, tempT);\n        } else {\n            if (tempT > 0.) minT = min(minT, tempT);\n        }\n    }\n    t = maxT * flines;\n    \n    if (minT - maxT > 0.) {\n        \n        float d;\n        vec3 p,v=vec3(0);\n        bvec3 sides = bvec3(dir.x > 0., dir.y > 0., dir.z > 0.);\n        vec3 dists;\n\n        for (int i = 0; i < 512; i++){\n            p = o*flines + dir*t;\n\n            if (\n                   p.x > flines + eps\n                || p.y > flines + eps\n                || p.z > flines + eps\n                || p.x < -eps \n                || p.y < -eps\n                || p.z < -eps\n            ) break; // prevents loop unrolling too. \n\n            vec3 vox = voxel(p);\n            \n            for (int q = 0; q < 3; q++){\n                dists[q] = (sides[q]?ceil(p[q])-p[q]:floor(p[q])-p[q])/dir[q];\n            }\n\n            d = min(dists.x, min(dists.y, dists.z));\n\n            t += d + max(t*1e-5, 1e-4);\n            \n            v += d * max(vec3(0), vox);\n\n        }\n\n        O.xyz += (1.-exp(-v*.02));\n\n    }\n    \n    O += vec4(pow(x, 1./2.2));    \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wcySzV",
    "date": "1750358832",
    "viewed": 11,
    "name": "fast pixel sort x and y",
    "description": "hshssgsgs",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "idontcare"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"fast pixel sort\" by Nguyen2007. https://shadertoy.com/view/WfyXDh\n// 2025-06-19 18:46:49\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    vec2 R = iResolution.xy;\n    O = texture(iChannel0, I / R);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dfGRn",
       "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define R iResolution\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    if(iFrame < 1)\n    {\n        O = texture(iChannel0, I / R.xy);\n        return;\n    }\n    \n\n    if(iFrame<100){\n    int b = iFrame - 1;\n    int i = int(I.x);\n    \n    int h = int((sqrt(float(8 * b + 1)) - 1.0) / 2.0);\n    int k = (h * (h + 3) / 2 - b) % (h + 1);\n    int j = i ^ (k < h ? 1 << k : (2 << k) - 1);\n    vec4 A = texelFetch(iChannel1, ivec2(i, I.y), 0); if (j >= int(R.x)) { O = A; return; }\n    vec4 B = texelFetch(iChannel1, ivec2(j, I.y), 0);\n    float va = dot(A.xyz, vec3(0.2126, 0.7152, 0.0722));\n    float vb = dot(B.xyz, vec3(0.2126, 0.7152, 0.0722));\n    O = i < j ^^ va < vb ? B : A;\n    \n    }else{\n    int b = iFrame - 100;\n\n    \n    int h = int((sqrt(float(8 * b + 1)) - 1.0) / 2.0);\n    int k = (h * (h + 3) / 2 - b) % (h + 1);\n\n    int iy = int(I.y);\n    int jy = iy ^ (k < h ? 1 << k : (2 << k) - 1);\n    vec4 Ay = texelFetch(iChannel1, ivec2(I.x, iy), 0); if (jy >= int(R.y)) { O = Ay; return; }\n    vec4 By = texelFetch(iChannel1, ivec2(I.x, jy), 0);\n    float vay = dot(Ay.xyz, vec3(0.2126, 0.7152, 0.0722));\n    float vby = dot(By.xyz, vec3(0.2126, 0.7152, 0.0722));\n    O = iy < jy ^^ vay < vby ? By : Ay;}\n    \n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3fySzc",
    "date": "0",
    "viewed": 0,
    "name": "Bubble Colors Feedback",
    "description": "Bubble Colors",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "raymarch",
     "bubbles"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Bubble Colors\" by diatribes. https://shadertoy.com/view/wcGXWR\n// 2025-06-20 13:05:36\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 o, vec2 u) \n{\n    float i,r,s,d,n,t=iTime;\n    vec3  p = iResolution; \n    vec3 pr = texture(iChannel0, u/p.xy, 0.).rgb;\n    u = (u-p.xy/2.)/p.y;\n    for (o*=i;i++<9e1; \n         d += s = .005 + abs(r)*.2,\n         o += (1.+cos(.1*p.z+vec4(3,1,0,0))) / s)\n        for(p = vec3(u * d, d + t*16.),\n            r = 50.-abs(p.y)+ cos(t - dot(u,u) * 6.)*3.3,\n            n = pr.r/10.;\n            n < .8;\n            n *= 1.4)\n            r -= abs(dot(sin(.3*t+.8*p*n), .7 +p-p )) / n;\n    o = tanh(o / 2e3);\n}\n\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wcKSWK",
    "date": "1750702655",
    "viewed": 9,
    "name": "Crystal's Hypertile PI value",
    "description": "Changing PI according to mouseX",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "hypertile3swirl"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Crystal's Hypertile 3 Swirl\" by Crystalize. https://shadertoy.com/view/lcSXR1\n// 2025-06-23 18:16:45\n\n//many thanks to my friend, Zueuk, who supplied the distance formulae used here\n\nconst float Psym=3.;\nconst float Qsym=5.;\nconst float Rsym=4.;\n\nconst int iters=10;\n\nconst vec2 Re = vec2(1,0);\nconst vec2 Im = vec2(0,1);\nconst float TWOPI = 6.283185307179586476;\nfloat PI = 3.141592653589793238;\n\nvec2 cmul(vec2 z, vec2 c) {\n    return vec2(z.x * c.x - z.y * c.y, z.x * c.y + z.y * c.x);\n}\n\nvec2 cdiv(vec2 z, vec2 c) {\n    float r = dot(c, c);\n    return vec2(z.x * c.x + z.y * c.y, z.y * c.x - z.x * c.y) / r;\n}\n\nvec2 conj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nvec2 recip(vec2 z) {\n    return conj(z)/dot(z,z);\n}\n\nvec2 hypershift(vec2 z, vec2 s) {\n    return cdiv(z + s, cmul(z,conj(s))+Re);\n}\n\nvec2 cpow(vec2 z, vec2 p) {\n    float a = atan(z.y, z.x);\n    float lnr = 0.5 * log(dot(z,z));\n    float m = exp(p.x * lnr - p.y * a);\n    float angle = p.x * a + p.y * lnr;\n    return vec2(cos(angle), sin(angle)) * m;\n}\n\nvec2 cabs(vec2 z, vec2 c) {\n    return cpow(cpow(z,c), cdiv(Re,c));\n}\n\nvec2 swirl3sin(vec2 z, float shift, float minimum, float maximum, float type) {\n    //type = negative for fixed min, type = 0 for fixed unit, type = positive for fixed max\n    float minOffset = minimum > 0. ? log(minimum) * shift : 0.;\n    float maxOffset = maximum > 0. ? log(maximum) * shift : 0.;\n    \n    vec2 MinMaxAngle = type < 0. ? vec2(0., maxOffset - minOffset) : type == 0. ? vec2(minOffset, maxOffset) : vec2(minOffset - maxOffset, 0.);\n    \n    float dist = maximum - minimum;\n    \n    float angle = atan(z.y, z.x);\n    float range = length(z);\n    if(range < minimum) {\n        angle += MinMaxAngle.x;\n    } else if (range > maximum) {\n        angle += MinMaxAngle.y;\n    } else {\n        angle += log((1. - cos((range - minimum) / dist * PI)) * .5 * dist + minimum) * shift - minOffset + MinMaxAngle.x;\n    }\n    return vec2(cos(angle),sin(angle)) * range;\n}\n\nvec2 hypertile3swirl(vec2 z, float p, float q, float r, float swirl, float sBuffer) {\n    float pp = PI/p;\n    float pq = PI/q;\n    float spq = sin(pq);\n    float pr = PI/r;\n    float spr = sin(pr);\n    float a1 = acosh((cos(pp) + cos(pq) * cos(pr)) / (spq * spr));\n    float a2 = asinh(spq / sin(pp) * sinh(a1));\n    float sha2 = sinh(a2);\n    float a3 = asinh(spr * sha2);\n    float rcha3 = 1./cosh(a3);\n    float a4 = asinh(spr * sha2 / spq);\n    \n    float h = tanh(a3 * .5);\n    float b1 = tanh(acosh(cosh(a4) * rcha3) * .5);\n    float b2 = tanh(acosh(cosh(a2) * rcha3) * .5);\n    float sSize = h - sBuffer;\n    for(int i = 0; i < iters; i++) {\n        z = hypershift(z,-b1*Re);\n        z = -cabs(-z, Re*q);\n        z = hypershift(z,b1*Re);\n        z = hypershift(z,b2*Re);\n        z = cabs(z, Re*r);\n        z = hypershift(z,-b2*Re);\n    }\n    z = hypershift(z, h * Im);\n    z = swirl3sin(z/sSize, swirl, 0., 1., 0.);\n    z = hypershift(z*sSize, -h * Im);\n    z = hypershift(z, -h * Im);\n    z = swirl3sin(z/sSize, swirl, 0., 1., 0.);\n    z = hypershift(z*sSize, h * Im);\n    for(int i = 0; i < iters/2; i++) {\n        z = hypershift(z,-b1*Re);\n        z = -cabs(-z, Re*q);\n        z = hypershift(z,b1*Re);\n        z = hypershift(z,b2*Re);\n        z = cabs(z, Re*r);\n        z = hypershift(z,-b2*Re);\n    }\n    z = z.x>0.?hypershift(z,-b1*Re)/b1:hypershift(z,b2*Re)/b2;\n    return z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * (fragCoord.xy - 0.5*iResolution.xy) / -iResolution.y;\n    PI = 4.*(iMouse.x/iResolution.x);\n    uv = dot(uv,uv)<1.?uv:recip(uv);\n    uv = hypertile3swirl(uv, Psym, Qsym, Rsym, 1., -0.05);\n    \n    vec3 col = 0.5+0.5*cos(abs(uv.x)*2.+vec3(0,1,2));\n\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "w33GW7",
    "date": "1751312167",
    "viewed": 21,
    "name": "Fork of 3D implicit plotter",
    "description": "Testing it out with an sdf model from another shader.",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "3d",
     "plot",
     "implicit"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"3D implicit plotter\" by FordPerfect. https://shadertoy.com/view/W3d3R8\n// 2025-06-30 19:34:48\n\n// Public Domain under http://unlicense.org, see link for details.\n\n// A simple implicit 3D surface plotter.\n\nfloat f(vec3 r)\n{\n    r=r.xzy;\n    r-=vec3(25.,30.,30.)/80.;\n    return map(r);\n    //return dot(r*r,r*r)-dot(r,r)+sqrt(0.125);\n    return dot(r,r)-1.0 // Another similar shape.\n        +exp(-8.0*dot(r.xy,r.xy))\n        +exp(-8.0*dot(r.yz,r.yz))\n        +exp(-8.0*dot(r.zx,r.zx));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 xy=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col=vec3(1.0/128.0);\n    vec3 aabb_lo=vec3(-1.125);\n    vec3 aabb_hi=vec3(+1.125);\n    float D=length(aabb_hi-aabb_lo);\n    vec3 org=1.25*vec3(length((aabb_hi-aabb_lo).xy),0.0,(aabb_hi-aabb_lo).z);\n    float t=iTime;\n    org.xy=mat2(cos(t),-sin(t),sin(t),cos(t))*org.xy;\n    org+=0.5*(aabb_lo+aabb_hi);\n    vec3 fwd=normalize(0.5*(aabb_lo+aabb_hi)-org);\n    vec3 rgt=normalize(cross(fwd,vec3(0,0,1)));\n    vec3 up =normalize(cross(rgt,fwd));\n    vec3 dir=normalize(xy.x*rgt+xy.y*up+2.5*fwd);\n    vec2 s=vec2(0.0,1e7);\n    vec3 ls=(aabb_lo-org)/dir,hs=(aabb_hi-org)/dir;\n    if(dir.x>0.0) s=vec2(max(s.s,ls.x),min(s.t,hs.x)); else s=vec2(max(s.s,hs.x),min(s.t,ls.x));\n    if(dir.y>0.0) s=vec2(max(s.s,ls.y),min(s.t,hs.y)); else s=vec2(max(s.s,hs.y),min(s.t,ls.y));\n    if(dir.z>0.0) s=vec2(max(s.s,ls.z),min(s.t,hs.z)); else s=vec2(max(s.s,hs.z),min(s.t,ls.z));\n    if(s.s<s.t)\n    {\n        float c=-1.0;\n        float a=s.s;\n        float A=f(org+a*dir);\n        const int n=64;\n        for(int i=1;i<=n;++i)\n        {\n            float b=mix(s.s,s.t,float(i)/float(n));\n            float B=f(org+b*dir);\n            if(A*B<0.0)\n            {\n                for(int i=0;i<4;++i)\n                {\n                    if(A==B) {c=0.5*(a+b); break;}\n                    c=(a*B-b*A)/(B-A);\n                    float C=f(org+c*dir);\n                    if(A*C<0.0) {b=c; B=C;} else {a=c; A=C;}\n                }\n                break;\n            }\n        }\n        col+=1.0/128.0;\n        if(c>0.0)\n        {\n            vec3 r=org+c*dir;\n            vec2 e=vec2(0,1e-2);\n            vec3 light=normalize(-fwd+rgt+0.5*up);\n            vec3 normal=normalize(vec3(\n                f(r+e.yxx)-f(r-e.yxx),\n                f(r+e.xyx)-f(r-e.xyx),\n                f(r+e.xxy)-f(r-e.xxy)));\n            col=vec3(0.0625)+0.5*max(dot(normal,light),0.0);\n        }\n    }\n    col=mix(12.92*col,1.055*pow(col,vec3(1.0/2.4))-0.055,step(0.0031308,col)); // sRGB\n    fragColor=vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "float sdSphere( in vec3 p, in float r)\n{\n    return length(p)-r;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat dot2(in vec3 v ) { return dot(v,v); }\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    return -opSmoothUnion(d1,-d2,k);\n    \n    //float h = max(k-abs(-d1-d2),0.0);\n    //return max(-d1, d2) + h*h*0.25/k;\n}\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    //vec3 q = abs(p)-h;\n    //return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n// Euclidean distance to a capped torus\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdVerticalVesicaSegment( in vec3 p, in float h, in float w )\n{\n    // shape constants\n    h *= 0.5;\n    w *= 0.5;\n    float d = 0.5*(h*h-w*w)/w;\n    \n    // project to 2D\n    vec2  q = vec2(length(p.xz), abs(p.y-h));\n    \n    // feature selection (vertex or body)\n    vec3  t = (h*q.x < d*(q.y-h)) ? vec3(0.0,h,0.0) : vec3(-d,0.0,d+w);\n    \n    // distance\n    return length(q-t.xy) - t.z;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdHead( vec3 p, float r ){\n    // TOP - Cranium\n    float cran = sdSphere(p, r);\n    // BOTTOM - Jaw/Cheekbones\n    vec2 os = vec2(-0.14,0.05);\n    float ms = 0.1215;\n    vec3 ql = p - vec3(ms,os);\n    vec3 qr = p - vec3(-ms,os);\n    ql = ql*rotateZ(0.26);\n    qr = qr*rotateZ(-0.26);\n    ql = ql*rotateX(0.42);\n    qr = qr*rotateX(0.42);\n    vec3 a = vec3(0.,-0.4, 0.0);\n    vec3 b = vec3( 0., 0.4, 0.0);\n    float l = length(b-a);\n    float wv = sqrt(0.12/l);\n    float jaw = opSmoothUnion(sdVerticalVesicaSegment( ql-a, l, wv*0.85 ) - wv*0.15, \n    sdVerticalVesicaSegment( qr-a, l, wv*0.85 ) - wv*0.15, 0.07);\n    cran = opSmoothUnion( cran, jaw, 0.03);\n    // SHAPING - sides\n    float d2 = sdRoundBox(p-vec3(0.76,-0.6,-0.15), vec3(0.4,0.4,0.4), 0.02 ); \n    float d1 = sdRoundBox(p-vec3(-0.76,-0.6,-0.15), vec3(0.4,0.4,0.4), 0.02); \n    float d3 = sdRoundBox(p-vec3(0.76,0.35,-0.2), vec3(0.4,0.4,0.4), 0.02 ); \n    float d4 = sdRoundBox(p-vec3(-0.76,0.35,-0.2), vec3(0.4,0.4,0.4), 0.02 ); \n    cran = opSmoothSubtraction(d4,opSmoothSubtraction(d3,cran, .2), .2);\n    cran = opSmoothSubtraction(d2,opSmoothSubtraction(d1,cran, .2), .2);\n    // SHAPING - top\n    float d6 = sdRoundBox(p-vec3(0.,0.8,-0.0), vec3(0.4,0.4,0.4), 0.03 ); \n    cran = opSmoothSubtraction(d6,cran,.5);\n    // SHAPING - front\n    float d7 = sdRoundBox(p-vec3(0.,0.42,0.82), vec3(0.4,0.4,0.4), 0.03 ); \n    cran = opSmoothSubtraction(d7,cran,.17);\n    // Eye Sockets\n    float d5 = sdRoundBox(p-vec3(0.0,-0.22,0.39), vec3(0.18,0.001,0.001), 0.03 );\n    cran = opSmoothSubtraction( d5, cran, .08);\n    // Nose\n    cran = opSmoothUnion( cran, sdRoundCone(   p-vec3( 0.0,-0.3, 0.34), vec3(0.0,0.0,0), vec3(0.0,0.17,-0.06), 0.03, 0.001), 0.05);\n    // Eyes\n    float eyel = sdSphere(p-vec3(0.11,-0.2,0.257), 0.05);\n    float eyer = sdSphere(p-vec3(-0.11,-0.2,0.257), 0.05);\n    cran = opSmoothUnion( cran, eyer, 0.025);\n    cran = opSmoothUnion( cran, eyel, 0.025);\n\n    return cran;\n}\nfloat map( in vec3 pos )\n{\n    float d = 1e10;\n    pos *= 0.9;\n    // Shoulders-Arms-Torso\n    vec3 q = pos - vec3(0.0,0.0,0.0);\n    q.z-=0.3;\n    q.y+=1.8 - q.x/20.;\n    q.x+=0.35 + q.y/20.;;\n    q = q*rotateX(1.7);\n    q = q*rotateZ(0.4);\n    q = q*rotateY(0.25);\n    float an = 1.0;\n    vec2 c = vec2(sin(an),cos(an));\n    vec4 w = opElongate( q, vec3(0.13,0.27,0.78) );\n    float shoulder = sdCappedTorus(w.xyz, c, 0.7, 0.2);\n    shoulder = shoulder+ sin((1.75+q.x)*3.)/15.;\n    shoulder = shoulder+0.04;\n    d = min( d, shoulder);\n    // Collar Bones\n    vec3 qt = pos - vec3(-0.8,-1.1,-0.7);\n    float collar = rounding( udTriangle( qt, vec3(0.6,0.0,0.19), vec3(0.4,-0.7,0.2), vec3(-0.1,-0.2,0.03) ), 0.05 );\n    collar = opSmoothUnion(collar, rounding( udTriangle( qt, vec3(0.7,0.0,0.1), vec3(0.8,-0.7,0.2), vec3(1.1,0.2,0.5) ), 0.01 ), 0.1);\n    d = opSmoothUnion(d, collar , 0.13);\n    // Extra Arm Padding\n    vec3 qv = pos - vec3(-0.9,-2.3,-0.6);\n    vec3 a = vec3(0.,-0.5, 0.0);\n    vec3 b = vec3( 0., 0.5, 0.0);\n    float l = length(b-a);\n    float wv = sqrt(0.1/l);\n    d = opSmoothUnion( d, sdVerticalVesicaSegment( qv-a, l, wv*0.85 ) - wv*0.15 , 0.2);\n    // Extra Chest Padding\n    qv = pos - vec3(-0.1,-1.8,-0.5);\n    a = vec3(0.,-0.35, 0.0);\n    b = vec3( 0., 0.35, 0.0);\n    l = length(b-a);\n    wv = sqrt(0.2/l);\n    d = opSmoothUnion( d, sdVerticalVesicaSegment( qv-a, l, wv*0.85 ) - wv*0.15 , 0.3);\n    // Neck\n    qv = pos - vec3(0.2,-1.5,-0.3);\n    a = vec3(0.,-0.2, 0.0);\n    b = vec3( 0., 0.3, 0.0);\n    l = length(b-a);\n    qv = pos - vec3(-0.2,-0.9,-0.55);\n    qv = qv*rotateX(-0.3);\n    float neck = sdCylinder(qv, vec2(0.185, 0.65));\n    d = opSmoothUnion( d, neck, 0.2);\n    // Head\n    vec3 qh = pos - vec3(-0.1,-0.07,-0.3);\n    qh = qh*rotateY(-0.8);\n    float head = sdHead(qh, 0.36);\n    d = opSmoothUnion( d, head , 0.15);\n    return d;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3Xt3DM",
    "date": "1751329384",
    "viewed": 10,
    "name": "only mix",
    "description": "writing a shader using only mix function, no other built-in functions or operators",
    "likes": 2,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "mix"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float d = mix(0., 0.001, fragCoord.x);\n    float b = mix(0., 0.005, fragCoord.y);\n    float c = mix(0., 0.001, iMouse.x);\n    float a = mix(0., 0.005, iMouse.y);\n    \n    float m1 = mix(a,b,c);\n    float m2 = mix(a,b,d);\n    float m3 = mix(a,c,b);\n    float m4 = mix(a,c,d);\n    float m5 = mix(a,d,c);\n    float m6 = mix(a,d,b);\n    \n    vec3 cola = vec3(m1,m4,m6);\n    vec3 colb = vec3(m2,m3,m5);\n    vec3 colc = mix(cola, colb, a);\n    vec3 cold = vec3(m2,m5,m4);\n    vec3 cole = mix(colc, cold, b);\n    vec3 col = mix(cole, cola, cold);\n    \n    //if(col.r>0.5){col = cold;}\n    //else if(col.b>0.5){col = cole;}\n    //else if(col.g>0.5){col = cold;}\n    //col = mix(col, colb, colc);\n    \n    // cant use evaluation operators either, oops.\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WXtGW7",
    "date": "1751332941",
    "viewed": 13,
    "name": "random with only mix",
    "description": "random noise using only mix",
    "likes": 1,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "mix"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"only mix\" by Cotterzz. https://shadertoy.com/view/3Xt3DM\n// 2025-07-01 01:21:30\n\n// arithmetic\n# define MUL(a,b) mix(0.0, a, b)\n# define NEG(a) mix(a, 0.0, 2.0)\n# define ADD(a,b) MUL(mix(a,b, 0.5), 2.0)\n# define SUB(a,b) ADD(a, NEG(b))\n// DIV still missing (without some kind of loop)\n\n// logic\n# define NOT(a) bool(mix(1.0, 0.0, float(bool(a))))\n# define OR(a,b) bool(ADD(float(bool(a)), float(bool(b))))\n# define AND(a,b) NOT(OR(NOT(a), NOT(b)))\n# define XOR(a,b) AND(OR(a,b), NOT(AND(a,b)))\n\n// conditionals\n# define EQ(a,b) bool(NOT(bool(SUB(a,b))))\n\n\n// shader specific\n# define FLOOR(a) float(int(a))\n# define FRACT(a) SUB(a,FLOOR(a))\n# define STEP(a,x) float(bool(uint(ADD(SUB(x,a),1.0))))\n\n// exapand formulas to vectors where needed.\n# define MUL2(a,b) vec2(MUL(a.x, b.x), MUL(a.y, b.y))\n# define FRACT2(a) vec2(FRACT(a.x), FRACT(a.y))\n\nfloat random(vec2 seed){\n    float m = MUL(seed.x, 0.016);\n    m = MUL(m, MUL(seed.y, 0.021));\n    float a = ADD(FRACT(MUL(seed.x, MUL(m,1.1))),FRACT(MUL(seed.y, MUL(m,1.1))));\n    float b = ADD(FRACT(MUL(seed.x, MUL(m,.12))), FRACT(MUL(seed.y, MUL(m,.13))));\n    float c = ADD(FRACT(MUL(seed.x, MUL(m,.097))), FRACT(MUL(seed.y, MUL(m,.067))));\n    float d = ADD(FRACT(MUL(seed.x, MUL(m,.047))), FRACT(MUL(seed.y, MUL(m,.037))));\n    float e = ADD(FRACT(MUL(MUL(seed.x,seed.y), MUL(m,.13))), FRACT(MUL(MUL(seed.x,seed.y), MUL(m,.17))));\n    return SUB(MUL(ADD(ADD(a,b), ADD(c,d)), 0.3), 0.7);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.x = ADD(fragCoord.x, MUL(iResolution.x, 0.2));\n    fragCoord.y = ADD(fragCoord.y, MUL(iResolution.y, 0.2));\n    fragCoord = MUL2(fragCoord, vec2(0.6));\n    float rand = random(fragCoord);//+random(vec2(fragCoord.x,SUB(fragCoord.y, iResolution.y)) );\n    vec3 col = vec3(rand);\n    //if(rand>0.9){col=vec3(0,1,0);}\n   // if(rand<0.1){col=vec3(1,0,1);}\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WXdXzS",
    "date": "1753606072",
    "viewed": 85,
    "name": "Another Fraccident",
    "description": "I was trying to do something else with the iteration limits and ended up with this.\nUse the mouse to control parameters",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fractal",
     "mandelbrot",
     "accident"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/*\n//GOLFED VERSION\nvec3 H(vec3 c){return c.z+c.y*(clamp(abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.)-.5)*(1.-abs(2.*c.z-1.));}\nvoid M(out vec4 o,vec2 u){\nvec2 v=u/iResolution.y,m=iMouse.z>0.?iMouse.xy/iResolution.xy:vec2(sin(iTime/2.)+1.,cos(iTime)+1.)/2.+1e-4;\nfloat s=3.,x=-1.,y=-.5,l=m.y*60.,a=x+v.x,b=y+v.y,c=a*s,d=b*s,e,f,r;int i;\nfor(i=0;i<int(m.x*30.)+1;i++){e=c*c-d*d+a*s;f=2.*c*d+b*s;c=e;d=f;r=c*c+d*d;if(r>l)break;}\no=vec4(atan(sqrt(H(vec3(r>l?r/l:r,1.,r>l?.4+float(i)/50.:.5+m.x/2.)))),1);}\nvoid mainImage(out vec4 o, vec2 u) { float s = 16., k; vec2 j = vec2(.5); o = vec4(0); vec4 c; M(c, u); \nfor (k = s; k-- > .5; ) { M(c, u + j - .5); o += c; j = fract(j + vec2(.755, .57).yx); };o /= s;o.a==1.;} \n*/\n\n// HSL to RGB color conversion function\nvec3 hslToRgb(vec3 c){return c.z+c.y*(clamp(abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.)-.5)*(1.-abs(2.*c.z-1.));}\n\n// Main Mandelbrot calculation function\nvoid calculateMandelbrot(out vec4 outputColor, vec2 pixelCoords) {\n    // Normalize coordinates to maintain aspect ratio\n    vec2 normalizedCoords = pixelCoords / iResolution.y;\n    \n    // Set up mouse interaction or automatic animation\n    vec2 mouseParams;\n    if (iMouse.z > 0.0) {\n        // If mouse is clicked, use mouse position\n        mouseParams = iMouse.xy / iResolution.xy;\n    } else {\n        // Otherwise, animate automatically\n        mouseParams = vec2(sin(iTime / 2.0) + 1.0, cos(iTime) + 1.0) / 2.0 + 0.0001;\n    }\n    \n    // Mandelbrot parameters\n    float zoom = 3.0;           // Zoom level\n    float centerX = -1.0;       // X center of view\n    float centerY = -0.5;       // Y center of view\n    float escapeRadius = mouseParams.y * 60.0;  // Escape radius threshold\n    \n    // Convert pixel coordinates to complex plane coordinates\n    float realPart = centerX + normalizedCoords.x;\n    float imagPart = centerY + normalizedCoords.y;\n    \n    // Initialize z = 0 for Mandelbrot iteration (z = z² + c)\n    float zReal = realPart * zoom;\n    float zImag = imagPart * zoom;\n    \n    // Iterate the Mandelbrot equation\n    int iterations;\n    float magnitudeSquared;\n    int maxIterations = int(mouseParams.x * 30.0) + 1;\n    \n    for (iterations = 0; iterations < maxIterations; iterations++) {\n        // Calculate z² + c\n        float newReal = zReal * zReal - zImag * zImag + realPart * zoom;\n        float newImag = 2.0 * zReal * zImag + imagPart * zoom;\n        \n        zReal = newReal;\n        zImag = newImag;\n        \n        // Check if point escaped\n        magnitudeSquared = zReal * zReal + zImag * zImag;\n        if (magnitudeSquared > escapeRadius) {\n            break;\n        }\n    }\n    \n    // Color the pixel based on escape time and magnitude\n    float hue, saturation, lightness;\n    \n    if (magnitudeSquared > escapeRadius) {\n        // Point escaped - color based on iterations\n        hue = magnitudeSquared / escapeRadius;\n        saturation = 1.0;\n        lightness = 0.4 + float(iterations) / 50.0;\n    } else {\n        // Point is in the Mandelbrot set\n        hue = magnitudeSquared;\n        saturation = 1.0;\n        lightness = 0.5 + mouseParams.x / 2.0;\n    }\n    \n    // Convert HSL to RGB and apply artistic transformation\n    vec3 color = hslToRgb(vec3(hue, saturation, lightness));\n    outputColor = vec4(atan(sqrt(color)), 1.0);  // Artistic color transformation\n}\n\n// Main shader entry point with anti-aliasing\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float sampleCount = 16.0;\n    \n    // Random offset for jittered sampling (pseudo-random)\n    vec2 jitter = vec2(0.5);\n    \n    // Initialize output color\n    fragColor = vec4(0.0);\n    \n    // Perform multiple samples for anti-aliasing\n    for (float k = sampleCount; k > 0.5; k--) {\n        vec4 sampleColor;\n        \n        // Calculate color at jittered position\n        calculateMandelbrot(sampleColor, fragCoord + jitter - 0.5);\n        fragColor += sampleColor;\n        \n        // Update jitter position (creates pseudo-random pattern)\n        jitter = fract(jitter + vec2(0.755, 0.57).yx);\n    }\n    \n    // Average all samples\n    fragColor /= sampleCount;\n    fragColor.a = 1.0;  // Set full opacity\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WX3Szj",
    "date": "1753627407",
    "viewed": 8,
    "name": "Three body periodic buffered",
    "description": "A buffered version of https://shadertoy.com/view/33V3RR",
    "likes": 1,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "2d",
     "simulation",
     "forked",
     "buffered",
     "threebody"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Three body periodic solutions\" by neozhaoliang. https://shadertoy.com/view/33V3RR\n// 2025-07-27 14:41:50\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "\nvec2 accel(vec2 pi, vec2 pj) {\n    vec2 r = pj - pi;\n    float k = dot(r, r);\n    float invDist3 = inversesqrt(k * k * k);\n    return G * r * invDist3;\n}\n\nvec2[3] acceleration(vec2[3] positions) {\n    vec2 a[3];\n    a[0] =\n        accel(positions[0], positions[1]) + accel(positions[0], positions[2]);\n    a[1] =\n        accel(positions[1], positions[0]) + accel(positions[1], positions[2]);\n    a[2] =\n        accel(positions[2], positions[0]) + accel(positions[2], positions[1]);\n    return a;\n}\n\n\nvoid RK4(inout vec2[3] p, inout vec2[3] v) {\n    const float dt = 0.01;\n    vec2[3] k1v = acceleration(p);\n    vec2[3] k1p = v;\n\n    vec2[3] p2, v2;\n    for (int i = 0; i < 3; i++) {\n        p2[i] = p[i] + 0.5 * dt * k1p[i];\n        v2[i] = v[i] + 0.5 * dt * k1v[i];\n    }\n    vec2[3] k2v = acceleration(p2), k2p = v2;\n\n    vec2[3] p3, v3;\n    for (int i = 0; i < 3; i++) {\n        p3[i] = p[i] + 0.5 * dt * k2p[i];\n        v3[i] = v[i] + 0.5 * dt * k2v[i];\n    }\n    vec2[3] k3v = acceleration(p3), k3p = v3;\n\n    vec2[3] p4, v4;\n    for (int i = 0; i < 3; i++) {\n        p4[i] = p[i] + dt * k3p[i];\n        v4[i] = v[i] + dt * k3v[i];\n    }\n    vec2[3] k4v = acceleration(p4), k4p = v4;\n\n    for (int i = 0; i < 3; i++) {\n        p[i] += dt * (k1p[i] + 2. * k2p[i] + 2. * k3p[i] + k4p[i]) / 6.0;\n        v[i] += dt * (k1v[i] + 2. * k2v[i] + 2. * k3v[i] + k4v[i]) / 6.0;\n    }\n}\n\n\n// suggested by @rreusser and code taken from his notebook\n// https://observablehq.com/@rreusser/magnetic-pendulum#drawField\nvoid RK45(inout vec2[3] p, inout vec2[3] v, inout float dt) {\n    const float safety = 0.95;\n    const float maxDecrease = 0.2;\n    const float maxIncrease = 5.0;\n    const float tol2 = 1e-8;\n\n    vec2[3] k1p = v;\n    vec2[3] k1v = acceleration(p);\n\n    vec2[3] p2, v2;\n    for (int i = 0; i < 3; i++) {\n        p2[i] = p[i] + dt * 0.2 * k1p[i];\n        v2[i] = v[i] + dt * 0.2 * k1v[i];\n    }\n    vec2[3] k2p = v2, k2v = acceleration(p2);\n\n    vec2[3] p3, v3;\n    for (int i = 0; i < 3; i++) {\n        p3[i] = p[i] + dt * (0.075 * k1p[i] + 0.225 * k2p[i]);\n        v3[i] = v[i] + dt * (0.075 * k1v[i] + 0.225 * k2v[i]);\n    }\n    vec2[3] k3p = v3, k3v = acceleration(p3);\n\n    vec2[3] p4, v4;\n    for (int i = 0; i < 3; i++) {\n        p4[i] = p[i] + dt * (0.3 * k1p[i] - 0.9 * k2p[i] + 1.2 * k3p[i]);\n        v4[i] = v[i] + dt * (0.3 * k1v[i] - 0.9 * k2v[i] + 1.2 * k3v[i]);\n    }\n    vec2[3] k4p = v4, k4v = acceleration(p4);\n\n    vec2[3] p5, v5;\n    for (int i = 0; i < 3; i++) {\n        p5[i] = p[i] + dt * (-0.2037037 * k1p[i] + 2.5 * k2p[i] - 2.5925926 * k3p[i] + 1.2962963 * k4p[i]);\n        v5[i] = v[i] + dt * (-0.2037037 * k1v[i] + 2.5 * k2v[i] - 2.5925926 * k3v[i] + 1.2962963 * k4v[i]);\n    }\n    vec2[3] k5p = v5, k5v = acceleration(p5);\n\n    vec2[3] p6, v6;\n    for (int i = 0; i < 3; i++) {\n        p6[i] = p[i] + dt * (0.0294958 * k1p[i] + 0.3417969 * k2p[i] + 0.0415943 * k3p[i] + 0.4003454 * k4p[i] + 0.0617676 * k5p[i]);\n        v6[i] = v[i] + dt * (0.0294958 * k1v[i] + 0.3417969 * k2v[i] + 0.0415943 * k3v[i] + 0.4003454 * k4v[i] + 0.0617676 * k5v[i]);\n    }\n    vec2[3] k6p = v6, k6v = acceleration(p6);\n    float err2 = 0.0;\n    for (int i = 0; i < 3; i++) {\n        vec2 err = dt * (\n            0.00429377 * k1p[i]\n            - 0.0186686 * k3p[i]\n            + 0.0341550 * k4p[i]\n            + 0.0193220 * k5p[i]\n            - 0.0391022 * k6p[i]\n        );\n        err2 += dot(err, err);\n    }\n\n    bool accept = err2 <= tol2;\n\n    if (accept) {\n        for (int i = 0; i < 3; i++) {\n            p[i] += dt * (0.0978836 * k1p[i] + 0.4025765 * k3p[i] + 0.2104377 * k4p[i] + 0.2891022 * k6p[i]);\n            v[i] += dt * (0.0978836 * k1v[i] + 0.4025765 * k3v[i] + 0.2104377 * k4v[i] + 0.2891022 * k6v[i]);\n        }\n    }\n    float scale = clamp(safety * pow(tol2 / (err2 + 1e-12), accept ? 0.125 : 0.1), maxDecrease, maxIncrease);\n    dt *= scale;\n}\n\n\nvoid adaptiveRK45(inout vec2[3] p, inout vec2[3] v) {\n    float t = 0.0;\n    float totalDt = 0.01;\n    float dt = totalDt / float(MaxIterEachStep);\n\n    for (int i = 0; i < MaxIterEachStep; i++) {\n        if (t + dt > totalDt) {\n            dt = totalDt - t;\n        }\n\n        vec2[3] pTemp = p;\n        vec2[3] vTemp = v;\n        float dtTemp = dt;\n\n        RK45(pTemp, vTemp, dtTemp);\n\n        if (dtTemp >= dt * 0.99) {\n            p = pTemp;\n            v = vTemp;\n            t += dt;\n        }\n\n        dt = dtTemp;\n\n        if (t >= totalDt - 1e-6) break;\n    }\n}\n\n\nvoid initState(int idx, out vec2[3] p, out vec2[3] v) {\n    if (idx == 0) {\n        p = vec2[3](vec2(-1, 0), vec2(1, 0), vec2(0, 0));\n        v = vec2[3](vec2(0.347111, 0.532728), vec2(0.347111, 0.532728),\n                    vec2(-2. * 0.347111, -2. * 0.532728));\n    } else if (idx == 1) {\n        p = vec2[3](vec2(0.2843198916, 0), vec2(0.8736097872, 0),\n                    vec2(-1.1579296788, 0));\n        v = vec2[3](vec2(0, 1.3774179570), vec2(0, -0.4884226932),\n                    vec2(0, -0.8889952638));\n    } else if (idx == 2) {\n        p = vec2[3](vec2(0.0132604844, 0), vec2(1.4157286016, 0),\n                    vec2(-1.4289890859, 0));\n        v = vec2[3](vec2(0, 1.054151921), vec2(0, -0.2101466639),\n                    vec2(0, -0.8440052572));\n\n    } else if (idx == 3) {\n        p = vec2[3](vec2(0.8733047091, 0), vec2(-0.6254030288, 0),\n                    vec2(-0.2479016803, 0));\n        v = vec2[3](vec2(0, 1.0107764436), vec2(0, -1.6833533458),\n                    vec2(0, 0.6725769022));\n\n    } else if (idx == 4) {\n        p = vec2[3](vec2(0.6661637520772179, -0.081921852656887),\n                    vec2(-0.025192663684493022, 0.45444857588251897),\n                    vec2(-0.10301329374224, -0.765806200083609));\n        v = vec2[3](vec2(0.84120297540307, 0.029746212757039),\n                    vec2(0.142642469612081, -0.492315648524683),\n                    vec2(-0.98384544501151, 0.462569435774018));\n    } else if (idx == 5) {\n\n        p = vec2[3](vec2(0.486657678894505, 0.755041888583519),\n                    vec2(-0.681737994414464, 0.29366023319721),\n                    vec2(-0.02259632746864, -0.612645601255358));\n        v = vec2[3](vec2(-0.182709864466916, 0.363013287999004),\n                    vec2(-0.579074922540872, -0.748157481446087),\n                    vec2(0.761784787007641, 0.385144193447218));\n    } else {\n        p = vec2[3](vec2(0.5, 0), vec2(-0.5, 0), vec2(0, 0));\n        v = vec2[3](vec2(0, 0.3), vec2(0, 0.3), vec2(0, -0.6));\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 uv = ivec2(fragCoord);\n    int objIdx = uv.y / 3;\n    int localIdx = uv.y % 3;\n\n    vec2[3] p, v;\n\n    if (uv.x == 0 && uv.y < 18) {\n        if (iFrame == 0) {\n            initState(objIdx, p, v);\n        } else {\n            for (int i = 0; i < 3; i++) {\n                vec4 data = texelFetch(iChannel0, ivec2(0, objIdx * 3 + i), 0);\n                p[i] = data.xy;\n                v[i] = data.zw;\n            }\n            #ifdef USE_ADAPTIVE_RK45\n                adaptiveRK45(p, v);\n            #else\n                RK4(p,v);\n            #endif\n        }\n        fragColor = vec4(p[localIdx], v[localIdx]);\n    } else if (uv.x > 0 && uv.x < NTRAIL && uv.y < 18) {\n        vec4 prev = texelFetch(iChannel0, ivec2(uv.x - 1, uv.y), 0);\n        fragColor = vec4(prev.xy, 0.0, 1.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define USE_ADAPTIVE_RK45\n\n#define NTRAIL           300\n#define G                1.0\n#define MaxIterEachStep  40",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "/**\nPeriodic solutions of the three body problem (equal mass)\n\nUse adaptive RK45 with a fixed number of max iterations\n\n*/\n\n#define get(n, i) texelFetch(iChannel0, ivec2(i, n), 0).xy\n\nconst vec3 col[3] = vec3[3](\n    vec3(0.1, 0.9, 0.1),\n    vec3(0.9, 0.05, 0.05),\n    vec3(0.02, 0.02, 0.8));\nconst vec3 weights = vec3(0.299, 0.587, 0.114);\n\nconst float lum[3] = float[3](dot(col[0], weights),\n                              dot(col[1], weights),\n                              dot(col[2], weights));\n\nconst float scales[6] = float[6](2.1, 2.8, 3.4, 2.0, 1.7, 1.9);\n\nconst float fade = 0.025;\nconst float trail_strength = 0.008;\nconst float particle_strength = 0.04;\n\nvec3 glowPoint(vec2 p, vec2 center, vec3 col, float lum, float strength) {\n    float d = max(abs(length(p - center)), 1e-5);\n    d = pow(strength / d, 4.);\n    d /= lum*30.;\n    return 1.0 - exp(-d * col);\n}\n\nvec2 sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float d = length(pa - ba * h);\n    d = max(abs(d), 1e-5);\n    return vec2(d, h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    ivec2 grid = ivec2(3, 2);\n    ivec2 cell = ivec2(uv * vec2(grid));\n    int simIndex = cell.y * grid.x + cell.x;\n\n    vec2 cellCenter = (vec2(cell) + 0.5) / vec2(grid);\n    vec2 shift = vec2(0);\n\n    vec2 localUV = (uv - cellCenter) * vec2(grid);\n    float aspect =\n        (iResolution.x / float(grid.x)) / (iResolution.y / float(grid.y));\n    localUV.x *= aspect;\n\n    float zoom = scales[simIndex];\n    localUV *= zoom;\n\n    if (simIndex == 4)\n        shift = vec2(-0.15, 0.1);\n    else if (simIndex == 5)\n        shift = vec2(0.1, -0.1);\n    localUV -= shift;\n\n    vec3 color = vec3(0.0);\n\n\n    for (int j = 0; j < 3; j++) {\n        int idx = simIndex * 3 + j;\n        vec2 end = get(idx, 0);\n        color += glowPoint(localUV, end, col[j], lum[j], particle_strength);\n    }\n    \n    fragColor = texture(iChannel1, uv)*0.998;\n\n    fragColor +=\n        vec4(pow(clamp(color, 0.0, 1.0), vec3(0.4545)), 1.0)*0.04;\n        \n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WXdSzX",
    "date": "1753734125",
    "viewed": 66,
    "name": "Fine Derivative test",
    "description": "Test to see if fine derivatives are available, checks to see if dFdx is same for row above/below, red screen means no fine derivatives.\nI'm unlisting this shader, check Fabrice's version in the comments, it is better",
    "likes": 1,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "derivatives",
     "dfdx",
     "dfdy",
     "fwidth",
     "fine",
     "coarse"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 samp = texelFetch(iChannel0,  ivec2(fragCoord), 0);\n    vec4 sampU = texelFetch(iChannel0,  ivec2(fragCoord)+ivec2(0,1), 0);\n    vec4 sampD = texelFetch(iChannel0,  ivec2(fragCoord)+ivec2(0,-1), 0);\n    \n    if(samp==sampU || samp==sampD){\n        fragColor = vec4(1,0,0,1);\n    } else {\n        fragColor = samp;\n    }\n    //fragColor = samp;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dfGRn",
       "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 samp = texture(iChannel0, uv, 0.);\n    vec4 sxd = dFdx(samp);\n    fragColor = sxd;\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WXdSWf",
    "date": "1754005951",
    "viewed": 6,
    "name": "moving hippy energy+supersample",
    "description": "added supersampling",
    "likes": 1,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "colorful"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"moving hippy energy\" by nayk. https://shadertoy.com/view/t33SDf\n// 2025-07-31 23:49:15\n\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define PI_2        (0.5*3.141592654)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 p) {\n  float a = dot (p, vec2 (127.1, 311.7));\n  return fract (sin(a)*43758.5453123);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float logo_radius= 0.25;\nconst float logo_off   = 0.25;\nconst float logo_dx    = 0.5/sqrt(3.0);\nconst float logo_width = 0.1;\n\nfloat rcp(float x) {\n  return 1.0 / x;\n}\n\n//P. Gilcher '21, strange approximation\n// Source found at: https://www.shadertoy.com/view/flSXRV\nfloat fast_atan2(float y, float x) {\n  float cosatan2 = x * rcp(abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d\nfloat hex(vec2 p, float r) {\n  const vec3 k = vec3(-sqrt(3.0)*0.5,0.5,sqrt(1.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = 2.0*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/index.htm\nvec3 postProcess(vec3 col, vec2 q) {\n  //  Found this somewhere on the interwebs\n  col = clamp(col, 0.0, 1.0);\n  // Gamma correction\n  col = pow(col, 1.0/vec3(2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  // Vignetting\n  col*= 0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return pmax(a, -a, k);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nfloat stripes(float d) {\n  const float cc = 0.42;\n  d = abs(d)-logo_width*cc;\n  d = abs(d)-logo_width*cc*0.5;\n  return d;\n}\n\nvec4 merge(vec4 s0, vec4 s1) {\n  bool dt = s0.z < s1.z; \n  vec4 b = dt ? s0 : s1;\n  vec4 t = dt ? s1 : s0;\n\n  b.x *= 1.0-exp(-max(80.0*(t.w), 0.0));\n\n  vec4 r = vec4(\n      mix(b.xy, t.xy, t.y)\n    , b.w < t.w ? b.z : t.z \n    , min(b.w, t.w)\n    );\n  \n  return r;\n}\n\nvec4 figure_8(float aa, vec2 p) {\n  vec2  p1 = p-vec2(logo_dx, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = fast_atan2(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec2  p2 = p-vec2(logo_dx, logo_off);\n  float d2 = abs(circle(p2, logo_radius));\n  float a2 = fast_atan2(p2.x, p2.y);  \n  float s2 = stripes(d2);\n  float o2 = d2 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n  vec4 c1 = vec4(smoothstep(aa, -aa, s2), smoothstep(aa, -aa, o2), a2, o2);\n\n  return merge(c0, c1);\n}\n\nvec4 figure_half_8(float aa, vec2 p) {\n  vec2  p1 = p-vec2(logo_dx, -logo_off);\n  float d1 = abs(circle(p1, logo_radius));\n  float a1 = fast_atan2(-p1.x, -p1.y);\n  float s1 = stripes(d1);\n  float o1 = d1 - logo_width;\n\n  vec4 c0 = vec4(smoothstep(aa, -aa, s1), smoothstep(aa, -aa, o1), a1, o1);\n\n  return c0;\n}\n\nvec2 flipy(vec2 p) {\n  return vec2(p.x, -p.y);\n}\n\nvec4 clogo(vec2 p, float z, out float d) {\n  float iz = 1.0/z;\n  p *= iz;\n  float aa = iz*2.0/RESOLUTION.y;\n  float  n = modPolar(p, 3.0);\n\n  vec4 s0 = figure_8(aa, p);\n  vec4 s1 = figure_half_8(aa, p*ROT(2.0*PI/3.0));\n  vec4 s2 = figure_half_8(aa, flipy(p*ROT(4.0*PI/3.0)));\n  s1.z += -PI;\n  \n  vec4 s = s0;\n  s = merge(s, s1);\n  s = merge(s, s2);\n\n  d = s.w;\n  vec3 hsv = vec3(fract(s.z/PI+TIME*0.5), 0.9, 1.0);\n  return vec4(hsv2rgb(hsv)*s.x, s.y);\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float aa = 2.0/RESOLUTION.y;\n\n  float d;\n  float a = TAU*TIME/300.0;\n  p += 10.0*vec2(sin(a), sin(sqrt(0.5)*a));\n  vec2 hp = p;\n  vec2 np = hextile(hp);\n  float hd = hex(hp.yx, 0.5);\n  hd = abs(hd) - 2.0*aa;\n  vec2 cp = hp;\n  float h = hash(np);\n  float hh = fract(137.0*h);\n  float sm = mix(mix(0.025, 0.25, hh), 0.025, h);\n  float rep = 2.0*floor(mix(8.0, 30.0, h));\n  float cn = smoothKaleidoscope(cp, sm, rep);\n  cp *= ROT(TIME*0.2+TAU*h);\n  \n  vec4 ccol = clogo(cp, 0.6, d);\n  vec3 gcol = hsv2rgb(vec3(h, 0.8, 4.0));\n  vec3 col  = vec3(0.0);\n  col += gcol*exp(-50.0*max(d, 0.0));\n  col = mix(col, vec3(0.2), smoothstep(aa, -aa, hd));\n  col = mix(col, ccol.xyz, ccol.w);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  p/=1.-p.y*0.5;\n     float rep =3.0;\nvec3 r2 = normalize(vec3(p.xy, 1.0 - dot(p.xy, p.xy) *30.5));\n   r2.xy/=1.-r2.y*0.5;\nr2*=10.;\nr2.xz+=5.*iMouse.xy/RESOLUTION.xy;\nr2.xy+=5.*iMouse.xy/RESOLUTION.xy;\n    float r3 = normalize(vec3(length(p),0.1,0.51)).x;\n    float a3 = log2(r3) - iTime * 1.522;\n    a3 *= rep /3.14;\n    float theta = atan(p.y, p.x);\n    theta *= rep /3.14;\n    vec2 polarUV = vec2(theta, a3);\n   \n\n\n  \n  p.xy+=fract(r2.xy-p.xy);\n\np*=10.;\n\n  vec3 col = effect(p, q);\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// from \"Weyl Supersample Any Shader\" by spalmer https://www.shadertoy.com/view/WXjXRt\n// (forked from from \"postprocess existing shaders\" by FabriceNeyret2 https://www.shadertoy.com/view/NdyfRz )\n// This is what makes it smooth\n// s is number of samples per pixel\n// 64 or more is very high, but it looks good.\n// Change to 1 to see original shader\n\n#define mainImage mainImage0(out vec4 O, vec2 U); \\\nvoid mainImage(out vec4 o, vec2 u) \\\n{ \\\n    float s = 32., k; \\\n    if(u.x>iResolution.x/2.){s=1.;} \\\n    vec2 j = vec2(.5); \\\n    o = vec4(0); \\\n    vec4 c; \\\n    mainImage0(c, u); \\\n    for (k = s; k-- > .5; ) { \\\n        mainImage0(c, u + j - .5); \\\n        o += c; \\\n        j = fract(j + vec2(.754877669, .569840296).yx); \\\n        \\\n    };o /= s;o.a==1.;\\\n    \\\n} \\\nvoid mainImage0",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "w3dSDs",
    "date": "1754097449",
    "viewed": 101,
    "name": "Noisy geometry god",
    "description": "Adding audio to an old shader, ended up here, not exactly what I was looking for, but interesting.",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "random",
     "audio",
     "generative",
     "code",
     "feedback",
     "geometry",
     "angrygod"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4df3Rn",
       "filepath": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Angry geometry god\" by Cotterzz. https://shadertoy.com/view/tftGD4\n// 2025-08-02 01:15:44\n\n// Fork of \"Random Generative Shaders v5\" by Cotterzz. https://shadertoy.com/view/wf3GRN\n// 2025-05-13 06:05:43\n\n// Fork of \"Random Generative Shaders v4\" by Cotterzz. https://shadertoy.com/view/Wcc3RH\n// 2025-05-10 06:21:07\n\n// Fork of \"Random Generative Shaders v3\" by Cotterzz. https://shadertoy.com/view/Wc33zr\n// 2025-05-09 06:01:58\n\n// Fork of \"Random Generative Shader v2\" by Cotterzz. https://shadertoy.com/view/3XjSWd\n// 2025-05-08 15:40:19\n\n// Fork of \"Random Generative Shader\" by Cotterzz. https://shadertoy.com/view/W3BXDd\n// 2025-05-08 04:36:29\n\n#define NEWVALUE values[int(floor(float(v)*GNF()))] \n#define NEWVALUE2 values[int(floor(float(v)*GNF()))] \n\nint PALETTE = 9;\n\nint note = -1;\n\nfloat cen = 0.;\n\nfloat GNF(){\n    note+=1;\n    if(note>=512){note=0;}\n    float r = texture(iChannel0, vec2(float(note)/512.,0)).r;\n    return (r + (r/cen))/2.;\n}\n\nfloat rand(float n){return fract(cos(n*89.42)*343.42);}\n\nfloat nz(vec2 nv){\n    float o = 0.;\n    for (float i = .2; i < 2.;\n    o += abs(dot(sin(nv * i * 64.), vec2(.05))) / i,\n    i *= 1.4142);\n    return mix(o,  distance(vec2(0), nv), 0.5 + (sin(iTime)/2.));\n}\n\nfloat rMix(float a, float b, float s){\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?nz(vec2(a,b)):s>0.3?b/(a==0.?0.01:a):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n}\n\nvec3 gpc(float t) {\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 contrast(vec3 color, float value) {return 0.5 + value * (color - 0.5);}\n\nvec3 addColor(float num, float seed, float alt){\n    if(isinf(num)){num = alt * seed;}\n    if(PALETTE == 7){\n        vec3 col = contrast(gpc(num),1.7);\n        return col;} else if(PALETTE > 2 || (PALETTE == 1 && rand(seed+19.)>0.3)){\n        float sat = 1.;\n        if(num<0.){sat = 1.-(1./(abs(num)+1.));}\n        float light = 1.0-(1./(abs(num)+1.));\n        vec3 col = hsl2rgb(vec3(fract(abs(num)), sat, light));\n        if(PALETTE == 1){col *= 2.;}\n        return col;\n    } else {\n        vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n        if(rand(seed*2.)>0.5){col = col.gbr;}\n        if(rand(seed*3.)>0.5){col = col.gbr;}\n        if(PALETTE == 1){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n        return col;\n    }\n}\n\nvec3 sanitize(vec3 dc){\n    dc.r = min(1., dc.r);\n    dc.g = min(1., dc.g);\n    dc.b = min(1., dc.b);\n    \n    if(!(dc.r>=0.) && !(dc.r<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.g>=0.) && !(dc.g<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.b>=0.) && !(dc.b<0.)){\n        return vec3(1,0,0);\n    } else {\n        return dc;\n    }\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    float zoom = 8.;\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    float o = nz(guv);\n    float seed = floor(iTime/1.0);\n    PALETTE = int(floor(float(8)*rand(seed+66.)));\n    const int v = 24;\n    vec3 col = vec3(0);\n    float cn = 1.;\n    float values[v];\n    values[0] = texture(iChannel0, vec2(x,0)).r;\n    values[1] = texture(iChannel0, vec2(x,1)).r;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = texture(iChannel0, vec2(y,1)).r;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = texture(iChannel0, vec2(y,0)).r;\n   values[21] = atan(x, y)*4.;\n   values[22] = o;\n   values[23] = distance(vec2(x,y), vec2(0))*sin(atan(x, y));\n   \n   cen = values[19];\n   \n    float total = 0.;\n    float sub = 0.;\n    int maxi = 20; int mini = 5;\n    int iterations = min(maxi,mini + int(floor(GNF()*float(maxi-mini))));\n    \n    for(int i = 0; i<iterations; i++){\n        if(GNF()>0.5){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, GNF()) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, GNF()), GNF());\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, GNF());\n        }\n        if(abs(sub)<1.){PALETTE = int(floor(float(8)*GNF()));}\n        if(GNF()>GNF()/2.){\n            total = total==0. ? sub : rMix(total, sub,GNF());\n            sub = 0.;\n            col += addColor(total, GNF(), values[21]);\n            cn+=1.;\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, GNF());\n    col += addColor(total, GNF(), values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + GNF()));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(GNF()>0.5){col = col.gbr;}\n        if(GNF()>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n    fragColor = vec4(col, 1.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wXVXzR",
    "date": "1754166000",
    "viewed": 86,
    "name": "FFT Audio Visualiser",
    "description": "Seeing how much information I can get out of the very limited 512 pixels of fft data.\nUsing a bit of time and frequency differential to amplify the sounds.",
    "likes": 7,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fft",
     "audio"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4sXGzn",
       "filepath": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 fcr = fragCoord;\n    if(fcr.x>=512.){fcr.x-=512.;}\n    vec2 uvr =  fcr/iResolution.xy;\n    vec3 col = vec3(0);\n    vec3 fcol = texture(iChannel0, vec2(fcr.x/512.,0.), 0.).rgb;\n    vec3 fcolr = texture(iChannel0, vec2((fcr.x+1.)/512.,0.), 0.).rgb;\n    vec3 fcoll = texture(iChannel0, vec2((fcr.x-1.)/512.,0.), 0.).rgb;\n    vec3 fcolo = texture(iChannel1, vec2(uvr.x,0.), 0.).rgb;\n    float dxr = fcol.r-fcolr.r;\n    float dxl = fcol.r-fcoll.r;\n    float dxt = max(0.,dxr+dxl);\n    float dxo = max(0.,fcol.r-fcolo.r);\n    float r2 = fcol.r * (0.4 + (fcr.x/300.));\n    r2 = mix(r2, fcol.r, fcr.x/1100.);\n    float r3 = max(0.,r2+(dxt));\n    float r4 = max(0.,r2+(dxo*1.5));\n    float r5 = max(0.,(r2/2.)+(dxt*2.)+(dxo))*2.;\n    if(fragCoord.x<512.){\n        if(fragCoord.y< 10.){col=fcol;}\n        else if(fragCoord.y< (10. + (fcol.r*100.))){col=vec3(0.5,0,0);}\n        else if(fragCoord.y< (110. + (r2*100.))){col=vec3(0.7,0.3,0);}\n        else if(fragCoord.y< (210. + (r3*100.))){col=vec3(1.0,1.0,0);}\n        else if(fragCoord.y< (310. + (r4*100.))){col=vec3(0.0,1.0,0);}\n        else if(fragCoord.y< (410. + (r5*100.))){col=vec3(0.0,0.4,1.0);}\n    } else if(fragCoord.x<1024.){\n        vec3 ocol = vec3(4.*dxt,r5/1.5,4.*dxo);\n        if(fragCoord.y< 10.){col=ocol;} else {col = texture(iChannel1, vec2(uv.x,uv.y-(1./iResolution.y)), 0.).rgb;}\n    }\n    fragColor = vec4(col,1.0);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3XGXRW",
    "date": "1754255998",
    "viewed": 77,
    "name": "Random Volumetric V2",
    "description": "I was just playing around with [url=https://shadertoy.com/view/3fc3Dn]this shader[/url] and I think I like it more now, the scrolling volume is no longer visible, but the overall effect is it's own thing.\nClick on the canvas to change the pattern",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "random",
     "volumetric",
     "generative",
     "code"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Random Volumetric Shader\" by Cotterzz. https://shadertoy.com/view/3fc3Dn\n// 2025-08-03 21:08:55\n\n// Fork of \"Random Generative Shaders v5\" by Cotterzz. https://shadertoy.com/view/wf3GRN\n// 2025-05-10 22:57:51\n\n// Fork of \"Random Generative Shaders v4\" by Cotterzz. https://shadertoy.com/view/Wcc3RH\n// 2025-05-10 06:21:07\n\n// Fork of \"Random Generative Shaders v3\" by Cotterzz. https://shadertoy.com/view/Wc33zr\n// 2025-05-09 06:01:58\n\n// Fork of \"Random Generative Shader v2\" by Cotterzz. https://shadertoy.com/view/3XjSWd\n// 2025-05-08 15:40:19\n\n// Fork of \"Random Generative Shader\" by Cotterzz. https://shadertoy.com/view/W3BXDd\n// 2025-05-08 04:36:29\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n    fragColor.rgb = contrast(fragColor.rgb, 1.5);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "float hash1(vec2 x)\n{\n    uvec2 t = floatBitsToUint(x);\n    uint h = 0xc2b2ae3du * t.x + 0x165667b9u;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h += 0xc2b2ae3du * t.y;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h ^= h >> 15u;\n    h *= 0x85ebca77u;\n    h ^= h >> 13u;\n    h *= 0xc2b2ae3du;\n    h ^= h >> 16u;\n    return uintBitsToFloat(h >> 9u | 0x3f800000u) - 1.0;\n}\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\nvec2 hash2(vec2 x) // improved hash using xxhash\n{\n    float k = 6.283185307 * hash1(x);\n    return vec2(cos(k), sin(k));\n}\n\nfloat noise2( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*vec3( dot(a,hash2(i+0.0)), dot(b,hash2(i+o)), dot(c,hash2(i+1.0))); // changed to h^3 [1]\n    return dot( n, vec3(32.99) ); // analytic factor (= 2916*sqrt(2)/125)\n}\n\nfloat pnoise (vec2 uv){\n    float f = 0.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2( uv ); uv = m*uv;\n    f += 0.2500*noise2( uv ); uv = m*uv;\n    f += 0.1250*noise2( uv ); uv = m*uv;\n    f += 0.0625*noise2( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n    return f;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i)))\n#define NEWVALUE2 values[int(floor(float(v)*rand(seed+float(i+5))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i+5)))\n#define T (iTime*4.)\n#define rot(a) mat2(cos(a+vec4(0,33,11,0)))\n#define P(z) (vec3(tanh(cos((z) * .15) * 1.) * 8., \\\n                   tanh(cos((z) * .12) * 1.) * 8., (z)))\n\n\n// PREVIEW 0 to disable preview mode\n// SHOWITER 0 to disable iterations view\n// select palette mode below\n\n#define PREVIEW 0\n#define SHOWITER 0\n#define VOLUMETRIC 1\n\nfloat displaytime = 2.5; // seconds between switch\n\nint PALETTE = 9;\n\n// 0 = Original\n// 1 = Original with hsl mixed\n// 2 = Original translated to hsl\n// 3 = hsl calculated\n// 4 = hsl enhanced\n// 5 = hsl*2\n// 6 = weird\n// 7 = fhex\n// 8 = Banded.\n// 9 = RANDOMISE!!!\n\nvec3 p = vec3(0);\n\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\nfloat map(vec3 p) {\n    return 1.5 - length(p - P(p.z));\n}\nfloat rMix(float a, float b, float s){\n    s = rand(s);\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?b/(a==0.?0.01:a):s>0.3?pnoise(vec2(a,b)):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n}\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nvec3 gmc(vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\nvec3 fhexRGB(float fh){\n    if(isinf(fh)||fh>100000.){fh = 0.;}\n    fh = abs(fh*10000000.);\n    float r = fract(fh/65536.);\n    float g = fract(fh/256.);\n    float b= fract(fh/16777216.);\n    //return gmc(contrast(hsl2rgb(vec3(r,g,b)), 0.9), 0.9);\n   return hsl2rgb(vec3(r,g,b));\n}\n\nvec3 addColor(float num, float seed, float alt){\n    if(isinf(num)){num = alt * seed;}\n    if(PALETTE == 7){\n        vec3 col = fhexRGB(num);\n        return col;} else if(PALETTE > 2 || (PALETTE == 1 && rand(seed+19.)>0.3)){\n    \n        float sat = 1.;\n        if(num<0.){sat = 1.-(1./(abs(num)+1.));}\n        float light = 1.0-(1./(abs(num)+1.));\n\n        vec3 col = hsl2rgb(vec3(fract(abs(num)), sat, light));\n        if(PALETTE == 1){col *= 2.;}\n       \n        return col;\n       \n    } else {\n\n        vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n        if(rand(seed*2.)>0.5){col = col.gbr;}\n        if(rand(seed*3.)>0.5){col = col.gbr;}\n        if(PALETTE == 1){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n        // if(PALETTE == 0){col = contrast(col, 1.01); }\n        return col;\n    \n    }\n}\n\nvec3 sanitize(vec3 dc){\n    dc.r = min(1., abs(dc.r));\n    dc.g = min(1., abs(dc.g));\n    dc.b = min(1., abs(dc.b));\n    \n    if(!(dc.r>=0.) && !(dc.r<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.g>=0.) && !(dc.g<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.b>=0.) && !(dc.b<0.)){\n        return vec3(1,0,0);\n    } else {\n        return dc;\n    }\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n     vec3  r = iResolution;\n    vec2 u = fragCoord;\n    \n        \n        float s=.002,d,i, l;\n\n        u = (u-r.xy/2.)/r.y;\n    \n        vec3  p = P(T),ro=p,q,\n              Z = normalize( P(T+1.)  - p),\n              X = normalize(vec3(Z.z,0,-Z)),\n              D = vec3(rot(tanh(sin(p.z*.03)*8.)*3.)*u, 1)* mat3(-X, cross(X, Z), Z);\n       \n        for(; i++<80. && s > .001; ) {\n    \n            p = ro + D * d,\n            s = map(p)*.8,\n            d += s;\n        }\n        p = ro + D * d;\n        \n    vec2 uv = fragCoord/iResolution.y;\n    vec2 uvd = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    float zoom = 4.;\n    if(VOLUMETRIC == 1 ){ zoom+= (1.5*(sin(iTime)+1.)); } else { zoom+= (3.*(sin(iTime)+1.));}\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    \n    float ix = 468.;\n    float iy = 330.;\n    if(iMouse.x>0.&&iMouse.y>0.){\n    ix = iMouse.x; iy = iMouse.y;}\n    \n    float thumb = 5.+sin((iTime/2.)-1.62)*2.;\n    \n    if(!(iMouse.z>0.)&& bool(PREVIEW)){\n        float pantime = (iTime)+50.;\n\n        ix = floor(pantime+(uv.x*thumb/(iResolution.x/iResolution.y)));\n        iy = floor((pantime+(uv.y*thumb)));\n\n        uv.y*=thumb;\n        uv.x*=thumb/(iResolution.x/iResolution.y);\n        uv+=pantime;\n        uv=fract(uv);\n        uv.x-=0.5;\n        uv.y-=0.5;\n        guv = (uv*zoom);\n        x = guv.x;\n        y = guv.y;\n    }\n    \n    float seed = (ix + (iy*iResolution.x))/iResolution.x;\n    \n    if(!(iMouse.z>0.) && iMouse.x==0. && iMouse.y==0.){\n        seed = floor(iTime+50./displaytime);\n    }\n    \n    if(PALETTE == 9){\n        PALETTE = int(floor(float(8)*rand(seed+66.)));\n    }\n\n    if(PALETTE == 8){\n        PALETTE = int(floor(fragCoord.x/iResolution.x * 8.));\n    }\n    \n    const int v = 24;\n    \n    vec3 col = vec3(0);\n    float cn = 1.;\n    \n    float values[v];\n    \n    values[0] = 1.0;\n    values[1] = p.x;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = p.y;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = p.z;\n   values[21] = atan(x, y)*4.;\n   values[22] = pnoise(vec2(x,y)/2.);\n   values[23] = pnoise(vec2(y,x)*10.);\n   \n    float total = 0.;\n    float sub = 0.;\n    int maxi = 40; int mini = 4;\n    int iterations = min(maxi,mini + int(floor(rand(seed*6.6)*float(maxi-mini))));\n    \n    \n    \n    \n    for(int i = 0; i<iterations; i++){\n        if(rand(seed+float(i+3))>rand(seed)){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)), seed+float(i));\n\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i));\n      \n        }\n        if(rand(seed+float(i))>rand(seed)/2.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2));\n            sub = 0.;\n            if(rand(seed+float(i+30))>rand(seed)){\n                col += addColor(total, seed+float(i), values[21]);\n                cn+=1.;\n            }\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, seed);\n    col += addColor(total, seed, values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + rand(seed+13.)));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(rand(seed+17.)>0.5){col = col.gbr;}\n        if(rand(seed+19.)>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n    if(VOLUMETRIC == 1 ) { \n    uv+=vec2(0.25,0.15);\n    //if(uvd.x<uvd.y){if(abs(uv.x)>0.6 || abs(uv.y)>0.32){col=vec3(0);}}\n    float xspeed = ar*4.*(iMouse.x/iResolution.x);\n    float yspeed = 4.*(iMouse.y/iResolution.y);\n    vec3 old = textureLod(iChannel0, (fragCoord+vec2(-xspeed,-yspeed))/iResolution.xy, 0.).rgb;\n    float alph = (col.r+col.g+col.b)/5.;\n    //if(uvd.x<uvd.y){alph = alph<0.5?0.0:alph<0.7?(alph-0.5)*5.:1.0;}\n    //alph = alph<0.25?0.0:alph<0.5?(alph-0.25)*5.:1.0;\n    fragColor = vec4(mix(old, col, alph), 1.);\n    } else {\n    fragColor = vec4(col, 1.);\n    }\n\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "33GXzD",
    "date": "1754270036",
    "viewed": 91,
    "name": "Per-Pixel Particle BufferView",
    "description": "Fork of [url=https://shadertoy.com/view/ll3SWs]this shader[/url]\nAmazing particle shader from 2016 by huwb\nAdded buffer view tab to see what is going on.",
    "likes": 11,
    "published": "Public",
    "usePreview": 1,
    "tags": [
     "2d",
     "simulation",
     "particles",
     "dynamics"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGR8",
       "filepath": "/media/previz/buffer03.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Per-Pixel Particle Party!\" by huwb. https://shadertoy.com/view/ll3SWs\n// 2025-08-04 01:10:24\n\n/* Use this code on your image tab to view the four different buffers as thumbnails.\nRemember to set up the four buffers in the iChannel screens at the bottom.\nClick on thumbnail to see it in main window\n*/\n\n// set this to 0 to only show thumbs on mouse down\n\n#define ALWAYSSHOW 1  \nvec2 getOUV(vec2 suv, vec4 sq){ vec2 nuv = vec2(sq.x + ((sq.z-sq.x)*suv.x), sq.y + ((sq.w-sq.y)*suv.y)); return nuv;}\nvec2 getSUV(vec2 uv, vec4 sq){  return vec2 ( (uv.x-sq.x) / (sq.z-sq.x) , (uv.y-sq.y) / (sq.w-sq.y) ); }\nbool isin(vec2 co, vec4 sq){ return ( co.x >= sq.x && co.x <= sq.z && co.y >= sq.y && co.y <= sq.w ); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float vb = 0.02;\n    float hb = vb/ar;\n    float th = (1. - (vb*5.))/4.;\n    float tw = th*ar/2.;\n    vec4  sc1 = vec4(1.-(tw+hb), vb, 1.-hb, vb+th);\n    \n    vec4  sc2 = sc1;  sc2.yw += (vb+th);\n    vec4  sc3 = sc2;  sc3.yw += (vb+th);\n    vec4  sc4 = sc3;  sc4.yw += (vb+th);\n    \n  \n   \n   if(isin(muv, sc1)){fragColor = texture(iChannel0, uv, 0.);}\n   else if(isin(muv, sc2)){fragColor = texture(iChannel1, uv, 0.);}\n   else if(isin(muv, sc3)){fragColor = texture(iChannel2, uv, 0.);}\n   else if(isin(muv, sc4)){fragColor = texture(iChannel3, uv, 0.);}\n    else {\n    \n         // just copy Buffer D\n         fragColor = texture(iChannel3, fragCoord/iResolution.xy, 0.);\n           \n         /*\n         Alternatively, if you wanted to do more processing in the Image tab for a fifth final image, do it here.\n         And if you already have a mainImage function in the Image tab, you can just rename it mainImage0\n         And call it with:\n         mainImage0(fragColor, fragCoord);\n         */\n         \n        }\n   \n   if(iMouse.z>0. || ALWAYSSHOW ==1){\n       if(isin(uv, sc1)){fragColor = texture(iChannel0, getSUV(uv,sc1), 0.);}\n       if(isin(uv, sc2)){fragColor = texture(iChannel1, getSUV(uv,sc2), 0.);}\n       if(isin(uv, sc3)){fragColor = texture(iChannel2, getSUV(uv,sc3), 0.);}\n       if(isin(uv, sc4)){fragColor = texture(iChannel3, getSUV(uv,sc4), 0.);}\n   }\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "\n// scene data\n#define HOSE vec2(0.5,0.5)\n#define ATTRACTOR vec2(1.5,0.5)\n#define COL0 vec2(2.5,0.5)\n#define COL1 vec2(3.5,0.5)\n#define COL2 vec2(4.5,0.5)\n#define HOSE_TARGET vec2(5.5,0.5)\n#define MOUSE vec2(6.5,0.5)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( fragCoord.y > 1. )\n        return;\n    \n    vec4 hoseData = textureLod(iChannel2, HOSE/iResolution.xy, 0.);\n    vec4 attrData = textureLod(iChannel2, ATTRACTOR/iResolution.xy, 0.);\n    vec4 col0Data = textureLod(iChannel2, COL0/iResolution.xy, 0.);\n    vec4 col1Data = textureLod(iChannel2, COL1/iResolution.xy, 0.);\n    vec4 col2Data = textureLod(iChannel2, COL2/iResolution.xy, 0.);\n    vec4 hoseTargetData = textureLod(iChannel2, HOSE_TARGET/iResolution.xy, 0.);\n    vec4 mouseOld = textureLod(iChannel2, MOUSE/iResolution.xy, 0.);\n    \n    bool clickEvent = mouseOld.z <= 0. && iMouse.z > 0.;\n    bool curDragging = hoseData.z + attrData.z + col0Data.z + col1Data.z + col2Data.z > 0.;\n    \n    if( fragCoord == HOSE )\n    {\n        if( iFrame == 0 )\n            fragColor = vec4(50., 200., 0., 0.);\n        else\n            fragColor = hoseData;\n        \n        vec2 moff = iMouse.xy-fragColor.xy;\n        if( iMouse.z <= 0. )\n        {\n            fragColor.z = 0.;\n        }\n        else if( (!curDragging && clickEvent && dot(moff,moff)<=11.*11.) || fragColor.z > 0. )\n        {\n            fragColor.z = 1.;\n            fragColor.xy = iMouse.xy;\n        }\n    }\n    else if( fragCoord == ATTRACTOR )\n    {\n        if( iFrame == 0 )\n            fragColor = vec4( 510., 100., 0., 0.);\n        else\n            fragColor = attrData;\n        \n        vec2 moff = iMouse.xy-fragColor.xy;\n        if( iMouse.z <= 0. )\n        {\n            fragColor.z = 0.;\n        }\n        else if( (!curDragging && clickEvent && dot(moff,moff)<=6.*6.) || fragColor.z > 0. )\n        {\n            fragColor.z = 1.;\n            fragColor.xy = iMouse.xy;\n        }\n    }\n    else if( fragCoord == COL0 )\n    {\n        if( iFrame == 0 )\n            fragColor = vec4( iResolution.xy/2. + vec2(-100.,20.), 0., 0.);\n        else\n            fragColor = col0Data;\n        \n        vec2 moff = iMouse.xy-fragColor.xy;\n        if( iMouse.z <= 0. )\n        {\n            fragColor.z = 0.;\n        }\n        else if( (!curDragging && clickEvent && dot(moff,moff)<=50.*50.) || fragColor.z > 0. )\n        {\n            fragColor.z = 1.;\n            fragColor.xy = iMouse.xy;\n        }\n    }\n    else if( fragCoord == COL1 )\n    {\n        if( iFrame == 0 )\n            fragColor = vec4( iResolution.xy/2. + vec2(-130.,-100.), 0., 0.);\n        else\n            fragColor = col1Data;\n        \n        vec2 moff = iMouse.xy-fragColor.xy;\n        if( iMouse.z <= 0. )\n        {\n            fragColor.z = 0.;\n        }\n        else if( (!curDragging && clickEvent && dot(moff,moff)<=50.*50.) || fragColor.z > 0. )\n        {\n            fragColor.z = 1.;\n            fragColor.xy = iMouse.xy;\n        }\n    }\n    else if( fragCoord == COL2 )\n    {\n        if( iFrame == 0 )\n            fragColor = vec4( iResolution.xy/2. + vec2(-20.,-80.), 0., 0.);\n        else\n            fragColor = col2Data;\n        \n        vec2 moff = iMouse.xy-fragColor.xy;\n        if( iMouse.z <= 0. )\n        {\n            fragColor.z = 0.;\n        }\n        else if( (!curDragging && clickEvent && dot(moff,moff)<=50.*50.) || fragColor.z > 0. )\n        {\n            fragColor.z = 1.;\n            fragColor.xy = iMouse.xy;\n        }\n    }\n    else if( fragCoord == HOSE_TARGET )\n    {\n        if( iFrame == 0 )\n            fragColor = vec4(iResolution.xy/2.,0.,0.);\n        else\n            fragColor = hoseTargetData;\n        \n        if( !curDragging && iMouse.z > 0. && !clickEvent )\n            fragColor.xy = iMouse.xy;\n    }\n    else if( fragCoord == MOUSE )\n    {\n        fragColor = iMouse;\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "Xsf3zn",
       "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Buf A is a uniform grid data structure, but storage in each pixel is 1 particle\n// (.xy=vel, .zw=pos). For each bucket, searches neighbourhood for newly arriving particle,\n// greedily takes first one so particles can annihilate each other if they land in the same\n// pixel bucket.\n\n// Flock or perhaps even SPH behavious could probably be implemented on a similar framework.\n\n#define R 5.\n#define RESTITUTION .5\n\n// scene data\n#define HOSE vec2(.5,.5)/iResolution.xy\n#define ATTRACTOR vec2(1.5,0.5)/iResolution.xy\n#define COL0 vec2(2.5,0.5)/iResolution.xy\n#define COL1 vec2(3.5,0.5)/iResolution.xy\n#define COL2 vec2(4.5,0.5)/iResolution.xy\n#define HOSE_TARGET vec2(5.5,0.5)/iResolution.xy\n\nvec2 GetVel( vec4 part ) { return part.xy; }\nvoid SetVel( inout vec4 part, vec2 newVel ) { part.xy = newVel; }\nvec2 GetPos( vec4 part ) { return part.zw; }\nvoid SetPos( inout vec4 part, vec2 newPos ) { part.zw = newPos; }\n\nvec2 FindArrivingParticle( vec2 arriveCoord, out vec4 partData )\n{\n    for( float i = -R; i <= R; i++ )\n    {\n        for( float j = -R; j <= R; j++ )\n        {\n            vec2 partCoord = arriveCoord + vec2( i, j );\n            \n            vec4 part = textureLod( iChannel0, partCoord / iResolution.xy, 0. );\n            \n            // particle in this bucket?\n            if( dot(part,part) < 0.001 )\n                continue;\n            \n            // is the particle going to arrive at the current pixel after one timestep?\n            vec2 partPos = GetPos( part );\n            vec2 partVel = GetVel( part );\n            vec2 nextPos = partPos + partVel;\n            // arrival means within half a pixel of this bucket\n            vec2 off = nextPos - arriveCoord;\n            if( abs(off.x)<=.5 && abs(off.y)<=.5 )\n            {\n                // yes! greedily take this particle.\n                // a better algorithm might be to inspect all particles that arrive here\n                // and pick the one with the highest velocity.\n                partData = part;\n                return partCoord;\n            }\n        }\n    }\n    // no particle arriving at this bucket.\n    return vec2(-1.);\n}\n\nvoid Clip( inout vec4 partData, vec2 col0Pos, vec2 col1Pos, vec2 col2Pos )\n{\n    vec2 pos = GetPos( partData );\n    vec2 vel = GetVel( partData );\n    \n    vec2 nextPos = pos + vel;\n    if( nextPos.y < 0. ) vel.y *= -RESTITUTION;\n    if( nextPos.x < 0. ) vel.x *= -RESTITUTION;\n    if( nextPos.y > iResolution.y ) vel.y *= -RESTITUTION;\n    if( nextPos.x > iResolution.x ) vel.x *= -RESTITUTION;\n\n    vec2 off; float loff2;\n    off = nextPos - col0Pos;\n    loff2 = dot(off,off);\n    if( loff2 < 50.*50. ) {\n        loff2 = sqrt(loff2);\n        vec2 n = off/loff2;\n        vel -= (1.+RESTITUTION) * dot( vel, n ) * n;\n        SetPos( partData, col0Pos + 50.*n );\n    }\n    off = nextPos - col1Pos;\n    loff2 = dot(off,off);\n    if( loff2 < 50.*50. ) {\n        loff2 = sqrt(loff2);\n        vec2 n = off/loff2;\n        vel -= (1.+RESTITUTION) * dot( vel, n ) * n;\n        SetPos( partData, col1Pos + 50.*n );\n    }\n    off = nextPos - col2Pos;\n    loff2 = dot(off,off);\n    if( loff2 < 50.*50. ) {\n        loff2 = sqrt(loff2);\n        vec2 n = off/loff2;\n        vel -= (1.+RESTITUTION) * dot( vel, n ) * n;\n        SetPos( partData, col2Pos + 50.*n );\n    }\n\n    SetVel( partData, vel );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col0Data = textureLod(iChannel2, COL0, 0.).xyz;\n    vec3 col1Data = textureLod(iChannel2, COL1, 0.).xyz;\n    vec3 col2Data = textureLod(iChannel2, COL2, 0.).xyz;\n    \n    // add loads of particles on first frame\n    if( iFrame == 0 )\n    {\n        fragColor = vec4(0.);\n        if( mod(fragCoord,10.) == vec2(2.5) )\n        {\n            vec4 newPart;\n            SetPos( newPart, fragCoord );\n            SetVel( newPart, vec2(0.) );\n            Clip( newPart, col0Data.xy, col1Data.xy, col2Data.xy );\n            fragColor = newPart;\n        }\n        return;\n    }\n    \n    // scene data\n    vec3 hoseData = textureLod(iChannel2, HOSE, 0.).xyz;\n    vec3 attractData = textureLod(iChannel2, ATTRACTOR, 0.).xyz;\n    vec2 hoseTarget = textureLod(iChannel2, HOSE_TARGET, 0.).xy;\n    \n    float dragCount = hoseData.z + attractData.z + col0Data.z + col1Data.z + col2Data.z;\n    \n    // mouse emits\n    if( iMouse.z > 0. && length(iMouse.xy-fragCoord.xy) < 9. && dragCount == 0. )\n    {\n        vec4 newPart;\n        SetPos( newPart, fragCoord );\n        SetVel( newPart, 3.*normalize(fragCoord.xy-iMouse.xy));\n        fragColor = newPart;\n        return;\n    }\n    \n    // hose 0\n    if( length(hoseData.xy-fragCoord.xy) < 9. )\n    {\n        vec4 newPart;\n        SetPos( newPart, fragCoord );\n        /*vec2 target = iResolution.xy/2.;\n        if( iMouse.x*iMouse.y > 0. ) target = iMouse.xy;*/\n        SetVel( newPart, 2.8*normalize(hoseTarget-fragCoord.xy) );\n        newPart.xy += .15*sin(15.*iTime)*vec2(-newPart.y,newPart.x);\n        fragColor = newPart;\n        return;\n    }\n    \n    // look for a particle arriving at the current bucket\n    vec4 partData;\n    vec2 partCoord = FindArrivingParticle( fragCoord, partData );\n    if( partCoord.x < 0. )\n    {\n        // no particle, empty this bucket\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec2 pos = GetPos( partData );\n    vec2 vel = GetVel( partData );\n    \n    // integrate pos using current vel\n    SetPos( partData, pos + vel );\n    \n    // integrate velocity\n    \n    // gravity\n    vel += vec2(0.,-.05);\n    \n    // attractor\n    vec2 attract = attractData.xy-fragCoord;\n    float attractStrength = 20./(.1+dot(attract,attract)) - 0.004;\n    if( attractStrength > 0. )\n    {\n        vel += attract*attractStrength;\n    }\n    \n    // drag\n    vel *= .995;\n    // turbulence (divergence free curl could work great here but i just want to add a little variation)\n    // NOTE this needs mipmapping to be disabled on the texture!\n    vel += .125*normalize(textureLod( iChannel1, iTime + 4.*fragCoord/iResolution.xy, 0. ).xy-.5);\n    // clamp to the maximum search radius. rsults would benefit from increasing R!\n    vel = clamp(vel,-R,R);\n    \n    SetVel( partData, vel );\n    \n    Clip( partData, col0Data.xy, col1Data.xy, col2Data.xy );\n    \n    fragColor = partData;\n}\n",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "\n// accumulation buffer for particle trails\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor.zw = vec2(0.);\n    fragColor.xy = .75 * texture( iChannel1, uv ).xy;\n    vec2 vel = texture(iChannel0,uv).xy;\n    if( dot(vel,vel) != 0. ) fragColor += 1.;\n}\n",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XdfGR8",
       "channel": 0
      }
     ],
     "code": "\n\n// final render\n\n// scene data\n#define HOSE vec2(.5,.5)/iResolution.xy\n#define ATTRACTOR vec2(1.5,0.5)/iResolution.xy\n#define COL0 vec2(2.5,0.5)/iResolution.xy\n#define COL1 vec2(3.5,0.5)/iResolution.xy\n#define COL2 vec2(4.5,0.5)/iResolution.xy\n#define HOSE_TARGET vec2(5.5,0.5)/iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // bg\n    fragColor = vec4(.22);\n    float period = 60.;\n    vec2 gridLocal = mod( fragCoord, period );\n    gridLocal.x = min( gridLocal.x, period - gridLocal.x );\n    gridLocal.y = min( gridLocal.y, period - gridLocal.y );\n    if( gridLocal.x < 2. && gridLocal.y < 8. ||\n        gridLocal.x < 8. && gridLocal.y < 2. ) fragColor += .07;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 col0Pos = texture(iChannel2, COL0).xy;\n    vec2 col1Pos = texture(iChannel2, COL1).xy;\n    vec2 col2Pos = texture(iChannel2, COL2).xy;\n\n    // draw colliders\n    vec2 off; float loff2;\n    off = fragCoord - col0Pos; loff2 = dot(off,off);\n    if( loff2 < 50.*50. ) fragColor = mix( fragColor, vec4(.5,.8,0.5,0.)*(.44 + .1*sign(off.x*off.y)),  smoothstep( 2500., 2400., loff2 ) );\n    off = fragCoord - col1Pos; loff2 = dot(off,off);\n    if( loff2 < 50.*50. ) fragColor = mix( fragColor, vec4(.5,.8,0.5,0.)*(.44 + .1*sign(off.x*off.y)),  smoothstep( 2500., 2400., loff2 ) );\n    off = fragCoord - col2Pos; loff2 = dot(off,off);\n    if( loff2 < 50.*50. ) fragColor = mix( fragColor, vec4(.5,.8,0.5,0.)*(.44 + .1*sign(off.x*off.y)),  smoothstep( 2500., 2400., loff2 ) );\n\n    // no reason for the max except it makes the result a little less pixel-y!\n    fragColor += max(abs(texture( iChannel1, uv )),abs(texture( iChannel1, uv+1./iResolution.xy )));\n\n    vec2 hoseCoord = texture(iChannel2, HOSE).xy;\n    vec2 hoseOff = fragCoord.xy - hoseCoord;\n    if( length(hoseOff) < 11. )\n    {\n        vec2 target = texture(iChannel2, HOSE_TARGET).xy;\n        vec2 dir = 2.8*normalize(target-fragCoord.xy);\n        dir += .15*sin(15.*iTime)*vec2(-dir.y,dir.x);\n        if( dot( hoseOff, dir ) < 0. )\n            fragColor = .5*vec4(.5,.8,0.5,0.);\n    }\n    \n    vec2 attractCoord = texture(iChannel2, ATTRACTOR).xy;\n    vec2 attractOff = fragCoord - attractCoord;\n    float attractDist = dot( attractOff, attractOff );\n    if( attractDist < 6.*6. )\n    {\n        fragColor.xyz = .2*fragColor.xyz + vec3(0.2,.5,0.2);\n    }\n    else if( abs(attractDist-50.*50.) < 200. )\n    {\n        float stroke = fract(2.*atan(attractOff.y,attractOff.x) + 3.142)<.5 ? 1. : 0.;\n        fragColor.xyz = mix( fragColor.xyz, .2*fragColor.xyz + vec3(0.2,.5,0.2), stroke );\n    }\n}\n",
     "name": "Buffer D",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "w3GSRD",
    "date": "1754286303",
    "viewed": 126,
    "name": "Random Volumetric V3",
    "description": "Final go at adding effects and making this look as otherworldly as possible.\nthx to chronos for the herringbone pattern",
    "likes": 7,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "random",
     "volumetric",
     "generative",
     "code"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Random Volumetric V2\" by Cotterzz. https://shadertoy.com/view/3XGXRW\n// 2025-08-04 05:40:13\n\n// Fork of \"Random Volumetric Shader\" by Cotterzz. https://shadertoy.com/view/3fc3Dn\n// 2025-08-03 21:08:55\n\n// Fork of \"Random Generative Shaders v5\" by Cotterzz. https://shadertoy.com/view/wf3GRN\n// 2025-05-10 22:57:51\n\n// Fork of \"Random Generative Shaders v4\" by Cotterzz. https://shadertoy.com/view/Wcc3RH\n// 2025-05-10 06:21:07\n\n// Fork of \"Random Generative Shaders v3\" by Cotterzz. https://shadertoy.com/view/Wc33zr\n// 2025-05-09 06:01:58\n\n// Fork of \"Random Generative Shader v2\" by Cotterzz. https://shadertoy.com/view/3XjSWd\n// 2025-05-08 15:40:19\n\n// Fork of \"Random Generative Shader\" by Cotterzz. https://shadertoy.com/view/W3BXDd\n// 2025-05-08 04:36:29\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n    fragColor.rgb = contrast(fragColor.rgb, 4.-(abs((iResolution.x/2.)-fragCoord.x)/(iResolution.x/2.)));\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "float hash1(vec2 x)\n{\n    uvec2 t = floatBitsToUint(x);\n    uint h = 0xc2b2ae3du * t.x + 0x165667b9u;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h += 0xc2b2ae3du * t.y;\n    h = (h << 17u | h >> 15u) * 0x27d4eb2fu;\n    h ^= h >> 15u;\n    h *= 0x85ebca77u;\n    h ^= h >> 13u;\n    h *= 0xc2b2ae3du;\n    h ^= h >> 16u;\n    return uintBitsToFloat(h >> 9u | 0x3f800000u) - 1.0;\n}\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\nvec2 hash2(vec2 x) // improved hash using xxhash\n{\n    float k = 6.283185307 * hash1(x);\n    return vec2(cos(k), sin(k));\n}\n\nfloat noise2( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*vec3( dot(a,hash2(i+0.0)), dot(b,hash2(i+o)), dot(c,hash2(i+1.0))); // changed to h^3 [1]\n    return dot( n, vec3(32.99) ); // analytic factor (= 2916*sqrt(2)/125)\n}\n\nfloat pnoise (vec2 uv){\n    float f = 0.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2( uv ); uv = m*uv;\n    f += 0.2500*noise2( uv ); uv = m*uv;\n    f += 0.1250*noise2( uv ); uv = m*uv;\n    f += 0.0625*noise2( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n    return f;\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i)))\n#define NEWVALUE2 values[int(floor(float(v)*rand(seed+float(i+5))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i+5)))\n#define T (iTime*4.)\n#define rot(a) mat2(cos(a+vec4(0,33,11,0)))\n#define P(z) (vec3(tanh(cos((z) * .15) * 1.) * 8., \\\n                   tanh(cos((z) * .12) * 1.) * 8., (z)))\n\n\n// PREVIEW 0 to disable preview mode\n// SHOWITER 0 to disable iterations view\n// select palette mode below\n\n#define PREVIEW 0\n#define SHOWITER 0\n#define VOLUMETRIC 1\n\nfloat displaytime = 1.0; // seconds between switch\n\nint PALETTE = 9;\n\n// 0 = Original\n// 1 = Original with hsl mixed\n// 2 = Original translated to hsl\n// 3 = hsl calculated\n// 4 = hsl enhanced\n// 5 = hsl*2\n// 6 = weird\n// 7 = fhex\n// 8 = Banded.\n// 9 = RANDOMISE!!!\n\nvec3 p = vec3(0);\n\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\nfloat map(vec3 p) {\n    return 1.5 - length(p - P(p.z));\n}\nfloat rMix(float a, float b, float s){\n    s = rand(s);\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?b/(a==0.?0.01:a):s>0.3?pnoise(vec2(a,b)):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n}\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nvec3 gmc(vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\nvec3 fhexRGB(float fh){\n    if(isinf(fh)||fh>100000.){fh = 0.;}\n    fh = abs(fh*10000000.);\n    float r = fract(fh/65536.);\n    float g = fract(fh/256.);\n    float b= fract(fh/16777216.);\n    //return gmc(contrast(hsl2rgb(vec3(r,g,b)), 0.9), 0.9);\n   return hsl2rgb(vec3(r,g,b));\n}\n\nvec3 addColor(float num, float seed, float alt){\n    if(isinf(num)){num = alt * seed;}\n    if(PALETTE == 7){\n        vec3 col = fhexRGB(num);\n        return col;} else if(PALETTE > 2 || (PALETTE == 1 && rand(seed+19.)>0.3)){\n    \n        float sat = 1.;\n        if(num<0.){sat = 1.-(1./(abs(num)+1.));}\n        float light = 1.0-(1./(abs(num)+1.));\n\n        vec3 col = hsl2rgb(vec3(fract(abs(num)), sat, light));\n        if(PALETTE == 1){col *= 2.;}\n       \n        return col;\n       \n    } else {\n\n        vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n        if(rand(seed*2.)>0.5){col = col.gbr;}\n        if(rand(seed*3.)>0.5){col = col.gbr;}\n        if(PALETTE == 1){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n        // if(PALETTE == 0){col = contrast(col, 1.01); }\n        return col;\n    \n    }\n}\n\nvec3 sanitize(vec3 dc){\n    dc.r = min(1., abs(dc.r));\n    dc.g = min(1., abs(dc.g));\n    dc.b = min(1., abs(dc.b));\n    \n    if(!(dc.r>=0.) && !(dc.r<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.g>=0.) && !(dc.g<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.b>=0.) && !(dc.b<0.)){\n        return vec3(1,0,0);\n    } else {\n        return dc;\n    }\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n     vec3  r = iResolution;\n    vec2 u = fragCoord;\n    \n        \n        float s=.002,d,i, l;\n\n        u = (u-r.xy/2.)/r.y;\n    \n        vec3  p = P(T),ro=p,q,\n              Z = normalize( P(T+1.)  - p),\n              X = normalize(vec3(Z.z,0,-Z)),\n              D = vec3(rot(tanh(sin(p.z*.03)*8.)*3.)*u, 1)* mat3(-X, cross(X, Z), Z);\n       \n        for(; i++<80. && s > .001; ) {\n    \n            p = ro + D * d,\n            s = map(p)*.8,\n            d += s;\n        }\n        p = ro + D * d;\n        \n    vec2 uv = fragCoord/iResolution.y;\n    vec2 uvd = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    float zoom = 4.;\n    if(VOLUMETRIC == 1 ){ zoom+= (1.5*(sin(iTime)+1.)); } else { zoom+= (3.*(sin(iTime)+1.));}\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    \n    float ix = 468.;\n    float iy = 330.;\n    if(iMouse.x>0.&&iMouse.y>0.){\n    ix = iMouse.x; iy = iMouse.y;}\n    \n    float thumb = 5.+sin((iTime/2.)-1.62)*2.;\n    \n    if(!(iMouse.z>0.)&& bool(PREVIEW)){\n        float pantime = (iTime)+50.;\n\n        ix = floor(pantime+(uv.x*thumb/(iResolution.x/iResolution.y)));\n        iy = floor((pantime+(uv.y*thumb)));\n\n        uv.y*=thumb;\n        uv.x*=thumb/(iResolution.x/iResolution.y);\n        uv+=pantime;\n        uv=fract(uv);\n        uv.x-=0.5;\n        uv.y-=0.5;\n        guv = (uv*zoom);\n        x = guv.x;\n        y = guv.y;\n    }\n    \n    float seed = (ix + (iy*iResolution.x))/iResolution.x;\n    \n    if(!(iMouse.z>0.) && iMouse.x==0. && iMouse.y==0.){\n        seed = floor(iTime/displaytime);\n    }\n    \n    if(PALETTE == 9){\n        PALETTE = int(floor(float(8)*rand(seed+66.)));\n    }\n\n    if(PALETTE == 8){\n        PALETTE = int(floor(fragCoord.x/iResolution.x * 8.));\n    }\n    \n    const int v = 26;\n    \n    vec3 col = vec3(0);\n    float cn = 1.;\n    \n    float values[v];\n    float xb = x*5.;\n    float yb = y*5.;\n    \n    values[0] = 1.0;\n    values[1] = p.x;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = p.y;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = p.z;\n   values[21] = atan(x, y)*4.;\n   values[22] = pnoise(vec2(x,y)/2.);\n   values[23] = pnoise(vec2(y,x)*10.);\n   values[24] = .2+(.4+.4*cos(xb*2. + sin(yb*2.)) * cos(yb*2.  + sin(xb*2.)))/2.;\n   values[25] = .2+(.4+.4*cos(xb + sin(yb)) * cos(yb  + sin(xb)))/2.;\n   \n    float total = 0.;\n    float sub = 0.;\n    int maxi = 40; int mini = 4;\n    int iterations = min(maxi,mini + int(floor(rand(seed*6.6)*float(maxi-mini))));\n    \n    \n    \n    \n    for(int i = 0; i<iterations; i++){\n        if(rand(seed+float(i+3))>rand(seed)){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)), seed+float(i));\n\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i));\n      \n        }\n        if(rand(seed+float(i))>rand(seed)/2.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2));\n            sub = 0.;\n            if(rand(seed+float(i+30))>rand(seed)){\n                col += addColor(total, seed+float(i), values[21]);\n                cn+=1.;\n            }\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, seed);\n    col += addColor(total, seed, values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + rand(seed+13.)));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(rand(seed+17.)>0.5){col = col.gbr;}\n        if(rand(seed+19.)>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n     \n    uv+=vec2(0.25,0.15);\n    //if(uvd.x<uvd.y){if(abs(uv.x)>0.6 || abs(uv.y)>0.32){col=vec3(0);}}\n    float xspeed = ar*(col.r-col.b)*10.;\n    float yspeed = (col.g+col.b)*10.;\n    yspeed = mix(xspeed,(col.g*5.)*col.b,uvd.x);\n    xspeed = mix(yspeed,(col.r*5.)*-col.b,uvd.x);\n    vec3 old = textureLod(iChannel0, (fragCoord+vec2(-xspeed,-yspeed))/iResolution.xy, 0.).rgb;\n    float alph1 = (col.r+col.g+col.b)/5.;\n    float alph2 = 1.-(abs(col.r-old.r)+abs(col.g-old.g)+abs(col.b-old.b))/3.;\n    vec3 col1 = 1.-col;\n    \n    float alph = alph1;//mix(alph1, alph2, uvd.y);\n    col = mix(col, col1, uvd.x);\n    \n    fragColor = vec4(mix(old, col, alph), 1.);\n    }\n\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tXyXzV",
    "date": "1754776669",
    "viewed": 107,
    "name": "Golfed Mandelbrot",
    "description": "Inspired by [url=https://www.shadertoy.com/view/wcyXRK]this shader[/url]\nI asked AI for shortest possible golfed mandelbrot.\nThe result was pretty bad, but I managed to improve it and bring it down to 125 chars. Then 109...\nMight look odd on big screen :)",
    "likes": 7,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fractal",
     "mandelbrot",
     "golf",
     "ai",
     "llm"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//   First AI attempt 151 chars:\n// void mainImage(out vec4 o,vec2 p){p=p/iResolution.y*3.-2.;vec2 z=p;for(int i=0;i<9;i++)z=vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y)+p;o=vec4(step(4.,dot(z,z)));}\n\n//   My improvement 125 chars:\n// void mainImage(out vec4 o,vec2 p){p=p*.01-2.;vec2 z=p;for(int i=0;i<23;i++)z=vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y)+p;o=vec4(z,z);}\n\n//   Second AI attempt (w matrix) 145 chars:\n// void mainImage(out vec4 o,vec2 c){c=c/iResolution.y-vec2(.7,.5);vec2 z;for(int i=0;i<99;i++)z=mat2(z,-z.y,z.x)*z+c;o=vec4(1.-step(4.,dot(z,z)));}\n\n//   My improvement 109 chars:\n// void mainImage(out vec4 o,vec2 c){c=c/99.-2.;vec2 z;for(int i=0;i<99;i++)z=mat2(z,-z.y,z.x)*z+c;o=1.-z.yxxx;}\n\n//   Edits by BlobKat & HexaPhoenix 100 chars:\n// void mainImage(out vec4 o,vec2 c){for(vec2 z,i;i.x++<99.;z=mat2(z,-z.y,z.x)*z+c/99.-2.)o=1.-z.yxxx;}\n\n//   Edit by shadertoyjiang 98 chars:\n// void mainImage(out vec4 o,vec2 c){for(vec2 z,i;i.x++<99.;z=mat2(z,-z.y,z)*z+c/99.-2.)o=1.-z.yxxx;}\n   \n//   Another Edit by HexaPhoenix 96 chars:\n   void mainImage(out vec4 o,vec2 c){for(vec2 z,i;i.x++<99.;z=mat2(z,-z.y,z)*z+c/99.-2.)o.xy = 1.-z;}\n   \n//   This is 94 chars, but breaks in win/chrome because of uninitialised o\n// void mainImage(out vec4 o,vec2 c){for(vec2 z;o.w++<99.;z=mat2(z,-z.y,z)*z+c/99.-2.)o.xy = 1.-z;}\n\n//   And this leads to: https://www.shadertoy.com/view/33KSRK - 85 chars! but only works on certain platforms.\n   ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tXKXzV",
    "date": "1754822552",
    "viewed": 100,
    "name": "Cat Eye SDF",
    "description": "Something I need for a shader",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "distancefield",
     "sdf",
     "eye",
     "distance",
     "cat",
     "vesica",
     "pupil"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Cat eye SDF.\n// It's almost identical to a vesica, but with different params/constraints\n// so it's suited for a specific use case.\n\n// See also: https://www.shadertoy.com/view/XtVfRW and https://www.shadertoy.com/view/XlVfz1\n// For similar/alternative SDF   \n\nfloat sdCateye(vec2 p, float height, float dilation)\n{\n    // height is actual height of pupil, vrad is half height\n    float vrad = height/2.;\n    // dilation is maxed at 1, a regular circle, zero would not be visible so it's limited to 0.001\n    dilation = min(.999, max(0.01, dilation));\n    // radius is half height when circle is centred and dilation is 1, and gets bigger as dilation gets smaller\n    float rad = (vrad)/dilation;\n    // dist is distance between circle centre and eye centre\n    float dist = sqrt((rad*rad)-(vrad*vrad));\n    // same as IQ's vesica, - we only need to calculate a quarter because of symmetry\n    p = abs(p);\n    // now we calculate distance from circle centre\n    vec2 center = vec2(-dist, 0.);\n    float tdist = distance(p, center);\n    // and subtract radius for distance from surface\n    float result = tdist - rad;\n    \n    // This is for correct distance from the sharp top and bottom corners\n    vec2 nearest = center+(p-center)*rad/tdist;\n    if(nearest.y>vrad){result=distance(p,vec2(0.,vrad));}\n\n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float eHeight = 1.;\n    float eDilation = 0.4*(sin(iTime)+1.3);\n    \n    //if( iMouse.z>0.001 ) {eHeight = iMouse.y/iResolution.y; eDilation = iMouse.x/iResolution.x;}\n    \n\tfloat d = sdCateye( p, eHeight, eDilation);\n\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-6.0*abs(d)); col *= 0.8 + 0.2*cos(110.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d)) );\n\n    if( iMouse.z>0.001 ){ d = sdCateye( m, eHeight, eDilation);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));}\n\n\tfragColor = vec4(col,1.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3XKXDK",
    "date": "0",
    "viewed": 0,
    "name": "Cat Hair SDF - WIP",
    "description": "Another thing I need for a shader",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "sdf",
     "domainrepetition",
     "hair",
     "fur",
     "organic",
     "cat"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "const float MULTISAMPLING =3.0; // 1.0 is no multi sampling, 4.0 is 2x2 etc \n\nconst float THICKNESS = 0.03;\nconst float SPACING = 0.04;\nconst float INNER_RADIUS = 0.2;\nconst float OUTER_RADIUS = 1.1;\nconst float MAX_DROOP = 0.4;\nconst float CURVE = 0.2; // Curve inwards for droop\nconst int INVERSE_DROOP_ITERATIONS = 4;\n\nconst float CURL_A = 0.0; // Curl Amplitude, typical values from 0.05 to 0.3\nconst float CURL_F = 10.0; // Curl Frequency, typical values from 10 to 100\n\nconst float UNEVEN = 0.0;\n\n\nstruct HairData {\n    vec3 straightPos;\n    vec2 spherical;\n    vec2 gridCell;\n    float radialDist;\n    float normalizedRadius;\n};\n\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec2 hash2(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)),\n             dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat hash(vec2 p) {\n    p = fract(p * vec2(123.34, 456.78));\n    p += dot(p, p + 34.56);\n    return fract(p.x * p.y);\n}\n\nvec2 cartesianToSpherical(vec3 p) {\n    float r = length(p);\n    if(r < 0.001) return vec2(0.0);\n    vec3 n = p / r;\n    return vec2(acos(clamp(n.y, -1.0, 1.0)), atan(n.z, n.x));\n}\n\nvec3 applyDroop(vec3 p) {\n    float radialDist = length(p);\n    float normalizedRadius = (radialDist - INNER_RADIUS) / (OUTER_RADIUS - INNER_RADIUS);\n    \n    float droopFactor = normalizedRadius * normalizedRadius;\n    vec3 droopedPos = p;\n    droopedPos.y -= droopFactor * MAX_DROOP;\n    \n    // Add slight inward curl\n    vec3 toCenter = -normalize(vec3(p.x, 0.0, p.z));\n    droopedPos += toCenter * droopFactor * CURVE;\n    \n    return droopedPos;\n}\n\n// Compute straight position from drooped position\nvec3 computeStraightPos(vec3 p) {\n    vec3 straightPos = p;\n    for(int i = 0; i < INVERSE_DROOP_ITERATIONS; i++) {\n        vec3 drooped = applyDroop(straightPos);\n        straightPos += (p - drooped) * 0.7;\n    }\n    return straightPos;\n}\n\nHairData getHairData(vec3 p) {\n    HairData data;\n    data.straightPos = computeStraightPos(p);\n    data.spherical = cartesianToSpherical(data.straightPos);\n    data.radialDist = length(data.straightPos);\n    data.normalizedRadius = (data.radialDist - INNER_RADIUS) / (OUTER_RADIUS - INNER_RADIUS);\n    \n    // Store grid indices for hair ID (without randomization)\n    float lat = data.spherical.x;\n    float lon = data.spherical.y;\n    float gridSpacing = 0.01; // Default value\n    float lonSpacing = gridSpacing / max(sin(lat), 0.1);\n    \n    data.gridCell = vec2(\n        round(lat / gridSpacing),\n        round(lon / lonSpacing)\n    );\n    \n    return data;\n}\n\n\nfloat sdRadialLineOptimized(vec3 p, float gridSpacing, float thickness, out HairData hairData) {\n    hairData = getHairData(p);\n    float lat = hairData.spherical.x;\n    float lon = hairData.spherical.y;\n    if(CURL_A>0.0){ lon += sin(length(p)*CURL_F)*CURL_A; }\n    float lonSpacing = gridSpacing / max(sin(lat), 0.1);\n    vec2 gridPos = vec2(lat, lon);\n    vec2 gridIndex = vec2(\n        round(gridPos.x / gridSpacing),\n        round(gridPos.y / lonSpacing)\n    );\n\n    \n    vec2 randomOffset = hash2(gridIndex) * 0.4;// = 40% of grid spacing\n    vec2 gridCell = vec2(\n        gridIndex.x * gridSpacing + randomOffset.x * gridSpacing,\n        gridIndex.y * lonSpacing + randomOffset.y * lonSpacing\n    );\n    \n    vec2 toLine = gridPos - gridCell;\n    toLine.y *= sin(lat);\n    float distToLine = length(toLine);\n        // Increase the cutoff distance since hairs can now be offset\n    if(distToLine > gridSpacing * 1.0) return 1e10;\n    float currentThickness;\n    if(UNEVEN>0.0){\n    float hairLengthRandom = hash(gridIndex + vec2(42.0, 17.0));\n    float minLength = 1.0/(1.0+UNEVEN);\n    float maxLength = 1.0*(1.0+UNEVEN);\n    float hairLengthFactor = mix(minLength, maxLength, hairLengthRandom);\n    \n    // Check if we're beyond this hair's length - if so, early exit\n    float adjustedRadius = hairData.normalizedRadius / hairLengthFactor;\n    if(adjustedRadius > 1.0) {\n        return 1e10; // Hair doesn't exist here at all\n    }\n    // Calculate taper\n    float baseTaperFactor = 1.0 - hairData.normalizedRadius;\n    float lengthTaperFactor = 1.0 - adjustedRadius;\n    float finalTaperFactor = baseTaperFactor * lengthTaperFactor;\n    \n    float thicknessVariation = 0.4 + 0.8 * hash(gridIndex);\n    currentThickness = thickness * finalTaperFactor * thicknessVariation;\n    \n    // Ensure we never have negative or too-small thickness\n    if(currentThickness < 0.0001) {\n        return 1e10; // Hair is too thin to render\n    }\n    } else {\n        float taperFactor = 1.0 - hairData.normalizedRadius;\n    // Add slight thickness variation per hair\n    float thicknessVariation = 0.4 + 0.8 * hash(gridIndex);\n    currentThickness = thickness * taperFactor * thicknessVariation;\n    \n    }\n    return distToLine - currentThickness;\n\n}\n\n\n\n// Optimized raymarch function\nvec4 raymarchWithLines(vec3 ro, vec3 rd, float lineSpacing, float lineThickness) {\n    float t = 0.0;\n    HairData hairData; // Reuse this structure\n    \n    for(int i = 0; i < 200; i++) {\n        vec3 p = ro + rd * t;\n        float distFromCenter = length(p);\n        \n        \n        float d;\n        bool betweenSpheres = distFromCenter > INNER_RADIUS && distFromCenter < OUTER_RADIUS;\n        \n        if(betweenSpheres) {\n            float innerSphere = sdSphere(p, INNER_RADIUS);\n            float lines = sdRadialLineOptimized(p, lineSpacing, lineThickness, hairData);\n            d = min(innerSphere, lines);\n        } else {\n            d = sdSphere(p, INNER_RADIUS);\n        }\n        \n        if(d < 0.0005) {\n            float objectId = 0.0;\n            float opacity = 1.0;\n            \n            if(betweenSpheres) {\n                float innerDist = sdSphere(p, INNER_RADIUS);\n                float lineDist = hairData.radialDist > 0.0 ? \n                    sdRadialLineOptimized(p, lineSpacing, lineThickness, hairData) : 1e10;\n                    \n                \n\n                if(lineDist < innerDist) {\n                    objectId = 1.0;\n                    opacity = 1.0 - hairData.normalizedRadius * 0.8;\n                }\n            }\n            \n            return vec4(t, objectId, hash(hairData.gridCell), opacity);\n        }\n        \n        t += d * 0.8;\n        if(t > 20.0) break;\n    }\n    \n    return vec4(-1.0, -1.0, 0.0, 0.0);\n}\n\n// Ray-sphere intersection (unchanged)\nvec2 raySphere(vec3 ro, vec3 rd, float r) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r*r;\n    float h = b*b - c;\n    if(h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// Unified map function for shadow marching\nfloat map(vec3 p, float lineSpacing, float lineThickness) {\n    float distFromCenter = length(p);\n    \n    if(distFromCenter > INNER_RADIUS && distFromCenter < OUTER_RADIUS) {\n        HairData hairData;\n        float innerSphere = sdSphere(p, INNER_RADIUS);\n        float lines = sdRadialLineOptimized(p, lineSpacing, lineThickness, hairData);\n        return min(innerSphere, lines);\n    } else {\n        return sdSphere(p, INNER_RADIUS);\n    }\n}\n\n// Modified soft shadow function\nfloat calcSoftshadow(in vec3 ro, in vec3 rd, float tmin, float tmax, float lineSpacing, float lineThickness, const float k)\n{\n    float res = 1.0;\n    float t = tmin;\n    for(int i = 0; i < 6; i++)\n    {\n        float h = map(ro + rd*t, lineSpacing, lineThickness);\n        res = min(res, k*h/t);\n        t += clamp(h, 0.02, 0.20);\n        if(res < 0.005 || t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// Simplified normal calculation\nvec3 calcNormal(vec3 p, float objectId, float lineSpacing, float lineThickness) {\n    if(objectId < 0.5) { // Inner sphere\n        return normalize(p);\n    }\n    \n    // Hair normal using finite differences\n    vec2 e = vec2(0.001, 0.0);\n    float base = map(p, lineSpacing, lineThickness);\n    return normalize(vec3(\n        map(p + e.xyy, lineSpacing, lineThickness) - base,\n        map(p + e.yxy, lineSpacing, lineThickness) - base,\n        map(p + e.yyx, lineSpacing, lineThickness) - base\n    ));\n}\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera setup\n    float time = iTime * 0.5;\n    float radius = 3.0;\n    float height = sin(time * 0.7) * 0.5;\n    \n    vec3 ro = vec3(radius * cos(time), height, radius * sin(time));\n    vec3 target = vec3(0.0);\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    \n    vec3 col = vec3(0.6, 0.6, 0.6);\n    \n    // Mouse-controlled parameters with better defaults\n    float lineSpacing = SPACING;\n    float lineThickness = THICKNESS;\n    \n    vec2 outerHit = raySphere(ro, rd, OUTER_RADIUS);\n           float lrad = 2.0;\n           float lheight = 1.;\n           vec3 lightPos = vec3(lrad, lheight, lrad);//vec3(lrad * cos(time), lheight, lrad * sin(time));\n    if(outerHit.x > 0.0) {\n        vec3 pEnter = ro + rd * outerHit.x;\n        vec3 roInner = pEnter + rd * 0.001;\n        vec4 hit = raymarchWithLines(roInner, rd, lineSpacing, lineThickness);\n        \nif(hit.x > 0.0) {\n    vec3 pHit = roInner + rd * hit.x;\n    vec3 nHit = calcNormal(pHit, hit.y, lineSpacing, lineThickness);\n    \n    vec3 lightDir = normalize(lightPos - pHit);\n    float diff = max(dot(nHit, lightDir), 0.0);\n    \n    // Calculate shadow\n    float shadow = calcSoftshadow(pHit + nHit*0.001, lightDir, 0.001, length(lightPos - pHit), lineSpacing, lineThickness, 2.0);\n    diff = diff*shadow;\n    \n    float ambient = 0.4;\n            \n            vec3 hitCol;\n            if(hit.y > 0.5) {\n                // Hair color selection\n                float hairRandom = hit.z;\n                vec3 hairColors[4] = vec3[4](\n                    vec3(0.95, 0.8, 0.4),  // Golden\n                    vec3(0.8, 0.5, 0.3),   // Brown\n                    vec3(0.9, 0.4, 0.4),   // Reddish\n                    vec3(0.5, 0.7, 0.9)    // Blue\n                );\n                \n                int colorIndex = int(hairRandom * 4.0);\n                vec3 hairBaseCol = hairColors[min(colorIndex, 3)];\n                \n                hitCol = hairBaseCol* (diff + ambient);\n                \n                // Specular highlight\n                vec3 viewDir = -rd;\n                vec3 halfDir = normalize(lightDir + viewDir);\n                float spec = pow(max(dot(nHit, halfDir), 0.0), 16.0);\n                hitCol += spec*.7;\n                \n                col = mix(col, hitCol, hit.w*1.5);\n            } else {\n                // Inner sphere\n                col = vec3(.9,.8,.8) * (diff + ambient);\n            }\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = MULTISAMPLING, k; \n    //if(u.x>iResolution.x/2.){s=1.;}\n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}\n\n/*\n\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// Convert cartesian to spherical coordinates\nvec2 cartesianToSpherical(vec3 p) {\n    float r = length(p);\n    if(r < 0.001) return vec2(0.0);\n    \n    // Normalize to unit sphere\n    vec3 n = p / r;\n    \n    // Longitude (phi): angle around Y axis, range [-PI, PI]\n    float lon = atan(n.z, n.x);\n    \n    // Latitude (theta): angle from Y axis, range [0, PI]\n    float lat = acos(clamp(n.y, -1.0, 1.0));\n    \n    return vec2(lat, lon);\n}\n\n// Apply drooping effect to position\nvec3 applyDroop(vec3 p) {\n    float radialDist = length(p);\n    float normalizedRadius = (radialDist - 0.4) / 0.7; // 0 at inner sphere, 1 at outer\n    \n    // Calculate droop amount based on distance from inner sphere\n    float droopFactor = normalizedRadius * normalizedRadius; // Quadratic for natural curve\n    float droopAmount = droopFactor * 0.6; // Maximum droop of 0.4 units\n    \n    // Apply downward displacement\n    vec3 droopedPos = p;\n    droopedPos.y -= droopAmount;\n    \n    // Optional: add slight inward \n    \n    float curlFactor = droopFactor * 0.1;\n    vec3 toCenter = -normalize(vec3(p.x, 0.0, p.z)); // Horizontal direction to center\n    droopedPos += toCenter * curlFactor;\n    \n    return droopedPos;\n}\n\n// Distance function for hair based on lat/lon grid with drooping\nfloat sdRadialLine(vec3 p, float gridSpacing, float thickness) {\n    // Apply inverse droop to find where this point would be on a straight hair\n    vec3 straightPos = p;\n    \n    // Iteratively find the original position (before droop)\n    for(int i = 0; i < 3; i++) {\n        vec3 drooped = applyDroop(straightPos);\n        vec3 error = p - drooped;\n        straightPos += error * 0.7;\n    }\n    \n    // Get spherical coordinates of the straight position\n    vec2 spherical = cartesianToSpherical(straightPos);\n    \n    float curlA = 0.1;\n    float curlF = 60.0;\n    \n    float lat = spherical.x;\n    float lon = spherical.y;\n\n    // Create grid in spherical coordinates\n    float lonSpacing = gridSpacing / max(sin(lat), 0.1);\n    \n    vec2 gridPos = vec2(lat, lon);\n    vec2 gridCell = vec2(\n        round(gridPos.x / gridSpacing) * gridSpacing,\n        round(gridPos.y / lonSpacing) * lonSpacing\n    );\n    vec2 toLine = gridPos - gridCell;\n    \n    // Adjust distance calculation for spherical distortion\n    toLine.y *= sin(lat);\n    float distToLine = length(toLine);\n    \n    // Only consider if we're near a grid point\n    if(distToLine > gridSpacing * 0.8) return 1e10;\n    \n    // Calculate radial position for tapering using the original (undrooped) position\n    float radialDist = length(straightPos);\n    float normalizedRadius = (radialDist - 0.5) / 0.5;\n    \n    // Taper the thickness from inner to outer sphere\n    float taperFactor = 1.0 - normalizedRadius;\n    float currentThickness = thickness * taperFactor;\n    \n    return distToLine - currentThickness;\n}\n\n// Hash colors\nfloat hash(vec2 p) {\n    p = fract(p * vec2(123.34, 456.78));\n    p += dot(p, p + 34.56);\n    return fract(p.x * p.y);\n}\n\nvec2 getHairID(vec3 p, float gridSpacing) {\n    // Use undrooped position for consistent coloring\n    vec3 straightPos = p;\n    for(int i = 0; i < 3; i++) {\n        vec3 drooped = applyDroop(straightPos);\n        vec3 error = p - drooped;\n        straightPos += error * 0.7;\n    }\n    \n    vec2 spherical = cartesianToSpherical(straightPos);\n    float lat = spherical.x;\n    float lon = spherical.y;\n    \n    float lonSpacing = gridSpacing / max(sin(lat), 0.1);\n    \n    vec2 gridCell = vec2(\n        round(lat / gridSpacing),\n        round(lon / lonSpacing)\n    );\n    \n    return gridCell;\n}\n\n// Scene\nfloat map(vec3 p) {\n    return sdSphere(p, 0.4);\n}\n\n// Hair\nfloat mapWithLines(vec3 p, float lineSpacing, float lineThickness) {\n    float innerSphere = sdSphere(p, 0.4);\n    float lines = sdRadialLine(p, lineSpacing, lineThickness);\n    return min(innerSphere, lines);\n}\n\n\nbool isBetweenSpheres(vec3 p) {\n    float distFromCenter = length(p);\n    return distFromCenter > 0.4 && distFromCenter < 1.0;\n}\n\n// Get opacity based on distance from inner sphere (using undrooped position)\nfloat getHairOpacity(vec3 p) {\n    vec3 straightPos = p;\n    for(int i = 0; i < 3; i++) {\n        vec3 drooped = applyDroop(straightPos);\n        vec3 error = p - drooped;\n        straightPos += error * 0.7;\n    }\n    \n    float radialDist = length(straightPos);\n    float normalizedRadius = (radialDist - 0.5) / 0.5;\n    return 1.0 - normalizedRadius * 0.8;\n}\n\n// Raymarch\nvec4 raymarchWithLines(vec3 ro, vec3 rd, float lineSpacing, float lineThickness) {\n    float t = 0.0;\n    \n    for(int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        \n        float d;\n        if(isBetweenSpheres(p)) {\n            d = mapWithLines(p, lineSpacing, lineThickness);\n        } else {\n            d = map(p);\n        }\n        \n        if(d < 0.001) {\n            float objectId = 0.0;\n            float opacity = 1.0;\n            vec2 hairID = getHairID(p, lineSpacing);\n            if(isBetweenSpheres(p)) {\n                float innerDist = sdSphere(p, 0.3);\n                float lineDist = sdRadialLine(p, lineSpacing, lineThickness);\n                \n                if(lineDist < innerDist) {\n                    objectId = 1.0;\n                    opacity = getHairOpacity(p);\n                }\n            }\n            \n            \n            return vec4(t, objectId, hash(hairID), opacity);\n        }\n        \n        t += d * 0.8;\n        \n        if(t > 10.0) break;\n    }\n    \n    return vec4(-1.0, -1.0, 0.0, 0.0);\n}\n\n// Ray-sphere intersection\nvec2 raySphere(vec3 ro, vec3 rd, float r) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r*r;\n    float h = b*b - c;\n    if(h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\n// Calculate normal\nvec3 calcNormal(vec3 p, float objectId) {\n    if(objectId > 0.5) {\n        // Hair normal - radial\n        return normalize(p);\n    }\n    \n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\n\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera orbiting around the sphere\n    float time = iTime * 0.5;\n    float radius = 3.0;\n    float height = sin(time * 0.7) * 0.5;\n    \n    vec3 ro = vec3(\n        radius * cos(time),\n        height,\n        radius * sin(time)\n    );\n    \n    // Look at center\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    \n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    \n    // Lighter background\n    vec3 col = vec3(0.3);\n    \n    // Mouse-controlled parameters\n    float lineSpacing = iMouse.x/iResolution.x/3.;\n    float lineThickness = iMouse.y/iResolution.y/50.;\n    \n    // Fallback values if mouse not used\n    if(lineSpacing <= 0.) lineSpacing = 0.1;\n    if(lineThickness <= 0.) lineThickness = 0.002;\n    \n    vec2 outerHit = raySphere(ro, rd, 1.0);\n    \n    if(outerHit.x > 0.0) {\n        vec3 pEnter = ro + rd * outerHit.x;\n        \n        vec3 roInner = pEnter + rd * 0.001;\n        vec4 hit = raymarchWithLines(roInner, rd, lineSpacing, lineThickness);\n        \n        if(hit.x > 0.0) {\n            vec3 pHit = roInner + rd * hit.x;\n            vec3 nHit = calcNormal(pHit, hit.y);\n            \n            vec3 lightPos = vec3(2.0, 2.0, -2.0);\n            vec3 lightPos2 = vec3(0.0, -3.0, -0.0);\n            vec3 lightDirInner = normalize(lightPos - pHit);\n            vec3 lightDirInner2 = normalize(lightPos2 - pHit);\n            float diffInner = max(dot(nHit, lightDirInner), 0.0);\n            float diffInner2 = max(dot(nHit, lightDirInner2), 0.0);\n            // Add ambient light\n            float ambient = 0.5;\n            \n            vec3 hitCol;\n            if(hit.y > 0.5) {\n                // Hit hair - colorful strands\n                float hairRandom = hit.z;\n                \n                \n                vec3 haircolA = vec3(0.85, 0.6, 0.3);\n                vec3 haircolB = vec3(0.5, 0.4, 0.0);\n                \n                vec3 hairBaseCol = mix(haircolA, haircolB, hairRandom);\n                \n                // Brighter colors with ambient light\n                hitCol = hairBaseCol * (diffInner + ambient);\n                hitCol += vec3(0.3,0,0) * (diffInner2 + ambient);\n                // Add highlight\n                float spec = pow(max(dot(reflect(-lightDirInner, nHit), -rd), 0.0), 16.0);\n                //float spec2 = pow(max(dot(reflect(-lightDirInner2, nHit), -rd), 0.0), 2.0);\n                hitCol += vec3(0.4) * spec;\n                //hitCol += vec3(0.3,0,0) * spec2;\n                // Apply opacity based on distance\n                float opacity = hit.w;\n                col = mix(col, hitCol, opacity);\n            } else {\n                // Inner sphere - brighter red with ambient\n                hitCol = vec3(0.3, 0.2, 0.1) * (diffInner + ambient);\n                col = hitCol;\n            }\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = 4., k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n} \n\n*/",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wfXczr",
    "date": "1755230781",
    "viewed": 134,
    "name": "Domain Repetition Hair/Fur",
    "description": "I needed something like this for a shader and I've not seen this approach used before so I thought I'd build a prototype.\nMouse over to change thickness/number",
    "likes": 12,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "domainrepetition",
     "hair",
     "fur",
     "organic",
     "cat"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// First proof of concept for raymarched hair/fur\n// I wondered if we couldn't just use domain repetition, in between an outer and inner sphere,\n// using perpendicular intervals to make a grid for the hair, with the hairs as grid points on a polar plane.\n// Still lots of things to do like shaping the hair more, light/shadow and adapting to more complex shapes\n// I also need to use cell noise on the grid positions so the hairs arent in perfect rows.\n// It's very fast though, without AA it's 60fps on intel 630 at 1200x675 with seemingly any number of hairs.\n\n// Check out v2 here: https://www.shadertoy.com/view/3fsyzn\n\n#define AA 4.0 // 1. is off, 4. is 2x2 etc...\n\nfloat sdSphere(vec3 p, float r) {return length(p) - r;}\n\nvec2 cartesianToSpherical(vec3 p) {\n    float r = length(p);\n    if(r < 0.001) return vec2(0.0);\n    vec3 n = p / r;\n    float lon = atan(n.z, n.x);\n    float lat = acos(clamp(n.y, -1.0, 1.0));\n    return vec2(lat, lon);\n}\n\nvec3 applyDroop(vec3 p) {\n    float radialDist = length(p);\n    float normalizedRadius = (radialDist - 0.4) / 0.7; // 0 at inner sphere, 1 at outer\n    \n    // Calculate droop amount based on distance from inner sphere\n    float droopFactor = normalizedRadius * normalizedRadius;\n    float droopAmount = droopFactor * 0.4; \n    \n    vec3 droopedPos = p;\n    droopedPos.y -= droopAmount;\n    \n    float curlFactor = droopFactor * 0.1;\n    vec3 toCenter = -normalize(vec3(p.x, 0.0, p.z));\n    droopedPos += toCenter * curlFactor;\n    \n    return droopedPos;\n}\n\n// Distance function for hair based on lat/lon grid with drooping\nfloat sdRadialLine(vec3 p, float gridSpacing, float thickness) {\n    vec3 straightPos = p;\n\n    for(int i = 0; i < 3; i++) {\n        vec3 drooped = applyDroop(straightPos);\n        vec3 error = p - drooped;\n        straightPos += error * 0.7;\n    }\n    \n    vec2 spherical = cartesianToSpherical(straightPos);\n    \n    float lat = spherical.x;\n    float lon = spherical.y;\n\n    float lonSpacing = gridSpacing / max(sin(lat), 0.1);\n    \n    vec2 gridPos = vec2(lat, lon);\n    vec2 gridCell = vec2(\n        round(gridPos.x / gridSpacing) * gridSpacing,\n        round(gridPos.y / lonSpacing) * lonSpacing\n    );\n    vec2 toLine = gridPos - gridCell;\n\n    toLine.y *= sin(lat);\n    float distToLine = length(toLine);\n\n    if(distToLine > gridSpacing * 0.8) return 1e10;\n    \n    float radialDist = length(straightPos);\n    float normalizedRadius = (radialDist - 0.5) / 0.5;\n\n    float taperFactor = 1.0 - normalizedRadius;\n    float currentThickness = thickness * taperFactor;\n    \n    return distToLine - currentThickness;\n}\n\n\nfloat hash(vec2 p) {\n    p = fract(p * vec2(123.34, 456.78));\n    p += dot(p, p + 34.56);\n    return fract(p.x * p.y);\n}\n\nvec2 getHairID(vec3 p, float gridSpacing) {\n    vec3 straightPos = p;\n    for(int i = 0; i < 3; i++) {\n        vec3 drooped = applyDroop(straightPos);\n        vec3 error = p - drooped;\n        straightPos += error * 0.7;\n    }\n    \n    vec2 spherical = cartesianToSpherical(straightPos);\n    float lat = spherical.x;\n    float lon = spherical.y;\n    \n    float lonSpacing = gridSpacing / max(sin(lat), 0.1);\n    \n    vec2 gridCell = vec2(\n        round(lat / gridSpacing),\n        round(lon / lonSpacing)\n    );\n    \n    return gridCell;\n}\n\nfloat map(vec3 p) {return sdSphere(p, 0.4);}\n\nfloat mapWithLines(vec3 p, float lineSpacing, float lineThickness) {\n    float innerSphere = sdSphere(p, 0.4);\n    float lines = sdRadialLine(p, lineSpacing, lineThickness);\n    return min(innerSphere, lines);\n}\n\nbool isBetweenSpheres(vec3 p) {\n    float distFromCenter = length(p);\n    return distFromCenter > 0.4 && distFromCenter < 1.0;\n}\n\nfloat getHairOpacity(vec3 p) {\n    vec3 straightPos = p;\n    for(int i = 0; i < 3; i++) {\n        vec3 drooped = applyDroop(straightPos);\n        vec3 error = p - drooped;\n        straightPos += error * 0.7;\n    }\n    \n    float radialDist = length(straightPos);\n    float normalizedRadius = (radialDist - 0.5) / 0.5;\n    return 1.0 - normalizedRadius * 0.8;\n}\n\nvec4 raymarchWithLines(vec3 ro, vec3 rd, float lineSpacing, float lineThickness) {\n    float t = 0.0;\n    \n    for(int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        \n        float d;\n        if(isBetweenSpheres(p)) {\n            d = mapWithLines(p, lineSpacing, lineThickness);\n        } else {\n            d = map(p);\n        }\n        \n        if(d < 0.001) {\n            float objectId = 0.0;\n            float opacity = 1.0;\n            vec2 hairID = getHairID(p, lineSpacing);\n            if(isBetweenSpheres(p)) {\n                float innerDist = sdSphere(p, 0.3);\n                float lineDist = sdRadialLine(p, lineSpacing, lineThickness);\n                \n                if(lineDist < innerDist) {\n                    objectId = 1.0;\n                    opacity = getHairOpacity(p);\n                }\n            }\n            \n            \n            return vec4(t, objectId, hash(hairID), opacity);\n        }\n        \n        t += d * 0.8;\n        \n        if(t > 10.0) break;\n    }\n    \n    return vec4(-1.0, -1.0, 0.0, 0.0);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, float r) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r*r;\n    float h = b*b - c;\n    if(h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float time = iTime * 0.5;\n    float radius = 3.0;\n    float height = sin(time * 0.7) * 0.5;\n    \n    vec3 ro = vec3(\n        radius * cos(time),\n        height,\n        radius * sin(time)\n    );\n    \n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    \n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n   \n    vec3 col = vec3(0.3);\n    \n    float lineSpacing = iMouse.x/iResolution.x/3.;\n    float lineThickness = iMouse.y/iResolution.y/50.;\n    \n    if(lineSpacing <= 0.) lineSpacing = 0.1;\n    if(lineThickness <= 0.) lineThickness = 0.002;\n    \n    vec2 outerHit = raySphere(ro, rd, 1.0);\n    \n    if(outerHit.x > 0.0) {\n        vec3 pEnter = ro + rd * outerHit.x;\n        \n        vec3 roInner = pEnter + rd * 0.001;\n        vec4 hit = raymarchWithLines(roInner, rd, lineSpacing, lineThickness);\n        \n        if(hit.x > 0.0) {\n            vec3 pHit = roInner + rd * hit.x;\n            vec3 nHit = normalize(pHit);\n            \n            vec3 lightPos = vec3(2.0, 2.0, -2.0);\n            vec3 lightPos2 = vec3(0.0, -3.0, -0.0);\n            vec3 lightDirInner = normalize(lightPos - pHit);\n            vec3 lightDirInner2 = normalize(lightPos2 - pHit);\n            float diffInner = max(dot(nHit, lightDirInner), 0.0);\n            float diffInner2 = max(dot(nHit, lightDirInner2), 0.0);\n            float ambient = 0.5;\n            \n            vec3 hitCol;\n            if(hit.y > 0.5) {\n                float hairRandom = hit.z;\n                vec3 haircolA = vec3(0.85, 0.6, 0.3);\n                vec3 haircolB = vec3(0.5, 0.4, 0.0);\n                vec3 hairBaseCol = mix(haircolA, haircolB, hairRandom);\n                hitCol = hairBaseCol * (diffInner + ambient);\n                hitCol += vec3(0.3,0,0) * (diffInner2 + ambient);\n                float spec = pow(max(dot(reflect(-lightDirInner, nHit), -rd), 0.0), 16.0);\n                hitCol += vec3(0.4) * spec;\n                float opacity = hit.w;\n                col = mix(col, hitCol, opacity);\n            } else {\n                hitCol = vec3(0.5);\n                col = hitCol;\n            }\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\n// multisampling, from \"Weyl Supersample Any Shader\" by spalmer https://www.shadertoy.com/view/WXjXRt\n// (forked from from \"postprocess existing shaders\" by FabriceNeyret2 https://www.shadertoy.com/view/NdyfRz \nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = AA, k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n} ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3fsyzn",
    "date": "1755238131",
    "viewed": 240,
    "name": "Domain Repetition Hair/Fur 2",
    "description": "More developed version - more natural distribution of hair and light/shadow.\nMouse to rotate, also - 1x multisampling with mouse on the left, to 16x on the far right",
    "likes": 15,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "domainrepetition",
     "hair",
     "fur",
     "organic",
     "cat"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Domain Repetition Hair/Fur\" by Cotterzz. https://shadertoy.com/view/wfXczr\n// 2025-08-15 04:55:44\n\n// Lots added here, more params..\n// lighting/shadows which I think are expensive,\n// ..and with hair you can't have one without the other\n// The most imprtant though is offset so the hairs aren't in straight rows. :)\n\n// There seem to be a few artifacts with certain parameters.\n\n// Set multisampling to 0.0 to make it xmouse dependent - left to right is 1x to 16x\n// Or set it to 1. + for number of samples (so 1.0 is effectively off, 4.0 is 2x2 multisampling etc etc..)\n\nconst float MULTISAMPLING = 0.0;\nconst float THICKNESS = 0.01;\nconst float SPACING = 0.03;\nconst float INNER_RADIUS = 0.4;\nconst float OUTER_RADIUS = 0.9;\nconst float MAX_DROOP = 0.3;\nconst float CURVE = 0.1;\nconst float CURL_AMPLITUDE = 0.0;\nconst float CURL_FREQUENCY = 10.0;\nconst float UNEVEN_LENGTH = 0.0;\nconst float RANDOM_OFFSET = 0.45;\n\nvec3 straightPos;\nvec2 sphericalCoords;\nvec2 gridCell;\nfloat radialDistance;\nfloat normalizedRadius;\n\nfloat sphereSDF(vec3 p) {\n    return length(p) - INNER_RADIUS;\n}\n\nvec2 hash2(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat hash(vec2 p) {\n    p = fract(p * vec2(123.34, 456.78));\n    p += dot(p, p + 34.56);\n    return fract(p.x * p.y);\n}\n\nvec2 cartesianToSpherical(vec3 p) {\n    float r = length(p);\n    if (r < 0.001) return vec2(0.0);\n    vec3 n = p / r;\n    return vec2(acos(clamp(n.y, -1.0, 1.0)), atan(n.z, n.x));\n}\n\nvec3 applyDroop(vec3 p) {\n    float r = length(p);\n    float normalized = (r - INNER_RADIUS) / (OUTER_RADIUS - INNER_RADIUS);\n    float droopFactor = normalized * normalized;\n    \n    vec3 droopedPos = p;\n    droopedPos.y -= droopFactor * MAX_DROOP;\n    \n    vec3 toCenter = -normalize(vec3(p.x, 0.0, p.z));\n    droopedPos += toCenter * droopFactor * CURVE;\n    \n    return droopedPos;\n}\n\nvec3 inverseDroop(vec3 p) {\n    vec3 straight = p;\n    for (int i = 0; i < 4; i++) {\n        straight += (p - applyDroop(straight)) * 0.7;\n    }\n    return straight;\n}\n\nvoid getHairData(vec3 p) {\n    straightPos = inverseDroop(p);\n    sphericalCoords = cartesianToSpherical(straightPos);\n    radialDistance = length(straightPos);\n    normalizedRadius = (radialDistance - INNER_RADIUS) / (OUTER_RADIUS - INNER_RADIUS);\n    \n    float gridSpacing = 0.01;\n    float lonSpacing = gridSpacing / max(sin(sphericalCoords.x), 0.1);\n    gridCell = vec2(\n        round(sphericalCoords.x / gridSpacing),\n        round(sphericalCoords.y / lonSpacing)\n    );\n}\n\nfloat sdRadialLine(vec3 p, float spacing, float thickness) {\n    getHairData(p);\n    \n    vec2 latLon = sphericalCoords;\n    float lonSpacing = spacing / max(sin(latLon.x), 0.1);\n    float latIndex = round(latLon.x / spacing);\n    float lonIndex = round(latLon.y / lonSpacing);\n    \n    if (CURL_AMPLITUDE > 0.0) {\n        latLon.y += sin(length(p) * CURL_FREQUENCY) * CURL_AMPLITUDE;\n    }\n    \n    vec2 randomOffset = hash2(vec2(latIndex, lonIndex)) * RANDOM_OFFSET;\n    vec2 gridCenter = vec2(\n        latIndex * spacing + randomOffset.x * spacing,\n        lonIndex * lonSpacing + randomOffset.y * lonSpacing\n    );\n    \n    vec2 toLine = latLon - gridCenter;\n    toLine.y *= sin(latLon.x);\n    float distToLine = length(toLine);\n    \n    if (distToLine > spacing) return 1e10;\n    \n    float taperFactor = 1.0 - normalizedRadius;\n    float thicknessVariation = 0.4 + 0.8 * hash(vec2(latIndex, lonIndex));\n    float currentThickness = thickness * taperFactor * thicknessVariation;\n    \n    if (UNEVEN_LENGTH > 0.0) {\n        float hairLengthRandom = hash(vec2(latIndex, lonIndex) + 42.0);\n        float minLength = 1.0 / (1.0 + UNEVEN_LENGTH);\n        float maxLength = 0.97;// * (1.0 + UNEVEN_LENGTH);\n        float adjustedRadius = normalizedRadius / mix(minLength, maxLength, hairLengthRandom);\n        \n        if (adjustedRadius > 1.0) return 1e10;\n        \n        currentThickness *= (1.0 - normalizedRadius) * (1.0 - adjustedRadius);\n    }\n    \n    return distToLine - currentThickness;\n}\n\nvec4 raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    \n    for (int i = 0; i < 200; i++) {\n        vec3 p = ro + rd * t;\n        float distFromCenter = length(p);\n        float d = sphereSDF(p);\n        \n        if (distFromCenter > INNER_RADIUS && distFromCenter < OUTER_RADIUS) {\n            d = min(d, sdRadialLine(p, SPACING, THICKNESS));\n        }\n        \n        if (d < 0.0005) {\n            float objectId = 0.0;\n            float opacity = 1.0;\n            \n            if (distFromCenter > INNER_RADIUS && distFromCenter < OUTER_RADIUS) {\n                if (sdRadialLine(p, SPACING, THICKNESS) < sphereSDF(p)) {\n                    objectId = 1.0;\n                    opacity = 1.0 - normalizedRadius * 0.8;\n                }\n            }\n            \n            return vec4(t, objectId, hash(gridCell), opacity);\n        }\n        \n        t += d * 0.8;\n        if (t > 20.0) break;\n    }\n    \n    return vec4(-1.0);\n}\n\nfloat mapScene(vec3 p) {\n    float distFromCenter = length(p);\n    if (distFromCenter > INNER_RADIUS && distFromCenter < OUTER_RADIUS) {\n        return min(sphereSDF(p), sdRadialLine(p, SPACING, THICKNESS));\n    }\n    return sphereSDF(p);\n}\n\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n    float res = 1.0;\n    float t = tmin;\n    \n    for (int i = 0; i < 6; i++) {\n        float h = mapScene(ro + rd * t);\n        res = min(res, 2.0 * h / t);\n        t += clamp(h, 0.02, 0.2);\n        if (res < 0.005 || t > tmax) break;\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(vec3 p, float objectId) {\n    if (objectId < 0.5) {\n        return normalize(p);\n    }\n    \n    vec2 e = vec2(0.001, 0.0);\n    float base = mapScene(p);\n    return normalize(vec3(\n        mapScene(p + e.xyy) - base,\n        mapScene(p + e.yxy) - base,\n        mapScene(p + e.yyx) - base\n    ));\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, float r) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r * r;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\nvoid mainImage0(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec2 pan = -5.*((iMouse.xy/iResolution.xy)-0.5);// = iTime * 0.5;\n    float camRadius = 3.0;\n    float camHeight = pan.y;\n    \n    vec3 ro = vec3(camRadius * cos(pan.x), camHeight, camRadius * sin(pan.x));\n    vec3 target = vec3(0.0);\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    \n    vec3 col = vec3(0.7);\n    vec3 lightPos = vec3(2.0, 1.0, 2.0);\n    \n    vec2 outerHit = raySphere(ro, rd, OUTER_RADIUS);\n    if (outerHit.x > 0.0) {\n        vec3 pEnter = ro + rd * outerHit.x + rd * 0.001;\n        vec4 hit = raymarch(pEnter, rd);\n        \n        if (hit.x > 0.0) {\n            vec3 pHit = pEnter + rd * hit.x;\n            vec3 normal = calcNormal(pHit, hit.y);\n            vec3 lightDir = normalize(lightPos - pHit);\n            \n            float diffuse = max(dot(normal, lightDir), 0.0);\n            float shadow = calcSoftShadow(pHit + normal * 0.001, lightDir, 0.001, length(lightPos - pHit));\n            diffuse *= shadow;\n            \n            float ambient = 0.4;\n            vec3 hitColor;\n            \n            if (hit.y > 0.5) {\n                vec3 hairColors[4] = vec3[4](\n                    vec3(0.95, 0.8, 0.4),\n                    vec3(0.8, 0.5, 0.3),\n                    vec3(0.9, 0.4, 0.4),\n                    vec3(0.5, 0.7, 0.9)\n                );\n                \n                int colorIndex = min(int(hit.z * 4.0), 3);\n                vec3 hairBaseColor = hairColors[colorIndex];\n                hitColor = hairBaseColor * (diffuse + ambient);\n                \n                vec3 viewDir = -rd;\n                vec3 halfDir = normalize(lightDir + viewDir);\n                float specular = pow(max(dot(normal, halfDir), 0.0), 8.0);\n                hitColor += specular * 0.4;\n                \n                col = mix(col, hitColor, hit.w*1.5);\n            } else {\n                col = vec3(0.9, 0.8, 0.8) * (diffuse + ambient);\n            }\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\n// multisampling, from \"Weyl Supersample Any Shader\" by spalmer https://www.shadertoy.com/view/WXjXRt\n// (forked from from \"postprocess existing shaders\" by FabriceNeyret2 https://www.shadertoy.com/view/NdyfRz \nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float samples = MULTISAMPLING<1.?floor(max(1.,((iMouse.x/iResolution.x)*16.))):MULTISAMPLING;\n    vec2 jitter = vec2(0.5);\n    fragColor = vec4(0.0);\n    vec4 color;\n    \n    mainImage0(color, fragCoord);\n    for (float k = samples; k-- > 0.5;) {\n        mainImage0(color, fragCoord + jitter - 0.5);\n        fragColor += color;\n        jitter = fract(jitter + vec2(0.755, 0.57).yx);\n    }\n    \n    fragColor /= samples;\n    fragColor.a = 1.0;\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tclcz8",
    "date": "1755335513",
    "viewed": 116,
    "name": "Magnetosphere adaptation",
    "description": "I was wondering if magnetic field lines would make for a better hair pattern, and that kinda led to this.",
    "likes": 13,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "domainrepetition",
     "earth",
     "fieldlines",
     "magnetosphere"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Domain Repetition Hair/Fur\" by Cotterzz. https://shadertoy.com/view/wfXczr\n// 2025-08-16 07:37:29\n\n// Also check out magnetosphere hair: https://www.shadertoy.com/view/3cfczN\n// And hair V2: https://www.shadertoy.com/view/3fsyzn\n\n#define AA 1.0\n#define LATSPACING 0.1\n#define AZISPACING 0.6\n#define LTHICKNESS 0.004\n\nfloat sdSphere(vec3 p, float r) {return length(p) - r;}\n\nvec3 getMagField(vec3 p) {\n   float r = length(p);\n   if(r < 0.001) return vec3(0,1,0);\n   vec3 rh = p / r;\n   float r3 = r * r * r, mdotr = rh.y;\n   return normalize((3.0 * mdotr * rh - vec3(0,1,0)) / r3);\n}\n\nvec2 getFieldParams(vec3 p) {\n   float r = length(p);\n   if(r < 0.001) return vec2(0);\n   float sinTheta = length(p.xz) / r, sinTheta2 = sinTheta * sinTheta;\n   return vec2(r / (sinTheta2 + 0.001), atan(p.z, p.x));\n}\n\nfloat LToLat(float L) {return asin(1.0 / sqrt(L));}\nfloat latToL(float lat) {float s = sin(lat); return 1.0 / (s*s + 0.001);}\n\nfloat sdMagLine(vec3 p, float latSpc, float aziSpc, float thick) {\n   vec2 prm = getFieldParams(p);\n   float L = prm.x, phi = prm.y;\n   if(L > 20.0) return 1e10;\n   \n   float lat = LToLat(L);\n   float nearLat = round(lat / latSpc) * latSpc;\n   float nearL = latToL(nearLat), nearPhi = round(phi / aziSpc) * aziSpc;\n   \n   float Ldiff = abs(L - nearL) / L;\n   float phiDiff = abs(phi - nearPhi) * sin(lat);\n   float dist = sqrt(Ldiff*Ldiff + phiDiff*phiDiff);\n   \n   float latFac = abs(p.y) / length(p), distFac = 0.4 / length(p);\n   return dist - thick * (1.0 + 2.0 * latFac) * (0.5 + distFac);\n}\n\nfloat hash(vec2 p) {\n   p = fract(p * vec2(123.34, 456.78));\n   p += dot(p, p + 34.56);\n   return fract(p.x * p.y);\n}\n\nvec2 getLineID(vec3 p, float latSpc, float aziSpc) {\n   vec2 prm = getFieldParams(p);\n   float lat = LToLat(prm.x);\n   return vec2(round(lat / latSpc), round(prm.y / aziSpc));\n}\n\nfloat map(vec3 p) {return sdSphere(p, 0.4);}\n\nfloat mapLines(vec3 p, float latSpc, float aziSpc, float thick) {\n   return min(sdSphere(p, 0.4), sdMagLine(p, latSpc, aziSpc, thick));\n}\n\nbool inMagnet(vec3 p) {float d = length(p); return d > 0.4 && d < 3.0;}\n\nfloat getOpacity(vec3 p) {\n   float r = length(p), nr = (r - 0.4) / 2.0, latFac = abs(p.y) / r;\n   return clamp((1.0 - nr * 0.5) * (0.5 + 0.5 * latFac), 0.3, 1.0);\n}\n\nvec4 raymarch(vec3 ro, vec3 rd, float latSpc, float aziSpc, float thick) {\n   float t = 0.0;\n   for(int i = 0; i < 100; i++) {\n       vec3 p = ro + rd * t;\n       float d = mapLines(p, latSpc, aziSpc, thick);\n       \n       if(d < 0.001) {\n           float objId = 0.0, opacity = 1.0;\n           vec2 lineID = getLineID(p, latSpc, aziSpc);\n           \n           if(inMagnet(p)) {\n               float innerD = sdSphere(p, 0.4);\n               float lineD = sdMagLine(p, latSpc, aziSpc, thick);\n               if(lineD < innerD) {objId = 1.0; opacity = getOpacity(p);}\n           }\n           return vec4(t, objId, hash(lineID), opacity);\n       }\n       t += d * 0.8;\n       if(t > 10.0) break;\n   }\n   return vec4(-1,-1,0,0);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, float r) {\n   float b = dot(ro, rd), c = dot(ro, ro) - r*r, h = b*b - c;\n   if(h < 0.0) return vec2(-1);\n   h = sqrt(h);\n   return vec2(-b - h, -b + h);\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n   vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n   \n   vec2 mouse = iMouse.xy / iResolution.xy;\n   if(length(iMouse.xy) < 0.001) mouse = vec2(0.5);\n   \n   float theta = (mouse.x - 0.5) * 6.28318;\n   float phi = (mouse.y - 0.5) * 3.14159;\n   float autoRot = iTime * 0.1;\n   if(iMouse.z > 0.0) autoRot = 0.0;\n   theta += autoRot;\n   \n   float radius = 3.5;\n   vec3 ro = vec3(radius * cos(theta) * cos(phi), radius * sin(phi),\n                  radius * sin(theta) * cos(phi));\n   \n   vec3 target = vec3(0), forward = normalize(target - ro);\n   vec3 right = normalize(cross(vec3(0,1,0), forward));\n   vec3 up = cross(forward, right);\n   vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n  \n   vec3 col = vec3(0.02, 0.05, 0.1);\n   \n   vec2 outerHit = raySphere(ro, rd, 3.0);\n   if(outerHit.x > 0.0) {\n       vec3 pEnter = ro + rd * outerHit.x;\n       vec3 roInner = pEnter + rd * 0.001;\n       vec4 hit = raymarch(roInner, rd, LATSPACING, AZISPACING, LTHICKNESS);\n       \n       if(hit.x > 0.0) {\n           vec3 pHit = roInner + rd * hit.x;\n           vec3 nHit = normalize(pHit);\n           vec3 lightDir = normalize(vec3(3,2,-3) - pHit);\n           float diff = max(dot(nHit, lightDir), 0.0), ambient = 0.4;\n           \n           if(hit.y > 0.5) {\n               vec3 lineColA = vec3(0.3, 0.7, 1.0);\n               vec3 lineColB = vec3(0.1, 1.0, 0.7);\n               vec3 lineCol = mix(lineColA, lineColB, hit.z);\n               vec3 hitCol = lineCol * (diff * 0.6 + ambient);\n               float glow = exp(-length(pHit) * 0.3);\n               hitCol += lineCol * glow * 0.3;\n               col = mix(col, hitCol, hit.w);\n           } else {\n               col = vec3(0.2, 0.4, 0.7) * (diff + ambient);\n           }\n       }\n   }\n   fragColor = vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n   float s = AA, k; vec2 j = vec2(.5); o = vec4(0); vec4 c;\n   mainImage0(c, u);\n   for (k = s; k-- > .5; ) {\n       mainImage0(c, u + j - .5); o += c;\n       j = fract(j + vec2(.755, .57).yx);\n   };o /= s;o.a==1.;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3cfczN",
    "date": "1755371188",
    "viewed": 100,
    "name": "Magnetosphere hair",
    "description": "I was wondering if magnetic field lines would make for a better hair pattern, this is the result applied to first prototype.\nHave a play with params, AA is broken",
    "likes": 10,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sdf",
     "domainrepetition",
     "hair",
     "fur",
     "fieldlines",
     "magnetosphere"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Magnetosphere adaptation\" by Cotterzz. https://shadertoy.com/view/tclcz8\n// 2025-08-16 19:00:03\n\n// Fork of \"Domain Repetition Hair/Fur\" by Cotterzz. https://shadertoy.com/view/wfXczr\n// 2025-08-16 07:37:29\n\n// Also check out Hair V2 here: https://www.shadertoy.com/view/3fsyzn\n\n// I did two things here:\n// 1. Apply the magnetic field pattern back to the first hair prototype\n// 2. Try and fix the problem I had with hair where the semi transparent ends cause the ray to stop\n// when it should pass though and render the next thing.\n// (Maybe using transparecy as a tapering method is also not the way to go.)\n// It works, mostly, but not with AA, still figuring that out\n// I still have more to learn with raymarching SDFs.\n\n\n#define AA 1.0  // AA is broken, don't use.\n#define LATSPACING 0.02\n#define AZISPACING 0.04\n#define HAIRTHICK 0.01\n#define HAIRLENGTH 0.6\n#define INNER_RADIUS 0.4\n#define OUTER_RADIUS 0.8\n#define MAX_PASSES 4\n\nfloat sdSphere(vec3 p, float r) {return length(p) - r;}\n\nvec3 getHairField(vec3 p) {\n    float r = length(p);\n    if(r < 0.001) return vec3(0,-1,0);\n    vec3 rh = p / r;\n    float r3 = r * r * r;\n    float mdotr = -rh.y;\n    return normalize((3.0 * mdotr * rh + vec3(0,1,0)) / r3);\n}\n\nvec2 getHairParams(vec3 p) {\n    float r = length(p);\n    if(r < 0.001) return vec2(0);\n    float sinTheta = length(p.xz) / r, sinTheta2 = sinTheta * sinTheta;\n    return vec2(r / (sinTheta2 + 0.001), atan(p.z, p.x));\n}\n\nfloat LToLat(float L) {\n    if(L < 1.0) return 1.57;\n    return asin(clamp(1.0 / sqrt(L), -1.0, 1.0));\n}\nfloat latToL(float lat) {float s = sin(lat); return 1.0 / (s*s + 0.001);}\n\nfloat sdHairLine(vec3 p, float latSpc, float aziSpc, float thick) {\n    float r = length(p);\n    if(r < INNER_RADIUS || r > INNER_RADIUS + HAIRLENGTH) return 1e10; \n    vec2 prm = getHairParams(p);\n    float L = prm.x, phi = prm.y;\n    if(L < 0.1 ) return 1e10;\n    float lat = LToLat(L);\n    if(lat < 0.1) return 1e10;\n    float nearLat = round(lat / latSpc) * latSpc;\n    if(nearLat < 0.1) return 1e10;\n    float nearL = latToL(nearLat), nearPhi = round(phi / aziSpc) * aziSpc;\n    float Ldiff = abs(L - nearL) / L;\n    float phiDiff = abs(phi - nearPhi) * sin(lat);\n    float dist = sqrt(Ldiff*Ldiff + phiDiff*phiDiff);\n    float taper = 1.0 - smoothstep(INNER_RADIUS, INNER_RADIUS + HAIRLENGTH, r);\n    if(taper <= 0.0) return 1e10;\n    return dist - thick * taper;\n}\n\nfloat hash(vec2 p) {\n    p = fract(p * vec2(123.34, 456.78));\n    p += dot(p, p + 34.56);\n    return fract(p.x * p.y);\n}\n\nvec2 getHairID(vec3 p, float latSpc, float aziSpc) {\n    vec2 prm = getHairParams(p);\n    if(prm.x < 1.0) return vec2(0);\n    float lat = LToLat(prm.x);\n    return vec2(round(lat / latSpc), round(prm.y / aziSpc));\n}\n\nfloat map(vec3 p) {return sdSphere(p, INNER_RADIUS);}\n\nfloat mapHairs(vec3 p, float latSpc, float aziSpc, float thick) {\n    return min(sdSphere(p, INNER_RADIUS), sdHairLine(p, latSpc, aziSpc, thick));\n}\n\nbool inHairZone(vec3 p) {\n    float d = length(p);\n    return d > INNER_RADIUS && d < INNER_RADIUS + HAIRLENGTH;\n}\n\nfloat getHairOpacity(vec3 p) {\n    float r = length(p);\n    float fade = 1.0 - smoothstep(INNER_RADIUS, INNER_RADIUS + HAIRLENGTH, r);\n    return fade * 0.9;\n}\n\nvec3 getHairColor(vec3 p, float random, vec3 lightDir, vec3 lightDir2, vec3 viewDir) {\n    vec3 nHit = normalize(p);\n    float diff = max(dot(nHit, lightDir), 0.0);\n    float diff2 = max(dot(nHit, lightDir2), 0.0);\n    float ambient = 0.3;\n    vec3 hairColA = vec3(0.85, 0.6, 0.3);\n    vec3 hairColB = vec3(0.5, 0.4, 0.0);\n    vec3 hairCol = mix(hairColA, hairColB, random);\n    vec3 hitCol = hairCol * (diff + ambient);\n    hitCol += vec3(0.3,0,0) * (diff2 + ambient);\n    float spec = pow(max(dot(reflect(-lightDir, nHit), viewDir), 0.0), 16.0);\n    hitCol += vec3(0.4) * spec;\n    return hitCol;\n}\n\nvec3 raymarchVolume(vec3 ro, vec3 rd, float latSpc, float aziSpc, float thick) {\n    float t = 0.0;\n    vec3 col = vec3(0.9, 0.85, 0.8); \n    \n    vec3 lightDir = normalize(vec3(2,3,-2));\n    vec3 lightDir2 = normalize(vec3(-1,-2,1));\n    \n    for(int pass = 0; pass < MAX_PASSES; pass++) {\n        bool hitSomething = false;\n        \n        for(int i = 0; i < 150; i++) {\n            vec3 p = ro + rd * t;\n            float d = mapHairs(p, latSpc, aziSpc, thick);\n            \n            if(d < 0.001) {\n                float objId = 0.0, opacity = 1.0;\n                vec2 hairID = getHairID(p, latSpc, aziSpc);\n                \n                if(inHairZone(p)) {\n                    float innerD = sdSphere(p, INNER_RADIUS);\n                    float hairD = sdHairLine(p, latSpc, aziSpc, thick);\n                    if(hairD < innerD && hairD < 0.001) {\n                        objId = 1.0;\n                        opacity = getHairOpacity(p);\n                    }\n                }\n                \n                if(objId > 0.5) {\n                    // Hair hit - blend and continue if transparent\n                    vec3 hairCol = getHairColor(p, hash(hairID), lightDir, lightDir2, -rd);\n                    col = mix(col, hairCol, opacity);\n                    // If mostly opaque, stop here\n                    if(opacity > 0.8) return col;           \n                    // Continue ray slightly past this hit\n                    t += 0.001;\n                    hitSomething = true;\n                    break;\n                } else {\n                    // Hit solid head - fully opaque\n                    vec3 nHit = normalize(p);\n                    float diff = max(dot(nHit, lightDir), 0.0);\n                    float ambient = 0.3;\n                    col = vec3(0.6, 0.5, 0.4) * (diff + ambient);\n                    return col;\n                }\n            }\n            \n            t += d * 0.8;\n            if(t > 5.0) break;\n        }\n        \n        // If we didn't hit anything in this pass, we're done\n        if(!hitSomething) break;\n    }\n    \n    return col;\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, float r) {\n    float b = dot(ro, rd), c = dot(ro, ro) - r*r, h = b*b - c;\n    if(h < 0.0) return vec2(-1);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if(length(iMouse.xy) < 0.001) mouse = vec2(0.5);\n    \n    float theta = (mouse.x - 0.5) * 6.28318;\n    float phi = (mouse.y - 0.5) * 3.14159;\n    float autoRot = iTime * 0.2;\n    if(iMouse.z > 0.0) autoRot = 0.0;\n    theta += autoRot;\n    \n    float radius = 2.5;\n    vec3 ro = vec3(radius * cos(theta) * cos(phi), radius * sin(phi),\n                   radius * sin(theta) * cos(phi));\n    \n    vec3 target = vec3(0), forward = normalize(target - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n   \n    vec3 col = vec3(0.9, 0.85, 0.8);\n    \n    vec2 outerHit = raySphere(ro, rd, OUTER_RADIUS);\n    if(outerHit.x > 0.0) {\n        vec3 pEnter = ro + rd * outerHit.x;\n        vec3 roInner = pEnter + rd * 0.001;\n        col = raymarchVolume(roInner, rd, LATSPACING, AZISPACING, HAIRTHICK);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float s = AA, k; vec2 j = vec2(.5); o = vec4(0); vec4 c;\n    mainImage0(c, u);\n    for (k = s; k-- > .5; ) {\n        mainImage0(c, u + j - .5); o += c;\n        j = fract(j + vec2(.755, .57).yx);\n    };o /= s;o.a==1.;\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wcfyzM",
    "date": "1755458213",
    "viewed": 221,
    "name": "Cat Eye Iris/Pupil texture",
    "description": "A quick 2D mockup of the eye turned out better than I expected.\nMouse over to dilate pupil",
    "likes": 26,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "sdf",
     "eye",
     "cat",
     "iris",
     "predator",
     "dilation",
     "vesica",
     "pupil"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dfGRn",
       "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "Xsf3Rr",
       "filepath": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Cat Eye SDF\" by Cotterzz. https://shadertoy.com/view/tXKXzV\n// 2025-08-17 19:10:26\n\nfloat sdCateye(vec2 p, float height, float dilation)\n{\n    float vrad = height/2.;\n    dilation = min(.999, max(0.01, dilation));\n    float rad = (vrad)/dilation;\n    float dist = sqrt((rad*rad)-(vrad*vrad));\n    p = abs(p);\n    vec2 center = vec2(-dist, 0.);\n    float tdist = distance(p, center);\n    float result = tdist - rad;\n    vec2 nearest = center+(p-center)*rad/tdist;\n    if(nearest.y>vrad){result=distance(p,vec2(0.,vrad));}\n\n    return result;\n}\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\nvec3 gmc(vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    p*=1.3;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float eHeight = 1.;\n    float eDilation = 0.4*(sin(iTime)+1.3);\n    \n    if( iMouse.z>0.001 ) {eHeight = 1.0;//iMouse.y/iResolution.y;\n        eDilation = iMouse.x/iResolution.x/0.9;}\n    eHeight*=1.5-(eDilation/6.);\n\tfloat dA = sdCateye( p, eHeight, 0.0);\n    float dB = sdCateye( p, eHeight, eDilation);\n    float d = dB-dA;\n    if(p.x<0.){d=-d;}\n    float cd = length(p*vec2(.9,1));\n    d = mix(d,0. , min(1.,max(0.,(cd-.8)*5.)));\n    float eb = distance(p, vec2(0.1, -0.6));\n    float el = distance(p, vec2(0.3, -1.2));\n    float et = distance(p, vec2(-.2, 0.6));\n    float ee = max(et, eb);\n    vec3 col = (dB>0.0) ? (texture(iChannel0, (p.xy+vec2(d,0))/6., 0.).rgb+0.2)/(0.7+dB): vec3(0);\n    col = mix(col*col*col, col, min(1.,dB*10.));\n    col = mix(vec3(0), col, min(1.,dB*45.));\n    dB = dB*dB;\n    col = contrast(col, 1.-(dB/5.));\n    col = gmc(col, 0.4+dB);\n    if(col.r<0.1-(dB/max(0.0001,eDilation*1.5))){col=vec3(0);}\n    if(col.g<0.1-(dB/max(0.0001,eDilation*1.5))){col=vec3(0);}\n    col = mix(col, vec3(0), max(0.,cd-.93 )*7.);\n    col = mix(col, vec3(0.9,1,1.0), min(1.,max(0.,cd-1.05 )*15.));\n    col = mix(col, col*vec3(.01,.015,.01), min(1.,max(0.,el-1.6 )*2.));\n    float ref = texture(iChannel1, (p.xy + vec2(-1.5,1))*vec2(-0.5,0.5), 0.).b;\n    ref=0.4+ref/2.;\n    if(ee<1.53){col = col+max(0.,(ref-0.8)*15.);}\n    col = mix(col, vec3(0.1,.11,0.1), min(1.,max(0.,ee-1.6 )*15.));\n    col.g*=1.5;\n\tfragColor = vec4(col,1.);\n}\n\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3clyz7",
    "date": "0",
    "viewed": 0,
    "name": "Cat Eye 3D",
    "description": "A quick 2D mockup of the eye turned out better than I expected.\nMouse over to dilate pupil",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "3d",
     "refraction",
     "eye",
     "cat",
     "iris",
     "realistic",
     "dilation",
     "pupil"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xsf3Rr",
       "filepath": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Shadertoy raymarched sphere with texture-based displacement\n// Eye with transparent lens covering\n\n#define MAX_STEPS 150\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n\n// Texture mapping and displacement parameters\n#define UV_SCALE_X 0.4\n#define UV_SCALE_Y 0.6\n#define UV_OFFSET 0.5\n#define DISPLACE_AMOUNT 0.02\n\n// Flatten parameters\n#define FLATTEN_ANGLE 0.76   // 45 degrees - outer edge of displacement area\n#define FLATTEN_DEPTH 0.5        // Inner radius where displacement is full strength\n\n#define LIGHTP vec3(1.5,1.5,-1.5)\n\n// iris texture functions\nfloat sdCateye(vec2 p, float height, float dilation)\n{\n    float vrad = height/2.;\n    dilation = min(.999, max(0.01, dilation));\n    float rad = (vrad)/dilation;\n    float dist = sqrt((rad*rad)-(vrad*vrad));\n    p = abs(p);\n    vec2 center = vec2(-dist, 0.);\n    float tdist = distance(p, center);\n    float result = tdist - rad;\n    vec2 nearest = center+(p-center)*rad/tdist;\n    if(nearest.y>vrad){result=distance(p,vec2(0.,vrad));}\n    return result;\n}\nvec3 contrast(vec3 color, float value) {return 0.5 + value * (color - 0.5);}\nvec3 gmc(vec3 colour, float gamma) {return pow(colour, vec3(1. / gamma));}\n\nvec4 eyeTexture( vec2 uv ){\n    vec2 p = (uv*2.)-1.;\n    p.x/=iResolution.y/iResolution.x;\n    p*=1.3;\n    float eHeight = 1.;\n    float eDilation = 0.4*(sin(iTime)+1.3);\n    if( iMouse.z>0.001 ) {eHeight = 1.0; eDilation = iMouse.x/iResolution.x/0.9;}\n    eHeight*=1.5-(eDilation/6.);\n\tfloat dA = sdCateye( p, eHeight, 0.0);\n    float dB = sdCateye( p, eHeight, eDilation);\n    float d = dB-dA;\n    d=d+abs(atanh((p.x*p.x)/1.3));\n    if(p.x<0.){d=-d;}\n    float cd = length(p*vec2(.85,1));\n    float eb = distance(p, vec2(0.1, -0.6));\n    float el = distance(p, vec2(0.3, -1.2));\n    float et = distance(p, vec2(-.2, 0.6));\n    float ee = max(et, eb);\n    vec3 col = (dB>0.0) ? (texture(iChannel0, (p.xy+vec2(d,0))/6., 0.).rgb+0.2)/(0.7+dB): vec3(0);\n    col = mix(col*col*col, col, min(1.,dB*10.));\n    col = mix(vec3(0), col, min(1.,dB*25.));\n    dB = dB*dB;\n    col = contrast(col, 1.-(dB/5.));\n    col = gmc(col, 0.4+dB);\n    if(col.r<0.3-(dB/max(0.0001,eDilation*1.5))){col=vec3(0);}\n    if(col.g<0.2-(dB/max(0.0001,eDilation*1.5))){col=vec3(0);}\n    col = mix(col, vec3(0,0,0.1), max(0.,cd-.93 )*7.);\n    col.g*=1.5;\n    col = mix(col, vec3(1,1,1), min(1.,max(0.,cd-1.05 )*15.));\n    return vec4(col, 1.);\n}\n\n// Eye sphere SDF (with flattening and displacement)\nfloat sdEye(vec3 p, float r) {\n    // Start with basic sphere\n    float d = length(p) - r;\n    \n    // Flatten the negative z side by intersecting with a plane\n    float cutDepth = r * cos(FLATTEN_ANGLE);\n    float planeD = -p.z - cutDepth;\n    d = max(d, planeD);\n    \n    // Apply texture displacement to the area\n    float outerRadius = r * sin(FLATTEN_ANGLE);\n    float innerRadius = FLATTEN_DEPTH;\n    float distFromCenter = length(p.xy);\n    \n    if (p.z <= -cutDepth + 0.1 && distFromCenter <= outerRadius) {\n        vec2 uv;\n        uv.x = p.x * UV_SCALE_X + UV_OFFSET;\n        uv.y = p.y * UV_SCALE_Y + UV_OFFSET;\n        uv = clamp(uv, 0.0, 1.0);\n        \n        vec4 texCol = eyeTexture( uv);\n        float darkness = 1.0 - (texCol.r * 0.299 + texCol.g * 0.587 + texCol.b * 0.114);\n        \n        float falloff = 1.0;\n        if (distFromCenter > innerRadius) {\n            falloff = 1.0 - smoothstep(innerRadius, outerRadius, distFromCenter);\n        }\n        \n        float displaceAmount = darkness * DISPLACE_AMOUNT * falloff;\n        d += displaceAmount;\n    }\n    \n    return d;\n}\n\n// Lens SDF - simple sphere shell - Thin shell slightly outside eye\nfloat sdLens(vec3 p, float r) {return abs(length(p) - r - 0.02) - 0.003; }\n\n// Get normal\nvec3 getEyeNormal(vec3 p) {\n    float d = sdEye(p, 1.0);\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = d - vec3(\n        sdEye(p - e.xyy, 1.0),\n        sdEye(p - e.yxy, 1.0),\n        sdEye(p - e.yyx, 1.0)\n    );\n    \n    return normalize(n);\n}\n\nvec3 getLensNormal(vec3 p) {\n\n    return normalize(p); // For a sphere centered at origin\n\n    // keep this in case we need it again\n    float d = sdLens(p, 1.0);\n    vec2 e = vec2(0.001, 0);\n    vec3 n = d - vec3(\n        sdLens(p - e.xyy, 1.0),\n        sdLens(p - e.yxy, 1.0),\n        sdLens(p - e.yyx, 1.0)\n    );\n    return normalize(n);\n    \n}\n\n// Separate raymarching for each object\nfloat rayMarchEye(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = sdEye(p, 1.0);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nfloat rayMarchLens(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = sdLens(p, 1.0);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n// Get texture color at hit point\nvec3 getTextureColor(vec3 p) {\n    if (p.z < 0.0) {\n        vec2 uv;\n        uv.x = p.x * UV_SCALE_X + UV_OFFSET;\n        uv.y = p.y * UV_SCALE_Y + UV_OFFSET;\n        uv = clamp(uv, 0.0, 1.0);\n        \n        return eyeTexture( uv).rgb;\n    }\n    return vec3(0.8, 0.8, 0.8);\n}\n\n// Eye lighting\nvec3 getEyeLight(vec3 p, vec3 rd) {\n    vec3 l = normalize(LIGHTP - p);\n    vec3 n = getEyeNormal(p);\n    vec3 v = -rd;\n    vec3 r = reflect(-l, n);\n    \n    vec3 albedo = getTextureColor(p);\n    \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    float spec = pow(max(dot(r, v), 0.0), 32.0);\n    \n    vec3 ambient = albedo * 0.1;\n    vec3 diffuse = albedo * dif *1.1;\n    vec3 specular = vec3(1.0) * spec * 0.01;\n    \n    return ambient + diffuse + specular;\n}\n\n// Lens lighting\nvec3 getLensLight(vec3 p, vec3 rd) {\n\n    vec3 l = normalize(LIGHTP - p);\n    vec3 n = getLensNormal(p);\n    vec3 v = -rd;\n    vec3 r = reflect(-l, n);\n    \n    float spec = pow(max(dot(r, v), 0.0), 32.0);\n    float fresnel = pow(1.0 - abs(dot(v, n)), 1.0);\n    \n    // Lens base color - slightly bluish/clear glass tint\n    vec3 lensColor = vec3(0.95, 0.97, 1.0); // Slight blue tint\n    \n    // Add some base brightness to the lens\n    vec3 baseGlass = lensColor * 0.2; // Base glass brightness\n    vec3 specular = vec3(1.) * spec * 50.0; // Increased from your settings\n    vec3 fresnelColor = lensColor * fresnel *0.2;\n    \n    return baseGlass + specular + fresnelColor;\n}\n\n// Refraction using Snell's law\nvec3 refract_ray(vec3 incident, vec3 normal, float eta) {\n    float cosI = -dot(normal, incident);\n    float sinT2 = eta * eta * (1.0 - cosI * cosI);\n    if (sinT2 > 1.0) return vec3(0.0); // Total internal reflection\n    float cosT = sqrt(1.0 - sinT2);\n    return eta * incident + (eta * cosI - cosT) * normal;\n}\n\n// Enhanced lens rendering with refraction\nvec4 renderWithRefraction(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.04, 0.04, 0.05); // Background\n    float nearestD = MAX_DIST;\n    // First, check if we hit the lens\n    float lensD = rayMarchLens(ro, rd);\n    nearestD = min(nearestD, lensD);\n    if(lensD < MAX_DIST) {\n        vec3 lensP = ro + rd * lensD;\n        vec3 lensN = getLensNormal(lensP);\n        \n        // Calculate refraction\n        float eta = 1.0 / 1.1; // Air to glass (1.52 is typical for eye lens)\n        vec3 refractedRay = refract_ray(rd, lensN, eta);\n        \n        if(length(refractedRay) > 0.0) {\n            // Continue raymarching with refracted ray\n            vec3 newRo = lensP + refractedRay * 0.01; // Small offset to avoid self-intersection\n            \n            // Check if refracted ray hits the eye\n            float eyeD = rayMarchEye(newRo, refractedRay);\n            \n            if(eyeD < MAX_DIST) {\n                vec3 eyeP = newRo + refractedRay * eyeD;\n                vec3 eyeCol = getEyeLight(eyeP, refractedRay);\n                \n                // Apply some color shift/distortion based on refraction angle\n                float refractionStrength = length(rd - refractedRay);\n                eyeCol = mix(eyeCol, eyeCol.gbr, refractionStrength * 0.1); // Slight chromatic aberration\n                \n                col = eyeCol;\n            }\n        }\n        \n        // Add lens surface effects\n        vec3 lensCol = getLensLight(lensP, rd);\n        float fresnel = pow(1.0 - abs(dot(-rd, lensN)), 2.);\n        col = mix(col, lensCol, fresnel * 0.2); // Blend lens surface\n        \n    } else {\n        // No lens hit, render eye directly\n        float eyeD = rayMarchEye(ro, rd);\n        nearestD = min(nearestD, eyeD);\n        if(eyeD < MAX_DIST) {\n            vec3 eyeP = ro + rd * eyeD;\n            col = getEyeLight(eyeP, rd);\n        }\n    }\n    \n    return vec4(col, nearestD);\n}\n\n\nvoid mainMS(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    // Camera\n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    // Mouse rotation\n    float angleY = (m.x - 0.5) * 6.28;\n    float angleX = (m.y - 0.5) * 3.14;\n    \n    mat3 rotY = mat3(\n        cos(angleY), 0, sin(angleY),\n        0, 1, 0,\n        -sin(angleY), 0, cos(angleY)\n    );\n    \n    mat3 rotX = mat3(\n        1, 0, 0,\n        0, cos(angleX), -sin(angleX),\n        0, sin(angleX), cos(angleX)\n    );\n    \n    ro = rotY * rotX * ro;\n    rd = rotY * rotX * rd;\n    \n    // Render\n    // Replace the existing render section with:\n    vec4 colPND = renderWithRefraction(ro, rd);\n    vec3 col = colPND.rgb;\n\n    // Apply fog\n\n    float nearestD = colPND.a;\n    if(nearestD < MAX_DIST) {\n        col = mix(col, vec3(0.1, 0.1, 0.15), 1.0 - exp(-0.0005 * nearestD * nearestD));\n    }\n    \n    // Gamma correction\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}\n\n// AA multisampling\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = 2., k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainMS(c, u); \n    for (k = s; k-- > .5; ) { \n        mainMS(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a=1.;\n} ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WfXcWn",
    "date": "1755512030",
    "viewed": 151,
    "name": "Cat Eye - Raymarched",
    "description": "A more realistic 3D version of a cat eye.\nUsing the texture animation from the 2D mockup.\nClick and drag.",
    "likes": 25,
    "published": "Public API",
    "usePreview": 1,
    "tags": [
     "3d",
     "refraction",
     "eye",
     "cat",
     "iris",
     "realistic",
     "dilation",
     "pupil"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xsf3Rr",
       "filepath": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Cat Eye Iris/Pupil texture\" by Cotterzz. https://www.shadertoy.com/view/wcfyzM\n// 2025-08-18 09:54:31\n// Fork of \"Cat Eye SDF\" by Cotterzz. https://shadertoy.com/view/tXKXzV\n// 2025-08-17 19:10:26\n\n#define AA 2.0\n#define MAX_STEPS 150\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n// Texture mapping and displacement parameters\n#define UV_SCALE_X 0.4\n#define UV_SCALE_Y 0.6\n#define UV_OFFSET 0.5\n#define DISPLACE_AMOUNT 0.02\n// Flatten parameters\n#define FLATTEN_ANGLE 0.7\n#define FLATTEN_DEPTH 0.5   \n#define LIGHTP vec3(1.0,1.0,-0.9)\n\nmat3 g_rotation;\nfloat g_lightIntensity = 0.0;\n\nfloat calculateIrisLightIntensity(mat3 rotation) {\n    \n    vec3 irisForward = rotation * vec3(0.0, 0.0, -1.0);\n    vec3 lightDir = normalize(LIGHTP);\n    float intensity = max(0.0, dot(irisForward, lightDir));\n    intensity = pow(intensity, 2.0); \n    return intensity;\n}\n\n// iris texture functions from first shader\nfloat sdCateye(vec2 p, float height, float dilation)\n{\n    float vrad = height/2.;\n    dilation = min(.999, max(0.01, dilation));\n    float rad = (vrad)/dilation;\n    float dist = sqrt((rad*rad)-(vrad*vrad));\n    p = abs(p);\n    vec2 center = vec2(-dist, 0.);\n    float tdist = distance(p, center);\n    float result = tdist - rad;\n    vec2 nearest = center+(p-center)*rad/tdist;\n    if(nearest.y>vrad){result=distance(p,vec2(0.,vrad));}\n    return result;\n}\nvec3 contrast(vec3 color, float value) {return 0.5 + value * (color - 0.5);}\nvec3 gmc(vec3 colour, float gamma) {return pow(colour, vec3(1. / gamma));}\n\nvec4 eyeTexture(vec2 uv, float lightDilation) {\n    vec2 p = (uv*2.)-1.;\n    p.x/=iResolution.y/iResolution.x;\n    p*=1.3;\n    float eHeight = 1.;\n    float eDilation = mix(1.0, 0.15, 1.-lightDilation); \n    eHeight= 1.0 + eDilation/2.;\n\tfloat dA = sdCateye( p, eHeight, 0.0);\n    float dB = sdCateye( p, eHeight, eDilation);\n    float d = dB-dA;\n    if(p.x<0.){d=-d;}\n    float cd = length(p*vec2(.84,1)*1.06);\n    d = mix(d,0. , min(1.,max(0.,(cd-.8)*5.)));\n    float eb = distance(p, vec2(0.1, -0.6));\n    float el = distance(p, vec2(0.3, -1.2));\n    float et = distance(p, vec2(-.2, 0.6));\n    float ee = max(et, eb);\n    vec3 col = (dB>0.0) ? (texture(iChannel0, (p.xy+vec2(d,0))/6., 0.).rgb+0.2)/(0.7+dB): vec3(0);\n    col = mix(col*col*col, col, min(1.,dB*10.));\n    col = mix(vec3(0), col, min(1.,dB*45.));\n    dB = dB*dB;\n    col = contrast(col, 1.-(dB/5.));\n    col = gmc(col, 0.4+dB);\n    if(col.r<0.1-(dB/max(0.0001,eDilation*1.5))){col=vec3(0);}\n    if(col.g<0.1-(dB/max(0.0001,eDilation*1.5))){col=vec3(0);}\n    col = mix(col, vec3(0,0,0.1), max(0.,cd-.93 )*7.);\n    col.g*=1.5;\n    col = mix(col, vec3(1,1,1), min(1.,max(0.,cd-1.05 )*15.));\n    return vec4(col, 1.);\n}\n\nfloat sdEye(vec3 p, float r) {\n    \n    float d = length(p) - r;\n    float cutDepth = r * cos(FLATTEN_ANGLE);\n    float planeD = -p.z - cutDepth;\n    d = max(d, planeD);\n\n    float outerRadius = r * sin(FLATTEN_ANGLE);\n    float innerRadius = FLATTEN_DEPTH;\n    float distFromCenter = length(p.xy);\n    \n    if (p.z <= -cutDepth + 0.1 && distFromCenter <= outerRadius) {\n        vec2 uv;\n        uv.x = p.x * UV_SCALE_X + UV_OFFSET;\n        uv.y = p.y * UV_SCALE_Y + UV_OFFSET;\n        uv = clamp(uv, 0.0, 1.0);\n        \n        vec4 texCol = eyeTexture(uv, g_lightIntensity);\n        float darkness = 1.0 - (texCol.r * 0.299 + texCol.g * 0.587 + texCol.b * 0.114);\n        \n        float falloff = 1.0;\n        if (distFromCenter > innerRadius) {\n            falloff = 1.0 - smoothstep(innerRadius, outerRadius, distFromCenter);\n        }\n        \n        float displaceAmount = darkness * DISPLACE_AMOUNT * falloff;\n        d += displaceAmount;\n    }\n    \n    return d;\n}\n\nfloat sdLens(vec3 p, float r) {return abs(length(p) - r - 0.02) - 0.003; }\n\nvec3 getEyeNormal(vec3 p) {\n    float d = sdEye(p, 1.0);\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = d - vec3(\n        sdEye(p - e.xyy, 1.0),\n        sdEye(p - e.yxy, 1.0),\n        sdEye(p - e.yyx, 1.0)\n    );\n    \n    return normalize(n);\n}\n\nvec3 getLensNormal(vec3 p) {\n\n    return normalize(p); // Only works for a sphere centered at origin\n    // keep this in case we need it again\n    float d = sdLens(p, 1.0);\n    vec2 e = vec2(0.001, 0);\n    vec3 n = d - vec3(\n        sdLens(p - e.xyy, 1.0),\n        sdLens(p - e.yxy, 1.0),\n        sdLens(p - e.yyx, 1.0)\n    );\n    return normalize(n);\n    \n}\n\nfloat rayMarchEye(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = sdEye(p, 1.0);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nfloat rayMarchLens(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = sdLens(p, 1.0);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\nvec3 getTextureColor(vec3 p) {\n    if (p.z < 0.0) {\n        vec2 uv;\n        uv.x = p.x * UV_SCALE_X + UV_OFFSET;\n        uv.y = p.y * UV_SCALE_Y + UV_OFFSET;\n        uv = clamp(uv, 0.0, 1.0);\n        \n        return eyeTexture(uv, g_lightIntensity).rgb;\n    }\n    return vec3(0.8, 0.8, 0.8);\n}\n\nvec3 getEyeLight(vec3 p, vec3 rd) {\n\n    vec3 lightInEyeSpace = g_rotation * LIGHTP;\n    vec3 l = normalize(lightInEyeSpace - p);\n    vec3 n = getEyeNormal(p);\n    vec3 v = -rd;\n    vec3 r = reflect(-l, n);\n    vec3 albedo = getTextureColor(p);\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    float spec = pow(max(dot(r, v), 0.0), 16.0);\n    vec3 ambient = albedo * 0.15;\n    vec3 diffuse = albedo * dif *0.5;\n    vec3 specular = vec3(1.0) * spec * 0.01;\n    return ambient + diffuse + specular;\n}\n\n\nvec3 getLensLight(vec3 p, vec3 rd) {\n    vec3 lightInEyeSpace = g_rotation * LIGHTP;\n    vec3 l = normalize(lightInEyeSpace - p);\n    vec3 n = getLensNormal(p);\n    vec3 v = -rd;\n    vec3 r = reflect(-l, n);\n    float spec = pow(max(dot(r, v), 0.0), 32.0);\n    float fresnel = pow(1.0 - abs(dot(v, n)), 1.0);\n    vec3 lensColor = vec3(0.95, 0.97, 1.0); \n    vec3 baseGlass = lensColor * 0.2; \n    vec3 specular = vec3(1.) * spec * 50.0; \n    vec3 fresnelColor = lensColor * fresnel *0.2;\n    \n    return baseGlass + specular + fresnelColor;\n}\n\n// Refraction using Snell's law\nvec3 refract_ray(vec3 incident, vec3 normal, float eta) {\n    float cosI = -dot(normal, incident);\n    float sinT2 = eta * eta * (1.0 - cosI * cosI);\n    if (sinT2 > 1.0) return vec3(0.0); // Total internal reflection\n    float cosT = sqrt(1.0 - sinT2);\n    return eta * incident + (eta * cosI - cosT) * normal;\n}\n\n\nvec4 renderWithRefraction(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.04, 0.04, 0.05);\n    float nearestD = MAX_DIST;\n    // First, check if we hit the lens\n    float lensD = rayMarchLens(ro, rd);\n    nearestD = min(nearestD, lensD);\n    if(lensD < MAX_DIST) {\n        vec3 lensP = ro + rd * lensD;\n        vec3 lensN = getLensNormal(lensP);\n        \n        // Calculate refraction\n        float eta = 1.0 / 1.1; // Air to glass (1.52 is typical for eye lens)\n        vec3 refractedRay = refract_ray(rd, lensN, eta);\n        \n        if(length(refractedRay) > 0.0) {\n            // Continue raymarching with refracted ray\n            vec3 newRo = lensP + refractedRay * 0.01; // Small offset to avoid self-intersection\n            // Check if refracted ray hits the eye\n            float eyeD = rayMarchEye(newRo, refractedRay);\n            \n            if(eyeD < MAX_DIST) {\n                vec3 eyeP = newRo + refractedRay * eyeD;\n                vec3 eyeCol = getEyeLight(eyeP, refractedRay);\n                \n                // Apply some color shift/distortion based on refraction angle\n                float refractionStrength = length(rd - refractedRay);\n                eyeCol = mix(eyeCol, eyeCol.gbr, refractionStrength * 0.1); // Slight chromatic aberration\n                \n                col = eyeCol;\n                \n                /* Additional check if we exit through the back of the lens\n                vec3 exitRo = eyeP;\n                vec3 exitRd = -refractedRay; // Ray going back\n                float exitD = rayMarchLens(exitRo, exitRd);\n                if(exitD < MAX_DIST) {\n                    vec3 exitP = exitRo + exitRd * exitD;\n                    vec3 exitN = -getLensNormal(exitP); // Inward normal\n                    vec3 exitRefracted = refract_ray(exitRd, exitN, 1.1); // Glass to air\n                    // Could add additional effects here\n                }*/\n            }\n        }\n        \n        // Add lens surface effects\n        vec3 lensCol = getLensLight(lensP, rd);\n        float fresnel = pow(1.0 - abs(dot(-rd, lensN)), 2.);\n        col = mix(col, lensCol, fresnel * 0.2); // Blend lens surface\n        \n    } else {\n        // No lens hit, render eye directly\n        float eyeD = rayMarchEye(ro, rd);\n        nearestD = min(nearestD, eyeD);\n        if(eyeD < MAX_DIST) {\n            vec3 eyeP = ro + rd * eyeD;\n            col = getEyeLight(eyeP, rd);\n        }\n    }\n    \n    return vec4(col, nearestD);\n}\n\n\nvoid mainMS(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = vec2(0.5+sin(iTime/4.)/5., 0.5+sin(iTime/1.5)/6.);\n    \n    if(iMouse.z>0.001){m = iMouse.xy / iResolution.xy;}\n    \n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float angleY = (m.x - 0.5) * -6.28;\n    float angleX = (m.y - 0.5) * 3.14;\n    \n    mat3 rotY = mat3(\n        cos(angleY), 0, sin(angleY),\n        0, 1, 0,\n        -sin(angleY), 0, cos(angleY)\n    );\n    \n    mat3 rotX = mat3(\n        1, 0, 0,\n        0, cos(angleX), -sin(angleX),\n        0, sin(angleX), cos(angleX)\n    );\n    \n    g_rotation = rotY * rotX;\n    \n    g_lightIntensity = calculateIrisLightIntensity(g_rotation);\n    \n    ro = g_rotation * ro;\n    rd = g_rotation * rd;\n    \n    vec4 colPND = renderWithRefraction(ro, rd);\n    vec3 col = colPND.rgb;\n\n    float nearestD = colPND.a;\n    if(nearestD < MAX_DIST) {\n        col = mix(col, vec3(0.1, 0.1, 0.15), 1.0 - exp(-0.0005 * nearestD * nearestD));\n    }\n    \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}\n\n// AA multisampling\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = AA, k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainMS(c, u); \n    for (k = s; k-- > .5; ) { \n        mainMS(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a=1.;\n} ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WfXcD7",
    "date": "1755687120",
    "viewed": 134,
    "name": "Cat Eye 3D w Fake Caustics",
    "description": "Several improvements:\nDelayed, nicer dilation, plus some fake caustic effects to match the refraction.\nNext I guess I need some subsurface lighting and then try a human eye...\nClick and drag.",
    "likes": 13,
    "published": "Public API",
    "usePreview": 1,
    "tags": [
     "3d",
     "refraction",
     "eye",
     "cat",
     "iris",
     "realistic",
     "dilation",
     "pupil"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Cat Eye - Raymarched\" by Cotterzz. https://shadertoy.com/view/WfXcWn\n// 2025-08-20 10:11:08\n// Fork of \"Cat Eye Iris/Pupil texture\" by Cotterzz. https://www.shadertoy.com/view/wcfyzM\n// 2025-08-18 09:54:31\n// Fork of \"Cat Eye SDF\" by Cotterzz. https://shadertoy.com/view/tXKXzV\n// 2025-08-17 19:10:26\n\n\n// I had to put it in a buffer so I could store the light amount and have the pupil realistically dilate after a delay\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "XsfGRn",
       "filepath": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg",
       "type": "texture",
       "channel": 2,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "Xsf3Rr",
       "filepath": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define AA 1.0\n#define MBLUR 2.5\n#define MAX_STEPS 300\n#define MAX_DIST 120.0\n#define SURF_DIST 0.00001\n// Texture mapping and displacement parameters\n#define UV_SCALE_X 0.4\n#define UV_SCALE_Y 0.6\n#define UV_OFFSET 0.5\n#define DISPLACE_AMOUNT 0.03\n// Flatten parameters\n#define FLATTEN_ANGLE 0.8\n#define FLATTEN_DEPTH 0.5   \n#define LIGHTP vec3(1.0,1.3,-1.2)\n\n#define REFRACT 1.12  //1.0 is no refraction.\n// apparenty 1.52 is recommended for eye but is way too much, possibly because geometry\n\n// Light focusing parameters\n#define LENS_FOCUS_STRENGTH 6.0   // How much the lens focuses light\n#define LENS_CUTOFF_ANGLE 1.2     // ~80 degrees in radians - maximum angle for light to pass through lens\n#define BASE_BRIGHTNESS 1.5       // Overall brightness multiplier\n\nmat3 g_rotation;\nfloat g_lightIntensity = 0.0; // real time light intensity\nfloat r_lightIntensity = 0.0; // delayed value for pupil dilation\n\nfloat calculateIrisLightIntensity(mat3 rotation) {\n    \n    vec3 irisForward = rotation * vec3(0.0, 0.0, -1.0);\n    vec3 lightDir = normalize(LIGHTP);\n    float intensity = max(0.0, dot(irisForward, lightDir));\n   intensity = pow(intensity,0.3); \n    return intensity;\n}\n\nfloat sdCateye(vec2 p, float height, float dilation)\n{\n    float vrad = height/2.;\n    dilation = min(.999, max(0.01, dilation));\n    float rad = (vrad)/dilation;\n    float dist = sqrt((rad*rad)-(vrad*vrad));\n    p = abs(p);\n    vec2 center = vec2(-dist, 0.);\n    float tdist = distance(p, center);\n    float result = tdist - rad;\n    vec2 nearest = center+(p-center)*rad/tdist;\n    if(nearest.y>vrad){result=distance(p,vec2(0.,vrad));}\n    return result;\n}\nvec3 contrast(vec3 color, float value) {return 0.5 + value * (color - 0.5);}\nvec3 gmc(vec3 colour, float gamma) {return pow(colour, vec3(1. / gamma));}\n\nvec4 eyeTexture(vec2 uv, float lightDilation) {\n    vec2 p = (uv*2.)-1.;\n    p.x/=iResolution.y/iResolution.x;\n    p*=1.3;\n    float eHeight = 1.;\n    float eDilation = mix(1.0, 0.15, 1.-lightDilation); \n    eHeight= 1.0 + eDilation/2.;\n\tfloat dA = sdCateye( p, eHeight, 0.0);\n    float dB = sdCateye( p, eHeight, eDilation);\n    float d = dB-dA;\n    if(p.x<0.){d=-d;}\n    float cd = length(p*vec2(.84,1)/1.07);\n    d = mix(d,0. , min(1.,max(0.,(cd-.8)*5.)));\n    float eb = distance(p, vec2(0.1, -0.6));\n    float el = distance(p, vec2(0.3, -1.2));\n    float et = distance(p, vec2(-.2, 0.6));\n    float ee = max(et, eb);\n    vec2 tuv =  (p.xy+vec2(0.2,-0.3)+vec2(d,0))/6.;\n    vec3 tcol = (texture(iChannel0, tuv.yx, 0.).rgb + texture(iChannel2, tuv.yx, 0.).rgb)/2.4;\n    vec3 col = (dB>0.0) ? (tcol+0.2)/(0.7+dB): vec3(0);\n    col = mix(col*col*col, col, min(1.,dB*20.));\n    col = mix(vec3(0), col, min(1.,dB*25.));\n    dB = dB*dB;\n    col = contrast(col, 1.-(dB/5.));\n    col = gmc(col, 0.4+dB);\n    if(col.r<0.1-(dB/max(0.0001,eDilation*1.5))){col=vec3(0);}\n    if(col.g<0.1-(dB/max(0.0001,eDilation*1.5))){col=vec3(0);}\n    col = mix(col, vec3(0,0,0.1), max(0.,cd-.93 )*7.);\n    col.g*=1.5;\n    col = mix(col, vec3(1,1,1), min(1.,max(0.,cd-1.05 )*15.));\n    return vec4(col, 1.);\n}\n\nfloat sdEye(vec3 p, float r) {\n    \n    float d = length(p) - r;\n    float cutDepth = r * cos(FLATTEN_ANGLE);\n    float planeD = -p.z - cutDepth;\n    d = max(d, planeD);\n\n    float outerRadius = r * sin(FLATTEN_ANGLE);\n    float innerRadius = FLATTEN_DEPTH;\n    float distFromCenter = length(p.xy);\n    \n    if (p.z <= -cutDepth + 0.1 && distFromCenter <= outerRadius) {\n        vec2 uv;\n        uv.x = p.x * UV_SCALE_X + UV_OFFSET;\n        uv.y = p.y * UV_SCALE_Y + UV_OFFSET;\n        uv = clamp(uv, 0.0, 1.0);\n        \n        vec4 texCol = eyeTexture(uv, r_lightIntensity);\n        float darkness = 1.0 - (texCol.r * 0.299 + texCol.g * 0.587 + texCol.b * 0.114);\n        \n        float falloff = 1.0;\n        if (distFromCenter > innerRadius) {\n            falloff = 1.0 - smoothstep(innerRadius, outerRadius, distFromCenter);\n        }\n        \n        float displaceAmount = darkness * DISPLACE_AMOUNT * falloff;\n        d += displaceAmount;\n    }\n    \n    return d;\n}\n\nfloat sdLens(vec3 p, float r) {return abs(length(p) - r - 0.02) - 0.003; }\n\nvec3 getEyeNormal(vec3 p) {\n    float d = sdEye(p, 1.0);\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = d - vec3(\n        sdEye(p - e.xyy, 1.0),\n        sdEye(p - e.yxy, 1.0),\n        sdEye(p - e.yyx, 1.0)\n    );\n    \n    return normalize(n);\n}\n\nvec3 getLensNormal(vec3 p) {\n\n    return normalize(p); // Only works for a sphere centered at origin\n    // keep this in case we need it again\n    float d = sdLens(p, 1.0);\n    vec2 e = vec2(0.001, 0);\n    vec3 n = d - vec3(\n        sdLens(p - e.xyy, 1.0),\n        sdLens(p - e.yxy, 1.0),\n        sdLens(p - e.yyx, 1.0)\n    );\n    return normalize(n);\n    \n}\n\nfloat rayMarchEye(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = sdEye(p, 1.0);\n        dO += dS/4.;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nfloat rayMarchLens(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = sdLens(p, 1.0);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\nvec3 getTextureColor(vec3 p) {\n    if (p.z < 0.0) {\n        vec2 uv;\n        uv.x = p.x * UV_SCALE_X + UV_OFFSET;\n        uv.y = p.y * UV_SCALE_Y + UV_OFFSET;\n        uv = clamp(uv, 0.0, 1.0);\n        \n        return eyeTexture(uv, r_lightIntensity).rgb;\n    }\n    return vec3(1.0);\n}\n\n// Calculate focused light intensity for iris - like a torch beam at angle\nfloat calculateLensFocusedLight(vec3 irisPoint, vec3 lightPos) {\n    // Eye forward direction (where lens is pointing)\n    vec3 eyeForward = vec3(0.0, 0.0, -1.0);\n    \n    // Light direction from eye center\n    vec3 lightDir = normalize(lightPos);\n    \n    // Angle between eye forward and light\n    float lightAngle = acos(clamp(dot(eyeForward, lightDir), -1.0, 1.0));\n    \n    // Cut off light if angle is too large - with smooth transition\n    if (lightAngle > LENS_CUTOFF_ANGLE) {\n        return 0.0;\n    }\n    \n    // Smooth cutoff transition\n    float angleFade = 1.0 - smoothstep(LENS_CUTOFF_ANGLE * 0.8, LENS_CUTOFF_ANGLE, lightAngle);\n    \n    float normalizedAngle = lightAngle / LENS_CUTOFF_ANGLE;\n    \n    // Calculate where the focused light beam hits the iris\n    // The beam center moves opposite to light direction (projected onto iris plane)\n    vec2 beamCenter = -lightDir.xy * normalizedAngle * 0.5;\n    \n    // Distance from iris point to beam center\n    vec2 irisPos2D = irisPoint.xy;\n    vec2 toBeam = irisPos2D - beamCenter;\n    \n    float na2 = pow(normalizedAngle, 3.0);\n    // Beam gets more elongated and focused as angle increases\n    float stretch = 1.0 + normalizedAngle * 3.0; // Elongation factor\n    float beamWidth = 0.4 * (1.0 - na2 * 0.7); // Gets narrower with angle\n    \n    // Apply stretching along the light direction\n    vec2 lightDir2D = normalize(lightDir.xy + vec2(0.001)); // Avoid division by zero\n    vec2 perpDir = vec2(-lightDir2D.y, lightDir2D.x);\n    \n    // Transform to stretched coordinates\n    float alongLight = dot(toBeam, lightDir2D) / stretch;\n    float perpToLight = dot(toBeam, perpDir);\n    \n    float distToBeamAxis = sqrt(alongLight * alongLight + perpToLight * perpToLight);\n    \n    // Gaussian falloff for the focused beam\n    float beamIntensity = exp(-distToBeamAxis * distToBeamAxis / (beamWidth * beamWidth));\n    \n    // Increase intensity as angle increases (lens focusing effect)\n    float focusMultiplier = 1.0 + normalizedAngle * LENS_FOCUS_STRENGTH;\n    \n    // Smooth blend between uniform and focused lighting based on angle\n    // At angle 0: uniform lighting (intensity = 1.0)\n    // At higher angles: focused beam lighting\n    float focusAmount = smoothstep(0.0, 0.3, normalizedAngle);\n    float uniformLighting = 1.0 + normalizedAngle * LENS_FOCUS_STRENGTH * 0.2;\n    float focusedLighting = beamIntensity * focusMultiplier;\n    \n    float finalIntensity = mix(uniformLighting, focusedLighting, focusAmount);\n    \n    return finalIntensity * angleFade * BASE_BRIGHTNESS;\n}\n\nvec3 getEyeLight(vec3 p, vec3 rd) {\n    vec3 lightInEyeSpace = g_rotation * LIGHTP;\n    vec3 l = normalize(lightInEyeSpace - p);\n    vec3 n = getEyeNormal(p);\n    vec3 v = -rd;\n    vec3 r = reflect(-l, n);\n    vec3 albedo = getTextureColor(p);\n    \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    \n    // Check if we're on the iris\n    float cutDepth = cos(FLATTEN_ANGLE);\n    float outerRadius = sin(FLATTEN_ANGLE);\n    bool isIris = p.z <= -cutDepth + 0.1 && length(p.xy) <= outerRadius;\n    \n    // Apply lens focusing effect only to iris\n    if (isIris) {\n        float lensFocus = calculateLensFocusedLight(p, lightInEyeSpace);\n        dif *= lensFocus;\n    }\n    \n    float spec = pow(max(dot(r, v), 0.0), 16.0);\n    vec3 ambient = albedo * 0.15;\n    vec3 diffuse = albedo * dif * 0.5;\n    vec3 specular = vec3(1.0) * spec * albedo.g * albedo.r *albedo.b;\n    \n    return ambient + diffuse + specular;\n}\n\n\nvec3 getLensLight(vec3 p, vec3 rd) {\n    vec3 lightInEyeSpace = g_rotation * LIGHTP;\n\n    vec3 l = normalize(lightInEyeSpace - p);\n    vec3 n = getLensNormal(p);\n    vec3 v = -rd;\n    vec3 r = reflect(-l, n);\n    float spec = pow(max(dot(r, v), 0.0), 32.0);\n    float fresnel = pow(1.0 - abs(dot(v, n)), 1.0);\n    vec3 lensColor = vec3(0.95, 0.97, 1.0); \n    vec3 baseGlass = lensColor * 0.2; \n    vec3 specular = vec3(1.) * spec * 50.0; \n    vec3 fresnelColor = lensColor * fresnel *0.2;\n    \n    return baseGlass + specular + fresnelColor;\n}\n\n/* Refraction using Snell's law - not needed because refract()\nvec3 refract_ray(vec3 incident, vec3 normal, float eta) {\n    float cosI = -dot(normal, incident);\n    float sinT2 = eta * eta * (1.0 - cosI * cosI);\n    if (sinT2 > 1.0) return vec3(0.0); // Total internal reflection\n    float cosT = sqrt(1.0 - sinT2);\n    return eta * incident + (eta * cosI - cosT) * normal;\n}\n*/\n\nvec4 renderWithRefraction(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.04, 0.04, 0.05);\n    float nearestD = MAX_DIST;\n    // First, check if we hit the lens\n    float lensD = rayMarchLens(ro, rd);\n    nearestD = min(nearestD, lensD);\n    if(lensD < MAX_DIST) {\n        vec3 lensP = ro + rd * lensD;\n        vec3 lensN = getLensNormal(lensP);\n        \n        // Calculate refraction\n        float eta = 1.0 / REFRACT;\n        vec3 refractedRay = refract(rd, lensN, eta);\n        \n        if(length(refractedRay) > 0.0) {\n            // Continue raymarching with refracted ray\n            vec3 newRo = lensP + refractedRay * 0.01; // Small offset to avoid self-intersection\n            // Check if refracted ray hits the eye\n            float eyeD = rayMarchEye(newRo, refractedRay);\n            \n            if(eyeD < MAX_DIST) {\n                vec3 eyeP = newRo + refractedRay * eyeD;\n                vec3 eyeCol = getEyeLight(eyeP, refractedRay);\n                \n                // Apply slight chromatic aberration based on refraction angle :)\n                float refractionStrength = length(rd - refractedRay);\n                eyeCol = mix(eyeCol, eyeCol.gbr, refractionStrength * 0.1);\n                \n                col = eyeCol;\n            }\n        }\n        \n        // Add lens surface effects\n        vec3 lensCol = getLensLight(lensP, rd);\n        float fresnel = pow(1.0 - abs(dot(-rd, lensN)), 2.);\n        col = mix(col, lensCol, fresnel * 0.2); // Blend lens surface\n        \n    } else {\n        // No lens hit, render eye directly\n        float eyeD = rayMarchEye(ro, rd);\n        nearestD = min(nearestD, eyeD);\n        if(eyeD < MAX_DIST) {\n            vec3 eyeP = ro + rd * eyeD;\n            col = getEyeLight(eyeP, rd);\n        }\n    }\n    \n    return vec4(col, nearestD);\n}\n\n\nvoid mainMS(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = vec2(0.5);\n    \n    vec2 pa = vec2 (sin (floor( iTime ) * 57.678)/10., sin (floor( iTime ) * 97.678)/10.);\n    vec2 pb = vec2 (sin (floor( iTime+1. ) * 57.678)/10., sin (floor( iTime+1. ) * 97.678)/10.);\n    \n    vec2 pm = mix (pa, pb, pow( (  max(0.,fract(iTime)-0.9)  *10.), 4.));\n    \n    m+= pm;\n    \n    if(iMouse.z>0.001){m = iMouse.xy / iResolution.xy;} \n    \n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float angleY = (m.x - 0.5) * -6.28;\n    float angleX = (m.y - 0.5) * 3.14;\n    \n    mat3 rotY = mat3(\n        cos(angleY), 0, sin(angleY),\n        0, 1, 0,\n        -sin(angleY), 0, cos(angleY)\n    );\n    \n    mat3 rotX = mat3(\n        1, 0, 0,\n        0, cos(angleX), -sin(angleX),\n        0, sin(angleX), cos(angleX)\n    );\n    \n    g_rotation = rotY * rotX;\n    \n    g_lightIntensity = calculateIrisLightIntensity(g_rotation);\n    \n    ro = g_rotation * ro;\n    rd = g_rotation * rd;\n    \n    vec4 colPND = renderWithRefraction(ro, rd);\n    vec3 col = colPND.rgb;\n\n    float nearestD = colPND.a;\n    if(nearestD < MAX_DIST) {\n        col = mix(col, vec3(0.1, 0.1, 0.15), 1.0 - exp(-0.0005 * nearestD * nearestD));\n    }\n    \n   col = pow(col, vec3(0.4545));\n    \n    \n    float getli = texture(iChannel1, vec2(0), 0.).r;\n    r_lightIntensity = (g_lightIntensity+getli+getli)/3.;\n    \n    if(fragCoord.x<2. && fragCoord.y<2.) {col.r = r_lightIntensity;}\n    fragColor = (texture(iChannel1, fragCoord/iResolution.xy, 0.)*MBLUR + vec4(col, 1.0))/(1.+MBLUR);\n}\n\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = AA, k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainMS(c, u); \n    for (k = s; k-- > .5; ) { \n        mainMS(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a=1.;\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tflcRS",
    "date": "0",
    "viewed": 0,
    "name": "Cat Eye 3D + Comments",
    "description": "Several improvements:\nDelayed, nicer dilation, plus some fake caustic effects to match the refraction.\nNext I guess I need some subsurface lighting and then try a human eye...\nClick and drag.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "3d",
     "refraction",
     "eye",
     "cat",
     "iris",
     "realistic",
     "dilation",
     "pupil"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Cat Eye 3D w Fake Caustics\" by Cotterzz. https://shadertoy.com/view/WfXcD7\n// 2025-08-21 13:03:17\n\n// Fork of \"Cat Eye - Raymarched\" by Cotterzz. https://shadertoy.com/view/WfXcWn\n// 2025-08-20 10:11:08\n// Fork of \"Cat Eye Iris/Pupil texture\" by Cotterzz. https://www.shadertoy.com/view/wcfyzM\n// 2025-08-18 09:54:31\n// Fork of \"Cat Eye SDF\" by Cotterzz. https://shadertoy.com/view/tXKXzV\n// 2025-08-17 19:10:26\n\n\n// I had to put it in a buffer so I could store the light amount and have the pupil realistically dilate after a delay\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "Xsf3Rr",
       "filepath": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define AA 1.0 // Anti-aliasing sample count\n#define MBLUR 2.5 // Motion blur strength for temporal smoothing\n#define MAX_STEPS 150 // Maximum ray marching iterations\n#define MAX_DIST 100.0 // Maximum ray marching distance\n#define SURF_DIST 0.001 // Surface hit detection threshold\n// Texture mapping and displacement parameters\n#define UV_SCALE_X 0.4 // Horizontal UV coordinate scaling for iris texture\n#define UV_SCALE_Y 0.6 // Vertical UV coordinate scaling for iris texture\n#define UV_OFFSET 0.5 // UV coordinate offset to center texture mapping\n#define DISPLACE_AMOUNT 0.015 // Amount of surface displacement based on texture darkness\n// Flatten parameters\n#define FLATTEN_ANGLE 0.8 // Angle at which the eye sphere is flattened (radians)\n#define FLATTEN_DEPTH 0.5 // Inner radius of the flattened iris area\n#define LIGHTP vec3(1.0,1.0,-0.9) // Light source position in world space\n\n#define REFRACT 1.15 // Lens refraction index (1.0 = no refraction)\n// apparenty 1.52 is recommended for eye but is way too much, possibly because geometry\n\n// Light focusing parameters\n#define LENS_FOCUS_STRENGTH 6.0 // Intensity multiplier for lens focusing effect\n#define LENS_CUTOFF_ANGLE 1.2 // Maximum angle for light to pass through lens (radians)\n#define BASE_BRIGHTNESS 1.5 // Overall brightness multiplier for focused lighting\n\nmat3 g_rotation; // Global rotation matrix for eye orientation\nfloat g_lightIntensity = 0.0; // Real-time calculated light intensity hitting iris\nfloat r_lightIntensity = 0.0; // Temporally smoothed light intensity for pupil dilation\n\n// Calculate how much light hits the iris based on eye orientation\nfloat calculateIrisLightIntensity(mat3 rotation) {\n    vec3 irisForward = rotation * vec3(0.0, 0.0, -1.0); // Eye's forward direction after rotation\n    vec3 lightDir = normalize(LIGHTP); // Normalized light direction\n    float intensity = max(0.0, dot(irisForward, lightDir)); // Dot product for light angle\n   intensity = pow(intensity,0.3); // Power curve to adjust intensity falloff\n    return intensity;\n}\n\n// Create cat-eye shaped pupil using signed distance field\nfloat sdCateye(vec2 p, float height, float dilation)\n{\n    float vrad = height/2.; // Vertical radius of cat eye\n    dilation = min(.999, max(0.01, dilation)); // Clamp dilation to valid range\n    float rad = (vrad)/dilation; // Circle radius for constructing cat eye shape\n    float dist = sqrt((rad*rad)-(vrad*vrad)); // Distance between circle centers\n    p = abs(p); // Mirror to work in first quadrant only\n    vec2 center = vec2(-dist, 0.); // Center position of construction circle\n    float tdist = distance(p, center); // Distance from point to circle center\n    float result = tdist - rad; // Basic circle SDF\n    vec2 nearest = center+(p-center)*rad/tdist; // Nearest point on circle\n    if(nearest.y>vrad){result=distance(p,vec2(0.,vrad));} // Cap the shape vertically\n    return result;\n}\nvec3 contrast(vec3 color, float value) {return 0.5 + value * (color - 0.5);} // Adjust color contrast around middle gray\nvec3 gmc(vec3 colour, float gamma) {return pow(colour, vec3(1. / gamma));} // Apply gamma correction to color\n\n// Generate procedural iris texture with cat-eye pupil\nvec4 eyeTexture(vec2 uv, float lightDilation) {\n    vec2 p = (uv*2.)-1.; // Convert UV to centered coordinates (-1 to 1)\n    p.x/=iResolution.y/iResolution.x; // Correct for aspect ratio\n    p*=1.3; // Scale the texture coordinates\n    float eHeight = 1.; // Base height for cat eye shape\n    float eDilation = mix(1.0, 0.15, 1.-lightDilation); // Calculate pupil dilation based on light\n    eHeight= 1.0 + eDilation/2.; // Adjust eye height based on dilation\n\tfloat dA = sdCateye( p, eHeight, 0.0); // Outer boundary of cat eye\n    float dB = sdCateye( p, eHeight, eDilation); // Inner boundary (pupil) of cat eye\n    float d = dB-dA; // Distance field for iris region\n    if(p.x<0.){d=-d;} // Mirror effect for asymmetry\n    float cd = length(p*vec2(.84,1)/1.07); // Distance from center with elliptical scaling\n    d = mix(d,0. , min(1.,max(0.,(cd-.8)*5.))); // Blend out displacement at edges\n    float eb = distance(p, vec2(0.1, -0.6)); // Distance to eye highlight point 1\n    float el = distance(p, vec2(0.3, -1.2)); // Distance to eye highlight point 2\n    float et = distance(p, vec2(-.2, 0.6)); // Distance to eye highlight point 3\n    float ee = max(et, eb); // Combine highlight distances\n    vec3 col = (dB>0.0) ? (texture(iChannel0, (p.xy+vec2(0.2,-0.3)+vec2(d,0))/6., 0.).rgb+0.2)/(0.7+dB): vec3(0); // Sample base texture with displacement\n    col = mix(col*col*col, col, min(1.,dB*10.)); // Darken areas closer to pupil\n    col = mix(vec3(0), col, min(1.,dB*45.)); // Create sharp pupil edge\n    dB = dB*dB; // Square distance for sharper falloff\n    col = contrast(col, 1.-(dB/5.)); // Reduce contrast near pupil\n    col = gmc(col, 0.4+dB); // Apply gamma correction varying with distance from pupil\n    if(col.r<0.1-(dB/max(0.0001,eDilation*1.5))){col=vec3(0);} // Threshold red channel for pupil\n    if(col.g<0.1-(dB/max(0.0001,eDilation*1.5))){col=vec3(0);} // Threshold green channel for pupil\n    col = mix(col, vec3(0,0,0.1), max(0.,cd-.93 )*7.); // Add blue tint at outer edge\n    col.g*=1.5; // Enhance green channel\n    col = mix(col, vec3(1,1,1), min(1.,max(0.,cd-1.05 )*15.)); // Add white outer rim\n    return vec4(col, 1.);\n}\n\n// Signed distance function for the eye sphere with flattened front\nfloat sdEye(vec3 p, float r) {\n    float d = length(p) - r; // Basic sphere distance\n    float cutDepth = r * cos(FLATTEN_ANGLE); // Depth of the flat cut\n    float planeD = -p.z - cutDepth; // Distance to cutting plane\n    d = max(d, planeD); // Intersect sphere with plane to flatten front\n\n    float outerRadius = r * sin(FLATTEN_ANGLE); // Radius of flattened circular area\n    float innerRadius = FLATTEN_DEPTH; // Inner radius for texture application\n    float distFromCenter = length(p.xy); // Distance from center axis in XY plane\n    \n    // Apply texture-based displacement only on the flattened front surface\n    if (p.z <= -cutDepth + 0.1 && distFromCenter <= outerRadius) {\n        vec2 uv; // UV coordinates for texture sampling\n        uv.x = p.x * UV_SCALE_X + UV_OFFSET; // Calculate U coordinate\n        uv.y = p.y * UV_SCALE_Y + UV_OFFSET; // Calculate V coordinate\n        uv = clamp(uv, 0.0, 1.0); // Clamp UV to valid range\n        \n        vec4 texCol = eyeTexture(uv, r_lightIntensity); // Sample eye texture\n        float darkness = 1.0 - (texCol.r * 0.299 + texCol.g * 0.587 + texCol.b * 0.114); // Convert to luminance and invert\n        \n        float falloff = 1.0; // Displacement falloff factor\n        if (distFromCenter > innerRadius) {\n            falloff = 1.0 - smoothstep(innerRadius, outerRadius, distFromCenter); // Smooth falloff towards edges\n        }\n        \n        float displaceAmount = darkness * DISPLACE_AMOUNT * falloff; // Calculate displacement amount\n        d += displaceAmount; // Apply displacement to surface\n    }\n    \n    return d;\n}\n\nfloat sdLens(vec3 p, float r) {return abs(length(p) - r - 0.02) - 0.003; } // Signed distance function for lens (hollow sphere)\n\n// Calculate surface normal for eye using finite differences\nvec3 getEyeNormal(vec3 p) {\n    float d = sdEye(p, 1.0); // Sample distance at current point\n    vec2 e = vec2(0.001, 0); // Small epsilon for finite difference\n    \n    vec3 n = d - vec3(\n        sdEye(p - e.xyy, 1.0), // Sample X offset\n        sdEye(p - e.yxy, 1.0), // Sample Y offset\n        sdEye(p - e.yyx, 1.0)  // Sample Z offset\n    );\n    \n    return normalize(n); // Return normalized gradient\n}\n\n// Calculate surface normal for lens (simplified for sphere)\nvec3 getLensNormal(vec3 p) {\n    return normalize(p); // For sphere centered at origin, normal is just normalized position\n    // keep this in case we need it again\n    float d = sdLens(p, 1.0); // Alternative: calculate via finite differences\n    vec2 e = vec2(0.001, 0);\n    vec3 n = d - vec3(\n        sdLens(p - e.xyy, 1.0),\n        sdLens(p - e.yxy, 1.0),\n        sdLens(p - e.yyx, 1.0)\n    );\n    return normalize(n);\n}\n\n// Ray march to find intersection with eye surface\nfloat rayMarchEye(vec3 ro, vec3 rd) {\n    float dO = 0.0; // Total distance traveled\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO; // Current ray position\n        float dS = sdEye(p, 1.0); // Distance to eye surface\n        dO += dS; // Step forward by distance to surface\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break; // Stop if too far or hit surface\n    }\n    \n    return dO; // Return total distance to intersection\n}\n\n// Ray march to find intersection with lens surface\nfloat rayMarchLens(vec3 ro, vec3 rd) {\n    float dO = 0.0; // Total distance traveled\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO; // Current ray position\n        float dS = sdLens(p, 1.0); // Distance to lens surface\n        dO += dS; // Step forward by distance to surface\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break; // Stop if too far or hit surface\n    }\n    \n    return dO; // Return total distance to intersection\n}\n\n// Get texture color for a point on the eye surface\nvec3 getTextureColor(vec3 p) {\n    if (p.z < 0.0) { // Only apply texture to front-facing surface\n        vec2 uv; // UV coordinates for texture sampling\n        uv.x = p.x * UV_SCALE_X + UV_OFFSET; // Calculate U coordinate\n        uv.y = p.y * UV_SCALE_Y + UV_OFFSET; // Calculate V coordinate\n        uv = clamp(uv, 0.0, 1.0); // Clamp UV to valid range\n        \n        return eyeTexture(uv, r_lightIntensity).rgb; // Return eye texture color\n    }\n    return vec3(1.0); // Return white for back surface\n}\n\n// Calculate focused light intensity for iris - simulates lens focusing effect like a torch beam at angle\nfloat calculateLensFocusedLight(vec3 irisPoint, vec3 lightPos) {\n    vec3 eyeForward = vec3(0.0, 0.0, -1.0); // Eye's forward direction (looking along -Z)\n    \n    vec3 lightDir = normalize(lightPos); // Normalized light direction from origin\n    \n    float lightAngle = acos(clamp(dot(eyeForward, lightDir), -1.0, 1.0)); // Angle between eye forward and light\n    \n    // Cut off light if angle is too large - with smooth transition\n    if (lightAngle > LENS_CUTOFF_ANGLE) {\n        return 0.0; // No light beyond cutoff angle\n    }\n    \n    float angleFade = 1.0 - smoothstep(LENS_CUTOFF_ANGLE * 0.8, LENS_CUTOFF_ANGLE, lightAngle); // Smooth fadeout near cutoff\n    \n    float normalizedAngle = lightAngle / LENS_CUTOFF_ANGLE; // Normalize angle to 0-1 range\n    \n    // Calculate where the focused light beam hits the iris\n    vec2 beamCenter = -lightDir.xy * normalizedAngle * 0.5; // Beam center moves opposite to light direction\n    \n    vec2 irisPos2D = irisPoint.xy; // Project iris point to XY plane\n    vec2 toBeam = irisPos2D - beamCenter; // Vector from beam center to iris point\n    \n    float na2 = pow(normalizedAngle, 3.0); // Cubed angle for stronger effect at high angles\n    float stretch = 1.0 + normalizedAngle * 3.0; // Beam elongation factor increases with angle\n    float beamWidth = 0.4 * (1.0 - na2 * 0.7); // Beam width decreases with angle (more focused)\n    \n    vec2 lightDir2D = normalize(lightDir.xy + vec2(0.001)); // Light direction in XY plane (avoid division by zero)\n    vec2 perpDir = vec2(-lightDir2D.y, lightDir2D.x); // Perpendicular direction for elliptical stretching\n    \n    float alongLight = dot(toBeam, lightDir2D) / stretch; // Distance along light direction (compressed by stretch)\n    float perpToLight = dot(toBeam, perpDir); // Distance perpendicular to light direction\n    \n    float distToBeamAxis = sqrt(alongLight * alongLight + perpToLight * perpToLight); // Distance from beam axis\n    \n    float beamIntensity = exp(-distToBeamAxis * distToBeamAxis / (beamWidth * beamWidth)); // Gaussian falloff for focused beam\n    \n    float focusMultiplier = 1.0 + normalizedAngle * LENS_FOCUS_STRENGTH; // Intensity multiplier increases with angle\n    \n    // Smooth blend between uniform and focused lighting based on angle\n    float focusAmount = smoothstep(0.0, 0.3, normalizedAngle); // Transition from uniform to focused lighting\n    float uniformLighting = 1.0 + normalizedAngle * LENS_FOCUS_STRENGTH * 0.2;  // Uniform lighting with slight boost\n    float focusedLighting = beamIntensity * focusMultiplier; // Focused beam lighting\n    \n    float finalIntensity = mix(uniformLighting, focusedLighting, focusAmount); // Blend between lighting modes\n    \n    return finalIntensity * angleFade * BASE_BRIGHTNESS; // Apply fadeout and base brightness\n}\n\n// Calculate lighting for eye surface with lens focusing effects\nvec3 getEyeLight(vec3 p, vec3 rd) {\n    vec3 lightInEyeSpace = g_rotation * LIGHTP; // Transform light position to eye space\n    vec3 l = normalize(lightInEyeSpace - p); // Light direction from surface point\n    vec3 n = getEyeNormal(p); // Surface normal at point\n    vec3 v = -rd; // View direction (opposite of ray direction)\n    vec3 r = reflect(-l, n); // Reflection direction for specular\n    vec3 albedo = getTextureColor(p); // Base color from texture\n    \n    float dif = clamp(dot(n, l), 0.0, 1.0); // Lambertian diffuse factor\n    \n    float cutDepth = cos(FLATTEN_ANGLE); // Depth of flattened area\n    float outerRadius = sin(FLATTEN_ANGLE); // Radius of flattened area\n    bool isIris = p.z <= -cutDepth + 0.1 && length(p.xy) <= outerRadius; // Check if point is on iris\n    \n    // Apply lens focusing effect only to iris\n    if (isIris) {\n        float lensFocus = calculateLensFocusedLight(p, lightInEyeSpace); // Get lens focusing multiplier\n        dif *= lensFocus; // Apply focusing to diffuse lighting\n    }\n    \n    float spec = pow(max(dot(r, v), 0.0), 16.0); // Phong specular highlight\n    vec3 ambient = albedo * 0.15; // Ambient lighting component\n    vec3 diffuse = albedo * dif * 0.5; // Diffuse lighting component\n    vec3 specular = vec3(1.0) * spec * albedo.g * albedo.r *albedo.b; // Specular component modulated by albedo\n    \n    return ambient + diffuse + specular; // Combine all lighting components\n}\n\n// Calculate lighting for lens surface (glass-like material)\nvec3 getLensLight(vec3 p, vec3 rd) {\n    vec3 lightInEyeSpace = g_rotation * LIGHTP; // Transform light position to eye space\n\n    vec3 l = normalize(lightInEyeSpace - p); // Light direction from surface point\n    vec3 n = getLensNormal(p); // Lens surface normal\n    vec3 v = -rd; // View direction\n    vec3 r = reflect(-l, n); // Reflection direction\n    float spec = pow(max(dot(r, v), 0.0), 32.0); // Sharp specular highlight for glass\n    float fresnel = pow(1.0 - abs(dot(v, n)), 1.0); // Fresnel effect for glass edges\n    vec3 lensColor = vec3(0.95, 0.97, 1.0); // Slightly blue-tinted glass color\n    vec3 baseGlass = lensColor * 0.2; // Base glass transparency\n    vec3 specular = vec3(1.) * spec * 50.0; // Bright specular highlight\n    vec3 fresnelColor = lensColor * fresnel *0.2; // Fresnel rim lighting\n    \n    return baseGlass + specular + fresnelColor; // Combine glass lighting components\n}\n\n// Refraction using Snell's law - calculates refracted ray direction\nvec3 refract_ray(vec3 incident, vec3 normal, float eta) {\n    float cosI = -dot(normal, incident); // Cosine of incident angle\n    float sinT2 = eta * eta * (1.0 - cosI * cosI); // Sine squared of transmitted angle\n    if (sinT2 > 1.0) return vec3(0.0); // Total internal reflection check\n    float cosT = sqrt(1.0 - sinT2); // Cosine of transmitted angle\n    return eta * incident + (eta * cosI - cosT) * normal; // Snell's law refraction formula\n}\n\n// Main rendering function with lens refraction effects\nvec4 renderWithRefraction(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.04, 0.04, 0.05); // Background color\n    float nearestD = MAX_DIST; // Track nearest intersection distance\n    float lensD = rayMarchLens(ro, rd); // Ray march to find lens intersection\n    nearestD = min(nearestD, lensD); // Update nearest distance\n    if(lensD < MAX_DIST) { // If we hit the lens\n        vec3 lensP = ro + rd * lensD; // Lens intersection point\n        vec3 lensN = getLensNormal(lensP); // Lens surface normal\n        \n        float eta = 1.0 / REFRACT; // Refraction ratio (air to glass)\n        vec3 refractedRay = refract_ray(rd, lensN, eta); // Calculate refracted ray\n        \n        if(length(refractedRay) > 0.0) { // If refraction succeeded (no total internal reflection)\n            vec3 newRo = lensP + refractedRay * 0.01; // New ray origin inside lens (small offset)\n            float eyeD = rayMarchEye(newRo, refractedRay); // Ray march to eye with refracted ray\n            \n            if(eyeD < MAX_DIST) { // If refracted ray hits eye\n                vec3 eyeP = newRo + refractedRay * eyeD; // Eye intersection point\n                vec3 eyeCol = getEyeLight(eyeP, refractedRay); // Calculate eye lighting\n                \n                float refractionStrength = length(rd - refractedRay); // Measure refraction amount\n                eyeCol = mix(eyeCol, eyeCol.gbr, refractionStrength * 0.1); // Chromatic aberration effect\n                \n                col = eyeCol; // Use eye color as final color\n            }\n        }\n        \n        vec3 lensCol = getLensLight(lensP, rd); // Calculate lens surface lighting\n        float fresnel = pow(1.0 - abs(dot(-rd, lensN)), 2.); // Fresnel factor for lens surface\n        col = mix(col, lensCol, fresnel * 0.2); // Blend lens surface effects\n        \n    } else {\n        float eyeD = rayMarchEye(ro, rd); // Direct ray march to eye (no lens)\n        nearestD = min(nearestD, eyeD); // Update nearest distance\n        if(eyeD < MAX_DIST) { // If ray hits eye directly\n            vec3 eyeP = ro + rd * eyeD; // Eye intersection point\n            col = getEyeLight(eyeP, rd); // Calculate direct eye lighting\n        }\n    }\n    \n    return vec4(col, nearestD); // Return color and distance\n}\n\n// Main shader function with eye movement and temporal effects\nvoid mainMS(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y; // Normalized screen coordinates\n    vec2 m = vec2(0.5); // Base eye orientation (centered)\n    \n    vec2 pa = vec2 (sin (floor( iTime ) * 57.678)/10., sin (floor( iTime ) * 97.678)/10.); // Eye position A (pseudorandom)\n    vec2 pb = vec2 (sin (floor( iTime+1. ) * 57.678)/10., sin (floor( iTime+1. ) * 97.678)/10.); // Eye position B (next second)\n    \n    vec2 pm = mix (pa, pb, pow( (  max(0.,fract(iTime)-0.9)  *10.), 4.)); // Smooth interpolation with quick saccade motion\n    \n    m+= pm; // Add procedural eye movement to base position\n    \n    if(iMouse.z>0.001){m = iMouse.xy / iResolution.xy;} // Override with mouse control if clicked\n    \n    vec3 ro = vec3(0, 0, -3); // Ray origin (camera position)\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1)); // Ray direction from camera through pixel\n    \n    float angleY = (m.x - 0.5) * -6.28; // Horizontal rotation angle from mouse/movement\n    float angleX = (m.y - 0.5) * 3.14; // Vertical rotation angle from mouse/movement\n    \n    mat3 rotY = mat3( // Y-axis rotation matrix\n        cos(angleY), 0, sin(angleY),\n        0, 1, 0,\n        -sin(angleY), 0, cos(angleY)\n    );\n    \n    mat3 rotX = mat3( // X-axis rotation matrix\n        1, 0, 0,\n        0, cos(angleX), -sin(angleX),\n        0, sin(angleX), cos(angleX)\n    );\n    \n    g_rotation = rotY * rotX; // Combine rotations\n    \n    g_lightIntensity = calculateIrisLightIntensity(g_rotation); // Calculate current light intensity on iris\n    \n    ro = g_rotation * ro; // Apply eye rotation to camera\n    rd = g_rotation * rd; // Apply eye rotation to ray direction\n    \n    vec4 colPND = renderWithRefraction(ro, rd); // Render the scene\n    vec3 col = colPND.rgb; // Extract color\n\n    float nearestD = colPND.a; // Extract nearest distance\n    if(nearestD < MAX_DIST) {\n        col = mix(col, vec3(0.1, 0.1, 0.15), 1.0 - exp(-0.0005 * nearestD * nearestD)); // Apply distance fog\n    }\n    \n   col = pow(col, vec3(0.4545)); // Apply gamma correction\n    \n    float getli = texture(iChannel1, vec2(0), 0.).r; // Read previous light intensity from buffer\n    r_lightIntensity = (g_lightIntensity+getli+getli)/3.; // Temporal smoothing of light intensity\n    \n    if(fragCoord.x<2. && fragCoord.y<2.) {col.r = r_lightIntensity;} // Store light intensity in buffer (top-left pixel)\n    fragColor = (texture(iChannel1, fragCoord/iResolution.xy, 0.)*MBLUR + vec4(col, 1.0))/(1.+MBLUR); // Apply motion blur/temporal smoothing\n}\n\n// Anti-aliasing wrapper function using multiple samples per pixel\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = AA, k; // Sample count and counter\n    vec2 j = vec2(.5); // Jitter offset for sampling\n    o = vec4(0); // Initialize output\n    vec4 c; // Color sample\n    mainMS(c, u); // Render main sample\n    for (k = s; k-- > .5; ) { // Loop for additional AA samples\n        mainMS(c, u + j - .5); // Render with jittered position\n        o += c; // Accumulate samples\n        j = fract(j + vec2(.755, .57).yx); // Update jitter with low-discrepancy sequence\n    };o /= s;o.a=1.; // Average samples and set alpha to 1\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tcsyzS",
    "date": "0",
    "viewed": 0,
    "name": "Dom Rep Hair/Fur w comments",
    "description": "More developed version - more natural distribution of hair and light/shadow.\nMouse to rotate, for other params you need to edit the constants and republish.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "sdf",
     "domainrepetition",
     "hair",
     "fur",
     "organic",
     "cat"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Domain Repetition Hair/Fur 2\" by Cotterzz. https://shadertoy.com/view/3fsyzn\n// 2025-08-21 13:04:12\n\n// Fork of \"Domain Repetition Hair/Fur\" by Cotterzz. https://shadertoy.com/view/wfXczr\n// 2025-08-15 04:55:44\n\n// Lots added here, more params..\n// lighting/shadows which I think are expensive,\n// ..and with hair you can't have one without the other\n// The most imprtant though is offset so the hairs aren't in straight rows. :)\n\n// There seem to be a few artifacts with certain parameters.\n\n// Set multisampling to 0.0 to make it ymouse dependent\n// Or set it to 1. + for number of samples (so 1.0 is effectively off, 4.0 is 2x2 multisampling etc etc..)\n\nconst float MULTISAMPLING = 2.0; // Number of samples per pixel for anti-aliasing\nconst float THICKNESS = 0.01; // Base thickness of individual hair strands\nconst float SPACING = 0.03; // Distance between adjacent hair strands on the sphere surface\nconst float INNER_RADIUS = 0.4; // Radius of the base sphere where hair roots attach\nconst float OUTER_RADIUS = 0.9; // Maximum radius where hair tips can extend\nconst float MAX_DROOP = 0.3; // Maximum vertical droop amount for gravity effect\nconst float CURVE = 0.1; // Amount of inward curve/bend in drooping hair\nconst float CURL_AMPLITUDE = 0.0; // Amplitude of hair curl/wave effect (0 = straight)\nconst float CURL_FREQUENCY = 10.0; // Frequency of curl oscillations along hair length\nconst float UNEVEN_LENGTH = 0.0; // Variation in hair lengths (0 = uniform length)\nconst float RANDOM_OFFSET = 0.45; // Random positional offset for hair strand placement\n\nvec3 straightPos; // Position in space before droop is applied (straight hair position)\nvec2 sphericalCoords; // Spherical coordinates (latitude, longitude) of current point\nvec2 gridCell; // Grid cell index for hair strand identification\nfloat radialDistance; // Distance from origin to current point\nfloat normalizedRadius; // Normalized distance from inner to outer radius (0-1)\n\n// Signed distance function for the base sphere\nfloat sphereSDF(vec3 p) {\n    return length(p) - INNER_RADIUS; // Distance from point to sphere surface\n}\n\n// Generate 2D hash values for procedural randomness\nvec2 hash2(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3))); // Mix coordinates with primes\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123); // Return values in range [-1, 1]\n}\n\n// Generate single hash value for procedural randomness\nfloat hash(vec2 p) {\n    p = fract(p * vec2(123.34, 456.78)); // Scale and wrap coordinates\n    p += dot(p, p + 34.56); // Self-mixing for better distribution\n    return fract(p.x * p.y); // Return value in range [0, 1]\n}\n\n// Convert 3D Cartesian coordinates to spherical (latitude, longitude)\nvec2 cartesianToSpherical(vec3 p) {\n    float r = length(p); // Calculate radius\n    if (r < 0.001) return vec2(0.0); // Avoid division by zero at origin\n    vec3 n = p / r; // Normalize to unit sphere\n    return vec2(acos(clamp(n.y, -1.0, 1.0)), atan(n.z, n.x)); // Return (theta, phi) angles\n}\n\n// Apply gravity droop effect to hair position\nvec3 applyDroop(vec3 p) {\n    float r = length(p); // Distance from origin\n    float normalized = (r - INNER_RADIUS) / (OUTER_RADIUS - INNER_RADIUS); // Normalize to hair length\n    float droopFactor = normalized * normalized; // Quadratic falloff for natural droop\n    \n    vec3 droopedPos = p; // Start with original position\n    droopedPos.y -= droopFactor * MAX_DROOP; // Apply downward droop\n    \n    vec3 toCenter = -normalize(vec3(p.x, 0.0, p.z)); // Horizontal direction toward center\n    droopedPos += toCenter * droopFactor * CURVE; // Apply inward curve\n    \n    return droopedPos; // Return drooped position\n}\n\n// Inverse transformation to find straight position from drooped position\nvec3 inverseDroop(vec3 p) {\n    vec3 straight = p; // Initial guess\n    for (int i = 0; i < 4; i++) { // Iterate to converge on solution\n        straight += (p - applyDroop(straight)) * 0.7; // Newton-like iteration with damping\n    }\n    return straight; // Return approximated straight position\n}\n\n// Calculate and cache hair-related data for current position\nvoid getHairData(vec3 p) {\n    straightPos = inverseDroop(p); // Find pre-droop position\n    sphericalCoords = cartesianToSpherical(straightPos); // Convert to spherical coordinates\n    radialDistance = length(straightPos); // Calculate distance from origin\n    normalizedRadius = (radialDistance - INNER_RADIUS) / (OUTER_RADIUS - INNER_RADIUS); // Normalize to hair length\n    \n    float gridSpacing = 0.01; // Base grid spacing for hair identification\n    float lonSpacing = gridSpacing / max(sin(sphericalCoords.x), 0.1); // Adjust for sphere convergence at poles\n    gridCell = vec2( // Calculate grid cell indices\n        round(sphericalCoords.x / gridSpacing), // Latitude cell\n        round(sphericalCoords.y / lonSpacing) // Longitude cell\n    );\n}\n\n// Signed distance function for radial hair strands\nfloat sdRadialLine(vec3 p, float spacing, float thickness) {\n    getHairData(p); // Calculate hair data for current position\n    \n    vec2 latLon = sphericalCoords; // Get spherical coordinates\n    float lonSpacing = spacing / max(sin(latLon.x), 0.1); // Adjust spacing for latitude\n    float latIndex = round(latLon.x / spacing); // Grid index for latitude\n    float lonIndex = round(latLon.y / lonSpacing); // Grid index for longitude\n    \n    if (CURL_AMPLITUDE > 0.0) { // Apply curl if enabled\n        latLon.y += sin(length(p) * CURL_FREQUENCY) * CURL_AMPLITUDE; // Add sinusoidal curl\n    }\n    \n    vec2 randomOffset = hash2(vec2(latIndex, lonIndex)) * RANDOM_OFFSET; // Random offset for natural look\n    vec2 gridCenter = vec2( // Calculate actual hair strand center\n        latIndex * spacing + randomOffset.x * spacing, // Latitude position with offset\n        lonIndex * lonSpacing + randomOffset.y * lonSpacing // Longitude position with offset\n    );\n    \n    vec2 toLine = latLon - gridCenter; // Vector from hair center to current point\n    toLine.y *= sin(latLon.x); // Correct for spherical distortion\n    float distToLine = length(toLine); // Distance to hair strand axis\n    \n    if (distToLine > spacing) return 1e10; // Early exit if too far from any hair\n    \n    float taperFactor = 1.0 - normalizedRadius; // Taper hair from root to tip\n    float thicknessVariation = 0.4 + 0.8 * hash(vec2(latIndex, lonIndex)); // Random thickness variation\n    float currentThickness = thickness * taperFactor * thicknessVariation; // Final thickness\n    \n    if (UNEVEN_LENGTH > 0.0) { // Apply length variation if enabled\n        float hairLengthRandom = hash(vec2(latIndex, lonIndex) + 42.0); // Random length factor\n        float minLength = 1.0 / (1.0 + UNEVEN_LENGTH); // Minimum hair length\n        float maxLength = 0.97; // Maximum hair length (slightly less than full)\n        float adjustedRadius = normalizedRadius / mix(minLength, maxLength, hairLengthRandom); // Adjust for length\n        \n        if (adjustedRadius > 1.0) return 1e10; // Hair has ended\n        \n        currentThickness *= (1.0 - normalizedRadius) * (1.0 - adjustedRadius); // Extra taper for varied length\n    }\n    \n    return distToLine - currentThickness; // Return signed distance to hair strand\n}\n\n// Raymarch through the scene to find intersections\nvec4 raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0; // Distance along ray\n    \n    for (int i = 0; i < 200; i++) { // Maximum iterations\n        vec3 p = ro + rd * t; // Current position along ray\n        float distFromCenter = length(p); // Distance from origin\n        float d = sphereSDF(p); // Distance to base sphere\n        \n        if (distFromCenter > INNER_RADIUS && distFromCenter < OUTER_RADIUS) { // Within hair volume\n            d = min(d, sdRadialLine(p, SPACING, THICKNESS)); // Include hair in distance field\n        }\n        \n        if (d < 0.0005) { // Hit surface\n            float objectId = 0.0; // 0 = sphere, 1 = hair\n            float opacity = 1.0; // Opacity for blending\n            \n            if (distFromCenter > INNER_RADIUS && distFromCenter < OUTER_RADIUS) { // In hair region\n                if (sdRadialLine(p, SPACING, THICKNESS) < sphereSDF(p)) { // Hair is closer than sphere\n                    objectId = 1.0; // Mark as hair hit\n                    opacity = 1.0 - normalizedRadius * 0.8; // Fade out toward tips\n                }\n            }\n            \n            return vec4(t, objectId, hash(gridCell), opacity); // Return hit data\n        }\n        \n        t += d * 0.8; // Step along ray (0.8 for safety)\n        if (t > 20.0) break; // Maximum distance reached\n    }\n    \n    return vec4(-1.0); // No hit\n}\n\n// Combined distance field for shadow calculations\nfloat mapScene(vec3 p) {\n    float distFromCenter = length(p); // Distance from origin\n    if (distFromCenter > INNER_RADIUS && distFromCenter < OUTER_RADIUS) { // In hair volume\n        return min(sphereSDF(p), sdRadialLine(p, SPACING, THICKNESS)); // Combine sphere and hair\n    }\n    return sphereSDF(p); // Just sphere outside hair volume\n}\n\n// Calculate soft shadows using sphere tracing\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n    float res = 1.0; // Shadow accumulator (1 = no shadow)\n    float t = tmin; // Start distance\n    \n    for (int i = 0; i < 6; i++) { // Limited iterations for performance\n        float h = mapScene(ro + rd * t); // Distance to nearest surface\n        res = min(res, 2.0 * h / t); // Accumulate shadow based on proximity\n        t += clamp(h, 0.02, 0.2); // Step forward with clamped step size\n        if (res < 0.005 || t > tmax) break; // Early exit if fully shadowed or reached light\n    }\n    \n    return clamp(res, 0.0, 1.0); // Return shadow factor [0,1]\n}\n\n// Calculate surface normal using finite differences\nvec3 calcNormal(vec3 p, float objectId) {\n    if (objectId < 0.5) { // Sphere surface\n        return normalize(p); // Analytical normal for sphere\n    }\n    \n    vec2 e = vec2(0.001, 0.0); // Small epsilon for finite difference\n    float base = mapScene(p); // Distance at center point\n    return normalize(vec3( // Calculate gradient\n        mapScene(p + e.xyy) - base, // X component\n        mapScene(p + e.yxy) - base, // Y component\n        mapScene(p + e.yyx) - base  // Z component\n    ));\n}\n\n// Calculate ray-sphere intersection points\nvec2 raySphere(vec3 ro, vec3 rd, float r) {\n    float b = dot(ro, rd); // Projection of origin onto ray\n    float c = dot(ro, ro) - r * r; // Origin distance squared minus radius squared\n    float h = b * b - c; // Discriminant\n    if (h < 0.0) return vec2(-1.0); // No intersection\n    h = sqrt(h); // Square root of discriminant\n    return vec2(-b - h, -b + h); // Near and far intersection distances\n}\n\n// Main rendering function for single sample\nvoid mainImage0(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y; // Normalized screen coordinates\n    \n    vec2 pan = -5.*((iMouse.xy/iResolution.xy)-0.5); // Camera rotation from mouse\n    float camRadius = 3.0; // Camera distance from origin\n    float camHeight = pan.y; // Camera height from mouse Y\n    \n    vec3 ro = vec3(camRadius * cos(pan.x), camHeight, camRadius * sin(pan.x)); // Camera position\n    vec3 target = vec3(0.0); // Look-at target (origin)\n    vec3 forward = normalize(target - ro); // Camera forward direction\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward)); // Camera right direction\n    vec3 up = cross(forward, right); // Camera up direction\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up); // Ray direction through pixel\n    \n    vec3 col = vec3(0.7); // Background color\n    vec3 lightPos = vec3(2.0, 1.0, 2.0); // Light source position\n    \n    vec2 outerHit = raySphere(ro, rd, OUTER_RADIUS); // Check ray-bounding sphere intersection\n    if (outerHit.x > 0.0) { // Ray enters bounding sphere\n        vec3 pEnter = ro + rd * outerHit.x + rd * 0.001; // Entry point with small offset\n        vec4 hit = raymarch(pEnter, rd); // Raymarch through hair volume\n        \n        if (hit.x > 0.0) { // Hit something\n            vec3 pHit = pEnter + rd * hit.x; // Hit position\n            vec3 normal = calcNormal(pHit, hit.y); // Surface normal\n            vec3 lightDir = normalize(lightPos - pHit); // Direction to light\n            \n            float diffuse = max(dot(normal, lightDir), 0.0); // Lambertian diffuse\n            float shadow = calcSoftShadow(pHit + normal * 0.001, lightDir, 0.001, length(lightPos - pHit)); // Shadow factor\n            diffuse *= shadow; // Apply shadow to diffuse\n            \n            float ambient = 0.4; // Ambient light level\n            vec3 hitColor; // Final hit color\n            \n            if (hit.y > 0.5) { // Hit hair\n                vec3 hairColors[4] = vec3[4]( // Hair color palette\n                    vec3(0.95, 0.8, 0.4), // Blonde\n                    vec3(0.8, 0.5, 0.3),  // Brown\n                    vec3(0.9, 0.4, 0.4),  // Red\n                    vec3(0.5, 0.7, 0.9)   // Blue\n                );\n                \n                int colorIndex = min(int(hit.z * 4.0), 3); // Select color based on hash\n                vec3 hairBaseColor = hairColors[colorIndex]; // Get base hair color\n                hitColor = hairBaseColor * (diffuse + ambient); // Apply lighting\n                \n                vec3 viewDir = -rd; // View direction\n                vec3 halfDir = normalize(lightDir + viewDir); // Half vector for specular\n                float specular = pow(max(dot(normal, halfDir), 0.0), 8.0); // Blinn-Phong specular\n                hitColor += specular * 0.4; // Add specular highlight\n                \n                col = mix(col, hitColor, hit.w*1.5); // Blend with background using opacity\n            } else { // Hit sphere\n                col = vec3(0.9, 0.8, 0.8) * (diffuse + ambient); // Simple sphere shading\n            }\n        }\n    }\n    \n    fragColor = vec4(col, 1.0); // Output final color\n}\n\n// Multisampling wrapper using Weyl sequence for anti-aliasing\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float samples = MULTISAMPLING<1.?floor(1.+((iMouse.y/iResolution.y)*16.)):MULTISAMPLING; // Sample count (mouse Y controls if MULTISAMPLING < 1)\n    vec2 jitter = vec2(0.5); // Initial jitter offset\n    fragColor = vec4(0.0); // Initialize accumulator\n    vec4 color; // Temporary color storage\n    \n    mainImage0(color, fragCoord); // Render center sample\n    for (float k = samples; k-- > 0.5;) { // Loop for additional samples\n        mainImage0(color, fragCoord + jitter - 0.5); // Render with jittered position\n        fragColor += color; // Accumulate color\n        jitter = fract(jitter + vec2(0.755, 0.57).yx); // Update jitter with Weyl sequence\n    }\n    \n    fragColor /= samples; // Average all samples\n    fragColor.a = 1.0; // Set full opacity\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tcfczf",
    "date": "1755882458",
    "viewed": 95,
    "name": "Buffer feedback real time",
    "description": "I finally got this working in real time.\nAll it does is draw one line then draws its own buffer twice.\nCan be improved loads.\nClick and drag.",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "line",
     "tree",
     "recursive",
     "feedback",
     "buffer"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Another feedback fractal\" by Cotterzz. https://shadertoy.com/view/3cVGzm\n// 2025-08-22 16:54:07\n\n// (Also inspired by: \"Dancy Tree Doodle  by wyatt. \"https://www.shadertoy.com/view/wslGz7 )\n\n// Fork of \"Koch with hexagons\" by Cotterzz. https://shadertoy.com/view/tfd3Ds\n// 2025-05-22 15:34:19\n\n// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 18:21:33\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy, 0.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float capsuleSDF(in vec2 P,in vec2 B,in vec2 E,in float R)\n{\n    vec2 BP = P - B;\n    vec2 BE = E - B;\n    float t = clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0);\n    vec2 K = BP - BE * t;\n    return sqrt(dot(K, K)) - R;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    vec2 pa = vec2(0.5*ar, 0.05);\n    vec2 pb = vec2(.9+sin(iTime/3.)/8., .4+cos(iTime/2.5)/9.);\n    if(iMouse.z>0.001) {pb = vec2(iMouse.x/iResolution.x*ar, iMouse.y/iResolution.y);}\n    vec2 pd = pb-pa;\n    float csdf = capsuleSDF(uvc, pa, pb, .01);\n    vec3 col = vec3(mix(0.,1., csdf*500.));\n    float angd = .2;\n    vec2 rv = uvc-pb;\n    float ano = atan(rv.y, rv.x);\n    float and = atan(pd.y,pd.x);\n    float ancl = ano-angd+and;\n    float ancr = ano-angd-and;\n    float len = length(rv);\n    vec2 rvnl = vec2(cos(ancl)*len, sin(ancl)*len);\n    vec2 tcl = vec2(0.5, 0.05)+rvnl*1.2;\n    vec2 rvnr = vec2(cos(ancr)*len, sin(ancr)*len);\n    vec2 tcr = vec2(0.5, 0.05)+rvnr*1.2;\n    col = min(col, texture(iChannel0, tcl, 0.).rgb);\n    col = min(col, texture(iChannel0, tcr, 0.).rgb);\n    fragColor = vec4(col,1.0);\n    if(iFrame<2||uv.x>.99||uv.x<0.01||uv.y>.99||uv.y<0.01){fragColor = vec4(1.0);}\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3cXcRs",
    "date": "1755924850",
    "viewed": 107,
    "name": "Buffer feedback weirdness",
    "description": "This went in an odd direction. Two different patterns.\nAll this from drawing a line and copying the buffer. I think the translation angle of the buffer is doing something here.\nClick and drag.",
    "likes": 11,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "line",
     "tree",
     "recursive",
     "feedback",
     "buffer"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Buffer feedback real time\" by Cotterzz. https://shadertoy.com/view/tcfczf\n// 2025-08-23 04:43:55\n\n// Fork of \"Another feedback fractal\" by Cotterzz. https://shadertoy.com/view/3cVGzm\n// 2025-08-22 16:54:07\n\n// (Also inspired by: \"Dancy Tree Doodle  by wyatt. \"https://www.shadertoy.com/view/wslGz7 )\n\n// Fork of \"Koch with hexagons\" by Cotterzz. https://shadertoy.com/view/tfd3Ds\n// 2025-05-22 15:34:19\n\n// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 18:21:33\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float co = distance(uv, vec2(0.5));\n    vec3 colA = texture(iChannel0, fragCoord/iResolution.xy, 0.).rgb;\n    vec3 colB = texture(iChannel1, fragCoord/iResolution.xy, 0.).rgb;\n    colA = hsl2rgb(vec3((colA.r/3.)-co, 1., colA.r/3.));\n    colB = hsl2rgb(vec3(colB.r/2.5, 1., colB.r/2.));\n    fragColor = vec4(colA+colB, 1.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    vec2 pa = vec2(0.5*ar, 0.05);\n    vec2 pb = vec2(ar/2.+(sin(iTime/1.1)/8.), .25+cos(iTime/1.3)/20.);\n    if(iMouse.z>0.001) {pb = vec2(iMouse.x/iResolution.x*ar, iMouse.y/iResolution.y);\n    pb.x = ar/2.+0.15-(pb.x-ar/2.);}\n    vec2 pd = pb-pa;\n    float csdf = capsuleSDF(uvc, pa, pb, .01);\n    vec3 col = vec3(mix(1.,0., csdf*50.));\n\n    vec2 rv = uvc-pb;\n    float ano = atan(rv.y, rv.x);\n    float and = atan(pd.y,pd.x);\n    float ang = abs(uv.x-.5)*3.;\n    \n    float ancl = ano-ang;\n    float ancr = ano+ang;\n    float len = length(rv);\n    vec2 rvnl = vec2(cos(ancl)*len, sin(ancl)*len);\n    vec2 tcl = vec2(0.5, 0.05)+rvnl*1.3;\n    vec2 rvnr = vec2(cos(ancr)*len, sin(ancr)*len);\n    vec2 tcr = vec2(0.5, 0.05)+rvnr*1.3;\n    col = max(col, texture(iChannel0, tcl, 0.).rgb);\n    col = max(col, texture(iChannel0, tcr, 0.).rgb);\n    fragColor = vec4(col,1.0);\n    if(iFrame<2||uv.x>.99||uv.x<0.01||uv.y>.99||uv.y<0.01){fragColor = vec4(0);}\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nfloat capsuleSDF(in vec2 P,in vec2 B,in vec2 E,in float R)\n{\n    vec2 BP = P - B;\n    vec2 BE = E - B;\n    float t = clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0);\n    vec2 K = BP - BE * t;\n    return sqrt(dot(K, K)) - R;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    vec2 pa = vec2(0.5*ar, 0.05);\n    vec2 pb = vec2(ar/2.+(sin(iTime/1.3)/-8.), .25+cos(iTime/2.9)/20.);\n    if(iMouse.z>0.001) {pb = vec2(iMouse.x/iResolution.x*ar, iMouse.y/iResolution.y);}\n    vec2 pd = pb-pa;\n    float csdf = capsuleSDF(uvc, pa, pb, .01);\n    vec3 col = vec3(mix(1.,0., csdf*150.));\n\n    vec2 rv = uvc-pb;\n    float ano = atan(rv.y, rv.x);\n    float and = atan(pd.y,pd.x);\n    float ang = pow(abs(uv.x-.5),.4);\n    float ancl = ano-ang;\n    float ancr = ano+ang;\n    float len = length(rv);\n    vec2 rvnl = vec2(cos(ancl)*len, sin(ancl)*len);\n    vec2 tcl = vec2(0.5, 0.05)+rvnl*1.3;\n    vec2 rvnr = vec2(cos(ancr)*len, sin(ancr)*len);\n    vec2 tcr = vec2(0.5, 0.05)+rvnr*1.3;\n    col = max(col, texture(iChannel0, tcl, 0.).rgb);\n    col = max(col, texture(iChannel0, tcr, 0.).rgb);\n    fragColor = vec4(col,1.0);\n    if(iFrame<2||uv.x>.99||uv.x<0.01||uv.y>.99||uv.y<0.01){fragColor = vec4(0);}\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wfsyWB",
    "date": "1756029395",
    "viewed": 83,
    "name": "Buffer feedback swap",
    "description": "What happens if the two trees copy each others buffers.. what then?\nExperiment commenting/uncommenting lines 27-30 in buffers A and B\nClick and drag.",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "line",
     "tree",
     "recursive",
     "feedback",
     "buffer"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Buffer feedback weirdness\" by Cotterzz. https://shadertoy.com/view/3cXcRs\n// 2025-08-24 09:49:35\n\n// Fork of \"Buffer feedback real time\" by Cotterzz. https://shadertoy.com/view/tcfczf\n// 2025-08-23 04:43:55\n\n// Fork of \"Another feedback fractal\" by Cotterzz. https://shadertoy.com/view/3cVGzm\n// 2025-08-22 16:54:07\n\n// (Also inspired by: \"Dancy Tree Doodle  by wyatt. \"https://www.shadertoy.com/view/wslGz7 )\n\n// Fork of \"Koch with hexagons\" by Cotterzz. https://shadertoy.com/view/tfd3Ds\n// 2025-05-22 15:34:19\n\n// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 18:21:33\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float co = distance(uv, vec2(0.5));\n    vec3 colA = texture(iChannel0, fragCoord/iResolution.xy, 0.).rgb;\n    vec3 colB = texture(iChannel1, fragCoord/iResolution.xy, 0.).rgb;\n    colA = hsl2rgb(vec3((colA.r/3.)-co, 1., colA.r/3.));\n    colB = hsl2rgb(vec3(colB.r/2.5, 1., colB.r/2.));\n    fragColor = vec4(colA+colB, 1.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    vec2 pa = vec2(0.5*ar, 0.05);\n    vec2 pb = vec2(ar/2.+(sin(iTime/1.1)/8.), .25+cos(iTime/1.3)/20.);\n    if(iMouse.z>0.001) {pb = vec2(iMouse.x/iResolution.x*ar, iMouse.y/iResolution.y);\n    pb.x = ar/2.+0.15-(pb.x-ar/2.);}\n    vec2 pd = pb-pa;\n    float csdf = capsuleSDF(uvc, pa, pb, .01);\n    vec3 col = vec3(mix(1.,0., csdf*50.));\n\n    vec2 rv = uvc-pb;\n    float ano = atan(rv.y, rv.x);\n    float and = atan(pd.y,pd.x);\n    float ang = abs(uv.x-.5)*3.;\n    \n    float ancl = ano-ang;\n    float ancr = ano+ang;\n    float len = length(rv);\n    vec2 rvnl = vec2(cos(ancl)*len, sin(ancl)*len);\n    vec2 tcl = vec2(0.5, 0.05)+rvnl*1.2;\n    vec2 rvnr = vec2(cos(ancr)*len, sin(ancr)*len);\n    vec2 tcr = vec2(0.5, 0.05)+rvnr*1.2;\n    //col = max(col, texture(iChannel1, tcl, 0.).rgb);\n   col = max(col, texture(iChannel0, tcr, 0.).rgb);\n  //col = max(col, texture(iChannel0, tcl, 0.).rgb);\n   col = max(col, texture(iChannel1, tcr, 0.).rgb);\n    fragColor = vec4(col,1.0);\n    if(iFrame<2||uv.x>.99||uv.x<0.01||uv.y>.99||uv.y<0.01){fragColor = vec4(0);}\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n\nfloat capsuleSDF(in vec2 P,in vec2 B,in vec2 E,in float R)\n{\n    vec2 BP = P - B;\n    vec2 BE = E - B;\n    float t = clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0);\n    vec2 K = BP - BE * t;\n    return sqrt(dot(K, K)) - R;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    vec2 pa = vec2(0.5*ar, 0.05);\n    vec2 pb = vec2(ar/2.+(sin(iTime/1.3)/-8.), .25+cos(iTime/2.9)/20.);\n    if(iMouse.z>0.001) {pb = vec2(iMouse.x/iResolution.x*ar, iMouse.y/iResolution.y);}\n    vec2 pd = pb-pa;\n    float csdf = capsuleSDF(uvc, pa, pb, .01);\n    vec3 col = vec3(mix(1.,0., csdf*150.));\n\n    vec2 rv = uvc-pb;\n    float ano = atan(rv.y, rv.x);\n    float and = atan(pd.y,pd.x);\n    float ang = pow(abs(uv.x-.5),.4);\n    float ancl = ano-ang;\n    float ancr = ano+ang;\n    float len = length(rv);\n    vec2 rvnl = vec2(cos(ancl)*len, sin(ancl)*len);\n    vec2 tcl = vec2(0.5, 0.05)+rvnl*1.2;\n    vec2 rvnr = vec2(cos(ancr)*len, sin(ancr)*len);\n    vec2 tcr = vec2(0.5, 0.05)+rvnr*1.2;\n  col = max(col, texture(iChannel1, tcl, 0.).rgb);\n    col = max(col, texture(iChannel0, tcr, 0.).rgb);\n   // col = max(col, texture(iChannel0, tcl, 0.).rgb);\n   // col = max(col, texture(iChannel1, tcr, 0.).rgb);\n    fragColor = vec4(col,1.0);\n    if(iFrame<2||uv.x>.99||uv.x<0.01||uv.y>.99||uv.y<0.01){fragColor = vec4(0);}\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3cXcW2",
    "date": "1756048246",
    "viewed": 146,
    "name": "Buffer feedback trees",
    "description": "More experimenting with buffer feedback trees.\nClick and drag.",
    "likes": 15,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "line",
     "tree",
     "recursive",
     "feedback",
     "buffer"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Buffer feedback swap\" by Cotterzz. https://shadertoy.com/view/wfsyWB\n// 2025-08-24 15:04:05\n\n// Fork of \"Buffer feedback weirdness\" by Cotterzz. https://shadertoy.com/view/3cXcRs\n// 2025-08-24 09:49:35\n\n// Fork of \"Buffer feedback real time\" by Cotterzz. https://shadertoy.com/view/tcfczf\n// 2025-08-23 04:43:55\n\n// Fork of \"Another feedback fractal\" by Cotterzz. https://shadertoy.com/view/3cVGzm\n// 2025-08-22 16:54:07\n\n// (Also inspired by: \"Dancy Tree Doodle  by wyatt. \"https://www.shadertoy.com/view/wslGz7 )\n\n// Fork of \"Koch with hexagons\" by Cotterzz. https://shadertoy.com/view/tfd3Ds\n// 2025-05-22 15:34:19\n\n// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 18:21:33\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float co = distance(uv, vec2(0.5));\n    vec3 colA = texture(iChannel0, fragCoord/iResolution.xy, 0.).rgb;\n    vec3 colB = texture(iChannel1, fragCoord/iResolution.xy, 0.).rgb;\n    colA = hsl2rgb(vec3((colA.r/2.5)-co, 1., colA.r/2.));\n    colB = hsl2rgb(vec3((colB.r/2.5)+co, 1., colB.r/2.));\n    fragColor = vec4((colA+colB)*2.5, 1.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    vec2 pa = vec2(0.5*ar, 0.05);\n    vec2 pb = vec2(ar/2.+(sin(iTime*1.15)/-5.), .18+cos(iTime*2.3)/-21.);\n    pb.y += .03 + pow(abs(pb.x-(ar*.5)),2.);\n    if(iMouse.z>0.001) {pb = vec2(iMouse.x/iResolution.x*ar, iMouse.y/iResolution.y);\n    pb.x = ar/2. - (pb.x-ar/2.);\n    }\n    vec2 pd = pb-pa;\n    float csdf = capsuleSDF(uvc, pa, pb, .001);\n    vec3 col = vec3(mix(1.,0., csdf*200.));\n\n    vec2 rv = uvc-pb;\n    float ano = atan(rv.y, rv.x);\n    float and = atan(pd.y,pd.x);\n    float anga = abs(uv.x-.5)*3.;\n    float ang = pow(abs(uv.x-.5),.4);\n    \n    float ancl = ano-ang;\n    float ancr = ano+anga;\n    float len = length(rv);\n    float tlen = 1. + length(pd);\n    vec2 rvnl = vec2(cos(ancl)*len, sin(ancl)*len);\n    vec2 tcl = vec2(0.5, 0.05)+rvnl*tlen;\n    vec2 rvnr = vec2(cos(ancr)*len, sin(ancr)*len);\n    vec2 tcr = vec2(0.5, 0.05)+rvnr*tlen;\n    col = max(col, texture(iChannel1, tcl, 0.).rgb*fade);\n   col = max(col, texture(iChannel0, tcr, 0.).rgb*fade);\n  col = max(col, texture(iChannel0, tcl, 0.).rgb*fade);\n   col = max(col, texture(iChannel1, tcr, 0.).rgb*fade);\n    fragColor = vec4(col,1.0);\n    if(iFrame<2||uv.x>.99||uv.x<0.01||uv.y>.99||uv.y<0.01){fragColor = vec4(0);}\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\nfloat fade  = 0.9;\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\nvec3 gmc(vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\nfloat capsuleSDF(in vec2 P,in vec2 B,in vec2 E,in float R)\n{\n    vec2 BP = P - B;\n    vec2 BE = E - B;\n    float t = clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0);\n    vec2 K = BP - BE * t;\n    return sqrt(dot(K, K)) - R;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    vec2 pa = vec2(0.5*ar, 0.05);\n    vec2 pb = vec2(ar/2.+(sin(iTime*1.15)/5.), .18+cos(iTime*2.3)/-21.);\n    pb.y += .03 + pow(abs(pb.x-(ar*.5)),2.);\n    if(iMouse.z>0.001) {pb = vec2(iMouse.x/iResolution.x*ar, iMouse.y/iResolution.y);}\n    vec2 pd = pb-pa;\n    float csdf = capsuleSDF(uvc, pa, pb, .001);\n    vec3 col = vec3(mix(1.,0., csdf*200.));\n    \n    vec2 rv = uvc-pb;\n    float ano = atan(rv.y, rv.x);\n    float and = atan(pd.y,pd.x);\n    float anga = abs(uv.x-.5)*3.;\n    float ang = pow(abs(uv.x-.5),.4);\n    \n\n    float ancr = ano-anga;\n    float ancl = ano+ang;\n    float len = length(rv);\n    float tlen = 1. + length(pd);\n    vec2 rvnl = vec2(cos(ancl)*len, sin(ancl)*len);\n    vec2 tcl = vec2(0.5, 0.05)+rvnl*tlen;\n    vec2 rvnr = vec2(cos(ancr)*len, sin(ancr)*len);\n    vec2 tcr = vec2(0.5, 0.05)+rvnr*tlen;\n  col = max(col, texture(iChannel1, tcl, 0.).rgb*fade);\n    col = max(col, texture(iChannel0, tcr, 0.).rgb*fade);\n    col = max(col, texture(iChannel0, tcl, 0.).rgb*fade);\n    col = max(col, texture(iChannel1, tcr, 0.).rgb*fade);\n    fragColor = vec4(col,1.0);\n    if(iFrame<2||uv.x>.99||uv.x<0.01||uv.y>.99||uv.y<0.01){fragColor = vec4(0);}\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3cXcWX",
    "date": "1756103775",
    "viewed": 8,
    "name": "Bft - messing with values",
    "description": "Trying different things with the left and right buffer rotation angles - ancl and ancr\nClick and drag.",
    "likes": 1,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "line",
     "tree",
     "recursive",
     "feedback",
     "buffer"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Buffer feedback trees\" by Cotterzz. https://shadertoy.com/view/3cXcW2\n// 2025-08-25 06:29:26\n\n// Fork of \"Buffer feedback swap\" by Cotterzz. https://shadertoy.com/view/wfsyWB\n// 2025-08-24 15:04:05\n\n// Fork of \"Buffer feedback weirdness\" by Cotterzz. https://shadertoy.com/view/3cXcRs\n// 2025-08-24 09:49:35\n\n// Fork of \"Buffer feedback real time\" by Cotterzz. https://shadertoy.com/view/tcfczf\n// 2025-08-23 04:43:55\n\n// Fork of \"Another feedback fractal\" by Cotterzz. https://shadertoy.com/view/3cVGzm\n// 2025-08-22 16:54:07\n\n// (Also inspired by: \"Dancy Tree Doodle  by wyatt. \"https://www.shadertoy.com/view/wslGz7 )\n\n// Fork of \"Koch with hexagons\" by Cotterzz. https://shadertoy.com/view/tfd3Ds\n// 2025-05-22 15:34:19\n\n// Fork of \"Koch with buffer rotation\" by Cotterzz. https://shadertoy.com/view/Wf33Wl\n// 2025-05-19 18:21:33\n\n// Fork of \"Koch Snowflake using buffer\" by Cotterzz. https://shadertoy.com/view/wf3GDX\n// 2025-05-19 06:46:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float co = distance(uv, vec2(0.5));\n    vec3 colA = texture(iChannel0, fragCoord/iResolution.xy, 0.).rgb;\n    vec3 colB = texture(iChannel1, fragCoord/iResolution.xy, 0.).rgb;\n    colA = hsl2rgb(vec3((colA.r/2.5)-co, 1., colA.r/2.));\n    colB = hsl2rgb(vec3((colB.r/2.5)+co, 1., colB.r/2.));\n    fragColor = vec4((colA+colB)*2.5, 1.);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    vec2 pa = vec2(0.5*ar, 0.05);\n    vec2 pb = vec2(ar/2.+(sin(iTime*1.15)/-5.), .18+cos(iTime*2.3)/-21.);\n    pb.y += .03 + pow(abs(pb.x-(ar*.5)),2.);\n    if(iMouse.z>0.001) {pb = vec2(iMouse.x/iResolution.x*ar, iMouse.y/iResolution.y);\n    pb.x = ar/2. - (pb.x-ar/2.);\n    }\n    vec2 pd = pb-pa;\n    float csdf = capsuleSDF(uvc, pa, pb, .001);\n    vec3 col = vec3(mix(1.,0., csdf*200.));\n\n    vec2 rv = uvc-pb;\n    float ano = atan(rv.y, rv.x);\n    float and = atan(pd.y,pd.x);\n    float anga = abs(uv.x-.5)*3.;\n    float ang = pow(abs(uv.x-.5),.4);\n     float nv = distance(uvc, pa);\n    \n    float ancl = ano+(anga-ang)-nv;\n    float ancr = ano-(ang*anga)+nv;\n    \n    float len = length(rv);\n    float tlen = 1. + length(pd);\n    vec2 rvnl = vec2(cos(ancl)*len, sin(ancl)*len);\n    vec2 tcl = vec2(0.5, 0.05)+rvnl*tlen;\n    vec2 rvnr = vec2(cos(ancr)*len, sin(ancr)*len);\n    vec2 tcr = vec2(0.5, 0.05)+rvnr*tlen;\n    col = max(col, texture(iChannel1, tcl, 0.).rgb*fade);\n   col = max(col, texture(iChannel0, tcr, 0.).rgb*fade);\n  col = max(col, texture(iChannel0, tcl, 0.).rgb*fade);\n   col = max(col, texture(iChannel1, tcr, 0.).rgb*fade);\n    fragColor = vec4(col,1.0);\n    if(iFrame<2||uv.x>.99||uv.x<0.01||uv.y>.99||uv.y<0.01){fragColor = vec4(0);}\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\nfloat fade  = 0.97;\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\nvec3 gmc(vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\nfloat capsuleSDF(in vec2 P,in vec2 B,in vec2 E,in float R)\n{\n    vec2 BP = P - B;\n    vec2 BE = E - B;\n    float t = clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0);\n    vec2 K = BP - BE * t;\n    return sqrt(dot(K, K)) - R;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    vec2 pa = vec2(0.5*ar, 0.05);\n    vec2 pb = vec2(ar/2.+(sin(iTime*1.15)/5.), .18+cos(iTime*2.3)/-21.);\n    pb.y += .03 + pow(abs(pb.x-(ar*.5)),2.);\n    if(iMouse.z>0.001) {pb = vec2(iMouse.x/iResolution.x*ar, iMouse.y/iResolution.y);}\n    vec2 pd = pb-pa;\n    float csdf = capsuleSDF(uvc, pa, pb, .001);\n    vec3 col = vec3(mix(1.,0., csdf*200.));\n    \n    vec2 rv = uvc-pb;\n    float ano = atan(rv.y, rv.x);\n    float and = atan(pd.y,pd.x);\n    float anga = abs(uv.x-.5)*3.;\n    float ang = pow(abs(uv.x-.5),.4);\n   float nv = distance(uvc, pa);\n    \n    float ancl = ano+(anga)+uvc.y;\n    float ancr = ano+(ang)*uvc.y;\n    \n    float len = length(rv);\n    float tlen = 1. + length(pd);\n    vec2 rvnl = vec2(cos(ancl)*len, sin(ancl)*len);\n    vec2 tcl = vec2(0.5, 0.05)+rvnl*tlen;\n    vec2 rvnr = vec2(cos(ancr)*len, sin(ancr)*len);\n    vec2 tcr = vec2(0.5, 0.05)+rvnr*tlen;\n  col = max(col, texture(iChannel1, tcl, 0.).rgb*fade);\n    col = max(col, texture(iChannel0, tcr, 0.).rgb*fade);\n    col = max(col, texture(iChannel0, tcl, 0.).rgb*fade);\n    col = max(col, texture(iChannel1, tcr, 0.).rgb*fade);\n    fragColor = vec4(col,1.0);\n    if(iFrame<2||uv.x>.99||uv.x<0.01||uv.y>.99||uv.y<0.01){fragColor = vec4(0);}\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3f2yWw",
    "date": "1756685234",
    "viewed": 6,
    "name": "Polar Spiral from Rectangle",
    "description": "constant width spiral, middle width always 1/2 radius, inner and outer add up to 1/2 radius.",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "spiral",
     "polar"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.y;\n    float radius = 0.4;\n    vec2 centre = vec2(0.5);\n    vec2 spos = uv-centre;\n    float dist = length(spos);\n    float ndist = dist/radius;\n    float angle = (atan(spos.x,spos.y)+3.1416)/6.2832;\n\n    vec3 col = vec3(1);\n    \n    float spirala = angle/2.;\n    float spiralb = 0.5 + angle/2.;\n    if(abs(ndist-spirala)<0.003){col=vec3(0);}\n    if(abs(ndist-spiralb)<0.003){col=vec3(0);}\n    if(abs(dist-radius)<0.005){col=vec3(0);}\n\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wc2cWK",
    "date": "1757103835",
    "viewed": 108,
    "name": "Wooden Block 3D Texture",
    "description": "Texture is fixed in space to see different grain cuts\nThere is a lot that could be improved/added to this, eg combining it with [url=https://www.shadertoy.com/view/tcScWy]this[/url] approach.\n..but it's a nice starting point.",
    "likes": 10,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "wood",
     "grain",
     "3dtexture"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\nmat3 rotation;\n\nmat3 rotateX(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(1,0,0, 0,c,-s, 0,s,c);\n}\n\nmat3 rotateY(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(c,0,s, 0,1,0, -s,0,c);\n}\n\nmat3 rotateZ(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(c,-s,0, s,c,0, 0,0,1);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdDodecahedron(vec3 p, float r) {\n    const vec3 n = normalize(vec3(1.0, 1.618, 0.0)); // Golden ratio\n    p = abs(p);\n    float a = dot(p, n.xyz);\n    float b = dot(p, n.zxy);\n    float c = dot(p, n.yzx);\n    return (max(max(a, b), c) - r) * 0.57735; \n}\n\nfloat getDist(vec3 p) {\n    vec2 mouse = (iMouse.xy / iResolution.xy - 0.5) * 2.0;\n    float rotY = mouse.x * 3.14159;\n    float rotX = mouse.y * 3.14159;\n    rotation = rotateY(rotY) * rotateX(rotX);\n    \n    // Apply rotation to the entire scene first\n    vec3 rotatedP = rotation * p;\n\n    // Center box (2x2x4, so half-extents are 1x1x2)\n    float box = sdBox(rotatedP, vec3(1.0, 1.0, 2.0));\n    \n    // Center box (2x2x4, so half-extents are 1x1x2)\n    float board = sdBox(rotatedP - vec3(0., 2., 0.0), vec3(5.0, .3, 2.));\n    \n    // Left sphere (radius 1, positioned at x = -4.5)\n    float sphere = sdSphere(rotatedP - vec3(-3., 0.0, 0.0), 1.3);\n    \n    // Right dodecahedron (radius 1, positioned at x = 4.5)\n    float dodeca = sdDodecahedron(rotatedP - vec3(3., 0.0, 0.0), 1.0);\n    \n    // Return minimum distance (union of all objects)\n    return min(min(min(box, board), sphere), dodeca);\n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(0.01, 0);\n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx)\n    );\n    return normalize(n);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDist(p);\n        dO += dS;\n        \n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nvec3 getWoodTexture(vec3 worldPos, out float darkness) {\n\n    // UNCOMMENT TO FIX TEXTURE TO OBJECTS\n    // worldPos = rotation*worldPos; \n\n    float distFromYAxis = length(worldPos.xz);\n    float angleFromAxis = atan(worldPos.z, worldPos.x);\n    \n    distFromYAxis  += (hash(vec2(floor(angleFromAxis*1200.), 0.)) + hash(vec2(0.,floor(angleFromAxis*700.))))*(0.1/max(1.,distFromYAxis*distFromYAxis));\n    \n    for(int i = 0; i < 10; i++) {\n        // Generate pseudo-random knot parameters\n        vec2 seed = vec2(float(i) * 12.345, float(i) * 67.89);\n        float knotAngle = hash(seed) * 6.28318;\n        float knotSize = 0.25 + hash(seed*2.) * 0.3;\n        float knotDist = 2.0 + hash(seed + vec2(1.5, 0.0)) * 0.5; \n        float knotY = -1.5 + hash(seed + vec2(1.0, 0.0)) * 2.0; \n        \n    \n        vec2 knotCenter = vec2(cos(knotAngle) * knotDist, sin(knotAngle) * knotDist);\n        float distFromKnot = length(worldPos.xz - knotCenter);\n        \n        //float yFalloff = exp(-abs(worldPos.y - knotY) * 0.8);\n        \n        // Modify the main distance field with knot influence\n        if(distFromKnot < knotSize ) {\n            // Create a \"well\" around the knot - negative values make it a new grain center\n            float knotInfluence = (knotSize - distFromKnot) / knotSize; // 1.0 at center, 0.0 at edge\n            //knotInfluence *= yFalloff;\n            \n            // Subtract from distance field to create negative regions (knot centers)\n            distFromYAxis -= (knotInfluence * knotInfluence *3.5);\n        }\n    }\n    \n    // Add some noise for more realistic wood grain\n    float noise = sin(worldPos.x * 4.0) * 0.05 + sin(worldPos.z * 4.0) * 0.05;\n    distFromYAxis += noise*distFromYAxis*0.9;\n    \n    \n    \n    // Now calculate ALL grain from this single modified distance field\n    // Main rings\n    float rings = fract(distFromYAxis * distFromYAxis *1.5);\n    \n    \n    float mainGrain = smoothstep(0.0, 0.3, rings) - smoothstep(0.7, 1.0, rings);\n     \n    \n    \n    // Sub-grain - faint lines between main lines\n    float subRings = fract(distFromYAxis * 30.0); // Higher frequency\n    float subGrain = smoothstep(0.1*mainGrain, 0.2*mainGrain, subRings) - smoothstep(0.7*mainGrain, 0.8*mainGrain, subRings);\n    subGrain *= 0.4;\n    \n    float combinedGrain = mainGrain + subGrain;\n        // Output darkness factor for specular modulation\n    darkness = 1.0 - (combinedGrain * 0.5 + 0.5); // Keep in 0-1 range for lighting\n\n    vec3 darkWood = vec3(0.65, 0.45, 0.15);\n    vec3 lightWood = vec3(0.85, 0.65, 0.35);\n    vec3 knotWood = vec3(0.4, 0.3, 0.1)+(distFromYAxis/10.); \n    \n    vec3 woodColor;\n    if(distFromYAxis < 0.0) {\n        woodColor = mix(knotWood, darkWood, combinedGrain * 0.5);\n        darkness +=0.5;\n    } else {\n        // Normal grain regions\n        woodColor = mix(darkWood, lightWood, combinedGrain);\n        \n    }\n    \n\n    \n    return woodColor;\n}\n\nvec3 getLight(vec3 p, vec3 normal, vec3 viewDir, vec3 albedo, float darkness) {\n    vec3 lightPos = vec3(5.0, 8.0, 10.0);\n    vec3 lightDir = normalize(lightPos - p);\n    \n    vec3 ambient = albedo * 0.2;\n\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = (albedo * diff) *0.8;\n    \n    // Variable specular - stronger where texture is darker\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 8.0);\n    float specularStrength = 0.1 + darkness * 0.7;\n    vec3 specular = vec3(specularStrength) * spec;\n    \n\n    float shadow = 1.0;\n    float shadowDist = rayMarch(p + normal * SURF_DIST * 2.0, lightDir);\n    if(shadowDist < length(lightPos - p)) {\n        shadow = 0.3;\n    }\n    \n    return ambient + (diffuse + specular) * shadow;\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0, 0, 10); \n    vec3 rd = normalize(vec3(uv, -1)); \n    float d = rayMarch(ro, rd);\n    vec3 col = vec3(0.1, 0.1, 0.2); \n    \n    if(d < MAX_DIST) {\n\n        vec3 p = ro + rd * d;\n        vec3 normal = getNormal(p);\n        float darkness;\n        vec3 albedo = getWoodTexture(p, darkness);\n        vec3 viewDir = normalize(-rd);\n        col = getLight(p, normal, viewDir, albedo, darkness);\n    }\n    \n    col = pow(col, vec2(0.4545).xxx);\n    fragColor = vec4(col, 1.0);\n}\n\n// multisampling, from \"Weyl Supersample Any Shader\" by spalmer https://www.shadertoy.com/view/WXjXRt\n// (forked from from \"postprocess existing shaders\" by FabriceNeyret2 https://www.shadertoy.com/view/NdyfRz \nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = 4., k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n} ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WfffR8",
    "date": "1757597918",
    "viewed": 37,
    "name": "Pumpkin Carver 1.0",
    "description": "Carve your own pumpkin, see code for instructions and info.\nThanks to Diatribes for the Sky and TheTurk for the 3D noise",
    "likes": 4,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "raymarch",
     "sdf",
     "halloween",
     "pumpkin",
     "october"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// ABOUT\n// I wanted to make an interactive pumpkin carving shader for halloween.\n// This is my first attempt at a basic prototype, and it went a lot further than originally planned.\n// Using a drawn texture to postively displace a sphere SDF and then subtracting that from the main pumpkin.\n// The texture also provides an easy route to volumetric light.\n// --\n// It was a lot of fun to make and as a prototype/proof of concept it's a success that turned out better than expected\n// However - it has plenty of issues and will benefit from a complete rebuild.\n// Performance, compile time, messy code, untidy carve subtraction and the overall scene rendering could all be improved a lot.\n// --\n// I'm working on the next version.\n\n// LICENSE\n// Permission required for use outside shadertoy.\n\n\n// INSTRUCTIONS\n// Click and drag on pumpkin to carve.\n// Select mirror mode (second button down on the left) to draw symmetrical patterns.\n// Inverse mode to draw/fill pumpkin back in.\n// Inverse mirror for both.\n// Top button to set back to regualr carving.\n// Brush size slider on the left.\n// FPS indicator top right, blue/green is good, red is bad, adjust quality settings.\n// Quality settings on the bottom right, Antialiasing, volumetric light, smoke and skies.\n// up is higher quality but more GPU intensive.\n// Watch the FPS indicator, you really need it in the green (55+ frames per second) if possible.\n// Right-click and save-as to save image, hit rewind to reset.\n\n\n// ---- Fast Improved Perlin Noise by TheTurk: https://www.shadertoy.com/view/slB3z3\n\nuint hash(uint x, uint seed) {\n    const uint m = 0x5bd1e995U;uint h = seed;uint k = x;k *= m;k ^= k >> 24;\n    k *= m;h *= m;h ^= k;h ^= h >> 13;h *= m;h ^= h >> 15;return h;\n}\n\nuint hash(uvec3 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint h = seed;uint k = x.x; \n    k *= m;k ^= k >> 24;k *= m;h *= m;h ^= k;\n    k = x.y;k *= m;k ^= k >> 24;k *= m;h *= m;h ^= k;\n    k = x.z;k *= m;k ^= k >> 24;k *= m;h *= m;h ^= k;\n    h ^= h >> 13;h *= m;h ^= h >> 15;\n    return h;\n}\n\nvec3 gradientDirection(uint hash) {\n    vec3 r = vec3(0,1,-1);switch (int(hash) & 15) {\n    case 0:return r.yyx;case 1:return r.zxy;\n    case 2:return r.yzx;case 3:return r.zzx;\n    case 4:return r.yyx;case 5:return r.zxy;\n    case 6:return r.yxz;case 7:return r.zxz;\n    case 8:return r.xyy;case 9:return r.xzy;\n    case 10:return r.xzz;case 11:return r.xyz;\n    case 12:return r.yyx;case 13:return r.zxy;\n    case 14:return r.xzy;case 15:return r.xzz;\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, float value5, float value6, float value7, float value8, vec3 t) {\n    return mix(mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y),mix(mix(value5, value6, t.x), mix(value7, value8, t.x), t.y), t.z);\n}\n\nvec3 fade(vec3 t) {return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);}\n\nfloat perlinNoise(vec3 position, uint seed) {\n    vec3 floorPosition = floor(position);\n    vec3 fractPosition = position - floorPosition;\n    uvec3 cellCoordinates = uvec3(floorPosition);\n    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 0)), seed)), fractPosition - vec3(1, 0, 0));\n    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 0)), seed)), fractPosition - vec3(0, 1, 0));\n    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 0)), seed)), fractPosition - vec3(1, 1, 0));\n    float value5 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 0, 1)), seed)), fractPosition - vec3(0, 0, 1));\n    float value6 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 1)), seed)), fractPosition - vec3(1, 0, 1));\n    float value7 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 1)), seed)), fractPosition - vec3(0, 1, 1));\n    float value8 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 1)), seed)), fractPosition - vec3(1, 1, 1));\n    return interpolate(value1, value2, value3, value4, value5, value6, value7, value8, fade(fractPosition));\n}\n\nfloat perlinNoise(vec3 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;float amplitude = 1.0;float currentFrequency = float(frequency);uint currentSeed = seed;\n    for (int i = 0; i < octaveCount; i++) {\n        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;currentFrequency *= lacunarity;\n    }\n    return value;\n}\n\n\n// --- Main Shader Code by Cotterzz\n\nint AA = 0;\nint VOLUMETRIC = 2;\nint SMOKE = 2;\nint SKIES = 2;\n\n// store rd and ro for volumetric without AA\nvec3 sro;\nvec3 srd;\n\n// UI Helper functions\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat drawSquiggly(vec2 p, bool mirrored) {\n    if (mirrored) p.x = -p.x;\n    \n    // Smaller squiggly line\n    float y = sin(p.x * 190.0) * 0.007;\n    float line = abs(p.y - y) - 0.002;\n    return line;\n}\n\n// Draw mode button - returns color mixing factor\nvec3 drawModeButton(vec2 uv, vec2 center, bool invers, bool mirrored, bool selected) {\n    // Button color scheme\n    vec3 regularColor = vec3(0.5, 0.2, 0.0);\n    vec3 inverseColor = vec3(1.0, 1.0, 0.5);\n    \n    vec2 p = uv - center;\n    float buttonSize = 0.048; // 60% of 0.08\n    \n    // Main circle\n    float mainCircle = sdCircle(p, buttonSize);\n    \n    // Selection highlight\n    float highlight = selected ? sdCircle(p, buttonSize + 0.006) : 1.0; // 60% of 0.01\n    \n    // Return background if outside button\n    if (mainCircle > 0.0 && (!selected || highlight > 0.0)) {\n        return vec3(-1.0); // Signal: no button here\n    }\n    \n    // Selection highlight (blue border)\n    if (selected && highlight < 0.0 && mainCircle > 0.0) {\n        return vec3(0.3, 0.5, 1.0); // Blue highlight\n    }\n    \n    // Button interior\n    if (mainCircle < 0.0) {\n        \n        if (mirrored) {\n            // Mirror mode: show two sets of icons with center line\n            \n            // Thinner center mirror line\n            float centerLine = abs(p.x) - 0.0006; // 60% of 0.001\n            if (centerLine < 0.0) {\n                return invers ? regularColor : inverseColor; // Mirror line color\n            }\n            \n            // Left side icons\n            vec2 leftOffset = vec2(-0.021, 0.024); // 60% scaling\n            float leftSmallCircle = sdCircle(p - leftOffset, 0.007); // 60% of 0.012\n            \n            // Left squiggly line - only on left side\n            vec2 leftSquigglyPos = p - vec2(-0.021, 0); // 60% of -0.035\n            float leftSquiggly = drawSquiggly(leftSquigglyPos.yx, false);\n            // Clip squiggly to left side only\n            if (leftSquigglyPos.y > 0.021) leftSquiggly = 1.0; // 60% of 0.035\n            \n            // Right side icons (mirrored)\n            vec2 rightOffset = vec2(0.021, 0.024); // 60% scaling\n            float rightSmallCircle = sdCircle(p - rightOffset, 0.007); // 60% of 0.012\n            \n            // Right squiggly line - only on right side\n            vec2 rightSquigglyPos = p - vec2(0.021, 0); // 60% of 0.035\n            float rightSquiggly = drawSquiggly(rightSquigglyPos.yx, true);\n            // Clip squiggly to right side only\n            if (rightSquigglyPos.y > 0.021) rightSquiggly = 1.0; // 60% of 0.035\n            \n            // Check for any icon element\n            if (leftSmallCircle < 0.0 || rightSmallCircle < 0.0 || \n                leftSquiggly < 0.0 || rightSquiggly < 0.0) {\n                return invers ? regularColor : inverseColor; // Icon color\n            }\n            \n        } else {\n            // Regular mode: single set of icons\n            \n            // Small circle\n            vec2 smallOffset = vec2(0.018, 0.012); // 60% scaling\n            float smallCircle = sdCircle(p - smallOffset, 0.009); // 60% of 0.015\n            \n            // Squiggly line\n            vec2 squigglyPos = p - vec2(0.0, 0.012); // 60% of 0.02\n            float squiggly = drawSquiggly(squigglyPos, false);\n            if (squigglyPos.x > 0.021) squiggly = 1.0; // 60% of 0.035\n            // Check for icon elements\n            if (smallCircle < 0.0 || squiggly < 0.0) {\n                return invers ? regularColor : inverseColor; // Icon color\n            }\n        }\n        \n        // Main button background\n        return invers ? inverseColor : regularColor;\n    }\n    \n    return vec3(-1.0); // No button\n}\n\n// Draw quality slider - returns color\nvec3 drawQualitySlider(vec2 uv, vec2 center, float value, bool selected) {\n    vec2 p = uv - center;\n    \n    // Slider track (vertical)\n    float trackWidth = 0.008;\n    float trackHeight = 0.08;\n    float track = max(abs(p.x) - trackWidth, abs(p.y) - trackHeight);\n    \n    // Slider button (square, positioned based on value 0-4)\n    float buttonY = (value / 4.0 - 0.5) * trackHeight * 1.8;\n    vec2 buttonPos = vec2(0.0, buttonY);\n    float buttonSize = 0.012;\n    float button = max(abs(p.x - buttonPos.x) - buttonSize, abs(p.y - buttonPos.y) - buttonSize);\n    \n    if (track < 0.0 && button > 0.0) {\n        return vec3(0.3, 0.3, 0.3); // Track color\n    }\n    \n    if (button < 0.0) {\n        return selected ? vec3(0.2, 0.6, 1.0) : vec3(0.8, 0.8, 0.8); // Button color\n    }\n    \n    return vec3(-1.0); // No slider\n}\n\n// Draw brush slider - returns color  \nvec3 drawBrushSlider(vec2 uv, vec2 center, float brushSize, bool selected) {\n    vec2 p = uv - center;\n    \n    // Slider track (vertical)\n    float trackWidth = 0.008;\n    float trackHeight = 0.15;\n    float track = max(abs(p.x) - trackWidth, abs(p.y) - trackHeight);\n    \n    // Map brush size (0.03 to 0.15) to slider position\n    float normalizedSize = (brushSize - 0.03) / (0.15 - 0.03);\n    float buttonY = (normalizedSize - 0.5) * trackHeight * 1.8;\n    \n    // Round button that scales with brush size\n    vec2 buttonPos = vec2(0.0, buttonY);\n    float buttonRadius = 0.008 + (normalizedSize * 0.015); // Grows with brush size\n    float button = length(p - buttonPos) - buttonRadius;\n    \n    // Larger hit area for interaction (but don't show visually)\n    float hitRadius = max(buttonRadius, 0.025); // Minimum hit area\n    float hitArea = length(p - buttonPos) - hitRadius;\n    \n    if (track < 0.0 && button > 0.0) {\n        return vec3(0.3, 0.3, 0.3); // Track color\n    }\n    \n    if (button < 0.0) {\n        return selected ? vec3(0.2, 0.6, 1.0) : vec3(0.8, 0.8, 0.8); // Button color\n    }\n    \n    return vec3(-1.0); // No slider\n}\n\n// Draw FPS indicator\nvec3 drawFPSIndicator(vec2 uv, vec2 center, float fps) {\n    vec2 p = uv - center;\n    float size = 0.01;\n    \n    if (abs(p.x) < size && abs(p.y) < size) {\n        // Color code based on FPS\n        if (fps >= 100.0) return vec3(0.4, 0.8, 1.0);      // Light blue\n        else if (fps >= 55.0) return vec3(0.0, 1.0, 0.0);  // Green\n        else if (fps >= 25.0) return vec3(1.0, 1.0, 0.0);  // Yellow\n        else if (fps >= 15.0) return vec3(1.0, 0.5, 0.0);  // Orange\n        else return vec3(1.0, 0.0, 0.0);                   // Red\n    }\n    \n    return vec3(-1.0); // No indicator\n}\n\n// Sample the carving texture\nfloat getCarvingDepth(vec3 p) {\n\n    vec3 np = normalize(p);\n    float theta = atan(np.z, np.x);\n    float phi = acos(clamp(np.y, -1.0, 1.0));\n    vec2 uv;\n    uv.x = (theta + 3.14159) / (2.0 * 3.14159);\n    uv.y = 1.0 - phi / 3.14159;\n    return texture(iChannel0, uv).r;\n}\n\n// Utility functions\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec2 fold(vec2 p,float s){float a=3.142/s-atan(p.x,p.y),n=6.283/s;p*=rot(floor(a/n)*n);return p;}\nfloat sminCubic(float a,float b,float k){float h=max(k-abs(a-b),0.)/k;return min(a,b)-h*h*h*k*(1./6.);}\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// SDF functions\nfloat sdTorus(vec3 p,vec2 t){return length(vec2(length(p.yz)-t.x,p.x))-t.y;}\nfloat sdCube(vec3 p){vec3 q=abs(p)-.5;return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);}\nfloat sdCappedCylinder(vec3 p,float h,float r){vec2 d=abs(vec2(length(p.xz),p.y))-vec2(h,r);return min(max(d.x,d.y),0.)+length(max(d,0.));}\nfloat sdEllipsoid(vec3 p, vec3 r) {\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// Realistic pumpkin shape with ridges\nfloat sdPumpkin(vec3 p, float r) {\n    // Main pumpkin body - flattened sphere\n    vec3 bodyScale = vec3(1.0, 0.85, 1.0);\n    float body = sdEllipsoid(p, bodyScale * r);\n    \n    // Add vertical ridges\n    float angle = atan(p.z, p.x);\n    float ridgeCount = 12.0;\n    float ridgePhase = sin(angle * ridgeCount) * 0.15;\n    \n    // Modulate the ridges based on height\n    float heightFactor = smoothstep(-0.6, 0.4, p.y);\n    ridgePhase *= heightFactor;\n    \n    body += ridgePhase * r * 0.1;\n    \n    // Add slight indentation at top and bottom\n    float topIndent = smoothstep(0.3, 0.5, p.y) * 0.2 * r;\n    float bottomIndent = smoothstep(-0.5, -0.3, p.y) * 0.03 * r;\n    \n    return body+ topIndent + bottomIndent;\n}\n\n// Pumpkin stem\nfloat sdStem(vec3 p) {\n    vec3 stemPos = p - vec3(0.0, 0.45, 0.0);\n    \n    // Curved stem\n    stemPos.x += sin(stemPos.y * 3.0) * 0.1;\n    stemPos.z += cos(stemPos.y * 2.5) * 0.08;\n    \n    float stem = sdCappedCylinder(stemPos, 0.05, 0.19);\n    \n    // Add some bumps to the stem\n    float noise = sin(stemPos.y * 15.0) * sin(stemPos.x * 20.0) * 0.01;\n    return stem + noise;\n}\n\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\n// Candle flame SDF\nfloat sdFlame(vec3 p) {\n    p.x = abs(p.x)*2.5;\n    vec3 flamePos = p - vec3(0.45, -0.05, 0.0);\n    float it = iTime+p.x;\n    // Flame shape - teardrop\n    float flameHeight = 0.02;\n    float flameWidth = 0.02;\n    \n    // Add flickering animation\n    float flicker = sin(it * 19.0) * 0.02 + cos(it * 37.0) * 0.015;\n    flamePos.y += flicker;\n    flamePos.x += sin(it * 13.) * sin(it * 1.9) *0.02;\n    \n    // Flame SDF - teardrop shape\n    float flame = length(vec2(length(flamePos.xy) - flameHeight * (1.0 - flamePos.y/flameHeight), \n                             flamePos.y)) - flameWidth;\n    flame = max(flame, -flamePos.y);\n    flame = max(flame, flamePos.y - flameHeight);\n    \n    return flame;\n}\n\n\n// Main pumpkin SDF (solid shell only)\nfloat map(vec3 p) {\n    float outer = sdPumpkin(p, 0.6);\n    float inner = sdSphere(p, 0.5);\n    float shell = max(outer, -inner);\n    \n    // Enhanced carving system - subtract carved areas\n    float carving = getCarvingDepth(p);\n    if (carving > 0.3) {\n        float carveIntensity = smoothstep(0.3, 1.0, carving);\n        float expandedInner = sdSphere(p, 0.5 + carveIntensity * 0.2);\n        shell = max(shell, -expandedInner);\n    }\n    \n    // Add stem\n    float stem = sdStem(p);\n    shell = smin(shell, stem, 0.02);\n    \n    return shell;\n}\n\n// Ground plane SDF\nfloat sdGround(vec3 p) {\n    return p.y + 0.8; // Ground at y = -0.8\n}\n\n// Map function that includes flame and ground for rendering\nfloat mapWithFlame(vec3 p) {\n    float pumpkinDist = map(p);\n    float flameDist = sdFlame(p);\n    float groundDist = sdGround(p);\n    \n    // Only render flame if inside pumpkin\n    float inner = sdSphere(p, 0.45);\n    if (inner < 0.0) {\n        return min(min(pumpkinDist, flameDist), groundDist);\n    }\n    \n    return min(pumpkinDist, groundDist);\n}\n\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\n// Simple raymarch\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    \n    for (int i = 0; i < 200; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapWithFlame(p);\n        \n        if (abs(d) < 0.0001) return t;\n        if (t > 10.0) break;\n        \n        t += d * 0.4;\n    }\n    return t;\n}\n\n// Simple volumetric light extending from pumpkin surface\nvec3 renderVolumetricLayers(vec3 ro, vec3 rd, float startDist) {\n    vec3 volumetricColor = vec3(0.0);\n    \n    // Candle light properties\n    vec3 candlePos = vec3(0.0, -0.1, 0.0);\n    float flicker = 0.7 + 0.07 * sin(iTime*37.) + 0.06 * sin(iTime * 19.);\n    vec3 lightColor = vec3(1.5, 1.0, 0.5) * flicker;\n    \n    // Start from pumpkin surface and extend toward camera\n     int numSteps = VOLUMETRIC * 12;\n    float maxDist = 0.3 + float(VOLUMETRIC)*0.3;\n    float stepSize = maxDist / float(numSteps);\n    \n    // Go FROM surface TOWARD camera (negative direction)\n    float t = startDist - 0.02;\n    \n    for (int i = 0; i < numSteps; i++) {\n        //if (t <= 0.0) break; // Don't go behind camera\n        \n        vec3 p = ro + rd * t;\n        float carving = getCarvingDepth(p);\n        \n        if (carving > 0.3) {\n            float carveIntensity = smoothstep(0.3, 1.0, carving);\n            \n            float distToCandle = length(p - candlePos);\n            float attenuation = 1.0 / (1.0 + distToCandle * distToCandle * 0.8);\n            \n            // Distance from surface (how far light has traveled)\n            float distanceFromSurface = startDist - t;\n            float falloff = exp(-distanceFromSurface * 1.5);\n            \n            // Layer effect - expanding shells that move outward\n            float layerSpeed = 2.0;\n            float layerSpacing = 0.3;\n            float expandingLayers = sin((distanceFromSurface - iTime * layerSpeed) / layerSpacing) * 0.4 + 1.0;\n            \n            float contribution = carveIntensity * attenuation * falloff * expandingLayers * 0.06;\n            float smoke;\n            if (SMOKE>0){\n            vec3 sp = p;\n            sp+=1.;\n            sp.x+=iTime/10.;\n            sp*=10.;\n            if (SMOKE>1){\n            smoke = perlinNoise(sp, 1, (SMOKE*2)-2, 0.5, 2.0, 123456u);\n            }else{\n            smoke = perlinNoise(sp, 123456u);\n            }\n            smoke = (smoke + 1.0) * 0.5;\n            contribution*=smoke;\n            }\n            \n            volumetricColor += lightColor * contribution;\n        }\n        \n        t -= stepSize; // Move toward camera\n    }\n    if (SMOKE>0){\n    volumetricColor*=3.;\n    }\n    return volumetricColor;\n}\n\n\n// Get subsurface scattering color based on depth from center\nvec3 getSubsurfaceColor(float distFromCenter) {\n    // Interior glow color - warm candlelight\n    vec3 innerGlow = vec3(1.2, 0.8, 0.3);\n    \n    // Outer pumpkin color\n    vec3 outerColor = vec3(0.8, 0.35, 0.05);\n    \n    // Map distance to depth (0 = inside, 1 = outside surface)\n    float depth = (distFromCenter - 0.4) / 0.2; // 0.6 to 0.7 range\n    depth = clamp(depth, 0.0, 1.0);\n    \n    // Create gradient\n    vec3 subsurfaceColor = mix(innerGlow, outerColor, depth);\n    \n    // Add transmission falloff\n    float transmission = exp(-depth * 5.0);\n    \n    return subsurfaceColor * (0.5 + transmission * 0.5);\n}\n\n\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord, vec4 bg) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Static camera setup - moved pumpkin down slightly (compromise position)\n    vec3 ro = vec3(0.0, 0.1, -2.5);\n    vec3 rd = normalize(vec3(uv, 1.5));\n    \n    // Background\n    vec3 col = bg.rgb;\n    \n    // Raymarch solid surfaces\n    float t = raymarch(ro, rd);\n    \n    if (t < 10.0) {\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal(p);\n        float distFromCenter = length(p);\n        float carving = getCarvingDepth(p);\n        \n        // Check if we hit the flame\n        float flameDist = sdFlame(p);\n        float groundDist = sdGround(p);\n        bool isFlame = flameDist < 0.01 && sdSphere(p, 0.45) < 0.0;\n        bool isGround = groundDist < 0.01;\n        \n        if (isFlame) {\n            // Render flame\n            float flameIntensity = 1.0 - smoothstep(0.0, 0.04, flameDist);\n            float flicker = 0.8 + 0.2 * sin(iTime * 37.0) + 0.15 * sin(iTime * 19.0);\n            \n            // Flame color gradient from blue at base to yellow-orange at tip\n            float heightGradient = (p.y + 0.1) / 0.15;\n            vec3 flameColor = mix(\n                vec3(1.0, 0.9, 0.8),  // Blue base\n                vec3(0.3, 0.1, 0.0),  // Orange tip\n                heightGradient\n            );\n            \n            col = flameColor * flameIntensity * flicker * 3.0;\n        } else if (isGround) {\n            // Render ground\n            vec3 groundColor = vec3(0.3, 0.8, 0.3); // Dark earth tone\n            \n            // Key light - strong moonlight from above-behind-side\n            vec3 keyLightDir = normalize(vec3(-0.7, 1.2, -0.8));\n            vec3 keyLightColor = vec3(0.7, 0.8, 1.0) * 1.5;\n            \n            // Simple ground lighting\n            float keyDiff = max(dot(n, keyLightDir), 0.0);\n            vec3 keyDiffuse = groundColor * keyLightColor * keyDiff * 0.6;\n            \n            // Ambient for ground\n            vec3 ambient = groundColor * vec3(0.02, 0.03, 0.05);\n            \n            // Subtle glow from pumpkin onto ground\n            vec3 pumpkinPos = vec3(0.0, 0.0, 0.0);\n            float distToPumpkin = length(p - pumpkinPos);\n            float pumpkinGlow = exp(-distToPumpkin * 1.5) * 0.1;\n            vec3 pumpkinLightColor = vec3(1.0, 0.6, 0.2);\n            \n            col = ambient + keyDiffuse + pumpkinLightColor * pumpkinGlow;\n        } else {\n            // Enhanced lighting system with key light\n            vec3 candlePos = vec3(0.0, -0.3, 0.0);\n            vec3 candleLight = normalize(candlePos - p);\n            vec3 viewDir = normalize(ro - p);\n            \n            // Key light - strong moonlight from above-behind-side\n            vec3 keyLightDir = normalize(vec3(-0.7, 1.2, -0.8));;//normalize(vec3(0.5, 0.7, 2.5));\n            vec3 keyLightColor = vec3(0.8, 0.9, 1.0) * 1.5; // Cool blue moonlight\n            // Key light contribution\n            float keyDiff = max(dot(n, keyLightDir), 0.0);\n            // Flickering candle light intensity\n            float flicker = 0.8 + 0.07 * sin(iTime * 37.0) + 0.06 * sin(iTime * 19.0);\n            vec3 candleLightColor = vec3(1.2, 0.8, 0.4) * flicker;\n            \n            // Are we in a carved area?\n            if (carving > 0.6) {\n                // Enhanced subsurface scattering for carved areas\n                vec3 subsurfaceCol = getSubsurfaceColor(distFromCenter);\n                \n                // Distance-based light falloff\n                float lightDist = length(candlePos - p);\n                float attenuation = 1.5/ (2.0 + lightDist * 2.0);\n                \n                // Inner glow effect\n                float innerGlow = exp(-lightDist * 3.0);\n                \n                col = subsurfaceCol * candleLightColor * (attenuation + innerGlow * 1.5);\n                \n                // Enhanced rim lighting\n               // float rim = 2.0 - abs(dot(viewDir, n));\n                //col += candleLightColor * 4.8 * attenuation * flicker;\n                col*=1.2;\n            } else {\n                // Enhanced pumpkin surface material\n                vec3 pumpkinColor = vec3(0.9, 0.4, 0.05);\n               \n                // Add surface variation based on ridges\n                float angle = atan(p.z, p.x);\n                float ridgePhase = sin(angle * 12.0) * 0.4 + 0.5;\n                ridgePhase += ridgePhase-keyDiff; ridgePhase*=.55;\n                pumpkinColor *= 0.5 + candleLightColor * pow(ridgePhase, 8.);\n                pumpkinColor += (pumpkinColor*=pumpkinColor)/5.;\n                pumpkinColor +=  vec3(1.0, 0.3, 0.02); \n                \n                if(p.z>0.0){pumpkinColor *=1.3;} else { pumpkinColor *=0.5;}\n                // Stem coloring\n                if (p.y > 0.38) {\n                    pumpkinColor = mix(vec3(0.9, 0.4, 0.05), vec3(0.3, 0.5, 0.2), smoothstep(0.5, 0.7, p.y));\n                }\n                \n               \n                vec3 keyDiffuse = pumpkinColor * keyLightColor * keyDiff * 0.8;\n                \n                // Candle light contribution\n                float lightDist = length(candlePos - p);\n                float attenuation = 1.0 / (1.0 + lightDist * lightDist * 0.5);\n                float candleDiff = max(dot(n, candleLight), 0.0);\n                vec3 candleDiffuse = pumpkinColor * candleLightColor * candleDiff * attenuation * 0.6;\n                \n                // Ambient lighting\n                vec3 ambient = pumpkinColor * vec3(0.05, 0.08, 0.15);\n                \n                // Specular highlights from key light\n                vec3 keyHalfDir = normalize(keyLightDir + viewDir);\n                float keySpec = pow(max(dot(n, keyHalfDir), 0.0), 16.0);\n                vec3 keySpecular = keyLightColor * keySpec * 0.3;\n                \n                // Specular highlights from candle\n                vec3 candleHalfDir = normalize(candleLight + viewDir);\n                float candleSpec = pow(max(dot(n, candleHalfDir), 0.0), 8.0);\n                vec3 candleSpecular = candleLightColor * candleSpec * 0.3 * attenuation;\n                \n                col = ambient + keyDiffuse + candleDiffuse + keySpecular + candleSpecular;\n            }\n        }\n    }\n   \n   \n   sro=ro;\n   srd=rd;\n    \n    // Add UI buttons overlay\n    vec2 screenUV = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // UI button positions (moved further left)\n    vec2 buttonPos1 = vec2(-0.78, 0.42);   // Regular mode\n    vec2 buttonPos2 = vec2(-0.78, 0.31);   // Mirror mode  \n    vec2 buttonPos3 = vec2(-0.78, 0.20);   // Inverse mode\n    vec2 buttonPos4 = vec2(-0.78, 0.09);   // Mirror + Inverse mode\n    \n    // Read current mode state from BufferA\n    bool currentInverse = texelFetch(iChannel0, ivec2(38,0), 0).x > 0.5;\n    bool currentMirror = texelFetch(iChannel0, ivec2(39,0), 0).x > 0.5;\n    int currentMode = (currentMirror ? 2 : 0) + (currentInverse ? 1 : 0);\n    \n    // Read quality settings and brush size from BufferA and update global variables\n    AA = int(floor(texelFetch(iChannel0, ivec2(40,0), 0).x * 5.0));\n    VOLUMETRIC = int(floor(texelFetch(iChannel0, ivec2(41,0), 0).x * 5.0));\n    SMOKE = int(floor(texelFetch(iChannel0, ivec2(42,0), 0).x * 5.0));\n    \n    \n    float aaQuality = float(AA);\n    float volumetricQuality = float(VOLUMETRIC);\n    float smokeQuality = float(SMOKE);\n    float skiesQuality = float(SKIES);\n    float brushSize = 0.03 + texelFetch(iChannel0, ivec2(44,0), 0).x * (0.15 - 0.03);\n    \n    // Calculate FPS using stored frame timing data\n    //float currentTime = iTime;\n    //float lastFrameTime = texelFetch(iChannel0, ivec2(45,0), 0).x;\n    float deltaTime = texelFetch(iChannel0, ivec2(47,0), 0).x;\n    float fps = (deltaTime > 0.0) ? 1.0 / deltaTime : 60.0;\n    \n    // Quality slider positions (moved up from bottom)\n    vec2 aaSliderPos = vec2(0.71, -0.37);\n    vec2 volumetricSliderPos = vec2(0.76, -0.37);\n    vec2 smokeSliderPos = vec2(0.81, -0.37);\n    vec2 skiesSliderPos = vec2(0.86, -0.37);\n    \n    // Brush slider position (moved down by half its length)\n    vec2 brushSliderPos = vec2(-0.78, -0.155);\n    \n    // FPS indicator position (between original and current)\n    vec2 fpsPos = vec2(0.85, 0.465);\n    \n    // Draw mode buttons\n    vec3 btn1 = drawModeButton(screenUV, buttonPos1, false, false, currentMode == 0);\n    if (btn1.x >= 0.0) col = btn1;\n    \n    vec3 btn2 = drawModeButton(screenUV, buttonPos2, false, true, currentMode == 2);\n    if (btn2.x >= 0.0) col = btn2;\n    \n    vec3 btn3 = drawModeButton(screenUV, buttonPos3, true, false, currentMode == 1);\n    if (btn3.x >= 0.0) col = btn3;\n    \n    vec3 btn4 = drawModeButton(screenUV, buttonPos4, true, true, currentMode == 3);\n    if (btn4.x >= 0.0) col = btn4;\n    \n    // Draw quality sliders\n    vec3 aaSlider = drawQualitySlider(screenUV, aaSliderPos, aaQuality, false);\n    if (aaSlider.x >= 0.0) col = aaSlider;\n    \n    vec3 volumetricSlider = drawQualitySlider(screenUV, volumetricSliderPos, volumetricQuality, false);\n    if (volumetricSlider.x >= 0.0) col = volumetricSlider;\n    \n    vec3 smokeSlider = drawQualitySlider(screenUV, smokeSliderPos, smokeQuality, false);\n    if (smokeSlider.x >= 0.0) col = smokeSlider;\n    \n    vec3 skiesSlider = drawQualitySlider(screenUV, skiesSliderPos, skiesQuality, false);\n    if (skiesSlider.x >= 0.0) col = skiesSlider;\n    \n    // Draw brush slider\n    vec3 brushSlider = drawBrushSlider(screenUV, brushSliderPos, brushSize, false);\n    if (brushSlider.x >= 0.0) col = brushSlider;\n    \n    // Draw FPS indicator\n    vec3 fpsIndicator = drawFPSIndicator(screenUV, fpsPos, fps);\n    if (fpsIndicator.x >= 0.0) col = fpsIndicator;\n    \n    fragColor = vec4(col, 1.0);\n}\n\nvec4 mainImageBG(vec2 u) {\nSKIES = int(floor(texelFetch(iChannel0, ivec2(43,0), 0).x * 5.0));\n    float d, // total distance marched\n          n, // noise iterator\n          i, // raymarch iterator\n          s, // signed distance\n          t = iTime/6.;\n    vec3  p = iResolution;    \n    \n    // scale coords\n    u = -(u-p.xy/2.)/p.y;\n    \n    vec4 o = vec4(0);\n    for(; i++<float(SKIES)*24.;) {\n        \n        p = vec3(u*d,d+t);\n        \n        p.z *= .4;\n        \n        p.y += 4.;\n        \n        p.y += sin(.2*t+p.x*.2);\n\n        // noise loop start, march\n        for (n = .01; n < 1.+float(SKIES)/2.; n += n)\n            p += abs(dot(cos(p.x*.1 + p.z *.3+  t + p / n ), vec3(.33))) * n;\n            d += s = .2 + .7 * abs(p.y),\n            o += 1./s;\n        \n    }\n    o = vec4(0.2,0.2,0.3,0)*o/1e2;\n    o = max(o, vec4(0));\n    return o;\n}\n\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    vec4 b = mainImageBG(u);\n   \n    vec2 j = vec2(.5); \n    o = vec4(0);\n    vec4 c;\n    mainImage0(c, u, b); \n     float s = pow(2.,float(AA)), k;\n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5, b); \n        o+=c;\n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n    \n    // volumetric light after AA\n    if (VOLUMETRIC>0){\n    vec3 volumetricLight = renderVolumetricLayers(sro, srd, 1.99);\n    o.rgb += volumetricLight;\n    }\n    // gamma correction after AA\n       o.rgb = pow(o.rgb, vec3(0.6));\n       \n       //o= texture(iChannel0, u.xy/iResolution.xy, 0.);\n    \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "\nvoid draw( inout vec4 pre , in vec2 muv, in vec2 uv){\n// Static camera setup matching main image\n        vec3 ro = vec3(0.0, 0.1, -2.5);\n        vec3 rd = normalize(vec3(muv, 1.5));\n        \n        bool inverted = false;\n        bool mirrored = false;\n        \n        if(texture( iChannel0, vec2(38.5/iResolution.x, 0.5/iResolution.y)).x>0.5){inverted = true;}\n        if(texture( iChannel0, vec2(39.5/iResolution.x, 0.5/iResolution.y)).x>0.5){mirrored = true;}\n        \n        // Intersect ray with pumpkin shape (approximate with ellipsoid)\n        vec3 scale = vec3(1.0, 0.85, 1.0) * 0.6;\n        \n        // Transform ray to ellipsoid space\n        vec3 roScaled = ro / scale;\n        vec3 rdScaled = rd / scale;\n        \n        float a = dot(rdScaled, rdScaled);\n        float b = 2.0 * dot(roScaled, rdScaled);\n        float c = dot(roScaled, roScaled) - 1.0;\n        float discriminant = b*b - 4.0*a*c;\n        \n        if (discriminant > 0.0) {\n            float t = (-b - sqrt(discriminant)) / (2.0 * a);\n            if (t > 0.0) {\n                vec3 hitPoint = (ro + rd * t);\n                \n                // Convert hit point to spherical coordinates\n                vec3 np = normalize(hitPoint);\n                float hitTheta = atan(np.z, np.x);\n                float hitPhi = acos(clamp(np.y, -1.0, 1.0));\n                \n                // Current texel in spherical coords\n                float texTheta = uv.x * 2.0 * 3.14159 - 3.14159;\n                float texPhi = (1.0 - uv.y) * 3.14159;\n                \n                // Calculate angular distance with better accuracy\n                vec3 p1 = vec3(sin(texPhi) * cos(texTheta), cos(texPhi), sin(texPhi) * sin(texTheta));\n                vec3 p2 = vec3(sin(hitPhi) * cos(hitTheta), cos(hitPhi), sin(hitPhi) * sin(hitTheta));\n                \n                float dist = acos(clamp(dot(p1, p2), -1.0, 1.0));\n                \n                // Enhanced brush system with pressure sensitivity\n                float brushSize = 0.03 + texture(iChannel0, vec2(44.5/iResolution.x, 0.5/iResolution.y)).x * (0.15 - 0.03);\n                \n                if (dist < brushSize) {\n                    // Smooth falloff for natural carving\n                    float falloff = inverted ? smoothstep(0.0, brushSize, dist) : 1.0 - smoothstep(0.0, brushSize, dist);\n                    float newCarve = falloff;\n                    \n                    // Blend with existing carving\n                    // Normal mode: max (additive carving), Inverse mode: min (subtractive carving)\n                    pre.r = inverted ? min(pre.r, newCarve) : max(pre.r, newCarve);\n                }\n            }\n        }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 screenUV = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec4 prev = texture(iChannel0, uv);\n    \n    // UI button positions (moved further left)\n    vec2 buttonPos1 = vec2(-0.78, 0.42);   // Regular mode\n    vec2 buttonPos2 = vec2(-0.78, 0.31);   // Mirror mode  \n    vec2 buttonPos3 = vec2(-0.78, 0.20);   // Inverse mode\n    vec2 buttonPos4 = vec2(-0.78, 0.09);   // Mirror + Inverse mode\n    \n    // Read current mode state from previous frame\n    bool currentInverse = texture(iChannel0, vec2(38.5/iResolution.x, 0.5/iResolution.y)).x > 0.5;\n    bool currentMirror = texture(iChannel0, vec2(39.5/iResolution.x, 0.5/iResolution.y)).x > 0.5;\n    \n    // Quality slider positions (moved up from bottom)\n    vec2 aaSliderPos = vec2(0.71, -0.37);\n    vec2 volumetricSliderPos = vec2(0.76, -0.37);\n    vec2 smokeSliderPos = vec2(0.81, -0.37);\n    vec2 skiesSliderPos = vec2(0.86, -0.37);\n    \n    // Brush slider position (moved down by half its length)\n    vec2 brushSliderPos = vec2(-0.78, -0.155);\n    \n    // Handle button clicks\n    bool buttonClicked = false;\n    if (iMouse.z > 0.0) {\n        vec2 mouseScreen = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n        \n        // Check button clicks first (using smaller button size)\n        if (length(mouseScreen - buttonPos1) < 0.048) {\n            // Regular mode: mirror=false, inverse=false\n            buttonClicked = true;\n            if (ivec2(fragCoord) == ivec2(38,0)) prev.r = 0.0; // inverse = false\n            if (ivec2(fragCoord) == ivec2(39,0)) prev.r = 0.0; // mirror = false\n        }\n        else if (length(mouseScreen - buttonPos2) < 0.048) {\n            // Mirror mode: mirror=true, inverse=false  \n            buttonClicked = true;\n            if (ivec2(fragCoord) == ivec2(38,0)) prev.r = 0.0; // inverse = false\n            if (ivec2(fragCoord) == ivec2(39,0)) prev.r = 1.0; // mirror = true\n        }\n        else if (length(mouseScreen - buttonPos3) < 0.048) {\n            // Inverse mode: mirror=false, inverse=true\n            buttonClicked = true;\n            if (ivec2(fragCoord) == ivec2(38,0)) prev.r = 1.0; // inverse = true\n            if (ivec2(fragCoord) == ivec2(39,0)) prev.r = 0.0; // mirror = false\n        }\n        else if (length(mouseScreen - buttonPos4) < 0.048) {\n            // Mirror + Inverse mode: mirror=true, inverse=true\n            buttonClicked = true;\n            if (ivec2(fragCoord) == ivec2(38,0)) prev.r = 1.0; // inverse = true\n            if (ivec2(fragCoord) == ivec2(39,0)) prev.r = 1.0; // mirror = true\n        }\n        \n        // Check for slider interactions\n        else if (abs(mouseScreen.x - aaSliderPos.x) < 0.02 && abs(mouseScreen.y - aaSliderPos.y) < 0.08) {\n            // AA Quality slider\n            buttonClicked = true;\n            float sliderValue = clamp((mouseScreen.y - aaSliderPos.y + 0.08) / 0.16, 0.0, 1.0);\n            if (ivec2(fragCoord) == ivec2(40,0)) prev.r = sliderValue;\n        }\n        else if (abs(mouseScreen.x - volumetricSliderPos.x) < 0.02 && abs(mouseScreen.y - volumetricSliderPos.y) < 0.08) {\n            // Volumetric Quality slider\n            buttonClicked = true;\n            float sliderValue = clamp((mouseScreen.y - volumetricSliderPos.y + 0.08) / 0.16, 0.0, 1.0);\n            if (ivec2(fragCoord) == ivec2(41,0)) prev.r = sliderValue;\n        }\n        else if (abs(mouseScreen.x - smokeSliderPos.x) < 0.02 && abs(mouseScreen.y - smokeSliderPos.y) < 0.08) {\n            // Smoke Quality slider\n            buttonClicked = true;\n            float sliderValue = clamp((mouseScreen.y - smokeSliderPos.y + 0.08) / 0.16, 0.0, 1.0);\n            if (ivec2(fragCoord) == ivec2(42,0)) prev.r = sliderValue;\n        }\n        else if (abs(mouseScreen.x - skiesSliderPos.x) < 0.02 && abs(mouseScreen.y - skiesSliderPos.y) < 0.08) {\n            // Skies Quality slider\n            buttonClicked = true;\n            float sliderValue = clamp((mouseScreen.y - skiesSliderPos.y + 0.08) / 0.16, 0.0, 1.0);\n            if (ivec2(fragCoord) == ivec2(43,0)) prev.r = sliderValue;\n        }\n        else if (abs(mouseScreen.x - brushSliderPos.x) < 0.04 && abs(mouseScreen.y - brushSliderPos.y) < 0.18) {\n            // Brush size slider (bigger hit area)\n            buttonClicked = true;\n            float sliderValue = clamp((mouseScreen.y - brushSliderPos.y + 0.15) / 0.3, 0.0, 1.0);\n            if (ivec2(fragCoord) == ivec2(44,0)) prev.r = sliderValue;\n        }\n        \n        // Only do pumpkin carving if no button or slider was clicked\n        if (!buttonClicked) {\n            vec2 mouseUV = mouseScreen;\n            \n            // Use current brush size for carving\n            float currentBrushSize = 0.03 + texture(iChannel0, vec2(44.5/iResolution.x, 0.5/iResolution.y)).x * (0.15 - 0.03);\n            draw(prev, mouseUV, uv);\n            \n            // Apply mirroring if enabled\n            if(currentMirror){\n                mouseUV.x = -mouseUV.x;\n                draw(prev, mouseUV, uv);\n            }\n        }\n    }\n    \n    // Note: UI rendering moved to main image shader\n    // BufferA only handles button interaction logic and data storage\n    \n    // FPS calculation - update timing data\n    if (ivec2(fragCoord) == ivec2(45,0)) {\n        // Store current time in pixel 45\n        prev.r = iTime;\n    }\n    else if (ivec2(fragCoord) == ivec2(46,0)) {\n        // Calculate and store delta time in pixel 46\n        float currentTime = iTime;\n        float lastFrameTime = texture(iChannel0, vec2(45.5/iResolution.x, 0.5/iResolution.y)).x;\n        float deltaTime = currentTime - lastFrameTime;\n        prev.r = deltaTime;\n    }else if (ivec2(fragCoord) == ivec2(47,0)) {\n        // Calculate and store delta time in pixel 46\n        float currentTime = iTime;\n        float lastFrameTime = texture(iChannel0, vec2(45.5/iResolution.x, 0.5/iResolution.y)).x;\n        float deltaTime = currentTime - lastFrameTime;\n        float lastDelta = texture(iChannel0, vec2(46.5/iResolution.x, 0.5/iResolution.y)).x;\n        float lastDeltab = texture(iChannel0, vec2(47.5/iResolution.x, 0.5/iResolution.y)).x;\n        prev.r = lastDeltab - (lastDeltab - lastDelta)/15.;\n    }\n    \n    // Clear on rewind - initialize default state\n    if (iFrame < 2) {\n        prev = vec4(0.0);\n        // Set default mode (regular: no mirror, no inverse)\n        if (ivec2(fragCoord) == ivec2(38,0)) prev.r = 0.0; // inverse = false\n        if (ivec2(fragCoord) == ivec2(39,0)) prev.r = 0.0; // mirror = false\n        \n        // Set default quality values (matching original defines)\n        if (ivec2(fragCoord) == ivec2(40,0)) prev.r = 0.0 / 4.0; // AA = 0\n        if (ivec2(fragCoord) == ivec2(41,0)) prev.r = 2.0 / 4.0; // VOLUMETRIC = 2\n        if (ivec2(fragCoord) == ivec2(42,0)) prev.r = 2.0 / 4.0; // SMOKE = 2\n        if (ivec2(fragCoord) == ivec2(43,0)) prev.r = 2.0 / 4.0; // SKIES = 2\n        \n        // Set default brush size (0.09 normalized to 0-1 range)\n        if (ivec2(fragCoord) == ivec2(44,0)) prev.r = (0.09 - 0.03) / (0.15 - 0.03); // Default brush size\n        \n        // Initialize timing data\n        if (ivec2(fragCoord) == ivec2(45,0)) prev.r = iTime; // Current time\n        if (ivec2(fragCoord) == ivec2(46,0)) prev.r = 1.0/60.0; // Initial delta time (60 FPS)\n        if (ivec2(fragCoord) == ivec2(47,0)) prev.r = 1.0/60.0; // Initial delta time (60 FPS)\n    }\n    \n    fragColor = prev;\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wclBW7",
    "date": "1757700769",
    "viewed": 11,
    "name": "Pumpkin of Discord",
    "description": ":D",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "raymarch",
     "sdf",
     "halloween",
     "pumpkin",
     "october"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Pumpkin Carver WIP\" by Cotterzz. https://shadertoy.com/view/WfffR8\n// 2025-09-12 18:11:50\n\n// Quality numbers, 0 is off, 1 is low, 2 is medium, 3 is high, 4 is ultra\n\n#define AA 0\n#define VOLUMETRIC 3\n#define SMOKE 2\n#define SKIES 1\n\n// These settings run at 25-30fps on intel 630 at 630x354\n// Setting SMOKE to 0 will also give faster compile time when testing, esp on windows/angle/directx)\n\n\n\n// ---- Fast Improved Perlin Noise by TheTurk: https://www.shadertoy.com/view/slB3z3\n\nuint hash(uint x, uint seed) {\n    const uint m = 0x5bd1e995U;uint h = seed;uint k = x;k *= m;k ^= k >> 24;\n    k *= m;h *= m;h ^= k;h ^= h >> 13;h *= m;h ^= h >> 15;return h;\n}\n\nuint hash(uvec3 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint h = seed;uint k = x.x; \n    k *= m;k ^= k >> 24;k *= m;h *= m;h ^= k;\n    k = x.y;k *= m;k ^= k >> 24;k *= m;h *= m;h ^= k;\n    k = x.z;k *= m;k ^= k >> 24;k *= m;h *= m;h ^= k;\n    h ^= h >> 13;h *= m;h ^= h >> 15;\n    return h;\n}\n\nvec3 gradientDirection(uint hash) {\n    vec3 r = vec3(0,1,-1);switch (int(hash) & 15) {\n    case 0:return r.yyx;case 1:return r.zxy;\n    case 2:return r.yzx;case 3:return r.zzx;\n    case 4:return r.yyx;case 5:return r.zxy;\n    case 6:return r.yxz;case 7:return r.zxz;\n    case 8:return r.xyy;case 9:return r.xzy;\n    case 10:return r.xzz;case 11:return r.xyz;\n    case 12:return r.yyx;case 13:return r.zxy;\n    case 14:return r.xzy;case 15:return r.xzz;\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, float value5, float value6, float value7, float value8, vec3 t) {\n    return mix(mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y),mix(mix(value5, value6, t.x), mix(value7, value8, t.x), t.y), t.z);\n}\n\nvec3 fade(vec3 t) {return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);}\n\nfloat perlinNoise(vec3 position, uint seed) {\n    vec3 floorPosition = floor(position);\n    vec3 fractPosition = position - floorPosition;\n    uvec3 cellCoordinates = uvec3(floorPosition);\n    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 0)), seed)), fractPosition - vec3(1, 0, 0));\n    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 0)), seed)), fractPosition - vec3(0, 1, 0));\n    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 0)), seed)), fractPosition - vec3(1, 1, 0));\n    float value5 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 0, 1)), seed)), fractPosition - vec3(0, 0, 1));\n    float value6 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 1)), seed)), fractPosition - vec3(1, 0, 1));\n    float value7 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 1)), seed)), fractPosition - vec3(0, 1, 1));\n    float value8 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 1)), seed)), fractPosition - vec3(1, 1, 1));\n    return interpolate(value1, value2, value3, value4, value5, value6, value7, value8, fade(fractPosition));\n}\n\nfloat perlinNoise(vec3 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;float amplitude = 1.0;float currentFrequency = float(frequency);uint currentSeed = seed;\n    for (int i = 0; i < octaveCount; i++) {\n        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;currentFrequency *= lacunarity;\n    }\n    return value;\n}\n\n\n// --- Main Shader Code by Cotterzz\n\n// store rd and ro for volumetric without AA\nvec3 sro;\nvec3 srd;\n\n// Sample the carving texture\nfloat getCarvingDepth(vec3 p) {\n    vec3 np = normalize(p);\n    float theta = atan(np.z, np.x);\n    float phi = acos(clamp(np.y, -1.0, 1.0));\n    \n    vec2 uv;\n    uv.x = (theta + 3.14159) / (2.0 * 3.14159);\n    uv.y = 1.0 - phi / 3.14159;\n    \n    return texture(iChannel1, uv+vec2(0.19,0)).r;\n}\n\n// Utility functions\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec2 fold(vec2 p,float s){float a=3.142/s-atan(p.x,p.y),n=6.283/s;p*=rot(floor(a/n)*n);return p;}\nfloat sminCubic(float a,float b,float k){float h=max(k-abs(a-b),0.)/k;return min(a,b)-h*h*h*k*(1./6.);}\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// SDF functions\nfloat sdTorus(vec3 p,vec2 t){return length(vec2(length(p.yz)-t.x,p.x))-t.y;}\nfloat sdCube(vec3 p){vec3 q=abs(p)-.5;return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);}\nfloat sdCappedCylinder(vec3 p,float h,float r){vec2 d=abs(vec2(length(p.xz),p.y))-vec2(h,r);return min(max(d.x,d.y),0.)+length(max(d,0.));}\nfloat sdEllipsoid(vec3 p, vec3 r) {\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// Realistic pumpkin shape with ridges\nfloat sdPumpkin(vec3 p, float r) {\n    // Main pumpkin body - flattened sphere\n    vec3 bodyScale = vec3(1.0, 0.8, 1.0);\n    float body = sdEllipsoid(p, bodyScale * r);\n    \n    // Add vertical ridges\n    float angle = atan(p.z, p.x);\n    float ridgeCount = 12.0;\n    float ridgePhase = sin(angle * ridgeCount) * 0.15;\n    \n    // Modulate the ridges based on height\n    float heightFactor = smoothstep(-0.6, 0.4, p.y);\n    ridgePhase *= heightFactor;\n    \n    body += ridgePhase * r * 0.1;\n    \n    // Add slight indentation at top and bottom\n    float topIndent = smoothstep(0.3, 0.5, p.y) * 0.04 * r;\n    float bottomIndent = smoothstep(-0.5, -0.3, p.y) * 0.03 * r;\n    \n    return body+ topIndent + bottomIndent;\n}\n\n// Pumpkin stem\nfloat sdStem(vec3 p) {\n    vec3 stemPos = p - vec3(0.0, 0.45, 0.0);\n    \n    // Curved stem\n    stemPos.x += sin(stemPos.y * 3.0) * 0.1;\n    stemPos.z += cos(stemPos.y * 2.5) * 0.08;\n    \n    float stem = sdCappedCylinder(stemPos, 0.05, 0.19);\n    \n    // Add some bumps to the stem\n    float noise = sin(stemPos.y * 15.0) * sin(stemPos.x * 20.0) * 0.01;\n    return stem + noise;\n}\n\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\n\n// Main pumpkin SDF (solid shell only)\nfloat map(vec3 p) {\n    float outer = sdPumpkin(p, 0.6);\n    float inner = sdSphere(p, 0.5);\n    float shell = max(outer, -inner);\n    \n    // Enhanced carving system - subtract carved areas\n    float carving = getCarvingDepth(p);\n    if (carving > 0.3) {\n        float carveIntensity = smoothstep(0.3, 1.0, carving);\n        float expandedInner = sdSphere(p, 0.5 + carveIntensity * 0.2);\n        shell = max(shell, -expandedInner);\n    }\n    \n    // Add stem\n    float stem = sdStem(p);\n    shell = smin(shell, stem, 0.02);\n    \n    return shell;\n}\n\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\n// Simple raymarch\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    \n    for (int i = 0; i < 200; i++) {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        \n        if (abs(d) < 0.0001) return t;\n        if (t > 10.0) break;\n        \n        t += d * 0.4;\n    }\n    return t;\n}\n\n// Simple volumetric light extending from pumpkin surface\nvec3 renderVolumetricLayers(vec3 ro, vec3 rd, float startDist) {\n    vec3 volumetricColor = vec3(0.0);\n    \n    // Candle light properties\n    vec3 candlePos = vec3(0.0, -0.1, 0.0);\n    float flicker = 0.7 + 0.07 * sin(iTime*19.) + 0.06 * sin(iTime * 37.);\n    vec3 lightColor = vec3(1.5, 1.0, 0.5) * flicker;\n    \n    // Start from pumpkin surface and extend toward camera\n    const int numSteps = VOLUMETRIC * 12;\n    float maxDist = 0.3 + float(VOLUMETRIC)*0.3;\n    float stepSize = maxDist / float(numSteps);\n    \n    // Go FROM surface TOWARD camera (negative direction)\n    float t = startDist - 0.02;\n    \n    for (int i = 0; i < numSteps; i++) {\n        //if (t <= 0.0) break; // Don't go behind camera\n        \n        vec3 p = ro + rd * t;\n        float carving = getCarvingDepth(p);\n        \n        if (carving > 0.3) {\n            float carveIntensity = smoothstep(0.3, 1.0, carving);\n            \n            float distToCandle = length(p - candlePos);\n            float attenuation = 1.0 / (1.0 + distToCandle * distToCandle * 0.8);\n            \n            // Distance from surface (how far light has traveled)\n            float distanceFromSurface = startDist - t;\n            float falloff = exp(-distanceFromSurface * 1.5);\n            \n            // Layer effect - expanding shells that move outward\n            float layerSpeed = 2.0;\n            float layerSpacing = 0.3;\n            float expandingLayers = sin((distanceFromSurface - iTime * layerSpeed) / layerSpacing) * 0.4 + 1.0;\n            \n            float contribution = carveIntensity * attenuation * falloff * expandingLayers * 0.06;\n            \n            #if SMOKE>0\n            vec3 sp = p;\n            sp+=1.;\n            sp.x+=iTime/10.;\n            sp*=10.;\n            #if SMOKE>1\n            float smoke = perlinNoise(sp, 1, (SMOKE*2)-2, 0.5, 2.0, 123456u);\n            #else\n            float smoke = perlinNoise(sp, 123456u);\n            #endif\n            smoke = (smoke + 1.0) * 0.5;\n            contribution*=smoke;\n            #endif\n            \n            volumetricColor += lightColor * contribution;\n        }\n        \n        t -= stepSize; // Move toward camera\n    }\n    #if SMOKE>0\n    volumetricColor*=3.;\n    #endif\n    return volumetricColor;\n}\n\n\n// Get subsurface scattering color based on depth from center\nvec3 getSubsurfaceColor(float distFromCenter) {\n    // Interior glow color - warm candlelight\n    vec3 innerGlow = vec3(1.2, 0.8, 0.3);\n    \n    // Outer pumpkin color\n    vec3 outerColor = vec3(0.8, 0.35, 0.05);\n    \n    // Map distance to depth (0 = inside, 1 = outside surface)\n    float depth = (distFromCenter - 0.4) / 0.2; // 0.6 to 0.7 range\n    depth = clamp(depth, 0.0, 1.0);\n    \n    // Create gradient\n    vec3 subsurfaceColor = mix(innerGlow, outerColor, depth);\n    \n    // Add transmission falloff\n    float transmission = exp(-depth * 5.0);\n    \n    return subsurfaceColor * (0.5 + transmission * 0.5);\n}\n\n// Animated candle flame - not used currently\nvec3 getCandleFlame(vec3 p, float time) {\n    vec3 flamePos = p - vec3(0.0, -0.1, 0.0);\n    \n    // Flame shape - teardrop\n    float flameHeight = 0.4;\n    float flameWidth = 0.12;\n    \n    // Add flickering animation\n    float flicker = sin(time * 19.0) * 0.1 + sin(time * 37.0) * 0.05;\n    flamePos.y += flicker;\n    flamePos.x += sin(time * 12.0) * 0.02;\n    \n    // Flame SDF\n    float flame = length(vec2(length(flamePos.xz) - flameWidth * (1.0 - flamePos.y/flameHeight), \n                             flamePos.y)) - flameWidth;\n    flame = max(flame, -flamePos.y);\n    flame = max(flame, flamePos.y - flameHeight);\n    \n    return vec3(flame);\n}\n\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord, vec4 bg) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Static camera setup\n    vec3 ro = vec3(0.0, 0.0, -2.5);\n    vec3 rd = normalize(vec3(uv, 1.5));\n    \n    // Background\n    vec3 col = bg.rgb;\n    \n    // Raymarch solid surfaces\n    float t = raymarch(ro, rd);\n    \n    if (t < 10.0) {\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal(p);\n        float distFromCenter = length(p);\n        float carving = getCarvingDepth(p);\n        \n        // Enhanced lighting system\n        vec3 candlePos = vec3(0.0, -0.1, 0.0);\n        vec3 candleLight = normalize(candlePos - p);\n        vec3 viewDir = normalize(ro - p);\n        \n        // Flickering candle light intensity\n        float flicker = 0.8 + 0.07 * sin(iTime * 19.0) + 0.06 * sin(iTime * 37.0);\n        vec3 lightColor = vec3(1.2, 0.8, 0.4) * flicker;\n        \n        // Are we in a carved area?\n        if (carving > 0.35) {\n            // Enhanced subsurface scattering for carved areas\n            vec3 subsurfaceCol = getSubsurfaceColor(distFromCenter);\n            \n            // Distance-based light falloff\n            float lightDist = length(candlePos - p);\n            float attenuation = 1.0 / (1.0 + lightDist * lightDist * 2.0);\n            \n            // Inner glow effect\n            float innerGlow = exp(-lightDist * 3.0);\n            \n            col = subsurfaceCol * lightColor * (attenuation + innerGlow * 0.5);\n            \n            // Enhanced rim lighting\n            float rim = 1.0 - abs(dot(viewDir, n));\n            col += lightColor * pow(rim, 1.5) * 3.8 * attenuation *flicker;\n            \n        } else {\n            // Enhanced pumpkin surface material\n            vec3 pumpkinColor = vec3(0.9, 0.4, 0.05);\n            \n            // Add surface variation based on ridges\n            float angle = atan(p.z, p.x);\n            float ridgePhase = sin(angle * 12.0) * 0.4 + 0.5;\n            pumpkinColor *= 0.9 + lightColor*pow(ridgePhase, 5.);\n            \n            // Stem coloring\n            if (p.y > 0.38) {\n                pumpkinColor = mix(vec3(0.9, 0.4, 0.05), vec3(0.3, 0.5, 0.2), smoothstep(0.5, 0.7, p.y));\n            }\n            \n            // Enhanced lighting calculation\n            float lightDist = length(candlePos - p);\n            float attenuation = 1.0 / (1.0 + lightDist * lightDist * 0.5);\n            \n            float diff = max(dot(n, candleLight), 0.0);\n            vec3 diffuse = pumpkinColor * lightColor * diff * attenuation;\n            \n            // Ambient lighting\n            vec3 ambient = pumpkinColor * vec3(0.1, 0.15, 0.2);\n            \n            // Specular highlights\n            vec3 halfDir = normalize(candleLight + viewDir);\n            float spec = pow(max(dot(n, halfDir), 0.0), 16.0);\n            vec3 specular = lightColor * spec * 0.3 * attenuation;\n            \n            col = ambient + diffuse + specular;\n            \n            // Darken near carved edges for depth\n            //if (carving > 0.05) {\n                //float edgeFactor = smoothstep(0.05, 0.4, carving);\n               //col *= (1.0 + edgeFactor * 1.5);\n            //}\n        }\n    }\n   \n   \n   sro=ro;\n   srd=rd;\n    \n    fragColor = vec4(col, 1.0);\n}\n\nvec4 mainImageBG(vec2 u) {\n\n    float d, // total distance marched\n          n, // noise iterator\n          i, // raymarch iterator\n          s, // signed distance\n          t = iTime/6.;\n    vec3  p = iResolution;    \n    \n    // scale coords\n    u = -(u-p.xy/2.)/p.y;\n    \n    vec4 o = vec4(0);\n    for(; i++<float(SKIES)*24.;) {\n        \n        p = vec3(u*d,d+t);\n        \n        p.z *= .4;\n        \n        p.y += 4.;\n        \n        p.y += sin(.2*t+p.x*.2);\n\n        // noise loop start, march\n        for (n = .01; n < 1.+float(SKIES)/2.; n += n)\n            p += abs(dot(cos(p.x*.1 + p.z *.3+  t + p / n ), vec3(.33))) * n;\n            d += s = .2 + .7 * abs(p.y),\n            o += 1./s;\n        \n    }\n    o = vec4(0.25,0.2,0.5,0)*o/1e2;\n    o = max(o, vec4(0));\n    return o;\n}\n\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    vec4 b = mainImageBG(u);\n    float s = pow(2.,float(AA)), k;\n    vec2 j = vec2(.5); \n    o = vec4(0);\n    vec4 c;\n    mainImage0(c, u, b); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5, b); \n        o+=c;\n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n    \n    // volumetric light after AA\n    #if VOLUMETRIC>0\n    vec3 volumetricLight = renderVolumetricLayers(sro, srd, 1.99);\n    o.rgb += volumetricLight;\n    #endif\n    // gamma correction after AA\n       o.rgb = pow(o.rgb, vec3(0.4545));\n       \n       //o= texture(iChannel0, u.xy/iResolution.xy, 0.);\n    \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 prev = texture(iChannel0, uv);\n    \n    // Enhanced mouse drawing with better ray-pumpkin intersection\n    if (iMouse.z > 0.0) {\n        vec2 mouseUV = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n        \n        // Static camera setup matching main image\n        vec3 ro = vec3(0.0, 0.0, -2.5);\n        vec3 rd = normalize(vec3(mouseUV, 1.5));\n        \n        // Intersect ray with pumpkin shape (approximate with ellipsoid)\n        vec3 scale = vec3(1.0, 0.8, 1.0) * 0.6;\n        \n        // Transform ray to ellipsoid space\n        vec3 roScaled = ro / scale;\n        vec3 rdScaled = rd / scale;\n        \n        float a = dot(rdScaled, rdScaled);\n        float b = 2.0 * dot(roScaled, rdScaled);\n        float c = dot(roScaled, roScaled) - 1.0;\n        float discriminant = b*b - 4.0*a*c;\n        \n        if (discriminant > 0.0) {\n            float t = (-b - sqrt(discriminant)) / (2.0 * a);\n            if (t > 0.0) {\n                vec3 hitPoint = (ro + rd * t);\n                \n                // Convert hit point to spherical coordinates\n                vec3 np = normalize(hitPoint);\n                float hitTheta = atan(np.z, np.x);\n                float hitPhi = acos(clamp(np.y, -1.0, 1.0));\n                \n                // Current texel in spherical coords\n                float texTheta = uv.x * 2.0 * 3.14159 - 3.14159;\n                float texPhi = (1.0 - uv.y) * 3.14159;\n                \n                // Calculate angular distance with better accuracy\n                vec3 p1 = vec3(sin(texPhi) * cos(texTheta), cos(texPhi), sin(texPhi) * sin(texTheta));\n                vec3 p2 = vec3(sin(hitPhi) * cos(hitTheta), cos(hitPhi), sin(hitPhi) * sin(hitTheta));\n                \n                float dist = acos(clamp(dot(p1, p2), -1.0, 1.0));\n                \n                // Enhanced brush system with pressure sensitivity\n                float brushSize = 0.08;\n                \n                if (dist < brushSize) {\n                    // Smooth falloff for natural carving\n                    float falloff = 1.0 - smoothstep(0.0, brushSize, dist);\n                    float newCarve = falloff;\n                    \n                    // Blend with existing carving\n                    prev.r = max(prev.r, newCarve);\n                    \n                }\n            }\n        }\n    }\n    \n    // Clear on rewind\n    if (iFrame < 2) {\n        prev = vec4(0.0);\n    }\n    \n    fragColor = prev;\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "float sdEllipse(vec2 p, vec2 r)\n{\n    float f = length(p / r),\n          g = length(p / r / r);\n    \n    return f * (f - 1.) / g;\n}\n\nfloat sdDiscord(vec2 p)\n{\n    p.x = abs(p.x);\n    \n    float d = length(p + vec2(0, .52)) - .91;\n          d = max(d, length(p - vec2(0, .41)) - .83);\n          d = max(d, length(p - vec2(.82, .09)) - .74);\n          d = max(d, min(.54 - length(p - vec2(0, .21)), \n                         -(.81 * p.x + p.y + .01) / length(vec2(.81, 1))));\n          d = min(d, max(length(p - vec2(0, .3)) - .59,\n                         length(p + vec2(0, .36)) - .7));\n          d = max(d, length(p + vec2(.34, .16)) - .84);\n          d = max(d, -sdEllipse(p - vec2(.165, -.038), vec2(.09, .1)));\n    \n    return d;\n}\n\nfloat helper(float x, float a, float b, float c, float d, float m, float n)\n{\n    float x2 = x * x, x3 = x2 * x;\n    return (a * x3 + b * x2 + c * x + d) / (x2 + m * x + n);\n}\n\nvec2 rotate(vec2 p, float a) \n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a)) * p;\n}\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    vec2 p = (I + I - iResolution.xy) / iResolution.y;\n    p*=2.5;\n    float r1 = .5, r2 = .351;\n    \n    float t = fract(iTime + texelFetch(iChannel0, ivec2(I) % 1024, 0).x / 48.);\n    \n    float k = t * (t - 1.), k2 = k * k;\n    \n    float s1 = k2 * helper(t, 18.69441, -38.86151, 23.25180, -3.53363, -1.27120, 0.535271) + 1.;\n    float s2 = k2 * helper(t, 10.50167, -22.56208, 13.91412, -2.31023, -1.07310, 0.364973) + 1.;\n    float s3 = k2 * helper(t, 21.72620, -40.39696, 22.28075, -3.43598, -1.22944, 0.605636) + 1.;\n    \n    float a1 = t * (k * helper(t, -0.668041,  1.870240, -2.58381, 0.798835, -1.029650, 0.321038) + t);\n    float a2 = t * (k * helper(t,  0.274534, -0.241024, -1.22258, 0.473114, -0.881859, 0.239837) + t);\n    float a3 = t * (k * helper(t, -2.536390,  5.595520, -4.82078, 1.054856, -0.926966, 0.280363) + t);\n    \n    a1 = mix(a1, a2, smoothstep(.15, .25, abs(t - .47)));\n    a3 = mix(a3, a2, smoothstep(.15, .25, abs(t - .47)));\n    \n    vec2 p1 = rotate(p, radians(360. * a1)) / s1;\n    vec2 p2 = rotate(p, radians(360. * a2)) / s2;\n    vec2 p3 = rotate(p, radians(360. * a3)) / s3;\n    \n    float d1 = max(sdDiscord(p1), r1 - length(p1)) * s1;\n    float d2 = max(sdDiscord(p2), max(length(p2) - r1, r2 - length(p2))) * s2;\n    float d3 = max(sdDiscord(p3), length(p3) - r2) * s3;\n    \n    float d = (abs(t - .46) < .39 ? min(min(d1, d2), d3) : sdDiscord(p2) * s2) * iResolution.y;\n    \n    O = vec4(mix(vec3(1), vec3(28, 29, 35) / 255., smoothstep(-1., 1., d)), 1);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wflfzB",
    "date": "1757789959",
    "viewed": 18,
    "name": "Pumpkin Carver 2.0",
    "description": "This is a fork of P-Malin's amazing [url=https://shadertoy.com/view/MdBXR3]Jack-o'-lantern[/url]\nAfter [url=https://shadertoy.com/view/WfffR8]version 1[/url], I wanted to test a different approach to the carving using a better scene with convincing SSS",
    "likes": 1,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "fork",
     "halloween",
     "drawing",
     "pumpkin",
     "carving",
     "october",
     "jackolantern"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGRn",
       "filepath": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGRn",
       "filepath": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Jack-o'-lantern\" by P_Malin. https://shadertoy.com/view/MdBXR3\n// and \"Texture Drawing SDF\" by Cotterzz. https://shadertoy.com/view/3cfBzj\n// and \"Pumpkin Carver 1.0\" by Cotterzz. https://shadertoy.com/view/WfffR8\n\n// This is a much simpler shader without all the bells and whistles of the first one.\n// But I though it worked really well keeping it simple like this.\n\n// Instead of using a texture to displace an SDF and then subtracting it.\n// Using 2D SDF extrusion is a lot cleaner. (P_Malin's original shader already used this technique to cut out the face.)\n// All I needed to do was convert a brush-drawn texture into 2D SDF first, then I could still use a drawing texture like before.\n// Luckily there is a quick hack for this - comparing minimum distance with mouse position to effectively draw an SDF.\n// It's very crude, but for a single path it does a near perfect job in the positive distance.\n// And is drawn for very little performance cost in real time, so no conversion passes.\n\n#define kRaymarchMaxIter 64\n\n#define kBounceCount 1\n\nfloat kFarClip=100.0;\n\nvec2 GetWindowCoord( const in vec2 vUV );\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget );\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir );\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput );\n\nfloat GetCarving2dDistance(const in vec2 vPos );\n\nvec3 vLightPos = vec3(0.0,0.0, 0.5);\t\t\t\nvec3 vLightColour = vec3(1.0, 0.8, 0.4);\n\nfloat fCarving = 1.0;\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n\n    vLightColour *= hash(iTime) * 0.2 + 0.8;\n    \n    float fDist = 5.5;\n    float fAngle = 3.141;\n    float fHeight = 1.0;\n    \n    if(iTime < 1.5)\n    {\n        fDist += pow(abs(iTime - 1.5), 3.);\n    }\n        if(iTime < 3.)\n    {\n        fHeight += pow(abs(iTime -3.), 2.)/5.;\n    }\n    \n\tvec2 vMouse = iMouse.xy / iResolution.xy;\n    \n\tvec3 vCameraPos = vec3(sin(fAngle) * fDist, fHeight, cos(fAngle) * fDist);\n\tvec3 vCameraTarget = vec3(0.0, -0.5, 0.0);\n\n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n\t    \n\tvec3 vFinal = ApplyPostFX( vUV, vResult );\n\t\n\tfragColor = vec4(vFinal, 1.0);\n}\n\n// CAMERA\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 1.5);\n\n\treturn vDir;\n}\n\n// POSTFX\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.95;\n\tconst float kPower = 1.5;\n\n\treturn vInput * ((1.0 - kStrength) +  kStrength * pow(1.0 - fDist, kPower));\n}\n\nvec3 ApplyTonemap( const in vec3 vLinear )\n{\n\tfloat kExposure = 1.0;\n    \n    if(iTime < 2.0)\n    {\n        kExposure = iTime / 2.0;\n    }\n    \t\n\treturn 1.0 - exp2(vLinear * -kExposure);\t\n}\n\nvec3 ApplyGamma( const in vec3 vLinear )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow(vLinear, vec3(1.0/kGamma));\t\n}\n\nvec3 ApplyBlackLevel( const in vec3 vColour )\n{\n    float fBlackLevel = 0.1;\n    return vColour / (1.0 - fBlackLevel) - fBlackLevel;\n}\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec3 vTemp = ApplyVignetting( vUV, vInput );\t\n\t\n\tvTemp = ApplyTonemap(vTemp);\n\t\n\tvTemp = ApplyGamma(vTemp);\t\t\n    \n    vTemp = ApplyBlackLevel(vTemp);\n    \n    return vTemp;\n}\n\t\n// RAYTRACE\n\nstruct C_Intersection\n{\n\tvec3 vPos;\n\tfloat fDist;\t\n\tvec3 vNormal;\n\tvec3 vUVW;\n\tfloat fObjectId;\n};\n\n\nfloat GetCarving2dDistance(const in vec3 vPos) // Note: take full vec3\n{\n    float frontZ = -2.7; // front of pumpkin\n    vec2 surfaceXY = vPos.xy * (frontZ / vPos.z); // perspective correct projection\n    \n    vec2 uv = surfaceXY * vec2(.15,.25) + vec2(.5,.45); \n\n    float userCarving = texture(iChannel2, uv).r-texture(iChannel2, uv).g;\n    userCarving = (userCarving) * 2.0;\n    \n    return userCarving;\n}\n\nfloat GetCarvingDistance(const in vec3 vPos )\n{\n\tfloat fDist = (length(vPos * vec3(1.0, 1.4, 1.0)) - 2.7) / 1.5;\n\n    float fFaceDist = GetCarving2dDistance(vPos);\n    \n\tfloat fRearDist = vPos.z;\n\t\n\tif(fRearDist > fFaceDist)\n\t{\n\t\tfFaceDist = fRearDist;\n\t}\t\n\t\n\tif(fFaceDist < fDist )\n\t{\n\t\tfDist = fFaceDist;\n\t}\n\n    float fR = length(vPos.xz);\n   \n    float fLidDist = dot( vec2(fR, vPos.y), normalize(vec2(1.0, -1.3)));\n    \n    fLidDist = abs(fLidDist) - 0.03;\n\tif(fLidDist < fDist )\n\t{\n\t\tfDist = fLidDist;\n\t}\n   \n\treturn fDist;\n}\n\nfloat GetPumpkinDistance( out vec4 vOutUVW_Id, const in vec3 vPos )\n{\n    vec3 vSphereOrigin = vec3(0.0, 0.0, 0.0);\n    float fSphereRadius = 3.0;\n\n\tvec3 vOffset = vPos - vSphereOrigin;\n\tfloat fFirstDist = length(vOffset);\n\t\n\tfloat fOutDist;\n\tif(fFirstDist > 3.5)\n\t{\n\t\tfOutDist = fFirstDist - fSphereRadius;\n\t}\n\telse\n\t{\n\t\tfloat fAngle1 = atan(vOffset.x, vOffset.z);\n\t\tfloat fSin = sin(fAngle1 * 10.0);\n\t\tfSin = 1.0 - sqrt(abs(fSin));\n\t\tvOffset *= 1.0 + fSin * vec3(0.05, 0.025, 0.05);\n\t\tvOffset.y *= 1.0 + 0.5 * (fSphereRadius - length(vOffset.xz)) / fSphereRadius;\n\t\tfOutDist = length(vOffset) - fSphereRadius;\n\t}\n\t\n\n\tvec4 vSphere1UVW_Id = vec4(normalize(vPos - vSphereOrigin), 3.0);\n\tvOutUVW_Id = vSphere1UVW_Id;\n\t\n\tvec3 vStalkOffset = vPos;\n\tvStalkOffset.x += -(vStalkOffset.y - fSphereRadius) * 0.1;\n\tfloat fDist2d = length(vStalkOffset.xz);\n\tfloat fStalkDist = fDist2d - 0.2;\n\tfStalkDist = max(fStalkDist, vPos.y - 2.5 + vPos.x * 0.25);\n\tfStalkDist = max(fStalkDist, -vPos.y);\n\tif( fStalkDist < fOutDist )\n\t{\n\t\tfOutDist = fStalkDist;\n\t\tvOutUVW_Id = vSphere1UVW_Id;\n\t\tvOutUVW_Id.w = 2.0;\n\t}\n\n\treturn fOutDist;\n}\n\nfloat GetSceneDistance( out vec4 vOutUVW_Id, const in vec3 vPos )\n{\n\tfloat fFloorDist = vPos.y + 2.0;\n\tvec4 vFloorUVW_Id = vec4(vPos.xz, 0.0, 1.0);\n\n\t\n\tvec3 vPumpkinDomain = vPos;\n    \n\tfloat fOutDist = fFloorDist;\n\tvOutUVW_Id = vFloorUVW_Id;\n\n\tvec4 vPumpkinUVW_Id;\n\tfloat fPumpkinDist = GetPumpkinDistance( vPumpkinUVW_Id, vPumpkinDomain );\n\n\tfloat fCarvingDist = GetCarvingDistance( vPumpkinDomain );\n\t\n\tif(-fCarvingDist > fPumpkinDist)\n\t{\n\t\tfPumpkinDist = -fCarvingDist;\n\t\tvPumpkinUVW_Id = vec4(4.0);\n\t}\n\n\t\n\tif(fPumpkinDist < fOutDist)\n\t{\n\t\tfOutDist = fPumpkinDist;\n\t\tvOutUVW_Id = vPumpkinUVW_Id;\n\t}\n\t\n\treturn fOutDist;\n}\n\nvec3 GetSceneNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n\n    vec3 vDir1 = vec3( 1.0, -1.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, -1.0,  1.0);\n    vec3 vDir3 = vec3(-1.0,  1.0, -1.0);\n    vec3 vDir4 = vec3( 1.0,  1.0,  1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n    vec3 vOffset4 = vDir4 * fDelta;\n\n\tvec4 vUnused;\n    float f1 = GetSceneDistance( vUnused, vPos + vOffset1 );\n    float f2 = GetSceneDistance( vUnused, vPos + vOffset2 );\n    float f3 = GetSceneDistance( vUnused, vPos + vOffset3 );\n    float f4 = GetSceneDistance( vUnused, vPos + vOffset4 );\n\t\n    vec3 vNormal = vDir1 * f1 + vDir2 * f2 + vDir3 * f3 + vDir4 * f4;\t\n\t\t\n    return normalize( vNormal );\n}\n\nvoid TraceScene( out C_Intersection outIntersection, const in vec3 vOrigin, const in vec3 vDir )\n{\t\n\tvec4 vUVW_Id = vec4(0.0);\t\t\n\tvec3 vPos = vec3(0.0);\n\t\n\tfloat t = 0.01;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\n\t\tvPos = vOrigin + vDir * t;\n\t\tfloat fDist = GetSceneDistance(vUVW_Id, vPos);\t\t\n\t\tt += fDist;\n\t\tif(abs(fDist) < 0.001)\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\t\tif(t > 100.0)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tvPos = vOrigin + vDir * t;\n\t\t\tvUVW_Id = vec4(0.0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\toutIntersection.fDist = t;\n\toutIntersection.vPos = vPos;\n\toutIntersection.vNormal = GetSceneNormal(vPos);\n\toutIntersection.vUVW = vUVW_Id.xyz;\n\toutIntersection.fObjectId = vUVW_Id.w;\n}\n\n\nfloat TraceShadow( const in vec3 vOrigin, const in vec3 vDir, const in float fDist )\n{\n    C_Intersection shadowIntersection;\n\tTraceScene(shadowIntersection, vOrigin, vDir);\n\tif(shadowIntersection.fDist < fDist) \n\t{\n\t\treturn 0.0;\t\t\n\t}\n\t\n\treturn 1.0;\n}\n\nfloat GetSSS( const in vec3 vPos, const in vec3 vLightPos )\n{\n    vec3 vLightToPos = vPos - vLightPos;\n    vec3 vDir = normalize(vLightToPos);\n    \n\tC_Intersection intersection;\n\tTraceScene(intersection, vLightPos, vDir);\n\tfloat fOpticalDepth = length(vLightToPos) - intersection.fDist;\n\n    fOpticalDepth = max(0.00001, fOpticalDepth);\n    \n\treturn exp2( fOpticalDepth * -8.0 );\n}\n\n// LIGHTING\n\nfloat GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid AddLighting(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightColour)\n{\n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNDotL = clamp(dot(vLightDir, vNormal), 0.0, 1.0);\n\tfloat fNDotV = clamp(dot(-vViewDir, vNormal), 0.0, 1.0);\n\tfloat fNDotH = clamp(dot(vNormal, vH), 0.0, 1.0);\n\t\n\tfloat alpha = 1.0 - fSmoothness;\n\talpha = alpha * alpha;\n\t// D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNDotH * fNDotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (pi * denom * denom);\n\n\tfloat k = alpha / 2.0;\n\tfloat vis = GIV(fNDotL, k) * GIV(fNDotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;\n\tvSpecularLight += vLightColour * fSpecularIntensity;\n\n\tvDiffuseLight += vLightColour * fNDotL;\n}\n\nvoid AddPointLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n\tvec3 vToLight = vLightPos - vPos;\t\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\tvec3 vLightDir = normalize(vToLight);\n\t\n\tvec3 vShadowRayDir = vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, length(vToLight));\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\n}\n\nfloat AddDirectionalLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\n\tvec3 vShadowRayDir = -vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, 10.0);\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, -vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\t\n    \n    return fShadowFactor;\n}\n\nvoid AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(-vLightDir, vRayDir), 0.0, 1.0);\n\tfloat kSpreadPower = 4.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower);\n}\n\n// SCENE MATERIALS\n\nvoid GetSurfaceInfo(out vec3 vOutAlbedo, out vec3 vOutR0, out float fOutSmoothness, out vec3 vOutBumpNormal, const in C_Intersection intersection )\n{\n\tvOutBumpNormal = intersection.vNormal;\n\t\n\tif(intersection.fObjectId == 1.0)\n\t{\n\t\tvec2 vUV = intersection.vUVW.xy * 0.1;\n\t\tvOutAlbedo = texture(iChannel0, vUV).rgb;\n\t\tfloat fBumpScale = 10.0;\n\t\t\n\t\tvec2 vRes = iChannelResolution[0].xy;\n\t\tvec2 vDU = vec2(1.0, 0.0) / vRes;\n\t\tvec2 vDV = vec2(0.0, 1.0) / vRes;\n\t\t\n\t\tfloat fSampleW = texture(iChannel0, vUV - vDU).r;\n\t\tfloat fSampleE = texture(iChannel0, vUV + vDU).r;\n\t\tfloat fSampleN = texture(iChannel0, vUV - vDV).r;\n\t\tfloat fSampleS = texture(iChannel0, vUV + vDV).r;\n\t\t\n\t\tvec3 vNormalDelta = vec3(0.0);\n\t\tvNormalDelta.x += \n\t\t\t( fSampleW * fSampleW\n\t\t\t - fSampleE * fSampleE) * fBumpScale;\n\t\tvNormalDelta.z += \n\t\t\t(fSampleN * fSampleN\n\t\t\t - fSampleS * fSampleS) * fBumpScale;\n\t\t\n\t\tvOutBumpNormal = normalize(vOutBumpNormal + vNormalDelta);\n\n\t\tvOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n\t\tfOutSmoothness = clamp((0.8 - vOutAlbedo.r * 4.0), 0.0, 1.0);\n\t\t\n\t\tvOutR0 = vec3(0.01) * vOutAlbedo.g;\n\t}\n\telse if(intersection.fObjectId == 2.0)\n\t{\n\t\tvOutAlbedo = vec3(0.5, 0.5, 0.2);\n\t\tfOutSmoothness = 0.4;\n\t\tvOutR0 = vec3(0.05);\n\t}\n\telse if(intersection.fObjectId == 3.0)\n\t{\n        float fAngle = atan(intersection.vUVW.x, intersection.vUVW.z);\n        vec2 vUV = vec2(fAngle, intersection.vUVW.y) * vec2(1.0, 0.2) * 8.0;\n\t\tvOutAlbedo = texture(iChannel1, vUV).rgb;\n\t\tfOutSmoothness = clamp(1.0 - vOutAlbedo.r * vOutAlbedo.r * 2.0, 0.0, 1.0);\t\t\t\n\t\tvec3 vCol1 = vec3(1.0, 0.5, 0.0);\n\t\tvec3 vCol2 = vec3(0.5, 0.06, 0.0);\n\t\tvOutAlbedo = mix(vCol1, vCol2, vOutAlbedo.r * 0.5).rgb;\n\t\tvOutR0 = vec3(0.05);\n\t}\n\telse if(intersection.fObjectId == 4.0)\n    {\n\t\tvOutAlbedo = vec3(1.0, 0.824, 0.301);\n\t\tfOutSmoothness = 0.4;\n\t\tvOutR0 = vec3(0.05);\n\t}\n}\n\nvec3 GetSkyColour( const in vec3 vDir )\n{\t\n\tvec3 vResult = mix(vec3(0.02, 0.04, 0.06), vec3(0.1, 0.5, 0.8), abs(vDir.y));\n\t\n\treturn vResult;\t\n}\n\nfloat GetFogFactor(const in float fDist)\n{\n\tfloat kFogDensity = 0.025;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 GetFogColour(const in vec3 vDir)\n{\n\treturn vec3(0.01);\t\t\n}\n\nvec3 vSunLightColour = vec3(0.1, 0.2, 0.3) * 5.0;\nvec3 vSunLightDir = normalize(vec3(0.4, -0.3, -0.5));\n\t\nvoid ApplyAtmosphere(inout vec3 vColour, const in float fDist, const in vec3 vRayOrigin, const in vec3 vRayDir)\n{\t\t\n\tfloat fFogFactor = GetFogFactor(fDist);\n\tvec3 vFogColour = GetFogColour(vRayDir);\t\t\t\n\tAddDirectionalLightFlareToFog(vFogColour, vRayDir, vSunLightDir, vSunLightColour);\n\t\n\tvColour = mix(vFogColour, vColour, fFogFactor);\t\n}\n\n// TRACING LOOP\n\n\t\nvec3 GetSceneColour( in vec3 _vRayOrigin,  in vec3 _vRayDir )\n{\n    vec3 vRayOrigin = _vRayOrigin;\n    vec3 vRayDir = _vRayDir;\n\tvec3 vColour = vec3(0.0);\n\tvec3 vRemaining = vec3(1.0);\n\t\n    float fLastShadow = 1.0;\n    \n\tfor(int i=0; i<kBounceCount; i++)\n\t{\t\n\t\tvec3 vCurrRemaining = vRemaining;\n\t\tfloat fShouldApply = 1.0;\n\t\t\n\t\tC_Intersection intersection;\t\t\t\t\n\t\tTraceScene( intersection, vRayOrigin, vRayDir );\n\n\t\tvec3 vResult = vec3(0.0);\n\t\tvec3 vBlendFactor = vec3(0.0);\n\t\t\t\t\t\t\n\t\tif(intersection.fObjectId == 0.0)\n\t\t{\n\t\t\tvBlendFactor = vec3(1.0);\n\t\t\tfShouldApply = 0.0;\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tvec3 vAlbedo;\n\t\t\tvec3 vR0;\n\t\t\tfloat fSmoothness;\n\t\t\tvec3 vBumpNormal;\n\t\t\t\n\t\t\tGetSurfaceInfo( vAlbedo, vR0, fSmoothness, vBumpNormal, intersection );\t\t\t\n\t\t\n\t\t\tvec3 vDiffuseLight = vec3(0.0);\n\t\t\tvec3 vSpecularLight = vec3(0.0);\n\n            fLastShadow = AddDirectionalLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vSunLightDir, vSunLightColour);\t\t\t\t\t\t\t\t\n\n            vec3 vPointLightPos = vLightPos;\n          \n            \n\t\t\tAddPointLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vPointLightPos, vLightColour);\t\t\t\t\t\t\t\t\n          \n            if(intersection.fObjectId >= 3.0)\n            {\n                vDiffuseLight += GetSSS(intersection.vPos+vec3(0,0.0,0), vPointLightPos) * vLightColour;\n            } else\n            {\n                vec3 vToLight = vPointLightPos - intersection.vPos;\n                float fNdotL = dot(normalize(vToLight), vBumpNormal) * 0.5 + 0.5;\n\t\t\t\tvDiffuseLight += max(0.0, 1.0 - length(vToLight)/5.0) * vLightColour * fNdotL;                \n            }\n\n\t\t\tfloat fSmoothFactor = fSmoothness * 0.9 + 0.1;\n            float fFresnelClamp = 0.25; // too much fresnel produces sparkly artefacts\n            float fNdotD = clamp(dot(vBumpNormal, -vRayDir), fFresnelClamp, 1.0);\n\t\t\tvec3 vFresnel = vR0 + (1.0 - vR0) * pow(1.0 - fNdotD, 5.0) * fSmoothFactor;\n\n            \n\t\t\tvResult = mix(vAlbedo * vDiffuseLight, vSpecularLight, vFresnel);\t\t\n\t\t\tvBlendFactor = vFresnel;\n\t\t\t\n\t\t\tApplyAtmosphere(vResult, intersection.fDist, vRayOrigin, vRayDir);\t\t\n\t\t\t\n\t\t\tvRemaining *= vBlendFactor;\t\t\t\t\n\t\t\tvRayDir = normalize(reflect(vRayDir, vBumpNormal));\n\t\t\tvRayOrigin = intersection.vPos;\n\t\t}\t\t\t\n\n\t\tvColour += vResult * vCurrRemaining * fShouldApply;\t\n\t}\n\n\tvec3 vSkyColor = GetSkyColour(vRayDir);\n\t\n\tApplyAtmosphere(vSkyColor, kFarClip, vRayOrigin, vRayDir);\t\t\n\t\n    // Hack for this scene when using 1 bounce.\n    // remove final sky reflection when in shadow\n    vSkyColor *= fLastShadow; \n    \n\tvColour += vSkyColor * vRemaining;\n    \n\treturn vColour;\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tex = texture(iChannel0, fragCoord.xy/iResolution.xy, 0.);\n    float inside = 0.02;\n    float dist = tex.r-tex.g;\n    float newDist ;\n    if(iMouse.z > 0.0)\n    {\n        newDist = (distance(iMouse.xy, fragCoord.xy)/iResolution.x) - inside;\n        \n        if(tex.b==0.1){newDist = min(dist, newDist);} // if drawing has happened compare with existing distance\n        \n        fragColor = vec4(max(newDist,0.),-min(newDist,0.),0.1,1.0);\n        \n    } else if(tex.b!=0.1){fragColor = vec4(0.5,0,0.1,1.);} else {\n        fragColor = tex;\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3cfBzj",
    "date": "1757784817",
    "viewed": 20,
    "name": "Texture Drawing SDF",
    "description": "Very crude method for drawing a dynamic 2D SDF with a texture.\nI need this for version 2 of my [url=https://shadertoy.com/view/WfffR8]Pumpkin Carver[/url]\nThere are other, better ways to do this like [url=https://shadertoy.com/view/McByRd]Jump Flood[/url]",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "2d",
     "sdf",
     "texture",
     "drawing"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texture(iChannel0, fragCoord.xy/iResolution.xy, 0.);\n    float d = data.a;\n    d *= 3.0;\n    vec3 col = (d > 0.0) ? vec3(0.9, 0.6, 0.3) : vec3(0.65, 0.85, 1.0);\n    col *= 1.0 - exp(-6.0 * abs(d));\n    col *= 0.8 + 0.2 * cos(150.0 * d);\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.005, abs(d)));\n    fragColor = vec4(col, 1.0);\n    //fragColor = pow(texture(iChannel1, fragCoord.xy/iResolution.xy, 0.)*3., vec4(.7)); //view buffer A\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tex = texture(iChannel0, fragCoord.xy/iResolution.xy, 0.);\n    float inside = 0.02;\n    float dist = tex.r;\n    float newDist;\n    \n    if(iMouse.z > 0.0)\n    {\n        newDist = (distance(iMouse.xy, fragCoord.xy)/iResolution.x) - inside;\n        \n        if(tex.b == 0.1) {\n            newDist = min(dist, newDist);\n        }\n        \n        // Store distance in R, final corrected in G, state in B\n        fragColor = vec4(newDist, tex.g, 0.1, 1.0);\n    } \n    else if(tex.b != 0.1) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    } \n    else {\n        fragColor = tex;\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 pixelSize = 1.0/iResolution.xy;\n    \n    vec4 drawn = texture(iChannel1, uv, 0.);\n    vec4 prev = texture(iChannel0, uv, 0.);\n    \n    // If mouse is pressed, keep working with drawn data but preserve corrected\n    if(iMouse.z > 0.0) {\n        // Pass through drawn distance, but keep the corrected value\n        fragColor = vec4(drawn.r, prev.g, drawn.b, 1.0);\n        fragColor.a = (fragColor.r<0.) ? prev.g == 0.0? drawn.r:prev.g : fragColor.r;\n        return;\n    }\n    \n    float currentDist = prev.r;\n    float correctedDist = prev.g; // Final corrected distance\n    float state = prev.b;\n    \n    // Pixel-relative boundary threshold\n    float boundaryThreshold = pixelSize.x;\n    \n    // Initialize: mark pixels near boundary as correct\n    if(state == 0.1 && abs(currentDist) < boundaryThreshold) {\n        state = 0.5;\n        correctedDist = currentDist;\n    }\n    \n    // If this pixel needs fixing (not yet corrected)\n    if(state == 0.1 && currentDist < 0.0) {\n        \n        float bestDist = currentDist;\n        bool foundCorrect = false;\n        \n        // Larger kernel for faster initial propagation\n        const int kernelSize = 5; // Adjust this: 1=3x3, 2=5x5, 4=9x9, 8=17x17\n        \n        for(int y = -kernelSize; y <= kernelSize; y++) {\n            for(int x = -kernelSize; x <= kernelSize; x++) {\n                if(x == 0 && y == 0) continue;\n                \n                vec2 offset = vec2(x, y) * pixelSize;\n                vec4 neighbor = texture(iChannel0, uv + offset, 0.);\n                \n                if(neighbor.b >= 0.5) {\n                    float nDist = neighbor.g; // Use corrected distance from neighbor\n                    float stepDist = length(vec2(x, y)) * pixelSize.x;\n                    float proposedDist = nDist - stepDist;\n                    \n                    if(!foundCorrect || proposedDist > bestDist) {\n                        bestDist = proposedDist;\n                        foundCorrect = true;\n                    }\n                }\n            }\n        }\n        \n        if(foundCorrect) {\n            correctedDist = bestDist;\n            state = 0.5;\n        }\n    }\n    \n    // Corrected pixels: refine distance and apply smoothing\n    else if(state >= 0.5 && state < 1.0 && currentDist < 0.0) {\n        \n        float bestDist = correctedDist;\n        \n        // Still use larger kernel for refinement (or reduce to 1 for accuracy)\n        const int refineKernel = 2; // 5x5 for refinement phase\n        \n        for(int y = -refineKernel; y <= refineKernel; y++) {\n            for(int x = -refineKernel; x <= refineKernel; x++) {\n                if(x == 0 && y == 0) continue;\n                \n                vec2 offset = vec2(x, y) * pixelSize;\n                vec4 neighbor = texture(iChannel0, uv + offset, 0.);\n                \n                if(neighbor.b >= 0.5) {\n                    float nDist = neighbor.g; // Use corrected distance\n                    float stepDist = length(vec2(x, y)) * pixelSize.x;\n                    float proposedDist = nDist - stepDist;\n                    \n                    if(proposedDist > bestDist) {\n                        bestDist = proposedDist;\n                    }\n                }\n            }\n        }\n        \n        correctedDist = bestDist;\n        \n        // Apply smoothing\n        if(state > 0.5 && state < 0.9) {\n            float sumDist = 0.0;\n            float sumWeight = 0.0;\n            \n            for(int y = -1; y <= 1; y++) {\n                for(int x = -1; x <= 1; x++) {\n                    vec2 offset = vec2(x, y) * pixelSize;\n                    vec4 neighbor = texture(iChannel0, uv + offset, 0.);\n                    \n                    if(neighbor.b >= 0.5) {\n                        float nDist = neighbor.g; // Use corrected distance\n                        float weight = 1.0 / (1.0 + length(vec2(x, y)));\n                        sumDist += nDist * weight;\n                        sumWeight += weight;\n                    }\n                }\n            }\n            \n            if(sumWeight > 0.0) {\n                float smoothedDist = sumDist / sumWeight;\n                float smoothStrength = 0.3 * (1.0 - (state - 0.5) / 0.4);\n                correctedDist = mix(correctedDist, smoothedDist, smoothStrength);\n            }\n        }\n        \n        state = min(state + 0.009, 1.0);\n    }\n    \n    // Store: R = current/working distance, G = corrected distance, B = state\n    fragColor = vec4(currentDist, correctedDist, state, 1.0);\n    fragColor.a = (fragColor.r<0.) ? fragColor.g : fragColor.r;\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WcsBWB",
    "date": "1758020116",
    "viewed": 347,
    "name": "Ortho Spiral Random shaders",
    "description": "I saw this stereo spiral shader posted and thought it would work well with my random shaders.",
    "likes": 25,
    "published": "Public API",
    "usePreview": 1,
    "tags": [
     "spiral",
     "random",
     "generative",
     "stereo",
     "code",
     "geometry",
     "moebius",
     "ortho"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"I heard yall like Ortho spiral?\" by frisk256. https://shadertoy.com/view/3fffRs\n// 2025-09-16 10:45:13\n// Fork of \"Angry geometry god\" by Cotterzz. https://shadertoy.com/view/tftGD4\n// 2025-09-16 10:44:50\n\n#define NEWVALUE values[int(floor(float(v)*rand(seed+float(i))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i)))\n#define NEWVALUE2 values[int(floor(float(v)*rand(seed+float(i+5))))] * (sin(iTime*rand(seed+float(i)))*rand(seed+float(i+5)))\n\nint PALETTE = 9;\n\nfloat rand(float n){return fract(cos(n*89.42)*343.42);}\nvec2 shake() {\n    return vec2(\n        sin(iTime*1e2),\n        cos(iTime*2e2)\n    ) * max(0.,1.2-iTime)/20.;\n}\nfloat nz(vec2 nv){\n    float o = 0.;\n    for (float i = .2; i < 2.;\n    o += abs(dot(sin(nv * i * 64.), vec2(.05))) / i,\n    i *= 1.4142);\n    return mix(o,  distance(vec2(0), nv), 0.5 + (sin(iTime)/2.));\n}\n\nfloat rMix(float a, float b, float s){\n    s = rand(s);\n    return s>0.9?sin(a):s>0.8?sqrt(abs(a)):s>0.7?a+b:s>0.6?a-b:s>0.5?b-a:s>0.4?nz(vec2(a,b)):s>0.3?b/(a==0.?0.01:a):s>0.2?a/(b==0.?0.01:b):s>0.1?a*b:cos(a);\n}\n\nvec3 gpc(float t) {\n    return 0.5 + 0.5*cos(vec3(0,2,4) + t*2.0);\n}\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 contrast(vec3 color, float value) {return 0.5 + value * (color - 0.5);}\n\nvec3 addColor(float num, float seed, float alt){\n    if(isinf(num)){num = alt * seed;}\n    if(PALETTE == 7){\n        vec3 col = contrast(gpc(num),1.7);\n        return col;} else if(PALETTE > 2 || (PALETTE == 1 && rand(seed+19.)>0.3)){\n        float sat = 1.;\n        if(num<0.){sat = 1.-(1./(abs(num)+1.));}\n        float light = 1.0-(1./(abs(num)+1.));\n        vec3 col = hsl2rgb(vec3(fract(abs(num)), sat, light));\n        if(PALETTE == 1){col *= 2.;}\n        return col;\n    } else {\n        vec3 col = vec3(fract(abs(num)), 1./num, 1.-fract(abs(num)));\n        if(rand(seed*2.)>0.5){col = col.gbr;}\n        if(rand(seed*3.)>0.5){col = col.gbr;}\n        if(PALETTE == 1){col += (1.+cos(rand(num)+vec3(4,2,1))) / 2.;}\n        return col;\n    }\n}\n\nvec3 sanitize(vec3 dc){\n    dc.r = min(1., dc.r);\n    dc.g = min(1., dc.g);\n    dc.b = min(1., dc.b);\n    \n    if(!(dc.r>=0.) && !(dc.r<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.g>=0.) && !(dc.g<0.)){\n        return vec3(1,0,0);\n    } else if(!(dc.b>=0.) && !(dc.b<0.)){\n        return vec3(1,0,0);\n    } else {\n        return dc;\n    }\n\n}\n\nvec3 mainAgg(vec2 uv, float seed){\n   // uv = fragCoord/iResolution.y;\n    uv.x-=0.5*iResolution.x/iResolution.y;\n    uv.y-=0.5;\n    uv += shake();\n    float zoom = 4. + (3.*(sin(iTime/1.5)+1.));\n    vec2 guv = (uv*zoom);\n    float x = guv.x;\n    float y = guv.y;\n    float o = nz(guv);\n   // float seed = floor(iTime/1.0);\n    PALETTE = int(floor(float(8)*rand(seed+66.)));\n    const int v = 24;\n    vec3 col = vec3(0);\n    float cn = 1.;\n    float values[v];\n    values[0] = 1.0;\n    values[1] = 10.0;\n    values[2] = x;\n    values[3] = y;\n    values[4] = x*x;\n    values[5] = y*y;\n    values[6] = x*x*x;\n    values[7] = y*y*y;\n    values[8] = x*x*x*x;\n    values[9] = y*y*y*y;\n   values[10] = x*y*x;\n   values[11] = y*y*x;\n   values[12] = sin(y);\n   values[13] = cos(y);    \n   values[14] = sin(x);\n   values[15] = cos(x);   \n   values[16] = sin(y)*sin(y);\n   values[17] = cos(y)*cos(y);\n   values[16] = sin(x)*sin(x);\n   values[17] = cos(x)*cos(x);\n   values[18] = 2.;\n   values[19] = distance(vec2(x,y), vec2(0));\n   values[20] = 3.14159;\n   values[21] = atan(x, y)*4.;\n   values[22] = o;\n   values[23] = distance(vec2(x,y), vec2(0))*sin(atan(x, y));\n   \n    float total = 0.;\n    float sub = 0.;\n    int maxi = 30; int mini = 5;\n    int iterations = min(maxi,mini + int(floor(rand(seed*6.6)*float(maxi-mini))));\n    \n    for(int i = 0; i<iterations; i++){\n        if(rand(seed+float(i+3))>rand(seed)){\n            sub = sub==0. ? rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)) : rMix(sub, rMix(NEWVALUE, NEWVALUE2, seed+float(i+4)), seed+float(i));\n        } else {\n            sub = sub==0. ? NEWVALUE : rMix(sub, NEWVALUE, seed+float(i));\n        }\n        if(abs(sub)<1.){seed+=100.;PALETTE = int(floor(float(8)*rand(seed+66.)));}\n        if(rand(seed+float(i))>rand(seed)/2.){\n            total = total==0. ? sub : rMix(total, sub,seed+float(i*2));\n            sub = 0.;\n            col += addColor(total, seed+float(i), values[21]);\n            cn+=1.;\n        }\n    }\n    total = sub==0. ? total : rMix(total, sub, seed);\n    col += addColor(total, seed, values[21]);\n    col /=cn;\n    if(PALETTE<3){col/=(3.* (0.5 + rand(seed+13.)));}\n    if(PALETTE == 4){col = pow(col, 1./col)*1.5;}\n    if(PALETTE == 2 || PALETTE == 5 ){col = hsl2rgb(col);}\n    \n    if(PALETTE == 6){\n        col = hsl2rgb(hsl2rgb(col));\n        if(rand(seed+17.)>0.5){col = col.gbr;}\n        if(rand(seed+19.)>0.5){col = col.gbr;}\n    }\n\n    col = sanitize(col);\n    return col;\n}\n\n\nvoid mainImage0(out vec4 c, vec2 p) {\n    vec2 r = iResolution.xy;\n    vec2 h = (p / r * 2. - 1.) * sqrt(r / r.yx);\n    vec3 g = vec3(1, h.yx) / (dot(h, h) + 1.) + vec3(-.5, 0, .5);\n    h = g.xy / dot(g, g);\n    h = vec2(atan(h.x, h.y), log(length(h))) / 6.28;\n    h += iTime * .1;\n    h *= mat2(8, 5, -5, 8);\n    \n    // Get the cell coordinates (which cell we're in)\n    vec2 cellID = floor(h);\n    \n    //--------thx to chronos for this seam fix.------\n    cellID = mod(cellID, vec2(8,5));\n    \n    // Get local UV within the cell (0 to 1)\n    vec2 cellUV = fract(h);\n    \n    // Create a unique seed from cell coordinates\n    // Simple hash - you can make this more sophisticated if needed\n    float seed = cellID.x + cellID.y * 10.0;\n    // Or better hash:\n    // float seed = dot(cellID, vec2(127.1, 311.7));\n    // seed = fract(sin(seed) * 43758.5453);\n    \n    // Now call your pattern function:\n    // vec3 pattern = yourPatternFunction(cellUV, seed);\n    \n    // Example visualization showing the UVs and cell IDs:\n    vec3 col = mainAgg(cellUV, seed);\n    \n    // Or keep the original square pattern:\n    // c = vec4(max(abs(cellUV.x - .5), abs(cellUV.y - .5)) * 2.);\n    \n    c = vec4(col, 1.0)-pow(vec4(max(abs(cellUV.x - .5), abs(cellUV.y - .5)) * 2.),vec4(6.))/2.;\n}\n\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = 3., k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WfXBWf",
    "date": "1758113832",
    "viewed": 11,
    "name": "Pumpkin Carver C",
    "description": "Third attempt at carved pumpkin magic.",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "halloween",
     "pumpkin"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Pumpkin Carver B\"                by Cotterzz. https://shadertoy.com/view/wflfzB\n// Fork of \"Ortho Spiral Random shaders\"     by Cotterzz. https://shadertoy.com/view/WcsBWB\n// Fork of \"Noise Derivative Approximation\"  by Cotterzz. https://shadertoy.com/view/wfcGRX\n// Fork of \"I heard yall like Ortho spiral?\" by frisk256. https://shadertoy.com/view/3fffRs\n// Fork of \"Jack-o'-lantern\"                 by P_Malin.  https://shadertoy.com/view/MdBXR3\n// Fork of \"Glow hack\"                       by nuclear.  https://shadertoy.com/view/XslGDr\n\n// This is for the glow/bloom effect, main code in Buffer A\nvec3 samplef(vec2 tc);\nvec3 blur(vec2 tc, float offs);\nvec3 highlights(vec3 pixel, float thres);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 tc = fragCoord.xy / iResolution.xy;\n\tvec3 color = blur(tc, 2.0);\n\tcolor += blur(tc, 3.0);\n\tcolor += blur(tc, 5.0);\n\tcolor += blur(tc, 7.0);\n\tcolor /= 4.0;\n\t\n\tcolor += samplef(tc);\n\t\n\n\n\tfragColor.xyz = color;\n\tfragColor.w = 1.0;\n}\n\nvec3 samplef(vec2 tc)\n{\n\treturn texture(iChannel0, tc).xyz;\n}\n\nvec3 hsample(vec2 tc)\n{\n\treturn highlights(samplef(tc), 0.6);\n}\n\nvec3 blur(vec2 tc, float offs)\n{\n\tvec4 xoffs = offs * vec4(-2.0, -1.0, 1.0, 2.0) / iResolution.x;\n\tvec4 yoffs = offs * vec4(-2.0, -1.0, 1.0, 2.0) / iResolution.y;\n\t\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\tcolor += hsample(tc + vec2(xoffs.x, yoffs.x)) * 0.00366;\n\tcolor += hsample(tc + vec2(xoffs.y, yoffs.x)) * 0.01465;\n\tcolor += hsample(tc + vec2(    0.0, yoffs.x)) * 0.02564;\n\tcolor += hsample(tc + vec2(xoffs.z, yoffs.x)) * 0.01465;\n\tcolor += hsample(tc + vec2(xoffs.w, yoffs.x)) * 0.00366;\n\t\n\tcolor += hsample(tc + vec2(xoffs.x, yoffs.y)) * 0.01465;\n\tcolor += hsample(tc + vec2(xoffs.y, yoffs.y)) * 0.05861;\n\tcolor += hsample(tc + vec2(    0.0, yoffs.y)) * 0.09524;\n\tcolor += hsample(tc + vec2(xoffs.z, yoffs.y)) * 0.05861;\n\tcolor += hsample(tc + vec2(xoffs.w, yoffs.y)) * 0.01465;\n\t\n\tcolor += hsample(tc + vec2(xoffs.x, 0.0)) * 0.02564;\n\tcolor += hsample(tc + vec2(xoffs.y, 0.0)) * 0.09524;\n\tcolor += hsample(tc + vec2(    0.0, 0.0)) * 0.15018;\n\tcolor += hsample(tc + vec2(xoffs.z, 0.0)) * 0.09524;\n\tcolor += hsample(tc + vec2(xoffs.w, 0.0)) * 0.02564;\n\t\n\tcolor += hsample(tc + vec2(xoffs.x, yoffs.z)) * 0.01465;\n\tcolor += hsample(tc + vec2(xoffs.y, yoffs.z)) * 0.05861;\n\tcolor += hsample(tc + vec2(    0.0, yoffs.z)) * 0.09524;\n\tcolor += hsample(tc + vec2(xoffs.z, yoffs.z)) * 0.05861;\n\tcolor += hsample(tc + vec2(xoffs.w, yoffs.z)) * 0.01465;\n\t\n\tcolor += hsample(tc + vec2(xoffs.x, yoffs.w)) * 0.00366;\n\tcolor += hsample(tc + vec2(xoffs.y, yoffs.w)) * 0.01465;\n\tcolor += hsample(tc + vec2(    0.0, yoffs.w)) * 0.02564;\n\tcolor += hsample(tc + vec2(xoffs.z, yoffs.w)) * 0.01465;\n\tcolor += hsample(tc + vec2(xoffs.w, yoffs.w)) * 0.00366;\n\n\treturn color;\n}\n\nvec3 highlights(vec3 pixel, float thres)\n{\n\tfloat val = (pixel.x + pixel.y + pixel.z) / 3.0;\n\treturn pixel * smoothstep(thres - 0.1, thres + 0.1, val);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 c,vec2 p) {\n    vec2 r = iResolution.xy;\n    vec2 h = (p / r * 2. - 1.) * sqrt(r / r.yx);\n    vec3 g = vec3(1,h.yx) / (dot(h,h) + 1.) + vec3(-.5,0,.5);\n    h = g.xy / dot(g,g);\n    h = vec2(atan(h.x,h.y),log(length(h))) / 6.28;\n    h += iTime * .1;\n    vec2 h2 = h;\n    h *= mat2(8,5,-5,8);\n    h = fract(h);\n    c = vec4(h,h);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265359\n// Hash function for randomization\nfloat hash(float p) {\n    vec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n    return fract(p2.x * p2.y * 95.4337);\n}\n\nfloat GetCharacter(int cx, int cy, vec2 cuv) {\n    cuv = clamp(cuv, vec2(0), vec2(1));\n    float tx = (cuv.x/16.) + (float(cx)*(1./16.));\n    float ty = (cuv.y/16.) + (float(cy)*(1./16.));\n    return -.5 + texture(iChannel0, vec2(tx, ty)).a;\n}\n\nfloat GetCarving2dDistance(const in vec3 vPos, float seed) {\n    float frontZ = -2.7;\n    vec2 surfaceXY = vPos.xy * (frontZ / vPos.z);\n    vec2 uv = surfaceXY * vec2(.2,.4) + vec2(.5,.3);\n    \n    // Randomize character based on seed\n    int cx = int(mod(hash(seed) * 100.0, 16.0));\n    int cy = int(mod(hash(seed + 1.0) * 100.0, 16.0));\n    \n    float userCarving = GetCharacter(cx, cy, uv);\n    return userCarving;\n}\n\nfloat GetCarvingDistance(const in vec3 vPos, float seed) {\n    float fDist = (length(vPos * vec3(1.0, 1.4, 1.0)) - 2.7) / 1.5;\n    float fFaceDist = GetCarving2dDistance(vPos, seed);\n    float fRearDist = vPos.z;\n    \n    if(fRearDist > fFaceDist) {\n        fFaceDist = fRearDist;\n    }\n    \n    if(fFaceDist < fDist) {\n        fDist = fFaceDist;\n    }\n    \n    float fR = length(vPos.xz);\n    float fLidDist = dot(vec2(fR, vPos.y), normalize(vec2(1.0, -1.3)));\n    fLidDist = abs(fLidDist) - 0.03;\n    \n    if(fLidDist < fDist) {\n        fDist = fLidDist;\n    }\n    \n    return fDist;\n}\n\nfloat GetPumpkinDistance(out vec4 vOutUVW_Id, const in vec3 vPos) {\n    vec3 vSphereOrigin = vec3(0.0, 0.0, 0.0);\n    float fSphereRadius = 3.0;\n    vec3 vOffset = vPos - vSphereOrigin;\n    float fFirstDist = length(vOffset);\n    \n    float fOutDist;\n    if(fFirstDist > 3.5) {\n        fOutDist = fFirstDist - fSphereRadius;\n    } else {\n        float fAngle1 = atan(vOffset.x, vOffset.z);\n        float fSin = sin(fAngle1 * 5.5);\n        fSin = 1.0 - sqrt(abs(fSin));\n        vOffset *= 0.95 + fSin * vec3(0.1, 0.02, 0.08);\n        vOffset.y *= 1.0 + 0.5 * (fSphereRadius - length(vOffset.xz)) / fSphereRadius;\n        fOutDist = length(vOffset) - fSphereRadius;\n    }\n    \n    vec4 vSphere1UVW_Id = vec4(normalize(vPos - vSphereOrigin), 3.0);\n    vOutUVW_Id = vSphere1UVW_Id;\n    \n    vec3 vStalkOffset = vPos;\n    vStalkOffset.x += -(vStalkOffset.y - fSphereRadius) * 0.1;\n    float fDist2d = length(vStalkOffset.xz);\n    float fStalkDist = fDist2d - 0.2;\n    fStalkDist = max(fStalkDist, vPos.y - 2.5 + vPos.x * 0.25);\n    fStalkDist = max(fStalkDist, -vPos.y);\n    \n    if(fStalkDist < fOutDist) {\n        fOutDist = fStalkDist;\n        vOutUVW_Id = vSphere1UVW_Id;\n        vOutUVW_Id.w = 2.0;\n    }\n    \n    return fOutDist;\n}\n\nfloat GetSceneDistance(out vec4 vOutUVW_Id, const in vec3 vPos, float seed) {\n    vec3 vPumpkinDomain = vPos;\n    vec4 vPumpkinUVW_Id;\n    float fPumpkinDist = GetPumpkinDistance(vPumpkinUVW_Id, vPumpkinDomain);\n    \n    float fCarvingDist = GetCarvingDistance(vPumpkinDomain, seed);\n    \n    if(-fCarvingDist > fPumpkinDist) {\n        fPumpkinDist = -fCarvingDist;\n        vPumpkinUVW_Id = vec4(4.0);\n    }\n    \n    vOutUVW_Id = vPumpkinUVW_Id;\n    return fPumpkinDist;\n}\n\nvec3 GetSceneNormal(const in vec3 vPos, float seed) {\n    const float fDelta = 0.001;\n    vec3 vDir1 = vec3(1.0, -1.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, -1.0, 1.0);\n    vec3 vDir3 = vec3(-1.0, 1.0, -1.0);\n    vec3 vDir4 = vec3(1.0, 1.0, 1.0);\n    \n    vec4 vUnused;\n    float f1 = GetSceneDistance(vUnused, vPos + vDir1 * fDelta, seed);\n    float f2 = GetSceneDistance(vUnused, vPos + vDir2 * fDelta, seed);\n    float f3 = GetSceneDistance(vUnused, vPos + vDir3 * fDelta, seed);\n    float f4 = GetSceneDistance(vUnused, vPos + vDir4 * fDelta, seed);\n    \n    vec3 vNormal = vDir1 * f1 + vDir2 * f2 + vDir3 * f3 + vDir4 * f4;\n    return normalize(vNormal);\n}\n\nvec3 mainPC(vec2 uv, float seed, float angle) {\n    // Convert UV to window coordinates\n    vec2 vWindow = uv * 2.0 - 1.0;\n    vec2 cuv = vWindow;\n    float sangle =atan(cuv.y,cuv.x);\n    float clength = length(cuv);\n    cuv.x = cos(sangle+angle)*clength;\n    cuv.y = sin(sangle+angle)*clength;\n    vWindow = cuv;\n    // Fixed camera setup\n    float fDist = 6.0;\n    float fAngle = 3.141;\n    float fHeight = 2.5;\n    \n    vec3 vCameraPos = vec3(sin(fAngle) * fDist, fHeight, cos(fAngle) * fDist);\n    vec3 vCameraTarget = vec3(0.0, -0.5, 0.0);\n    \n    // Camera ray direction\n    vec3 vForward = normalize(vCameraTarget - vCameraPos);\n    vec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n    vec3 vUp = normalize(cross(vForward, vRight));\n    vec3 vRayDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 1.5);\n    \n    // Raymarch\n    vec3 vRayOrigin = vCameraPos;\n    vec4 vUVW_Id = vec4(0.0);\n    vec3 vPos = vec3(0.0);\n    float t = 0.01;\n    \n    for(int i = 0; i < 64; i++) {\n        vPos = vRayOrigin + vRayDir * t;\n        float fDist = GetSceneDistance(vUVW_Id, vPos, seed);\n        t += fDist;\n        if(abs(fDist) < 0.001) break;\n        if(t > 100.0) {\n            return vec3(0.0); // Black background instead of sky\n        }\n    }\n    \n    // If we hit something\n    if(t < 100.0 && vUVW_Id.w > 0.0) {\n        vec3 vNormal = GetSceneNormal(vPos, seed);\n        \n        // Simple lighting\n        vec3 vLightDir = normalize(vec3(0.5, 1.0, 0.5));\n        float fDiffuse = max(0.0, dot(vNormal, vLightDir)) * 0.7 + 0.3;\n        \n        // Pumpkin color based on object ID\n        vec3 vColor;\n        if(vUVW_Id.w == 3.0) {\n            // Pumpkin surface\n            vColor = vec3(1.0, 0.5, 0.1);\n        } else if(vUVW_Id.w == 2.0) {\n            // Stalk\n            vColor = vec3(0.7, 1.0, 0.4);\n        } else if(vUVW_Id.w == 4.0) {\n            // Carving (glowing)\n            vColor = vec3(1.0, 0.8, 0.3);\n            fDiffuse = 01.7; // Make carving brighter\n        } else {\n            vColor = vec3(0.5);\n        }\n        \n        return vColor * fDiffuse;\n    }\n    \n    return vec3(0.0); // Black background\n}\n\nvoid mainImage0(out vec4 c, vec2 p) {\n\n\n\n    int pos = int(p.x)%2 + (int(p.y)%2 * 2);\n    float ra = texture(iChannel1, p/iResolution.xy, 0.).r;\n    float rb = texture(iChannel1, (p+vec2(1,0))/iResolution.xy, 0.).r;\n    float rc = texture(iChannel1, (p+vec2(0,1))/iResolution.xy, 0.).r;\n    float dx = dFdx(ra);\n    float dy = dFdy(ra);\n    if(pos == 1 || pos == 3){ dx = rb-ra; }\n    if(pos == 2 || pos == 3){ dy = rc-ra; }\n    float dz = sqrt((dx*dx) + (dy*dy));\n    float a = atan(dx,dy);\n\n\n    vec2 r = iResolution.xy;\n    vec2 h = (p / r * 2. - 1.) * sqrt(r / r.yx);\n    vec3 g = vec3(1, h.yx) / (dot(h, h) + 1.) + vec3(-.5, 0, .5);\n    h = g.xy / dot(g, g);\n    h = vec2(atan(h.x, h.y), log(length(h))) / 6.28;\n    h += iTime * .1;\n\n    h *= mat2(8, 5, -5, 8); \n    vec2 cellID = floor(h);\n    cellID = mod(cellID, vec2(8,5));// -----thx to chronos for this seam fix\n    vec2 cellUV = fract(h);\n    float seed = dot(cellID, vec2(127.1, 311.7)); seed = fract(sin(seed) * 43758.5453);\n    vec3 col = mainPC(1.-cellUV.yx, seed, 3.14-a);\n    c = vec4(col, 1.0);\n}\n\n\n// multisampling\nvoid mainImage(out vec4 o, vec2 u) \n{ \n// this is the numebr of samples - 1. is no multisampling\n    float s = 1., k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wf2fRz",
    "date": "1758237547",
    "viewed": 7,
    "name": "Desmos Pumpkin v2",
    "description": "From https://www.desmos.com/3d/afwrvhoa9n",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "pumpkin",
     "desmos"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Pumpkin SDF Shader - Shadertoy Compatible\n// Based on complex spherical equation from Desmos 3D\n// https://www.desmos.com/3d/afwrvhoa9n\n\n// Adjustable parameters for the pumpkin equation\n// Adjust these values to modify the shape\nconst float n0 = 20.0;   // Primary ridge frequency (higher = more ridges)\nconst float m0 = 0.0;    // Primary ridge offset\nconst float k0 = 0.1;    // Primary ridge amplitude\n\nconst float n1 = 20.0;    // Secondary ridge frequency\nconst float m1 = 0.0;    // Secondary ridge offset  \nconst float k1 = 0.15;   // Secondary ridge amplitude\n\nconst float n2 = 3.0;    // Tertiary ridge frequency\nconst float m2 = 0.0;    // Tertiary ridge offset\nconst float k2 = 0.1;    // Tertiary ridge amplitude\n\nconst float g = 0.5;     // Global size offset\nconst float p = 0.7;     // Vertical squash factor\nconst float h = 0.01;    // Top/bottom flattening\n\n// Additional parameters for hollowing and lid\nconst float thickness = 0.05;    // Wall thickness for hollow effect\nconst float cutSphereRadius = 0.6; // Size of sphere to cut from top\nconst float cutSphereY = 0.3;    // Height of cutting sphere center\nconst float lidRaise = 0.4;      // How much to raise the lid\nconst float lidTiltX = 0.3;      // Tilt angle around X axis\nconst float lidTiltZ = 0.1;      // Tilt angle around Z axis\n\n// SDF Operations\nfloat opOnion(float sdf, float thickness) {\n    return abs(sdf) - thickness;\n}\n\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\n// Sphere SDF\nfloat sphereSDF(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\n// Rotation matrices\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(1.0, 0.0, 0.0,\n                0.0, c, -s,\n                0.0, s, c);\n}\n\nmat3 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c, -s, 0.0,\n                s, c, 0.0,\n                0.0, 0.0, 1.0);\n}\n\n// Convert Cartesian to spherical coordinates\nvec3 cartesianToSpherical(vec3 pos) {\n    float rho = length(pos);\n    float theta = atan(pos.z, pos.x);\n    float phi = acos(pos.y / rho);\n    return vec3(rho, theta, phi);\n}\n\n// The complex pumpkin equation converted to SDF\nfloat pumpkinSDF(vec3 pos) {\n    vec3 spherical = cartesianToSpherical(pos);\n    float theta = spherical.y;\n    float phi = spherical.z;\n    \n    // Use the constant parameters directly\n    \n    // Calculate the three sin terms\n    float sin_term0 = sin(n0 * theta + m0);\n    float sin_term1 = sin(n1 * theta + m1);\n    float sin_term2 = sin(n2 * theta + m2);\n    \n    // First part: sum of the three weighted sin terms\n    float part1 = (1.0 - pow(sin_term0, 4.0)) * (k0 / n0) +\n                  (1.0 - sin_term1) * (k1 / n1) +\n                  (1.0 - sin_term2) * (k2 / n2);\n    \n    // Second part: phi modulation\n    float cos_2phi = cos(2.0 * phi);\n    float part2 = pow((1.0 - cos_2phi) / 2.0, 2.0);\n    \n    // Third part: exponential and constant term\n    float part3 = exp(-pow(phi - 3.14159 / 2.0, 2.0)) + p;\n    \n    // Fourth part: cosine modulation\n    float part4 = 1.0 - h * cos_2phi;\n    \n    // Combine all parts to get the target radius\n    float target_rho = (part1 * part2 + g) * part3 * part4;\n    \n    // Return SDF: current distance - target distance\n    return length(pos) - target_rho;\n}\n\n// Hollow pumpkin with top cut off\nfloat hollowPumpkinSDF(vec3 pos) {\n    // Get the base pumpkin shape\n    float pumpkin = pumpkinSDF(pos);\n    \n    // Make it hollow using onion operation\n    float hollow = opOnion(pumpkin, thickness);\n    \n    // Create cutting sphere at the top\n    vec3 cutSpherePos = pos - vec3(0.0, cutSphereY, 0.0);\n    float cuttingSphere = sphereSDF(cutSpherePos, cutSphereRadius);\n    \n    // Subtract the sphere from the hollow pumpkin\n    return opSubtraction(cuttingSphere, hollow);\n}\n\n// Lid (the cut-off part) - raised and tilted\nfloat lidSDF(vec3 pos) {\n    // Transform position for the lid\n    vec3 lidPos = pos;\n    \n    // Move down to original position, apply rotations, then raise up\n    lidPos.y -= lidRaise;\n    lidPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * lidPos;\n    \n    // Get the base pumpkin shape\n    float pumpkin = pumpkinSDF(lidPos);\n    \n    // Make it hollow\n    float hollow = opOnion(pumpkin, thickness);\n    \n    // Create cutting sphere - we want only the part that was cut off\n    vec3 cutSpherePos = lidPos - vec3(0.0, cutSphereY, 0.0);\n    float cuttingSphere = sphereSDF(cutSpherePos, cutSphereRadius);\n    \n    // Return only the intersection (the part that was inside the cutting sphere)\n    // We want the hollow pumpkin AND inside the cutting sphere\n    return max(hollow, cuttingSphere);\n}\n\n// Main scene SDF\nfloat sceneSDF(vec3 pos) {\n    float hollowPumpkin = hollowPumpkinSDF(pos);\n    float lid = lidSDF(pos);\n    \n    return opUnion(hollowPumpkin, lid);\n}\n\n// Ray-plane intersection for debug visualization (camera-relative)\nfloat rayPlaneIntersect(vec3 ro, vec3 rd, vec3 forward, float planeDistance) {\n    float denom = dot(rd, forward);\n    if (abs(denom) < 0.001) return -1.0; // Ray parallel to plane\n    return planeDistance / denom;\n}\n\n\n// Raymarching function\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 pos = ro + t * rd;\n        float d = sceneSDF(pos);\n        if (d < 0.001) break;\n        t += d * 0.8; // Use smaller step for complex shapes\n        if (t > 20.0) break;\n    }\n    return t;\n}\n\n// Calculate normal using finite differences\nvec3 getNormal(vec3 pos) {\n    float eps = 0.001;\n    vec3 n = vec3(\n        sceneSDF(pos + vec3(eps, 0, 0)) - sceneSDF(pos - vec3(eps, 0, 0)),\n        sceneSDF(pos + vec3(0, eps, 0)) - sceneSDF(pos - vec3(0, eps, 0)),\n        sceneSDF(pos + vec3(0, 0, eps)) - sceneSDF(pos - vec3(0, 0, eps))\n    );\n    return normalize(n);\n}\n\n// Enhanced lighting function with material detection\nvec3 lighting(vec3 pos, vec3 normal, vec3 viewDir) {\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 lightColor = vec3(1.0, 0.9, 0.8);\n    \n    // Ambient\n    vec3 ambient = vec3(0.1, 0.15, 0.2);\n    \n    // Diffuse\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * lightColor;\n    \n    // Specular\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    vec3 specular = spec * lightColor;\n    \n    // Determine material based on which part we're on\n    float hollowDist = hollowPumpkinSDF(pos);\n    float lidDist = lidSDF(pos);\n    \n    vec3 materialColor;\n    if (lidDist < hollowDist) {\n        // Lid material - slightly different color\n        materialColor = vec3(0.9, 0.5, 0.15);\n    } else {\n        // Main pumpkin body\n        materialColor = vec3(1.0, 0.6, 0.2);\n    }\n    \n    return materialColor * (ambient + diffuse) + specular;\n}\n\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera setup\n    float rot = iMouse.x/iResolution.x*4.;\n    vec3 ro = vec3(3.0 * cos(rot), 1.0, 3.0 * sin(rot));\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    \n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    \n    vec3 color = vec3(0.0);\n    \n    // Regular raymarch first\n    float t = raymarch(ro, rd);\n    \n\n    \n    // Render based on what we hit first\n    if (t < 20.0) {\n        \n        vec3 pos = ro + t * rd;\n        vec3 normal = getNormal(pos);\n        vec3 viewDir = normalize(ro - pos);\n        color = lighting(pos, normal, viewDir);\n        \n        // Add some atmospheric perspective\n        float fog = 1.0 - exp(-t * 0.1);\n        color = mix(color, vec3(0.5, 0.7, 1.0), fog * 0.3);\n    } else {\n        // Background gradient\n        color = mix(vec3(0.2, 0.3, 0.5), vec3(0.5, 0.7, 1.0), uv.y * 0.5 + 0.5);\n    }\n    \n    // Gamma correction\n    color = pow(color, vec2(1.0/2.2).xxx);\n    \n    fragColor = vec4(color, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WfBfR1",
    "date": "1758892996",
    "viewed": 11,
    "name": "Parametric Pumpkin",
    "description": "This is the base for the remaining pumpkin shaders.",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "procedural",
     "halloween",
     "drawing",
     "pumpkin",
     "carving",
     "octoberdesmos"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// 6th slider down on the left is AA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy, 0.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Mode selection - comment out for random mode\n#define USE_SLIDERS\n\n// Slider values on the right are pumpkin then stalk metrics.\n// Slider values on the left are camera/view at the top, then AA, then face then lid metrics at the bottom.\n\n// iChannel0 is this buffers output, iChannel1 is the font texture\n\n// Pumpkin Shader, SDF Based on:\n// https://www.desmos.com/3d/afwrvhoa9n\n\n\n// Random seed for random mode\nfloat randomSeed = 0.0;\n\nfloat n0 = 20.0;   // Primary ridge frequency (higher = more ridges)\nfloat m0 = 0.5;    // Primary ridge offset\nfloat k0 = 0.1;    // Primary ridge amplitude\n\nfloat n1 = 20.0;    // Secondary ridge frequency\nfloat m1 = 0.5;    // Secondary ridge offset  \nfloat k1 = 0.15;   // Secondary ridge amplitude\n\nfloat n2 = 3.0;    // Tertiary ridge frequency\nfloat m2 = 0.5;    // Tertiary ridge offset\nfloat k2 = 0.1;    // Tertiary ridge amplitude\n\nfloat g = 0.6;     // Global size offset\nfloat p = 0.9;     // Vertical squash factor\nfloat h = -0.3;    // Top/bottom flattening\n\nfloat[40] sliderValues;\nbool[40] hasInteracted;\n\nfloat thickness = 0.02;    // Wall thickness for hollow effect\nfloat cutSphereRadius = 0.6; // Size of sphere to cut from top\nfloat cutSphereY = 0.5;    // Height of cutting sphere center\nfloat lidRaise = 0.0;      // How much to raise the lid\nfloat lidTiltX = 0.04;      // Tilt angle around X axis\nfloat lidTiltZ = 0.05;      // Tilt angle around Z axis\nfloat lidGap = 0.02;       // Gap between lid and opening\n\n// Stalk parameters (now adjustable via sliders)\nfloat stalkRadius = 0.04;   // Base radius of stalk\nint   stalkStarN = 10;      // Number of star points\nfloat stalkStarM = 2.5;     // Star sharpness (between 2 and n)\nfloat stalkHeight = 0.35;   // Total height of stalk\nfloat stalkTwist = 0.1;     // Twisting amount around Y axis\nfloat stalkBend = 0.1;      // Bending amount (vertical curvature)\nfloat stalkTaper = -1.2;    // Tapering factor (0 = no taper, 1 = full taper)\nfloat stalkBulbHeight = 0.22; // Height of bulbous base\nfloat stalkBulbRadius = 0.45; // Maximum radius of bulbous base\nfloat stalkHeightOffset = 0.0; //minor adjustment when it gets displaced.\n\n// Face cutout parameters\nfloat faceScale = 0.3;     // Size of face characters\nfloat faceDepth = 0.1;     // How deep the cut goes  \nfloat faceZ = 0.0;         // Z offset for face position\n\nfloat stemSubtract;\n\nfloat mouthSliderA = 0.5;        // number telling us which mouth to use\nfloat mouthSliderB = 0.5;       // number of second shape for interpolation\nfloat mouthSliderC = 0.5;       // interpolation value\nint mouthTypes = 10;       // number of possible mouths for slider bounds calculation\nfloat eyeSliderA = 0.5;       // interpolation value\nint eyeTypes = 8;       // number of possible eyes for slider bounds calculation\n\n// Slider parameters\nconst float sliderLineWidth = 0.003;   // Width of the slider line (smaller)\nconst float sliderCircleRadius = 0.012; // Radius of the slider circle (smaller)\nconst int totalSliders = 40;           // Total number of sliders\n\n// Simple hash function for deterministic random values\nfloat hash(float seed) {\n    return fract(sin(seed * 12.9898) * 43758.5453);\n}\n\n// Parameter mapping functions - convert 0-1 values to parameter ranges\nfloat mapLidRaise(float t) { return t * 0.5; }\nfloat mapLidTiltX(float t) { return (t - 0.5) * 0.4; }\nfloat mapLidTiltZ(float t) { return (t - 0.5) * 0.4; }\nfloat mapCutSphereY(float t) { return mix(0.2, 1.0, clamp(t, 0.0, 1.0)); }\nfloat mapCutSphereRadius(float t) { return mix(0.4, 0.7, clamp(t, 0.0, 1.0)); }\nfloat mapThickness(float t) { return mix(0.04, 0.08, clamp(t, 0.0, 1.0)); }\nfloat mapLidGap(float t) { return mix(0.0, 0.05, clamp(t, 0.0, 1.0)); }\nfloat mapMouthSliderA(float t) { return t; }\nfloat mapMouthSliderB(float t) { return t; }\nfloat mapMouthSliderC(float t) { return t; }\nfloat mapFaceScale(float t) { return mix(3.25, 4.5, clamp(t, 0.0, 1.0)); }\nfloat mapEyeSliderA(float t) { return t; }\nfloat mapSubsurfaceDistance(float t) { return mix(0.0001, 0.2, clamp(t, 0.0, 1.0)); }  // How far to probe into surface\nfloat mapSubsurfaceAttenuation(float t) { return mix(0.1, 10.0, clamp(t, 0.0, 1.0)); } // Light falloff strength\n\n// Camera/scene parameters (sliders 14-19, hardcoded in random mode)\nfloat mapFocal(float t) { return t * 2.0; }\nfloat mapBaseCameraDist(float t) { return mix(4.0, 10.0, clamp(t, 0.0, 1.0)); }\nfloat mapScreenMag(float t) { return (t < 0.5) ? mix(0.75, 2.0, t * 2.0) : mix(2.0, 3.0, (t - 0.5) * 2.0); }\nfloat mapPitch(float t) { return radians(mix(-89.0, 70.0, clamp(t, 0.0, 1.0))); }\nfloat mapYaw(float t) { return mix(-4.7123, 1.5708, clamp(t, 0.0, 1.0)); }\n\n// Stalk parameters (sliders 20-27)\nfloat mapStalkRadius(float t) { return mix(0.04, 0.1, clamp(t, 0.0, 1.0)); }\nfloat mapStalkStarN(float t) { return floor(mix(5.0, 20.0, clamp(t, 0.0, 1.0))); }\nfloat mapStalkStarM(float t) { return mix(1.8, 4.0, clamp(t, 0.0, 1.0)); }\nfloat mapStalkHeight(float t) { return mix(0.2, 0.5, clamp(t, 0.0, 1.0)); }\nfloat mapStalkTwist(float t) { return mix(0.0, 1.5, clamp(t, 0.0, 1.0)); }\nfloat mapStalkBend(float t) { return mix(0.0, 0.6, clamp(t, 0.0, 1.0)); }\nfloat mapStalkTaper(float t) { return mix(-0.5, 0.3, clamp(t, 0.0, 1.0)); }\nfloat mapStalkBulbHeight(float t) { return mix(0.1, 0.3, clamp(t, 0.0, 1.0)); }\n\n// Pumpkin shape parameters (sliders 28-39)\nfloat mapK2(float t) { return mix(0.02, 0.3, clamp(t, 0.0, 1.0)); }\nfloat mapM2(float t) { return mix(0.0, 6.28, clamp(t, 0.0, 1.0)); }\nfloat mapN2(float t) { return floor(mix(4.0, 12.0, clamp(t, 0.0, 1.0))); }\nfloat mapK1(float t) { return mix(0.02, 0.3, clamp(t, 0.0, 1.0)); }\nfloat mapM1(float t) { return mix(0.0, 6.28, clamp(t, 0.0, 1.0)); }\nfloat mapN1(float t) { return floor(mix(5.0, 30.0, clamp(t, 0.0, 1.0))); }\nfloat mapK0(float t) { return mix(0.02, 0.3, clamp(t, 0.0, 1.0)); }\nfloat mapM0(float t) { return mix(0.0, 3.14, clamp(t, 0.0, 1.0)); }\nfloat mapN0(float t) { return floor(mix(6.0, 60.0, clamp(t, 0.0, 1.0))); }\nfloat mapH(float t) { return mix(-0.3, -0.05, clamp(t, 0.0, 1.0)); }\nfloat mapP(float t) { return mix(0.5, 0.8, clamp(t, 0.0, 1.0)); }\nfloat mapG(float t) { return mix(0.5, 0.7, clamp(t, 0.0, 1.0)); }\n\n// Get parameter value - either from slider or random\nfloat getParamValue(int sliderIndex) {\n#ifdef USE_SLIDERS\n    return sliderValues[sliderIndex];\n#else\n    // For random mode, hardcode camera/scene values (sliders 14-19)\n    if (sliderIndex == 14) return 0.0;  // AA\n    if (sliderIndex == 15) return 0.5;  // Focal\n    if (sliderIndex == 16) return 0.5;  // Camera distance\n    if (sliderIndex == 17) return 0.5;  // Screen magnification\n    if (sliderIndex == 18) return 0.5 - (0.5-(iMouse.y/iResolution.y))/6.; ;  // Pitch\n    if (sliderIndex == 19) return 0.5 - (0.5-(iMouse.x/iResolution.x))/3.;  // Yaw\n    \n    // For other parameters, use deterministic random based on slider index\n    return hash(randomSeed + float(sliderIndex) * 0.1);\n    //return (0.5-range/2.) + (hash(randomSeed + float(sliderIndex) * 0.1))*range;\n#endif\n}\n\n// SDF Operations\nfloat opOnion(float sdf, float thickness) {\n    return abs(sdf) - thickness;\n}\n\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\n// Sphere SDF\nfloat sphereSDF(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\n// 2D Star SDF\nfloat sdStar(vec2 p, float r, int n, float m) {\n    // Precomputed values for given shape\n    float an = 3.141593 / float(n);\n    float en = 3.141593 / m;  // m is between 2 and n\n    vec2 acs = vec2(cos(an), sin(an));\n    vec2 ecs = vec2(cos(en), sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.y, p.x), 2.0 * an) - an;\n    p = length(p) * vec2(cos(bn), abs(sin(bn)));\n    p -= r * acs;\n    p += ecs * clamp(-dot(p, ecs), 0.0, r * acs.y / ecs.y);\n    return length(p) * sign(p.x);\n}\n\n// get 2D sdf data from font texture.\nfloat GetCharacter(ivec2 ch, vec2 cuv, float th) {\n    cuv = clamp(cuv, vec2(0), vec2(1));\n    float tx = (cuv.x/16.) + (float(ch.x)*(1./16.));\n    float ty = (cuv.y/16.) + (float(ch.y)*(1./16.));\n    return (-.5*th) + texture(iChannel1, vec2(tx, ty)).a;\n}\n\n// Single character 2D SDF for face cutting\nfloat char2DSDF(vec2 p, float scale, ivec2 ch) {\n    // Map world XY to [0,1] glyph UV, centered at origin\n    vec2 uv = p / scale + 0.5;\n    return GetCharacter(ch, uv, 1.0);\n}\n\n// Rotated character SDF\nfloat char2DSDFRotated(vec2 p, vec2 scale, ivec2 ch, float angle, float th) {\n    float c = cos(angle);\n    float s = sin(angle);\n    vec2 rotP = vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n    vec2 uv = rotP / scale + 0.5;\n    return GetCharacter(ch, uv, th);\n}\n\nfloat eyesSDF(vec2 p, float scale, int index) {\n\n    ivec2 echars = ivec2(0);\n    float erotation = 0.;\n    vec2  escale = vec2(2,1) * scale;\n    vec2  eoffset = vec2(0,-0.4) * scale;\n    float ethickness = 1.0;\n\n    switch (index) {\n        case 0:echars = ivec2(5,15);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );erotation = -3.141;break;\n        case 1:echars = ivec2(14,14);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );erotation = -3.141;break;\n        case 2:echars = ivec2(4,15);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );escale = vec2(1,1) * scale;erotation = -3.141;break;\n        case 3:echars = ivec2(3,15);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );escale = vec2(1,1) * scale;erotation = -3.141;break;\n        case 4:echars = ivec2(12,14);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );escale = vec2(1,1) * scale;erotation = -3.141;break;\n        case 5:echars = ivec2(10,13);eoffset += vec2(-0.5,-0.2)*scale;p.x = abs (p.x );erotation = -3.141;break;\n        case 6:echars = ivec2(11,13);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );erotation = -3.141;break;\n        case 7:echars = ivec2(12,13);eoffset += vec2(-0.4,-0.4)*scale;p.x = abs (p.x );escale = vec2(2) * scale;break;\n        case 8:echars = ivec2(5,15);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );erotation = -3.141;break;\n    }\n    return  char2DSDFRotated(p + eoffset, escale, echars, erotation, ethickness);\n}\n\nfloat mouthSDF(vec2 p, float scale, int index) {\n\n    ivec2 mchars = ivec2(0);\n    float mrotation = 0.;\n    vec2  mscale = vec2(2,1) * scale;\n    vec2  moffset = vec2(0,0.3) * scale;\n    float mthickness = 1.0;\n\n    switch (index) {\n        //-------mouth is single character\n        case 0:mchars = ivec2(6,10);p.x = abs(p.x)<0.5?(fract( p.x * 6.)-0.5)/3.:p.x;break;\n        case 1:mchars = ivec2(15,6);moffset += vec2(-0.4,0)*scale;p.x = abs (p.x );mrotation = -.2;break;\n        case 2:mchars = ivec2(7,8); break;\n        case 3:mchars = ivec2(7,10);break;\n        case 4: mchars = ivec2(13,10);mrotation = 1.57;mscale = vec2(1.2,1.5) * scale;moffset += vec2(-0.1,0)*scale;\n        break;   case 5: mchars = ivec2(13,8);mrotation = 1.57;mscale = vec2(1.2,1.5) * scale;moffset += vec2(-0.1,0)*scale;\n        break;   case 6: mchars = ivec2(9,13);mrotation = 1.57;mscale = vec2(1.2,1.5) * scale;moffset += vec2(-0.1,0)*scale;\n        break;   case 7: mchars = ivec2(8,13);mrotation = 1.57;mscale = vec2(1.2,1.5) * scale;moffset += vec2(-0.1,0)*scale;\n        break;   case 8: mchars = ivec2(11,10);mrotation = 1.57;mscale = vec2(1.2,1.5) * scale;moffset += vec2(-0.1,0)*scale; \n        break;   case 9: mchars = ivec2(6,10);p.x = abs(p.x)<0.35?(fract( p.x * 6.)-0.5)/3.:p.x;break; \n        break;  case 10:mchars = ivec2(6,10);p.x = abs(p.x)<0.65?(fract( p.x * 6.)-0.5)/3.:p.x;break;\n        break;  case 11: mchars = ivec2(15,5);moffset += vec2(0,0.3)*scale;\n        break;  case 12: mchars = ivec2(3,15);mscale = vec2(2.5,1) * scale;\n        break;  case 13: mchars = ivec2(3,15);mscale = vec2(1.5,1.5) * scale;\n    }\n    \n    return  char2DSDFRotated(p + moffset, mscale, mchars, mrotation, mthickness);\n}\n\n// Complete face SDF - combines all features\nfloat faceSDF(vec2 p, float scale) {\n\n    \n    float mouthA = mouthSDF(p, scale, int(floor(mouthSliderA * float(mouthTypes))));\n    float mouthB = mouthSDF(p, scale, 1+int(floor(mouthSliderA * float(mouthTypes))));\n    float mouthC = mouthSDF(p, scale, 13);\n    float mouthD = mouthSDF(p, scale, 12);\n    float mouthE = mouthSDF(p, scale, 11);\n    float mouth = mix(mouthA, mouthB, fract(mouthSliderA * float(mouthTypes)));\n    mouth -= (0.5-abs(fract(mouthSliderA * float(mouthTypes)) - 0.5))/15.;\n    float mouthF = mouthSliderB<0.5 ? mix(mouthC, mouthD, mouthSliderB*2.) : mix(mouthD, mouthE, (mouthSliderB-0.5)*1.6);\n    mouth = mix(mouth, mouthF, mouthSliderC);\n    \n    float eyesA = eyesSDF(p, scale, int(floor(eyeSliderA * float(eyeTypes))));\n    float eyesB = eyesSDF(p, scale, 1+int(floor(eyeSliderA * float(eyeTypes))));  \n    float eyes = mix(eyesA, eyesB, fract(eyeSliderA * float(eyeTypes)));\n    \n    return min(mouth, eyes);\n\n}\n\n\n// Extrude a 2D SDF along Z axis\nfloat extrudeSDF(vec3 pos, float char2D, float halfDepth) {\n    vec2 w = vec2(char2D, abs(pos.z) - halfDepth);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n// 3D Extrusion operation\nfloat opExtrusion(vec2 p, float h, float r, int n, float m) {\n    float d = sdStar(p, r, n, m);\n    vec2 w = vec2(d, abs(h) - stalkHeight * 0.5);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n// Twisting operation (rotates around Y axis as Y increases)\nvec3 opTwist(vec3 p, float k) {\n    float c = cos(k * p.y);\n    float s = sin(k * p.y);\n    return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\n// Bending operation (curves the stalk in the XZ plane)\nvec3 opBend(vec3 p, float k) {\n    float bendAmount = k * p.y * p.y / stalkHeight; // Quadratic bend for natural curve\n    return vec3(p.x + bendAmount, p.y, p.z);\n}\n\n\n\n// Rotation matrices\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(1.0, 0.0, 0.0,\n                0.0, c, -s,\n                0.0, s, c);\n}\n\nmat3 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c, -s, 0.0,\n                s, c, 0.0,\n                0.0, 0.0, 1.0);\n}\n\n// Convert Cartesian to spherical coordinates\nvec3 cartesianToSpherical(vec3 pos) {\n    float rho = length(pos);\n    float theta = atan(pos.z, pos.x);\n    float phi = acos(pos.y / rho);\n    return vec3(rho, theta, phi);\n}\n\n// The complex pumpkin equation converted to SDF\nfloat pumpkinSDF(vec3 pos) {\n    vec3 spherical = cartesianToSpherical(pos);\n    float theta = spherical.y;\n    float phi = spherical.z;\n    \n    // Use the constant parameters directly\n    \n    // Calculate the three sin terms\n    float sin_term0 = sin(n0 * theta + m0);\n    float sin_term1 = sin(n1 * theta + m1);\n    float sin_term2 = sin(n2 * theta + m2);\n    \n    // First part: sum of the three weighted sin terms\n    float part1 = (1.0 - pow(sin_term0, 4.0)) * (k0 / n0) +\n                  (1.0 - sin_term1) * (k1 / n1) +\n                  (1.0 - sin_term2) * (k2 / n2);\n    \n    // Second part: phi modulation\n    float cos_2phi = cos(2.0 * phi);\n    float part2 = pow((1.0 - cos_2phi) / 2.0, 2.0);\n    \n    // Third part: exponential and constant term\n    float part3 = exp(-pow(phi - 3.14159 / 2.0, 2.0)) + p;\n    \n    // Fourth part: cosine modulation\n    float part4 = 1.0 - h * cos_2phi;\n    \n    // Combine all parts to get the target radius\n    float target_rho = (part1 * part2 + g) * part3 * part4;\n    \n    // Return SDF: current distance - target distance\n    return length(pos) - target_rho;\n}\n\n// Stalk SDF - curved, twisted, tapered star extrusion\nfloat stalkSDF(vec3 pos) {\n    // Transform position to match the lid's transformation\n    vec3 stalkPos = pos;\n    \n    // Move to lid's raised position\n    stalkPos.y -= lidRaise;\n    \n    // Apply inverse rotations (same as lid, but in reverse order)\n    stalkPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * stalkPos;\n    \n    // Position stalk above the lid center (now in lid's local space)\n    stalkPos = stalkPos - vec3(0.0, stalkHeightOffset + (g * p *1.2) - (h/3.), 0.0);\n    \n    // Apply twisting (the existing \"bend\" that creates spiral ridges)\n    vec3 twistedPos = opTwist(stalkPos, stalkTwist / stalkHeight);\n    \n    // Apply bending (new vertical curvature)\n    vec3 bentPos = opBend(twistedPos, stalkBend / stalkHeight);\n    \n    // Calculate radius with both tapering and bulbous base\n    float heightFactor = clamp((bentPos.y) / stalkHeight, 0.0, 1.0);\n    \n    // Bulbous base effect - smooth falloff from bulb radius to normal radius\n    float bulbFactor = 1.0 - smoothstep(0.0, stalkBulbHeight, bentPos.y);\n    float bulbRadius = mix(stalkRadius, stalkBulbRadius, bulbFactor);\n    \n    // Apply tapering on top of bulb radius\n    float taperedRadius = bulbRadius * (1.0 - stalkTaper * heightFactor);\n    \n    // Create extruded star - star shape in XZ plane, extruded along Y\n    float starDist = sdStar(bentPos.xz, taperedRadius, stalkStarN, stalkStarM);\n    float heightDist = (abs(bentPos.y - stalkHeight * 0.5) - stalkHeight * 0.5);\n    \n    // Combine using extrusion formula\n    vec2 w = vec2(starDist, heightDist);\n    float stalkBase = min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n\n    // Only show stalk outside the original pumpkin surface\n    // use stemsubtract stored in lidSDF()\n    return opSubtraction(stemSubtract, stalkBase);\n}\n\n\n\n// Hollow pumpkin with top cut off\nfloat hollowPumpkinSDF(vec3 pos) {\n    // Get the base pumpkin shape\n    float pumpkin = pumpkinSDF(pos);\n    \n    // Make it hollow using onion operation\n    float hollow = opOnion(pumpkin, thickness);\n    \n    // Create cutting sphere at the top - slightly larger for the gap\n    vec3 cutSpherePos = pos - vec3(0.0, cutSphereY, 0.0);\n    float cuttingSphere = sphereSDF(cutSpherePos, cutSphereRadius + lidGap);\n    \n    // Subtract the sphere from the hollow pumpkin\n    return opSubtraction(cuttingSphere, hollow);\n}\n\n// Lid (the cut-off part) - raised and tilted\nfloat lidSDF(vec3 pos) {\n    // Transform position for the lid\n    vec3 lidPos = pos;\n    \n    // Move down to original position, apply rotations, then raise up\n    lidPos.y -= lidRaise;\n    lidPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * lidPos;\n    \n    // Get the base pumpkin shape\n    float pumpkin = pumpkinSDF(lidPos);\n    \n    stemSubtract = pumpkin;\n    \n    // Make it hollow\n    float hollow = opOnion(pumpkin, thickness);\n    \n    // Create cutting sphere - we want only the part that was cut off\n    vec3 cutSpherePos = lidPos - vec3(0.0, cutSphereY, 0.0);\n    float cuttingSphere = sphereSDF(cutSpherePos, cutSphereRadius);\n    \n    // Return only the intersection (the part that was inside the cutting sphere)\n    // We want the hollow pumpkin AND inside the cutting sphere\n    return max(hollow, cuttingSphere);\n}\n\n// Main scene SDF\nfloat sceneSDF(vec3 pos) {\n    float hollowPumpkin = hollowPumpkinSDF(pos);\n    float lid = lidSDF(pos);\n    float stalk = stalkSDF(pos);\n    \n    // Create complete face cutout\n    float faceShape = faceSDF(pos.xy, faceScale);\n    \n    vec3 facePos = pos - vec3(0.0, 0.0, faceZ);\n    float faceCutout = extrudeSDF(facePos, faceShape, faceDepth);\n    \n    // Subtract face cutout from hollow pumpkin only\n    hollowPumpkin = opSubtraction(faceCutout, hollowPumpkin);\n    \n    return opUnion(opUnion(hollowPumpkin, lid), stalk);\n}\n\n\n// Debug plane (world-space Z plane) helpers\nfloat rayPlaneIntersectZ(vec3 ro, vec3 rd, float planeZ) {\n    if (abs(rd.z) < 1e-4) return -1.0; // Parallel\n    return (planeZ - ro.z) / rd.z;\n}\n\nfloat rayPlaneIntersectX(vec3 ro, vec3 rd, float planeX) {\n    if (abs(rd.x) < 1e-4) return -1.0;\n    return (planeX - ro.x) / rd.x;\n}\n\nfloat rayPlaneIntersectY(vec3 ro, vec3 rd, float planeY) {\n    if (abs(rd.y) < 1e-4) return -1.0;\n    return (planeY - ro.y) / rd.y;\n}\n\nvec3 debugSDFColor(vec3 pos) {\n    float d = sceneSDF(pos);\n    vec3 col = (d > 0.0) ? vec3(0.9, 0.6, 0.3) : vec3(0.65, 0.85, 1.0);\n    col *= 1.0 - exp(-6.0 * abs(d));\n    col *= 0.8 + 0.2 * cos(150.0 * d);\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.005, abs(d)));\n    return col;\n}\nfloat getSliderLength(vec2 resolution) {\n    return resolution.x / 4.0; // 1/6 screen width\n}\n// Slider functions\nvec2 getSliderPosition(vec2 resolution, int sliderIndex) {\n    float spacing = sliderCircleRadius * 4.0 * resolution.y; // More spacing\n    bool leftSide = sliderIndex < 20;\n    int localIndex = leftSide ? sliderIndex : (sliderIndex - 20);\n    \n    float x = leftSide ? resolution.x * 0.02 : resolution.x * 0.98 - getSliderLength(resolution);\n    float y = resolution.y * 0.02 + float(localIndex) * spacing;\n    \n    return vec2(x, y);\n}\n\n\n\nvec4 getSliderState(vec2 resolution, int sliderIndex) {\n    // Read state from different pixels for each slider (8x5 grid)\n    int x = sliderIndex % 8;\n    int y = sliderIndex / 8;\n    vec2 pixelPos = vec2(float(x) + 0.5, float(y) + 0.5) / resolution;\n    return texture(iChannel0, pixelPos);\n}\n\nbool isInSliderHitArea(vec2 pos, vec2 sliderPos, float sliderLength, vec2 resolution) {\n    vec2 lineStart = sliderPos;\n    vec2 lineEnd = sliderPos + vec2(sliderLength, 0.0);\n    \n    // Expand hit area by circle radius\n    float clearance = sliderCircleRadius * resolution.y * 2.;\n    \n    return pos.x >= lineStart.x - clearance && \n           pos.x <= lineEnd.x + clearance &&\n           pos.y >= lineStart.y - clearance && \n           pos.y <= lineEnd.y + clearance;\n}\n\nfloat updateSliderValue(vec2 mousePos, vec2 sliderPos, float sliderLength) {\n    // Calculate value based on mouse position along the line\n    float t = (mousePos.x - sliderPos.x) / sliderLength;\n    return clamp(t, 0.0, 1.0);\n}\n\nint getActiveSlider(vec2 mousePos, vec2 resolution) {\n    float sliderLength = getSliderLength(resolution);\n    \n    for (int i = 0; i < totalSliders; i++) {\n        vec2 sliderPos = getSliderPosition(resolution, i);\n        if (isInSliderHitArea(mousePos, sliderPos, sliderLength, resolution)) {\n            return i;\n        }\n    }\n    return -1; // No slider hit\n}\n\nvec3 renderSliders(vec2 fragCoord, vec2 resolution, float sliderValues[40]) {\n    float sliderLength = getSliderLength(resolution);\n    \n    // Pixel-precise screen position\n    vec2 screenPos = fragCoord;\n    vec3 col1 = vec3(0);\n    vec3 col2 = vec3(0.5);\n    vec3 col3 = vec3(0.25);\n    vec3 col4 = vec3(0.7);\n    \n    // Calculate slider area boundaries\n    float spacing = sliderCircleRadius * 4.0 * resolution.y;\n    float leftStartX = (resolution.x * 0.02)-2.0;\n    float leftEndX = (leftStartX + sliderLength)+4.0;\n    float rightStartX = (resolution.x * 0.98 - sliderLength)-2.0;\n    float rightEndX = (resolution.x * 0.98)+2.0;\n    float startY = (resolution.y * 0.02)-2.0;\n    float maxY = startY  + 19.0 * spacing + 4.0; // 20 sliders (0-19), plus knob height for last slider\n    \n    // Early exit if not in any slider area\n    bool inLeftArea = (screenPos.x >= leftStartX && screenPos.x <= leftEndX);\n    bool inRightArea = (screenPos.x >= rightStartX && screenPos.x <= rightEndX);\n    if (!inLeftArea && !inRightArea) {\n        return vec3(-1.0); // Transparent (no slider)\n    }\n    if (screenPos.y < startY || screenPos.y > maxY) {\n        return vec3(-1.0); // Above or below slider area\n    }\n    \n    // Determine which slider we're potentially in\n    bool isLeftSide = inLeftArea;\n    float relativeY = screenPos.y - startY;\n    int localIndex = int(floor(relativeY / spacing));\n    \n    // Bounds check\n    if (localIndex < 0 || localIndex >= 20) {\n        return vec3(-1.0);\n    }\n    \n    int sliderIndex = isLeftSide ? localIndex : (localIndex + 20);\n    \n    // Now check if we're actually on this specific slider\n    //bool inactive = sliderIndex > 11 && sliderIndex < 14;\n    vec2 sliderPos = getSliderPosition(resolution, sliderIndex);\n    \n    // Convert to pixel-aligned coordinates\n    float xStart = floor(sliderPos.x + 0.5);\n    float xEnd   = floor(sliderPos.x + sliderLength + 0.5);\n    float yLine  = floor(sliderPos.y + 0.5);\n    vec2 circlePos = vec2(xStart + sliderValues[sliderIndex] * (xEnd - xStart), yLine + 0.5);\n    \n    // 2-pixel-high, pixel-precise line: match exactly two rows (yLine and yLine+1)\n    float row = floor(screenPos.y + 0.5);\n    bool onLine = (screenPos.x >= xStart && screenPos.x <= xEnd) &&\n                  (row == yLine || row == (yLine + 1.0));\n\n    // 4x4 black square knob centered on line (rows yLine-1..yLine+2)\n    float knobX = floor(circlePos.x + 0.5);\n    bool onKnob = (screenPos.x >= knobX - 2.0 && screenPos.x <= knobX + 1.0) &&\n                  (row >= (yLine - 1.0) && row <= (yLine + 2.0));\n    if (onKnob) {\n        //if(inactive){return col4;}\n        return col1;\n    }\n    if (onLine) {\n        //if(inactive){return col4;}\n        // Dark grey to the left of the knob, medium grey to the right\n        return (screenPos.x < circlePos.x) ? col3 : col2;\n    }\n    \n    return vec3(-1.0); // Transparent (no slider)\n}\n\n// Raymarching function\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 pos = ro + t * rd;\n        float d = sceneSDF(pos);\n        if (d < 0.0005) break;\n        t += d * .9; // Use smaller step for complex shapes\n        if (t > 50.0) break;\n    }\n    return t;\n}\n\n// Calculate normal using finite differences\nvec3 getNormal(vec3 pos) {\n    float eps = 0.001;\n    vec3 n = vec3(\n        sceneSDF(pos + vec3(eps, 0, 0)) - sceneSDF(pos - vec3(eps, 0, 0)),\n        sceneSDF(pos + vec3(0, eps, 0)) - sceneSDF(pos - vec3(0, eps, 0)),\n        sceneSDF(pos + vec3(0, 0, eps)) - sceneSDF(pos - vec3(0, 0, eps))\n    );\n    return normalize(n);\n}\n\n\n// Subsurface scattering\nfloat calculateSubsurface(vec3 pos, vec3 interiorLightPos, float probeDistance, float atten) {\n    vec3 toLightDir = normalize(interiorLightPos - pos);\n    float toLightDist = distance(interiorLightPos , pos);\n    vec3 probePos = pos + toLightDir * probeDistance;\n    float d = sceneSDF(probePos);\n    \n    // Only apply subsurface if we're actually inside the object\n    // and not just in free space\n    float surfaceDist = sceneSDF(pos);\n    if (surfaceDist > 0.001) return 0.0;  // We're not on the surface\n    \n    return clamp(max(0., (d*atten)/toLightDist), 0.0, 1.0);\n}\n\nvec3 lighting(vec3 pos, vec3 normal, vec3 viewDir, float subsurfaceDistance, float subsurfaceAttenuation, mat3 cameraMatrix) {\n    float flicker = 0.5 + hash(randomSeed) + 0.2 * sin(iTime * 37.0) + 0.15 * sin(iTime * 71.0) * (0.5 + hash(randomSeed));\n    \n    vec3 worldKeyLightDir = normalize( vec3(0,.7,1.) );  // Original direction\n    vec3 keyLightDir = normalize(cameraMatrix * worldKeyLightDir);  // Transform to camera space\n    vec3 keyLightColor = vec3(.8, 0.9, 1.0);\n\n    vec3 interiorLightPos = vec3(0.0, 0.15, 0.0);\n    vec3 interiorLightColor = vec3(1.2, .8, 0.2);\n    float interiorLightIntensity = flicker;\n    \n    vec3 ambient = vec3(0.4, 0.3, 0.2);\n\n    float keyDiff = max(dot(normal, keyLightDir), 0.0);\n    vec3 keyDiffuse = keyDiff * keyLightColor;\n    \n    vec3 keyReflectDir = reflect(-keyLightDir, normal);\n    float keySpec = pow(max(dot(viewDir, keyReflectDir), 0.0), 32.0);\n    vec3 keySpecular = keySpec * keyLightColor;\n    \n    vec3 toInteriorLight = interiorLightPos - pos;\n    float interiorLightDist = length(toInteriorLight);\n    vec3 interiorLightDir = toInteriorLight / interiorLightDist;\n    \n    float attenuation = interiorLightIntensity / (1.0 + 0.5 * interiorLightDist * interiorLightDist);\n\n    float interiorDiff = max(dot(normal, interiorLightDir), 0.0);\n    vec3 interiorDiffuse = interiorDiff * interiorLightColor * attenuation;\n    \n    vec3 diffuse = keyDiffuse + interiorDiffuse;\n    \n    float hollowDist = hollowPumpkinSDF(pos);\n    float lidDist = lidSDF(pos);\n    float stalkDist = stalkSDF(pos);\n    \n    vec3 materialColor;\n    float fleshSpecular = 1.0;\n    \n    if (stalkDist < hollowDist && stalkDist < lidDist) {\n        materialColor = vec3(0.36, 0.57, 0.13);\n    } else if (lidDist < hollowDist) {\n        vec3 lidPos = pos;\n        lidPos.y -= lidRaise;\n        lidPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * lidPos;\n        \n        float originalLidPumpkin = pumpkinSDF(lidPos);\n        float fleshDepth = max(0.0, -originalLidPumpkin + thickness);\n        \n        if (fleshDepth > 0.001) {\n            float depthFactor = clamp(fleshDepth / 0.1, 0.0, 1.0);\n            vec3 fleshColor = mix(vec3(1.2, 0.9, 0.4), vec3(0.8, 0.4, 0.1), depthFactor);\n            materialColor = fleshColor;\n            fleshSpecular = max(0., mix(0.8, 0.1, depthFactor * 20.));\n        } else {\n            materialColor = vec3(0.8, 0.4, 0.12);\n        }\n    } else {\n        float originalPumpkin = pumpkinSDF(pos);\n        float fleshDepth = max(0.0, -originalPumpkin + (thickness));\n        //shadow = clamp(10.* clamp(-originalPumpkin, 0.01, 10.5) * (1.-guv.x), 0., 0.6);\n\n        if (fleshDepth > 0.001) {\n            float depthFactor = clamp(fleshDepth / 0.1, 0.0, 1.0);\n            vec3 fleshColor = mix(vec3(1.2, 0.9, 0.4), vec3(0.8, 0.4, 0.1), depthFactor);\n\n            materialColor = fleshColor;\n            fleshSpecular = max(0., mix(0.8, 0.1, depthFactor * 20.));\n        } else {\n            materialColor = vec3(0.9, 0.45, 0.15);\n        }\n    }\n    \n    float subsurfaceDistance_val = calculateSubsurface(pos, interiorLightPos, subsurfaceDistance, subsurfaceAttenuation);\n    float subsurfaceFactor = subsurfaceDistance_val > 0.0 ? clamp(subsurfaceDistance_val, 0.0, 1.0) : 0.0;\n    vec3 subsurfaceLight = subsurfaceFactor * interiorLightColor;\n    \n    return (materialColor * (ambient + diffuse + subsurfaceLight) + fleshSpecular * keySpecular) ;\n}\n\n\n// Main function\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n#ifdef USE_SLIDERS\n    // Read current states\n    for (int i = 0; i < totalSliders; i++) {\n        vec4 state = getSliderState(iResolution.xy, i);\n        sliderValues[i] = state.r;\n        hasInteracted[i] = state.g > 0.25;\n        \n        // Default values before first interaction\n        if (!hasInteracted[i]) {\n            sliderValues[i] = 0.5;\n        }\n    }\n#else\n    // In random mode, set up random seed (could be based on time, mouse, etc.)\n    randomSeed = iMouse.x + (iMouse.y/iResolution.y);  // Change over time, or use iMouse.x for user control\n#endif\n    \n#ifdef USE_SLIDERS\n    // Check for mouse interaction\n    bool mouseDown = (iMouse.z > 0.0); // abs() the z value\n    vec2 currentMousePos = abs(iMouse.xy); // Use current position for dragging, abs() as requested\n    vec2 clickPos = abs(iMouse.zw); // Click position, abs() as requested\n    \n    if (mouseDown) {\n        // Use click position to determine which slider was initially clicked\n        int activeSlider = getActiveSlider(clickPos, iResolution.xy);\n        if (activeSlider >= 0) {\n            // But use current mouse position for the actual value update (allows dragging)\n            vec2 sliderPos = getSliderPosition(iResolution.xy, activeSlider);\n            float sliderLength = getSliderLength(iResolution.xy);\n            sliderValues[activeSlider] = updateSliderValue(currentMousePos, sliderPos, sliderLength);\n            hasInteracted[activeSlider] = true;\n        }\n    }\n#endif\n\n    // Parameter assignments using new mapping system\n    lidRaise = mapLidRaise(getParamValue(0));\n    lidTiltX = mapLidTiltX(getParamValue(1));\n    lidTiltZ = mapLidTiltZ(getParamValue(2));\n    cutSphereY = mapCutSphereY(getParamValue(3));\n    cutSphereRadius = mapCutSphereRadius(getParamValue(4));\n    thickness = mapThickness(getParamValue(5));\n    lidGap = mapLidGap(getParamValue(6));\n    mouthSliderA = mapMouthSliderA(getParamValue(7));\n    mouthSliderB = mapMouthSliderB(getParamValue(8));\n    mouthSliderC = mapMouthSliderC(getParamValue(9));\n    eyeSliderA = mapEyeSliderA(getParamValue(11));\n    \n    // Subsurface scattering parameters (sliders 12-13)\n    float subsurfaceDistance = mapSubsurfaceDistance(getParamValue(12));\n    float subsurfaceAttenuation = mapSubsurfaceAttenuation(getParamValue(13));\n    \n    // Camera/scene parameters (sliders 14-19)\n    float focal = mapFocal(getParamValue(15));\n    float baseCameraDist = mapBaseCameraDist(getParamValue(16));\n    \n    // Stalk parameters (sliders 20-27)\n    stalkRadius = mapStalkRadius(getParamValue(20));\n    stalkStarN = int(mapStalkStarN(getParamValue(21)));\n    stalkStarM = mapStalkStarM(getParamValue(22));\n    stalkHeight = mapStalkHeight(getParamValue(23));\n    stalkTwist = mapStalkTwist(getParamValue(24));\n    stalkBend = mapStalkBend(getParamValue(25));\n    stalkTaper = mapStalkTaper(getParamValue(26));\n    stalkBulbHeight = mapStalkBulbHeight(getParamValue(27));\n    \n    // Pumpkin shape parameters (sliders 28-39)\n    k2 = mapK2(getParamValue(28));\n    m2 = mapM2(getParamValue(29));\n    n2 = mapN2(getParamValue(30));\n    k1 = mapK1(getParamValue(31));\n    m1 = mapM1(getParamValue(32));\n    n1 = mapN1(getParamValue(33));\n    k0 = mapK0(getParamValue(34));\n    m0 = mapM0(getParamValue(35));\n    n0 = mapN0(getParamValue(36));\n    h = mapH(getParamValue(37));\n    p = mapP(getParamValue(38));\n    g = mapG(getParamValue(39));\n    \n    // Derived parameters\n    stalkBulbRadius = cutSphereRadius * 0.6;\n    stalkHeightOffset = 0.0; // not used currently\n    faceScale = g*(p+.3)*((h+1.)/3.)*mapFaceScale(getParamValue(10));\n    faceDepth = 1.1;// should be fixed here now.\n    faceZ = 1.1;// should be fixed here now.\n    \n    // Screen-space magnify (scene-only)\n    float screenMag = mapScreenMag(getParamValue(17));\n        \n    baseCameraDist /= pow(max(0.5,focal), 2.);\n    screenMag /= pow(max(0.5,focal), 2.);\n    \n    vec2 suv = uv; // Save original UV for UI rendering\n    vec2 uvScene = uv / screenMag; // Scene-only magnification\n    \n    // Camera\n    float yaw = mapYaw(getParamValue(19));\n    float pitch = mapPitch(getParamValue(18));\n\n    vec3 target = vec3(0.0, 0.35, 0.0);\n    vec3 dir = vec3(cos(pitch) * cos(yaw),\n                    sin(pitch),\n                    cos(pitch) * sin(yaw));\n    vec3 ro = target - dir * baseCameraDist;\n\n    vec3 forward = normalize(target - ro);\n    vec3 upRef = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(forward, upRef));\n    vec3 up = cross(right, forward);\n\n    // Camera to world matrix (inverse of view matrix rotation part)\n    mat3 cameraMatrix = mat3(right, up, -forward);\n    vec3 rd = normalize(forward + uvScene.x * right + uvScene.y * up);\n    \n    vec3 color = vec3(0.8,1.0,1.);//vec3(0.0);\n    \n    float t = raymarch(ro, rd);\n\n    if (t < 50.0){\n        vec3 pos = ro + t * rd;\n        vec3 normal = getNormal(pos);\n        vec3 viewDir = normalize(ro - pos);\n        color = lighting(pos, normal, viewDir, subsurfaceDistance, subsurfaceAttenuation, cameraMatrix);\n\n    } else {\n        // Background\n        color = vec3(0.6, 0.8,1.);\n    }\n    \n    // Gamma correction\n    //color = pow(color, vec2(1.0/2.2).xxx);\n    color = atan(color);\n    fragColor = vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) \n{ \n     \n    vec2 j = vec2(.5); \n    fragColor= vec4(0); \n    vec4 c; \n    mainImage0(c, fragCoord);\n    float s = 1.0 + floor(getParamValue(14) * 4.0);\n    float k;\n    for (k = s; k-- > .5; ) { \n        mainImage0(c, fragCoord + j - .5); \n        fragColor += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };fragColor /= s;fragColor.a==1.;\n    vec3 color = fragColor.rgb;\n    \n#ifdef USE_SLIDERS\n    // Render all sliders on top\n    vec3 sliderColor = renderSliders(fragCoord, iResolution.xy, sliderValues);\n    \n    if (sliderColor.x >= 0.0) {\n        color = sliderColor;\n    }\n    \n    // Write slider states to 8x5 pixel grid (40 sliders)\n    if (fragCoord.y < 5.0 && fragCoord.x < 8.0) {\n        int sliderIndex = int(fragCoord.x) + int(fragCoord.y) * 8;\n        if (sliderIndex < totalSliders) {\n            fragColor = vec4(sliderValues[sliderIndex], hasInteracted[sliderIndex] ? 0.5 : 0.0, 0.0, 1.0);\n        } else {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    } else {\n        fragColor = vec4(color, 1.0);\n    }\n#else\n    // Random mode - no sliders\n    fragColor = vec4(color, 1.0);\n#endif\n} ",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tc2fzW",
    "date": "1759084287",
    "viewed": 3,
    "name": "Pumpkin∞Möbius",
    "description": "I finally got around to making my own procedural pumpkin for the next version of the pumpkin carver.\nIt is based on this desmos pumpkin equation: [url]https://www.desmos.com/3d/afwrvhoa9n[/url]\nI thought I'd have some fun with it first.",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "procedural",
     "spiral",
     "halloween",
     "pumpkin",
     "moebius",
     "mbius",
     "october"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// SDF based on:   https://www.desmos.com/3d/afwrvhoa9n\n// Fork of \"Pumpkin Carver C du\"           by Nguyen2007. https://shadertoy.com/view/wcsBDl\n// Fork of \"Pumpkin Carver C\"                by Cotterzz. https://shadertoy.com/view/WfXBWf\n// Fork of \"Ortho Spiral Random shaders\"     by Cotterzz. https://shadertoy.com/view/WcsBWB\n// Fork of \"I heard yall like Ortho spiral?\" by frisk256. https://shadertoy.com/view/3fffRs\n\n// rewind or resize to change the random seed\n\n// AA setting in buffer B\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy, 0.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Simple hash function\nfloat hash(float seed) {\n    return fract(sin(seed * 12.9898) * 43758.5453);\n}\n\n// Get 2D sdf data from font texture\nfloat GetCharacter(ivec2 ch, vec2 cuv, float th) {\n    cuv = clamp(cuv, vec2(0), vec2(1));\n    float tx = (cuv.x/16.) + (float(ch.x)*(1./16.));\n    float ty = (cuv.y/16.) + (float(ch.y)*(1./16.));\n    return (-.5*th) + texture(iChannel0, vec2(tx, ty)).a;\n}\n\nfloat char2DSDFRotated(vec2 p, vec2 scale, ivec2 ch, float angle, float th) {\n    float c = cos(angle);\n    float s = sin(angle);\n    vec2 rotP = vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n    vec2 uv = rotP / scale + 0.5;\n    return GetCharacter(ch, uv, th);\n}\n\nfloat eyesSDF(vec2 p, float scale, int index) {\n    ivec2 echars = ivec2(0);\n    float erotation = 0.;\n    vec2 escale = vec2(2,1) * scale;\n    vec2 eoffset = vec2(0,-0.4) * scale;\n    float ethickness = 1.0;\n\n    switch (index) {\n        case 0: echars = ivec2(5,15); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); erotation = -3.141; break;\n        case 1: echars = ivec2(14,14); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); erotation = -3.141; break;\n        case 2: echars = ivec2(4,15); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); escale = vec2(1,1) * scale; erotation = -3.141; break;\n        case 3: echars = ivec2(3,15); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); escale = vec2(1,1) * scale; erotation = -3.141; break;\n        case 4: echars = ivec2(12,14); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); escale = vec2(1,1) * scale; erotation = -3.141; break;\n        case 5: echars = ivec2(10,13); eoffset += vec2(-0.5,-0.2)*scale; p.x = abs(p.x); erotation = -3.141; break;\n        case 6: echars = ivec2(11,13); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); erotation = -3.141; break;\n        case 7: echars = ivec2(12,13); eoffset += vec2(-0.4,-0.4)*scale; p.x = abs(p.x); escale = vec2(2) * scale; break;\n        case 8: echars = ivec2(5,15); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); erotation = -3.141; break;\n    }\n    return char2DSDFRotated(p + eoffset, escale, echars, erotation, ethickness);\n}\n\nfloat mouthSDF(vec2 p, float scale, int index) {\n    ivec2 mchars = ivec2(0);\n    float mrotation = 0.;\n    vec2 mscale = vec2(2,1) * scale;\n    vec2 moffset = vec2(0,0.3) * scale;\n    float mthickness = 1.0;\n\n    switch (index) {\n        case 0: mchars = ivec2(6,10); p.x = abs(p.x)<0.5?(fract(p.x * 6.)-0.5)/3.:p.x; break;\n        case 1: mchars = ivec2(15,6); moffset += vec2(-0.4,0)*scale; p.x = abs(p.x); mrotation = -.2; break;\n        case 2: mchars = ivec2(7,8); break;\n        case 3: mchars = ivec2(7,10); break;\n        case 4: mchars = ivec2(13,10); mrotation = 1.57; mscale = vec2(1.2,1.5) * scale; moffset += vec2(-0.1,0)*scale; break;\n        case 5: mchars = ivec2(13,8); mrotation = 1.57; mscale = vec2(1.2,1.5) * scale; moffset += vec2(-0.1,0)*scale; break;\n        case 6: mchars = ivec2(9,13); mrotation = 1.57; mscale = vec2(1.2,1.5) * scale; moffset += vec2(-0.1,0)*scale; break;\n        case 7: mchars = ivec2(8,13); mrotation = 1.57; mscale = vec2(1.2,1.5) * scale; moffset += vec2(-0.1,0)*scale; break;\n        case 8: mchars = ivec2(11,10); mrotation = 1.57; mscale = vec2(1.2,1.5) * scale; moffset += vec2(-0.1,0)*scale; break;\n        case 9: mchars = ivec2(6,10); p.x = abs(p.x)<0.35?(fract(p.x * 6.)-0.5)/3.:p.x; break;\n        case 10: mchars = ivec2(6,10); p.x = abs(p.x)<0.65?(fract(p.x * 6.)-0.5)/3.:p.x; break;\n        case 11: mchars = ivec2(15,5); moffset += vec2(0,0.3)*scale; break;\n        case 12: mchars = ivec2(3,15); mscale = vec2(2.5,1) * scale; break;\n        case 13: mchars = ivec2(3,15); mscale = vec2(1.5,1.5) * scale; break;\n    }\n    \n    return char2DSDFRotated(p + moffset, mscale, mchars, mrotation, mthickness);\n}\n\nfloat faceSDF(vec2 p, float scale, float mouthSliderA, float mouthSliderB, float mouthSliderC, float eyeSliderA) {\n    int mouthTypes = 10;\n    int eyeTypes = 8;\n    \n    float mouthA = mouthSDF(p, scale, int(floor(mouthSliderA * float(mouthTypes))));\n    float mouthB = mouthSDF(p, scale, 1+int(floor(mouthSliderA * float(mouthTypes))));\n    float mouthC = mouthSDF(p, scale, 13);\n    float mouthD = mouthSDF(p, scale, 12);\n    float mouthE = mouthSDF(p, scale, 11);\n    float mouth = mix(mouthA, mouthB, fract(mouthSliderA * float(mouthTypes)));\n    mouth -= (0.5-abs(fract(mouthSliderA * float(mouthTypes)) - 0.5))/15.;\n    float mouthF = mouthSliderB<0.5 ? mix(mouthC, mouthD, mouthSliderB*2.) : mix(mouthD, mouthE, (mouthSliderB-0.5)*1.6);\n    mouth = mix(mouth, mouthF, mouthSliderC);\n    \n    float eyesA = eyesSDF(p, scale, int(floor(eyeSliderA * float(eyeTypes))));\n    float eyesB = eyesSDF(p, scale, 1+int(floor(eyeSliderA * float(eyeTypes))));  \n    float eyes = mix(eyesA, eyesB, fract(eyeSliderA * float(eyeTypes)));\n    \n    return min(mouth, eyes);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // Check resolution change from top-left pixel\n    vec4 storedData = texture(iChannel1, vec2(0.5) / iResolution.xy);\n    float storedWidth = storedData.b * 4096.0;\n    float storedHeight = storedData.a * 4096.0;\n    bool resolutionChanged = abs(storedWidth - iResolution.x) > 0.5 || \n                            abs(storedHeight - iResolution.y) > 0.5;\n    if(fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n            fragColor = vec4(0.0, 0.0, iResolution.x / 4096.0, iResolution.y / 4096.0);\n            return;\n        }\n    // Redraw if first 2 frames OR resolution changed\n    if(iFrame < 2 || resolutionChanged) {\n        // Top-left pixel stores resolution metadata\n        \n        \n        vec2 cellCoord = floor(fragCoord / (iResolution.xy / vec2(8.0, 5.0)));\n        vec2 cellUV = fract(fragCoord / (iResolution.xy / vec2(8.0, 5.0)));   \n        vec2 p = (cellUV * 2.0 - 1.0) * 1.5;\n        float sec = mod(iDate.w,3600.);\n        float randomSeed = cellCoord.x + (cellCoord.y / 10.0) + sec;\n        float mouthSliderA = hash(randomSeed + 0.7);\n        float mouthSliderB = hash(randomSeed + 0.8);\n        float mouthSliderC = hash(randomSeed + 0.9);\n        mouthSliderC *= mouthSliderC*mouthSliderC*mouthSliderC; // bias to lower values\n        //mouthSliderC = 1.-mouthSliderC;\n        float eyeSliderA = hash(randomSeed + 1.1);\n        if(cellCoord==vec2(0)){\n            mouthSliderA = 0.6;\n            mouthSliderB = 0.7;\n            mouthSliderC = 0.5;\n            eyeSliderA = 0.37;\n        }\n        float scale = 1.0;\n        float dist = faceSDF(p, scale, mouthSliderA, mouthSliderB, mouthSliderC, eyeSliderA);\n        float mask = smoothstep(0.02, -0.02, dist);\n        \n        fragColor = vec4(dist * 0.5 + 0.5, mask, 0.0, 1.0);\n    } else {\n        // Keep previous frame\n        fragColor = texture(iChannel1, fragCoord.xy / iResolution.xy);\n    }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#define AA 1\n// set to 1 to disable antialiasing, higher numbers for smooth gfx at the expense of FPS.\n\nfloat randomSeed = 0.0;\nvec4 guv;\nvec2 cellID;\nfloat shadow = 0.;\n// Pumpkin shape parameters\nfloat n0, m0, k0, n1, m1, k1, n2, m2, k2;\nfloat g, p, h;\n\n// Lid parameters\nfloat thickness;\nfloat cutSphereRadius;\nfloat cutSphereY;\nfloat lidRaise;\nfloat lidTiltX;\nfloat lidTiltZ;\nfloat lidGap;\n\n// Stalk parameters\nfloat stalkRadius;\nint stalkStarN;\nfloat stalkStarM;\nfloat stalkHeight;\nfloat stalkTwist;\nfloat stalkBend;\nfloat stalkTaper;\nfloat stalkBulbHeight;\nfloat stalkBulbRadius;\nfloat stalkHeightOffset;\n\n// Face parameters\nfloat faceScale;\nfloat faceDepth;\nfloat faceZ;\nfloat stemSubtract;\nfloat mouthSliderA;\nfloat mouthSliderB;\nfloat mouthSliderC;\nfloat eyeSliderA;\nint mouthTypes = 10;\nint eyeTypes = 8;\n\n// Simple hash function\nfloat hash(float seed) {\n    return fract(sin(seed * 12.9898) * 43758.5453);\n}\nvec2 hash2(float n) {\n    return vec2(hash(n), hash(n * 1.7));\n}\n// Parameter mapping functions\nfloat mapParam(float t, float minVal, float maxVal) {\n    return mix(minVal, maxVal, t);\n}\n\nfloat mapFloor(float t, float minVal, float maxVal) {\n    return floor(mix(minVal, maxVal, clamp(t, 0.0, 1.0)));\n}\n\n// SDF Operations\nfloat opOnion(float sdf, float thickness) {\n    return abs(sdf) - thickness;\n}\n\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat sphereSDF(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\n// 2D Star SDF\nfloat sdStar(vec2 p, float r, int n, float m) {\n    float an = 3.141593 / float(n);\n    float en = 3.141593 / m;\n    vec2 acs = vec2(cos(an), sin(an));\n    vec2 ecs = vec2(cos(en), sin(en));\n\n    float bn = mod(atan(p.y, p.x), 2.0 * an) - an;\n    p = length(p) * vec2(cos(bn), abs(sin(bn)));\n    p -= r * acs;\n    p += ecs * clamp(-dot(p, ecs), 0.0, r * acs.y / ecs.y);\n    return length(p) * sign(p.x);\n}\n\nfloat faceSDF(vec2 p, float scale) {\n    // Calculate which cell in the atlas to use\n    vec2 atlasSize = vec2(8.0, 5.0);\n    vec2 atlasCellA = mod(cellID, atlasSize);\n    vec2 atlasCellB = mod(vec2(0), atlasSize);\n    // Convert p from world space to atlas UV space\n    vec2 atlasUVA = (p / scale + 1.0) * 0.5; // -1..1 to 0..1\n    atlasUVA = (atlasUVA + atlasCellA) / atlasSize;\n     // Convert p from world space to atlas UV space\n    vec2 atlasUVB = (p / scale + 1.0) * 0.5; // -1..1 to 0..1\n    atlasUVB = (atlasUVB + atlasCellB) / atlasSize;   \n    // Sample the pre-rendered face\n    vec4 tex = mix(texture(iChannel0, atlasUVB), texture(iChannel0, atlasUVA), guv.w);\n    float sdfValue = mix(1.- tex.g, tex.r, guv.w); // Use iChannel1 for Buffer A\n    \n    // Convert back from normalized range\n    return (sdfValue - 0.5) / 5.0;\n}\n\n// Extrude a 2D SDF along Z axis\nfloat extrudeSDF(vec3 pos, float char2D, float halfDepth) {\n    vec2 w = vec2(char2D, abs(pos.z) - halfDepth);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n// Twisting operation\nvec3 opTwist(vec3 p, float k) {\n    float c = cos(k * p.y);\n    float s = sin(k * p.y);\n    return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\n// Bending operation\nvec3 opBend(vec3 p, float k) {\n    float bendAmount = k * p.y * p.y / stalkHeight;\n    return vec3(p.x + bendAmount, p.y, p.z);\n}\n\n// Rotation matrices\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\n\nmat3 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n\n// Convert Cartesian to spherical coordinates\nvec3 cartesianToSpherical(vec3 pos) {\n    float rho = length(pos);\n    float theta = atan(pos.z, pos.x);\n    float phi = acos(pos.y / rho);\n    return vec3(rho, theta, phi);\n}\n\n// Pumpkin equation SDF\nfloat pumpkinSDF(vec3 pos) {\n    vec3 spherical = cartesianToSpherical(pos);\n    float theta = spherical.y;\n    float phi = spherical.z;\n    \n    float sin_term0 = sin(n0 * theta + m0);\n    float sin_term1 = sin(n1 * theta + m1);\n    float sin_term2 = sin(n2 * theta + m2);\n    \n    float part1 = (1.0 - pow(sin_term0, 4.0)) * (k0 / n0) +\n                  (1.0 - sin_term1) * (k1 / n1) +\n                  (1.0 - sin_term2) * (k2 / n2);\n    \n    float cos_2phi = cos(2.0 * phi);\n    float part2 = pow((1.0 - cos_2phi) / 2.0, 2.0);\n    float part3 = exp(-pow(phi - 3.14159 / 2.0, 2.0)) + p;\n    float part4 = 1.0 - h * cos_2phi;\n    \n    float target_rho = (part1 * part2 + g) * part3 * part4;\n    \n    return length(pos) - target_rho;\n}\n\n// Stalk SDF\nfloat stalkSDF(vec3 pos) {\n    vec3 stalkPos = pos;\n    stalkPos.y -= lidRaise;\n    stalkPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * stalkPos;\n    stalkPos = stalkPos - vec3(0.0, stalkHeightOffset + (g * p * 1.2) - (h/3.), 0.0);\n    \n    vec3 twistedPos = opTwist(stalkPos, stalkTwist / stalkHeight);\n    vec3 bentPos = opBend(twistedPos, stalkBend / stalkHeight);\n    \n    float heightFactor = clamp((bentPos.y) / stalkHeight, 0.0, 1.0);\n    float bulbFactor = 1.0 - smoothstep(0.0, stalkBulbHeight, bentPos.y);\n    float bulbRadius = mix(stalkRadius, stalkBulbRadius, bulbFactor);\n    float taperedRadius = bulbRadius * (1.0 - stalkTaper * heightFactor);\n    \n    float starDist = sdStar(bentPos.xz, taperedRadius, stalkStarN, stalkStarM);\n    float heightDist = (abs(bentPos.y - stalkHeight * 0.5) - stalkHeight * 0.5);\n    \n    vec2 w = vec2(starDist, heightDist);\n    float stalkBase = min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n\n    return opSubtraction(stemSubtract, stalkBase);\n}\n\n// Hollow pumpkin with top cut off\nfloat hollowPumpkinSDF(vec3 pos) {\n    float pumpkin = pumpkinSDF(pos);\n    float hollow = opOnion(pumpkin, thickness);\n    \n    vec3 cutSpherePos = pos - vec3(0.0, cutSphereY, 0.0);\n    float cuttingSphere = sphereSDF(cutSpherePos, cutSphereRadius + lidGap);\n    \n    return opSubtraction(cuttingSphere, hollow);\n}\n\n// Lid SDF\nfloat lidSDF(vec3 pos) {\n    vec3 lidPos = pos;\n    lidPos.y -= lidRaise;\n    lidPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * lidPos;\n    \n    float pumpkin = pumpkinSDF(lidPos);\n    stemSubtract = pumpkin;\n    \n    float hollow = opOnion(pumpkin, thickness);\n    \n    vec3 cutSpherePos = lidPos - vec3(0.0, cutSphereY, 0.0);\n    float cuttingSphere = sphereSDF(cutSpherePos, cutSphereRadius);\n    \n    return max(hollow, cuttingSphere);\n}\n\n// Main scene SDF\nfloat sceneSDF(vec3 pos) {\n    float hollowPumpkin = hollowPumpkinSDF(pos);\n    float lid = lidSDF(pos);\n    float stalk = stalkSDF(pos);\n    \n    float faceShape = faceSDF(pos.xy, faceScale*1.4);\n    vec3 facePos = pos - vec3(0.0, 0.0, faceZ);\n    float faceCutout = extrudeSDF(facePos, faceShape, faceDepth);\n    \n    hollowPumpkin = opSubtraction(faceCutout, hollowPumpkin);\n    \n    return opUnion(opUnion(hollowPumpkin, lid), stalk);\n}\n\n// Raymarching\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 pos = ro + t * rd;\n        float d = sceneSDF(pos);\n        if (d < 0.0005) break;\n        t += d * .9;\n        if (t > 50.0) break;\n    }\n    return t;\n}\n\n// Calculate normal\nvec3 getNormal(vec3 pos) {\n    float eps = 0.001;\n    vec3 n = vec3(\n        sceneSDF(pos + vec3(eps, 0, 0)) - sceneSDF(pos - vec3(eps, 0, 0)),\n        sceneSDF(pos + vec3(0, eps, 0)) - sceneSDF(pos - vec3(0, eps, 0)),\n        sceneSDF(pos + vec3(0, 0, eps)) - sceneSDF(pos - vec3(0, 0, eps))\n    );\n    return normalize(n);\n}\n\n// Subsurface scattering\nfloat calculateSubsurface(vec3 pos, vec3 interiorLightPos, float probeDistance) {\n    vec3 toLightDir = normalize(interiorLightPos - pos);\n    float toLightDist = distance(interiorLightPos , pos);\n    vec3 probePos = pos + toLightDir * (probeDistance + 0.15);\n    float d = sceneSDF(probePos);\n    \n    // Only apply subsurface if we're actually inside the object\n    // and not just in free space\n    float surfaceDist = sceneSDF(pos);\n    if (surfaceDist > 0.001) return 0.0;  // We're not on the surface\n    \n    return clamp(max(0., (d*3.)/(toLightDist*toLightDist)), 0.0, 1.0);\n}\n\nvec3 lighting(vec3 pos, vec3 normal, vec3 viewDir, float subsurfaceDistance, float subsurfaceAttenuation, mat3 cameraMatrix) {\n    float flicker = 0.5 + hash(randomSeed) + 0.2 * sin(iTime * 37.0) + 0.15 * sin(iTime * 71.0) * (0.5 + hash(randomSeed));\n    \n    vec3 worldKeyLightDir = normalize( mix(vec3(0,1,0) , vec3(-1.,.7,-1.) , guv.x) );  // Original direction\n    vec3 keyLightDir = normalize(cameraMatrix * worldKeyLightDir);  // Transform to camera space\n    vec3 keyLightColor = mix(vec3(1) ,vec3(.1, 0.7, 1.0), guv.x);\n\n    vec3 interiorLightPos = vec3(0.0, 0.0, 0.0);\n    vec3 interiorLightColor = vec3(1.2, .8, 0.2);\n    float interiorLightIntensity = mix( 0. , flicker , guv.w);\n    \n    vec3 ambient = vec3(0.7, 0.5, 0.4)-guv.w/2.5;\n\n    float keyDiff = max(dot(normal, keyLightDir), 0.0);\n    vec3 keyDiffuse = keyDiff * keyLightColor;\n    \n    vec3 keyReflectDir = reflect(-keyLightDir, normal);\n    float keySpec = pow(max(dot(viewDir, keyReflectDir), 0.0), 32.0);\n    vec3 keySpecular = keySpec * keyLightColor;\n    \n    vec3 toInteriorLight = interiorLightPos - pos;\n    float interiorLightDist = length(toInteriorLight);\n    vec3 interiorLightDir = toInteriorLight / interiorLightDist;\n    \n    float attenuation = interiorLightIntensity / (1.0 + 0.5 * interiorLightDist * interiorLightDist);\n\n    float interiorDiff = max(dot(normal, interiorLightDir), 0.0);\n    vec3 interiorDiffuse = interiorDiff * interiorLightColor * attenuation * guv.w;\n    \n    vec3 diffuse = keyDiffuse + interiorDiffuse;\n    \n    float hollowDist = hollowPumpkinSDF(pos);\n    float lidDist = lidSDF(pos);\n    float stalkDist = stalkSDF(pos);\n    \n    vec3 materialColor;\n    float fleshSpecular = 1.0;\n    \n    if (stalkDist < hollowDist && stalkDist < lidDist) {\n        materialColor = vec3(0.36, 0.57, 0.13);\n    } else if (lidDist < hollowDist) {\n        vec3 lidPos = pos;\n        lidPos.y -= lidRaise;\n        lidPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * lidPos;\n        \n        float originalLidPumpkin = pumpkinSDF(lidPos);\n        float fleshDepth = max(0.0, -originalLidPumpkin + thickness);\n        \n        if (fleshDepth > 0.001) {\n            float depthFactor = clamp(fleshDepth / 0.1, 0.0, 1.0);\n            vec3 fleshColor = mix(vec3(1.2, 0.9, 0.4), vec3(0.8, 0.4, 0.1), depthFactor);\n            materialColor = fleshColor;\n            fleshSpecular = max(0., mix(0.8, 0.1, depthFactor * 20.));\n        } else {\n            materialColor = vec3(0.8, 0.4, 0.12);\n        }\n    } else {\n        float originalPumpkin = pumpkinSDF(pos);\n        float fleshDepth = max(0.0, -originalPumpkin + (thickness));\n        shadow = clamp(7.* clamp(-originalPumpkin, 0.01, 10.5) * (1.-guv.w), 0., 0.6);\n\n        if (fleshDepth > 0.001) {\n            float depthFactor = clamp(fleshDepth / 0.1, 0.0, 1.0);\n            vec3 fleshColor = mix(vec3(1.2, 0.9, 0.4), vec3(0.8, 0.4, 0.1), depthFactor);\n\n            materialColor = fleshColor;\n            fleshSpecular = max(0., mix(0.8, 0.1, depthFactor * 20.));\n        } else {\n            materialColor = vec3(0.9, 0.45, 0.15);\n        }\n    }\n    \n    float subsurfaceDistance_val = calculateSubsurface(pos, interiorLightPos, subsurfaceDistance);\n    float subsurfaceFactor = subsurfaceDistance_val > 0.0 ? clamp(subsurfaceDistance_val, 0.0, 1.0) : 0.0;\n    vec3 subsurfaceLight = subsurfaceFactor * interiorLightColor * guv.w;\n    \n    return (materialColor * (ambient + diffuse + subsurfaceLight - shadow) + fleshSpecular * keySpecular) ;\n}\n\nfloat sinS(float x, float skip_count) {\n    float period_length = 2.0 * 3.14159265359;\n    float period_number = floor(x / period_length);\n    float period_mod = mod(period_number, skip_count);\n    \n    if (period_mod >= skip_count - 1.0) {\n        return -cos(x);\n    } else {\n        return -1.0;\n    }\n}\nvec2 simulateCursorOrganic(float time) {\n    float changeInterval = 2.0;\n    float currentIndex = floor(time / changeInterval);\n    \n    // Generate multiple waypoints for more complex paths\n    vec2 p0 = hash2(currentIndex - 1.0);\n    vec2 p1 = hash2(currentIndex);\n    vec2 p2 = hash2(currentIndex + 1.0);\n    vec2 p3 = hash2(currentIndex + 2.0);\n    \n    float localTime = fract(time / changeInterval);\n    \n    // Elastic easing for \"darting\" with slight overshoot\n    float t = localTime;\n    if (t < 0.3) {\n        // Quick dart phase\n        t = pow(t / 0.3, 2.0);\n    } else {\n        // Settle with slight oscillation\n        t = 1.0 - pow(1.0 - (t - 0.3) / 0.7, 3.0) * 0.05 * \n            cos((t - 0.3) * 20.0);\n    }\n    \n    // Catmull-Rom spline for smoother path\n    vec2 cursor = 0.5 * (\n        (2.0 * p1) +\n        (-p0 + p2) * t +\n        (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3) * t * t +\n        (-p0 + 3.0 * p1 - 3.0 * p2 + p3) * t * t * t\n    );\n    \n    return clamp(cursor, 0.0, 1.0);\n}\nvec3 mainImage1(vec2 uv, vec2 id) {\n    // Set random seed based on cell\n    randomSeed = id.x + (id.y / 10.);\n    \n    // Generate all parameters from random seed\n    float anim = (2. + randomSeed / 2.)*3.;\n    float anims = 10.;\n    float tiltPhase = 1. - fract(  ( (iTime - 0.1 + (anim * 3.)) * anims /15. ) / (2.0 * 3.14159265359)  );\n    tiltPhase *=tiltPhase;\n    lidRaise = mix(0., mapParam((sinS(   ((iTime + (anim * 3.)) * anims *2. ) , 30. ) + 1.), 0.03, 0.3)  , guv.w) ;\n    lidTiltX = mix(0., mapParam((sin(((iTime + anim * 3.) * anim)) + 1.) / 2., -0.2, 0.2)  , guv.w) * tiltPhase; \n    lidTiltX += lidRaise * 2.*(hash(randomSeed +3.)-0.5);\n    lidTiltZ = mix(0., mapParam((cos(((iTime + anim * 3.) * anim)) + 1.) / 2., -0.15, 0.15)  , guv.w) * tiltPhase;\n    lidTiltZ += lidRaise * 2.*(hash(randomSeed)-0.5);\n    uv.y -= guv.w * (sinS(((iTime + anim * 3.) * anims), 15.) + 1.)/10.;\n    \n    \n    //uv.y -= tiltPhase;\n    cutSphereY = mapParam(hash(randomSeed + 0.3), 0.5, 0.8);\n    cutSphereRadius = mapParam(hash(randomSeed + 0.4), 0.45, 0.6);\n    thickness = mapParam(hash(randomSeed + 0.5), 0.05, 0.06);\n    lidGap = mapParam(hash(randomSeed + 0.6), 0.0, 0.05);\n    \n    mouthSliderA = hash(randomSeed + 0.7);\n    mouthSliderB = hash(randomSeed + 0.8);\n    mouthSliderC = hash(randomSeed + 0.9);\n    eyeSliderA = hash(randomSeed + 1.1);\n    \n    float subsurfaceDistance = mapParam(hash(randomSeed + 1.2), 0.05, 0.08);\n    float subsurfaceAttenuation = mapParam(hash(randomSeed + 1.3), 0.2, 2.0);\n    \n    vec2 sMouse = simulateCursorOrganic(anim+iTime*anim/10.);\n    \n    // Camera parameters\n    float focal = 0.0;\n    float baseCameraDist = mapParam(0.1, 4.0, 10.0);\n    float screenMag = mapParam(1.0, 0.75, 3.0);\n    vec2 spooky = mix(vec2(0.5), sMouse, guv.w/2.);\n    float pitch = radians(mapParam(0.5 - (0.5 - spooky.y) / 3., -89.0, 70.0));\n    float yaw = mapParam(0.5 - (0.5 - spooky.x) / 3., -4.7123, 1.5708);\n    //float yaw = mapParam(0.5 - (guv.x-0.5)/10., -4.7123, 1.5708);\n    \n    // Stalk parameters\n    stalkRadius = mapParam(hash(randomSeed + 2.0), 0.04, 0.1);\n    stalkStarN = int(mapFloor(hash(randomSeed + 2.1), 5.0, 20.0));\n    stalkStarM = mapParam(hash(randomSeed + 2.2), 1.8, 4.0);\n    stalkHeight = mapParam(hash(randomSeed + 2.3), 0.3, 0.5);\n    stalkTwist = mapParam(hash(randomSeed + 2.4), 0.0, 1.5);\n    stalkBend = mapParam(hash(randomSeed + 2.5), 0.0, 0.4);\n    stalkTaper = mapParam(hash(randomSeed + 2.6), -0.5, 0.3);\n    stalkBulbHeight = mapParam(hash(randomSeed + 2.7), 0.1, 0.3);\n    \n    // Pumpkin shape parameters\n    k2 = mapParam(hash(randomSeed + 2.8), 0.02, 0.3);\n    m2 = mapParam(hash(randomSeed + 2.9), 0.0, 6.28);\n    n2 = mapFloor(hash(randomSeed + 3.0), 4.0, 12.0);\n    k1 = mapParam(hash(randomSeed + 3.1), 0.02, 0.3);\n    m1 = mapParam(hash(randomSeed + 3.2), 0.0, 6.28);\n    n1 = mapFloor(hash(randomSeed + 3.3), 5.0, 30.0);\n    k0 = mapParam(hash(randomSeed + 3.4), 0.02, 0.3);\n    m0 = mapParam(hash(randomSeed + 3.5), 0.0, 3.14);\n    n0 = mapFloor(hash(randomSeed + 3.6), 6.0, 60.0);\n    h = mapParam( mix( 0.35, hash(randomSeed + 3.7), guv.w ), -0.3, 0.05) + guv.w * (sinS(((iTime - 0.25 + (anim * 3.)) *anims* 2.), 30.) + 1.)/15.;\n    p = mapParam( mix( 0.5, hash(randomSeed + 3.8), guv.w ), 0.5, 0.8);\n    g = mapParam( mix( 0.5, hash(randomSeed + 3.9), guv.w ), 0.5, 0.7);\n    \n    // Derived parameters\n    stalkBulbRadius = cutSphereRadius * 0.6;\n    stalkHeightOffset = 0.0;\n    faceScale = g * (p + .3) * ((h + 1.) / 3.) * mapParam(hash(randomSeed + 1.0), 3.25, 4.5);\n    faceDepth = 1.3;\n    faceZ = 1.3;\n    \n    baseCameraDist /= pow(max(0.5, focal), 2.);\n    screenMag /= pow(max(0.5, focal), 2.);\n    \n    vec2 uvScene = uv / screenMag;\n    \n    // Camera setup\n    vec3 target = vec3(0.0, 0.35, 0.0);\n    vec3 dir = vec3(cos(pitch) * cos(yaw), sin(pitch), cos(pitch) * sin(yaw));\n    vec3 ro = target - dir * baseCameraDist;\n\n    vec3 forward = normalize(target - ro);\n    vec3 upRef = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(forward, upRef));\n    vec3 up = cross(right, forward);\n// Camera to world matrix (inverse of view matrix rotation part)\nmat3 cameraMatrix = mat3(right, up, -forward);\n    vec3 rd = normalize(forward + uvScene.x * right + uvScene.y * up);\n    \n    vec3 color = mix(vec3(0.8,1.0,1.), vec3(0.0), guv.y);\n    \n    float t = raymarch(ro, rd);\n\n    if (t < 50.0) {\n        vec3 pos = ro + t * rd;\n        vec3 normal = getNormal(pos);\n        vec3 viewDir = normalize(ro - pos);\n       color = lighting(pos, normal, viewDir, subsurfaceDistance, subsurfaceAttenuation, cameraMatrix);\n    }\n    \n    return color;\n}\n\nvoid compute_things(in vec2 p, out vec2 h, out vec2 ddx, out vec2 ddy) {\n    const float TAU = 6.28318530718;\n    const mat2 M = mat2(8.0, 5.0, -5.0, 8.0);\n\n    vec2 r = iResolution.xy;\n    vec2 s = sqrt(r / r.yx);\n    vec2 a = 2.0 / r * s;\n    vec2 u = a * p - s;\n    \n    float S = dot(u, u) + 1.0;\n    float invS = 1.0 / S;\n    float invS2 = invS * invS;\n\n    vec3 g = vec3(1.0, u.yx) * invS + vec3(-0.5, 0.0, 0.5);\n\n    float T = dot(g, g);\n    float invT = 1.0 / T;\n    float invT2 = invT * invT;\n\n    vec3 dg_dux = vec3(-2.0 * u.x * invS2, -2.0 * u.x * u.y * invS2, invS - 2.0 * u.x * u.x * invS2);\n    vec3 dg_duy = vec3(-2.0 * u.y * invS2, invS - 2.0 * u.y * u.y * invS2, -2.0 * u.x * u.y * invS2);\n\n    vec3 dg_dx = dg_dux * a.x;\n    vec3 dg_dy = dg_duy * a.y;\n\n    vec2 q = g.xy * invT;\n\n    float dTdx = 2.0 * dot(g, dg_dx);\n    float dTdy = 2.0 * dot(g, dg_dy);\n\n    vec2 dq_dx = dg_dx.xy * invT - g.xy * dTdx * invT2;\n    vec2 dq_dy = dg_dy.xy * invT - g.xy * dTdy * invT2;\n\n    float denom = dot(q, q);\n    float scale = 1.0 / (TAU * denom);\n\n    ddx = vec2(dq_dx.x * q.y - dq_dx.y * q.x, dot(dq_dx, q)) * scale;\n    ddy = vec2(dq_dy.x * q.y - dq_dy.y * q.x, dot(dq_dy, q)) * scale;\n\n    h = vec2(atan(q.x, q.y), log(length(q))) / TAU;\n    h += iTime * 0.04;\n\n    h *= M;\n    ddx *= M;\n    ddy *= M;\n}\n\nmat2 rotate(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage0(out vec4 c, vec2 p) {\n    \n    vec2 h, ddx, ddy;\n    compute_things(p, h, ddx, ddy);\n \n    float a = atan(ddx.x, ddy.x);\n    cellID = floor(h);\n    cellID = mod(cellID, vec2(8, 5));\n    vec2 cellUV = fract(h);\n    \n    vec2 uv = cellUV.yx * 2.0 - 1.0;\n    //uv = mix(  uv*rotate(3.2)  ,    uv*rotate(-a), guv.y*guv.y);\n    uv *= rotate(-a);\n    //uv *= rotate(2.6);\n    vec3 col = mainImage1(uv, cellID);\n    c = vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    //fragCoord*=1.5;\n    //fragCoord += iMouse.xy-iResolution.xy/2.;\n    vec2 uv =  fragCoord.xy/iResolution.xy;\n    guv.xy = uv;\n    guv = guv.xxxx;\n    guv.y /= 0.4;\n    guv.y -= .8;\n    guv.z /= 0.2;\n    guv.z -= 02.;\n   // uv.y+=(-.1 + (uv.x*.2));\n    guv.w = distance(uv, vec2(.0, .5));\n    if (uv.y<.5) {\n    guv.w = 1.-(distance(uv, vec2(1., .5)));\n    }\n    guv.y  = guv.w *2.;guv.y -=.3;\n    guv.w  = guv.w *6.;guv.w -=2.4;\n    guv = clamp(guv, vec4(0), vec4(1));\n    vec2 j = vec2(.5);\n    fragColor = vec4(0);\n    vec4 c;\n    mainImage0(c, fragCoord);\n    float s = float(AA);\n    float k;\n    for (k = s; k-- > .5;) {\n        mainImage0(c, fragCoord + j - .5);\n        fragColor += c;\n        j = fract(j + vec2(.755, .57).yx);\n    }\n    fragColor /= s;\n    fragColor.a = 1.;\n    \n    vec3 color = fragColor.rgb;\n    \n    color = atan(color);\n    fragColor = vec4(color, 1.0);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WcBBWW",
    "date": "1758604301",
    "viewed": 3,
    "name": "Root Sanctum Pumpkin",
    "description": "I tried...",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "pumpkin",
     "mashup"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xsf3Rr",
       "filepath": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Root Sanctum\" by diatribes. https://shadertoy.com/view/3c2fz1\n// 2025-09-23 05:08:47\n\n// Using function-scoped variables instead of defines\n\nbool hitRootRS = false;\n\nvec3 tex3DRS( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001);\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n\nfloat sminRS(float a, float b, float k){\n   float f = max(0., 0.5 - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n\nfloat fractalRS(vec3 p) {\n    float s,w,l;\n\n    p.y *= .4;\n    p += cos(p.yzx*12.)*.07;\n    p.x -= 1.6;\n    for (s=0.,w=.7; s++ < 7.; p *= l, w *= l )\n        p  = abs(sin(p))-1.,\n        l = 1.5/dot(p,p);\n\n    return length(p)/w-.0005;\n}\n\n\nvec3 PRS(float z) {\n    return vec3((cos(z * .2) * .3) * 10., \n                (cos(z * .15) * .3) * 10., z);\n}\n\nmat2 RRS(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat lightRS(vec3 p) {\n    // Simplified static light source instead of moving one\n    // Remove path dependency and make light position fixed\n    vec3 lightPos = vec3(0.0, 0.5, 2.0); // Fixed light position\n    return length(p - lightPos) - 0.25;\n}\n\nfloat rootRS(vec3 p){\n    p.xy *= RRS(sin(p.z*2.)*.1 + sin(p.z*1.)*.3);\n    p = mod(p, 1.) - .5;\n    return .6*length(p.xy) - .01;\n}\n\nfloat mapRS(vec3 p) {\n    float s, r;\n    r = rootRS(p);\n    \n    // Remove the path movement - make the landscape static\n    // p.xy -= PRS(p.z).xy;  // This was causing the movement\n    s = sminRS(fractalRS(p), 2. - abs(p.y), .8);\n    hitRootRS = r < s;\n    s = min(s, r);\n    return s;\n}\n\n// @iq - Rootsanctum version\nfloat AORS(in vec3 pos, in vec3 nor) {\n\tfloat sca = 1.9, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = mapRS(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvoid mainImageRoot(out vec4 o, in vec2 u, float pumpkinRot, float pumpkinDist) {\n    float s=.1,d=0.,i=0.;\n    vec3  res = iResolution;\n    u = (u-res.xy/2.)/res.y;\n    vec3  e = vec3(.001,0,0);\n    \n    // Convert pumpkin camera position to rootsanctum world coordinates\n    // Pumpkin camera at (dist*cos(rot), dist, dist*sin(rot))\n    vec3 pumpkinCamPos = vec3(pumpkinDist * cos(pumpkinRot), pumpkinDist, pumpkinDist * sin(pumpkinRot));\n    \n    vec3 rootWorldPos = pumpkinCamPos;\n    \n    // Use the converted position as camera origin\n    vec3 ro = rootWorldPos;\n    \n    // Create a simple camera system instead of following the complex path\n    vec3 target = vec3(0.0, 0.0, 0.0); // Look toward center\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    \n    vec3 D = normalize(forward + u.x * right + u.y * up);\n\n    o = vec4(0);\n    for(;i++ < 128.;){\n        vec3 p = ro + D * d * 0.75;\n        d += s = mapRS(p*1.5);\n        o += 4e1*vec4(6,9,1,0) / max(s, .001);\n        }\n        \n    vec3 hitPos = ro + D * d;\n    vec3 normal = normalize(mapRS(hitPos) - vec3(mapRS(hitPos-e.xyy), \n                                                 mapRS(hitPos-e.yxy), \n                                                 mapRS(hitPos-e.yyx)));\n    \n    o.rgb *= tex3DRS(iChannel0, hitPos*.5, normal);\n    o *= o;\n    o *= hitRootRS ? .2*vec4(4,3,2,0) : vec4(1);\n    o *= AORS(hitPos, normal);\n    o = tanh(sqrt(d * o / pow(abs(lightRS(hitPos)), 7.) / 5e9 ));\n}\n\n\n// Based on complex spherical equation from Desmos 3D\n// https://www.desmos.com/3d/afwrvhoa9n\n\n// Adjustable parameters for the pumpkin equation\n// Adjust these values to modify the shape\nconst float n0 = 20.0;   // Primary ridge frequency (higher = more ridges)\nconst float m0 = 0.0;    // Primary ridge offset\nconst float k0 = 0.1;    // Primary ridge amplitude\n\nconst float n1 = 20.0;    // Secondary ridge frequency\nconst float m1 = 0.0;    // Secondary ridge offset  \nconst float k1 = 0.15;   // Secondary ridge amplitude\n\nconst float n2 = 3.0;    // Tertiary ridge frequency\nconst float m2 = 0.0;    // Tertiary ridge offset\nconst float k2 = 0.1;    // Tertiary ridge amplitude\n\nconst float g = 0.5;     // Global size offset\nconst float p = 0.7;     // Vertical squash factor\nconst float h = 0.01;    // Top/bottom flattening\n\n// Additional parameters for hollowing and lid\nconst float thickness = 0.03;    // Wall thickness for hollow effect\nconst float cutSphereRadius = 0.6; // Size of sphere to cut from top\nconst float cutSphereY = 0.3;    // Height of cutting sphere center\nconst float lidRaise = 0.5;      // How much to raise the lid\nconst float lidTiltX = 0.3;      // Tilt angle around X axis\nconst float lidTiltZ = 0.1;      // Tilt angle around Z axis\n\n// SDF Operations\nfloat opOnion(float sdf, float thickness) {\n    return abs(sdf) - thickness;\n}\n\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\n// Sphere SDF\nfloat sphereSDF(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\n// Rotation matrices\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(1.0, 0.0, 0.0,\n                0.0, c, -s,\n                0.0, s, c);\n}\n\nmat3 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c, -s, 0.0,\n                s, c, 0.0,\n                0.0, 0.0, 1.0);\n}\n\n// Convert Cartesian to spherical coordinates\nvec3 cartesianToSpherical(vec3 pos) {\n    float rho = length(pos);\n    float theta = atan(pos.z, pos.x);\n    float phi = acos(pos.y / rho);\n    return vec3(rho, theta, phi);\n}\n\n// The complex pumpkin equation converted to SDF\nfloat pumpkinSDF(vec3 pos) {\n    vec3 spherical = cartesianToSpherical(pos);\n    float theta = spherical.y;\n    float phi = spherical.z;\n    \n    // Use the constant parameters directly\n    \n    // Calculate the three sin terms\n    float sin_term0 = sin(n0 * theta + m0);\n    float sin_term1 = sin(n1 * theta + m1);\n    float sin_term2 = sin(n2 * theta + m2);\n    \n    // First part: sum of the three weighted sin terms\n    float part1 = (1.0 - pow(sin_term0, 4.0)) * (k0 / n0) +\n                  (1.0 - sin_term1) * (k1 / n1) +\n                  (1.0 - sin_term2) * (k2 / n2);\n    \n    // Second part: phi modulation\n    float cos_2phi = cos(2.0 * phi);\n    float part2 = pow((1.0 - cos_2phi) / 2.0, 2.0);\n    \n    // Third part: exponential and constant term\n    float part3 = exp(-pow(phi - 3.14159 / 2.0, 2.0)) + p;\n    \n    // Fourth part: cosine modulation\n    float part4 = 1.0 - h * cos_2phi;\n    \n    // Combine all parts to get the target radius\n    float target_rho = (part1 * part2 + g) * part3 * part4;\n    \n    // Return SDF: current distance - target distance\n    return length(pos) - target_rho;\n}\n\n// Hollow pumpkin with top cut off\nfloat hollowPumpkinSDF(vec3 pos) {\n    // Get the base pumpkin shape\n    float pumpkin = pumpkinSDF(pos);\n    \n    // Make it hollow using onion operation\n    float hollow = opOnion(pumpkin, thickness);\n    \n    // Create cutting sphere at the top\n    vec3 cutSpherePos = pos - vec3(0.0, cutSphereY, 0.0);\n    float cuttingSphere = sphereSDF(cutSpherePos, cutSphereRadius);\n    \n    // Subtract the sphere from the hollow pumpkin\n    return opSubtraction(cuttingSphere, hollow);\n}\n\n// Lid (the cut-off part) - raised and tilted\nfloat lidSDF(vec3 pos) {\n    // Transform position for the lid\n    vec3 lidPos = pos;\n    \n    // Move down to original position, apply rotations, then raise up\n    lidPos.y -= lidRaise;\n    lidPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * lidPos;\n    \n    // Get the base pumpkin shape\n    float pumpkin = pumpkinSDF(lidPos);\n    \n    // Make it hollow\n    float hollow = opOnion(pumpkin, thickness);\n    \n    // Create cutting sphere - we want only the part that was cut off\n    vec3 cutSpherePos = lidPos - vec3(0.0, cutSphereY, 0.0);\n    float cuttingSphere = sphereSDF(cutSpherePos, cutSphereRadius);\n    \n    // Return only the intersection (the part that was inside the cutting sphere)\n    // We want the hollow pumpkin AND inside the cutting sphere\n    return max(hollow, cuttingSphere);\n}\n\n// Main scene SDF\nfloat sceneSDF(vec3 pos) {\n    float hollowPumpkin = hollowPumpkinSDF(pos);\n    float lid = lidSDF(pos);\n    \n    return opUnion(hollowPumpkin, lid);\n}\n\n// Ray-plane intersection for debug visualization (camera-relative)\nfloat rayPlaneIntersect(vec3 ro, vec3 rd, vec3 forward, float planeDistance) {\n    float denom = dot(rd, forward);\n    if (abs(denom) < 0.001) return -1.0; // Ray parallel to plane\n    return planeDistance / denom;\n}\n\n// Raymarching function\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 pos = ro + t * rd;\n        float d = sceneSDF(pos);\n        if (d < 0.001) break;\n        t += d * 0.8; // Use smaller step for complex shapes\n        if (t > 20.0) break;\n    }\n    return t;\n}\n\n// Calculate normal using finite differences\nvec3 getNormal(vec3 pos) {\n    float eps = 0.001;\n    vec3 n = vec3(\n        sceneSDF(pos + vec3(eps, 0, 0)) - sceneSDF(pos - vec3(eps, 0, 0)),\n        sceneSDF(pos + vec3(0, eps, 0)) - sceneSDF(pos - vec3(0, eps, 0)),\n        sceneSDF(pos + vec3(0, 0, eps)) - sceneSDF(pos - vec3(0, 0, eps))\n    );\n    return normalize(n);\n}\n\n// Enhanced lighting function with material detection\nvec3 lighting(vec3 pos, vec3 normal, vec3 viewDir) {\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 lightColor = vec3(1.0, 0.9, 0.8);\n    \n    // Ambient\n    vec3 ambient = vec3(0.1, 0.15, 0.2);\n    \n    // Diffuse\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * lightColor;\n    \n    // Specular\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    vec3 specular = spec * lightColor;\n    \n    // Determine material based on which part we're on\n    float hollowDist = hollowPumpkinSDF(pos);\n    float lidDist = lidSDF(pos);\n    \n    vec3 materialColor;\n    if (lidDist < hollowDist) {\n        // Lid material - slightly different color\n        materialColor = vec3(0.9, 0.5, 0.15);\n    } else {\n        // Main pumpkin body\n        materialColor = vec3(1.0, 0.6, 0.2);\n    }\n    \n    return materialColor * (ambient + diffuse) + specular;\n}\n\n// Main function with split screen\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    bool rightHalf = fragCoord.x > iResolution.x * 0.5;\n\n    float rot = (iMouse.x/iResolution.x*4.)-2.0;\n    float dist = (iMouse.y/iResolution.y)*3.;\n    \n    if (rightHalf) {\n        // Right side: Rootsanctum shader\n        vec4 rootResult;\n        mainImageRoot(rootResult, fragCoord, rot, dist);\n        fragColor = rootResult;\n    } else {\n        // Left side: Pumpkin shader\n        vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n        \n        vec3 ro = vec3(dist * cos(rot), dist, dist * sin(rot));\n        vec3 target = vec3(0.0, 0.0, 0.0);\n        vec3 up = vec3(0.0, 1.0, 0.0);\n        \n        vec3 forward = normalize(target - ro);\n        vec3 right = normalize(cross(forward, up));\n        up = cross(right, forward);\n        \n        vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n        \n        vec3 color = vec3(0.0);\n        \n        // Regular raymarch\n        float t = raymarch(ro, rd);\n        \n        // Render based on what we hit\n        if (t < 20.0) {\n            vec3 pos = ro + t * rd;\n            vec3 normal = getNormal(pos);\n            vec3 viewDir = normalize(ro - pos);\n            color = lighting(pos, normal, viewDir);\n            \n            // Add atmospheric perspective\n            float fog = 1.0 - exp(-t * 0.1);\n            color = mix(color, vec3(0.5, 0.7, 1.0), fog * 0.3);\n        } else {\n            // Background gradient\n            color = mix(vec3(0.2, 0.3, 0.5), vec3(0.5, 0.7, 1.0), uv.y * 0.5 + 0.5);\n        }\n        \n        // Gamma correction\n        color = pow(color, vec2(1.0/2.2).xxx);\n        fragColor = vec4(color, 1.0);\n    }\n    \n\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3cBfDw",
    "date": "1758650315",
    "viewed": 317,
    "name": "Pumpkin Carver V1",
    "description": "Carve your own pumpkin, see code for instructions and info.\nThanks to Diatribes for the Sky and TheTurk for the 3D noise",
    "likes": 42,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "raymarch",
     "sdf",
     "halloween",
     "pumpkin",
     "october",
     "jackolantern"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// ABOUT\n// I wanted to make an interactive pumpkin carving shader for halloween.\n// This is my first attempt at a basic prototype, and it went a lot further than originally planned.\n// Using a drawn texture to postively displace a sphere SDF and then subtracting that from the main pumpkin.\n// The texture also provides an easy route to volumetric light.\n// --\n// It was a lot of fun to make and as a prototype/proof of concept it's a success that turned out better than expected\n// However - it has plenty of issues and will benefit from a complete rebuild.\n// Performance, compile time, messy code, untidy carve subtraction and the overall scene rendering could all be improved a lot.\n// --\n// I'm now working on the next version.\n\n// LICENSE\n// Permission required for use outside shadertoy.\n\n\n// INSTRUCTIONS\n// Click and drag on pumpkin to carve.\n// Select mirror mode (second button down on the left) to draw symmetrical patterns.\n// Inverse mode to draw/fill pumpkin back in.\n// Inverse mirror for both.\n// Top button to set back to regualr carving.\n// Brush size slider on the left.\n// FPS indicator top right, blue/green is good, red is bad, adjust quality settings.\n// Quality settings on the bottom right, Antialiasing, volumetric light, smoke and skies.\n// up is higher quality but more GPU intensive.\n// Watch the FPS indicator, you really need it in the green (55+ frames per second) if possible.\n// Right-click and save-as to save image, hit rewind to reset.\n\n\n// ---- Fast Improved Perlin Noise by TheTurk: https://www.shadertoy.com/view/slB3z3\n\nuint hash(uint x, uint seed) {\n    const uint m = 0x5bd1e995U;uint h = seed;uint k = x;k *= m;k ^= k >> 24;\n    k *= m;h *= m;h ^= k;h ^= h >> 13;h *= m;h ^= h >> 15;return h;\n}\n\nuint hash(uvec3 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint h = seed;uint k = x.x; \n    k *= m;k ^= k >> 24;k *= m;h *= m;h ^= k;\n    k = x.y;k *= m;k ^= k >> 24;k *= m;h *= m;h ^= k;\n    k = x.z;k *= m;k ^= k >> 24;k *= m;h *= m;h ^= k;\n    h ^= h >> 13;h *= m;h ^= h >> 15;\n    return h;\n}\n\nvec3 gradientDirection(uint hash) {\n    vec3 r = vec3(0,1,-1);switch (int(hash) & 15) {\n    case 0:return r.yyx;case 1:return r.zxy;\n    case 2:return r.yzx;case 3:return r.zzx;\n    case 4:return r.yyx;case 5:return r.zxy;\n    case 6:return r.yxz;case 7:return r.zxz;\n    case 8:return r.xyy;case 9:return r.xzy;\n    case 10:return r.xzz;case 11:return r.xyz;\n    case 12:return r.yyx;case 13:return r.zxy;\n    case 14:return r.xzy;case 15:return r.xzz;\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, float value5, float value6, float value7, float value8, vec3 t) {\n    return mix(mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y),mix(mix(value5, value6, t.x), mix(value7, value8, t.x), t.y), t.z);\n}\n\nvec3 fade(vec3 t) {return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);}\n\nfloat perlinNoise(vec3 position, uint seed) {\n    vec3 floorPosition = floor(position);\n    vec3 fractPosition = position - floorPosition;\n    uvec3 cellCoordinates = uvec3(floorPosition);\n    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 0)), seed)), fractPosition - vec3(1, 0, 0));\n    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 0)), seed)), fractPosition - vec3(0, 1, 0));\n    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 0)), seed)), fractPosition - vec3(1, 1, 0));\n    float value5 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 0, 1)), seed)), fractPosition - vec3(0, 0, 1));\n    float value6 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 1)), seed)), fractPosition - vec3(1, 0, 1));\n    float value7 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 1)), seed)), fractPosition - vec3(0, 1, 1));\n    float value8 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 1)), seed)), fractPosition - vec3(1, 1, 1));\n    return interpolate(value1, value2, value3, value4, value5, value6, value7, value8, fade(fractPosition));\n}\n\nfloat perlinNoise(vec3 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;float amplitude = 1.0;float currentFrequency = float(frequency);uint currentSeed = seed;\n    for (int i = 0; i < octaveCount; i++) {\n        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;currentFrequency *= lacunarity;\n    }\n    return value;\n}\n\n\n// --- Main Shader Code by Cotterzz\n\nint AA = 0;\nint VOLUMETRIC = 2;\nint SMOKE = 2;\nint SKIES = 2;\n\n// store rd and ro for volumetric without AA\nvec3 sro;\nvec3 srd;\n\n// UI Helper functions\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat drawSquiggly(vec2 p, bool mirrored) {\n    if (mirrored) p.x = -p.x;\n    \n    // Smaller squiggly line\n    float y = sin(p.x * 190.0) * 0.007;\n    float line = abs(p.y - y) - 0.002;\n    return line;\n}\n\n// Draw mode button - returns color mixing factor\nvec3 drawModeButton(vec2 uv, vec2 center, bool invers, bool mirrored, bool selected) {\n    // Button color scheme\n    vec3 regularColor = vec3(0.5, 0.2, 0.0);\n    vec3 inverseColor = vec3(1.0, 1.0, 0.5);\n    \n    vec2 p = uv - center;\n    float buttonSize = 0.048; // 60% of 0.08\n    \n    // Main circle\n    float mainCircle = sdCircle(p, buttonSize);\n    \n    // Selection highlight\n    float highlight = selected ? sdCircle(p, buttonSize + 0.006) : 1.0; // 60% of 0.01\n    \n    // Return background if outside button\n    if (mainCircle > 0.0 && (!selected || highlight > 0.0)) {\n        return vec3(-1.0); // Signal: no button here\n    }\n    \n    // Selection highlight (blue border)\n    if (selected && highlight < 0.0 && mainCircle > 0.0) {\n        return vec3(0.3, 0.5, 1.0); // Blue highlight\n    }\n    \n    // Button interior\n    if (mainCircle < 0.0) {\n        \n        if (mirrored) {\n            // Mirror mode: show two sets of icons with center line\n            \n            // Thinner center mirror line\n            float centerLine = abs(p.x) - 0.0006; // 60% of 0.001\n            if (centerLine < 0.0) {\n                return invers ? regularColor : inverseColor; // Mirror line color\n            }\n            \n            // Left side icons\n            vec2 leftOffset = vec2(-0.021, 0.024); // 60% scaling\n            float leftSmallCircle = sdCircle(p - leftOffset, 0.007); // 60% of 0.012\n            \n            // Left squiggly line - only on left side\n            vec2 leftSquigglyPos = p - vec2(-0.021, 0); // 60% of -0.035\n            float leftSquiggly = drawSquiggly(leftSquigglyPos.yx, false);\n            // Clip squiggly to left side only\n            if (leftSquigglyPos.y > 0.021) leftSquiggly = 1.0; // 60% of 0.035\n            \n            // Right side icons (mirrored)\n            vec2 rightOffset = vec2(0.021, 0.024); // 60% scaling\n            float rightSmallCircle = sdCircle(p - rightOffset, 0.007); // 60% of 0.012\n            \n            // Right squiggly line - only on right side\n            vec2 rightSquigglyPos = p - vec2(0.021, 0); // 60% of 0.035\n            float rightSquiggly = drawSquiggly(rightSquigglyPos.yx, true);\n            // Clip squiggly to right side only\n            if (rightSquigglyPos.y > 0.021) rightSquiggly = 1.0; // 60% of 0.035\n            \n            // Check for any icon element\n            if (leftSmallCircle < 0.0 || rightSmallCircle < 0.0 || \n                leftSquiggly < 0.0 || rightSquiggly < 0.0) {\n                return invers ? regularColor : inverseColor; // Icon color\n            }\n            \n        } else {\n            // Regular mode: single set of icons\n            \n            // Small circle\n            vec2 smallOffset = vec2(0.018, 0.012); // 60% scaling\n            float smallCircle = sdCircle(p - smallOffset, 0.009); // 60% of 0.015\n            \n            // Squiggly line\n            vec2 squigglyPos = p - vec2(0.0, 0.012); // 60% of 0.02\n            float squiggly = drawSquiggly(squigglyPos, false);\n            if (squigglyPos.x > 0.021) squiggly = 1.0; // 60% of 0.035\n            // Check for icon elements\n            if (smallCircle < 0.0 || squiggly < 0.0) {\n                return invers ? regularColor : inverseColor; // Icon color\n            }\n        }\n        \n        // Main button background\n        return invers ? inverseColor : regularColor;\n    }\n    \n    return vec3(-1.0); // No button\n}\n\n// Draw quality slider - returns color\nvec3 drawQualitySlider(vec2 uv, vec2 center, float value, bool selected) {\n    vec2 p = uv - center;\n    \n    // Slider track (vertical)\n    float trackWidth = 0.008;\n    float trackHeight = 0.08;\n    float track = max(abs(p.x) - trackWidth, abs(p.y) - trackHeight);\n    \n    // Slider button (square, positioned based on value 0-4)\n    float buttonY = (value / 4.0 - 0.5) * trackHeight * 1.8;\n    vec2 buttonPos = vec2(0.0, buttonY);\n    float buttonSize = 0.012;\n    float button = max(abs(p.x - buttonPos.x) - buttonSize, abs(p.y - buttonPos.y) - buttonSize);\n    \n    if (track < 0.0 && button > 0.0) {\n        return vec3(0.3, 0.3, 0.3); // Track color\n    }\n    \n    if (button < 0.0) {\n        return selected ? vec3(0.2, 0.6, 1.0) : vec3(0.8, 0.8, 0.8); // Button color\n    }\n    \n    return vec3(-1.0); // No slider\n}\n\n// Draw brush slider - returns color  \nvec3 drawBrushSlider(vec2 uv, vec2 center, float brushSize, bool selected) {\n    vec2 p = uv - center;\n    \n    // Slider track (vertical)\n    float trackWidth = 0.008;\n    float trackHeight = 0.15;\n    float track = max(abs(p.x) - trackWidth, abs(p.y) - trackHeight);\n    \n    // Map brush size (0.03 to 0.15) to slider position\n    float normalizedSize = (brushSize - 0.03) / (0.15 - 0.03);\n    float buttonY = (normalizedSize - 0.5) * trackHeight * 1.8;\n    \n    // Round button that scales with brush size\n    vec2 buttonPos = vec2(0.0, buttonY);\n    float buttonRadius = 0.008 + (normalizedSize * 0.015); // Grows with brush size\n    float button = length(p - buttonPos) - buttonRadius;\n    \n    // Larger hit area for interaction (but don't show visually)\n    float hitRadius = max(buttonRadius, 0.025); // Minimum hit area\n    float hitArea = length(p - buttonPos) - hitRadius;\n    \n    if (track < 0.0 && button > 0.0) {\n        return vec3(0.3, 0.3, 0.3); // Track color\n    }\n    \n    if (button < 0.0) {\n        return selected ? vec3(0.2, 0.6, 1.0) : vec3(0.8, 0.8, 0.8); // Button color\n    }\n    \n    return vec3(-1.0); // No slider\n}\n\n// Draw FPS indicator\nvec3 drawFPSIndicator(vec2 uv, vec2 center, float fps) {\n    vec2 p = uv - center;\n    float size = 0.01;\n    \n    if (abs(p.x) < size && abs(p.y) < size) {\n        // Color code based on FPS\n        if (fps >= 100.0) return vec3(0.4, 0.8, 1.0);      // Light blue\n        else if (fps >= 55.0) return vec3(0.0, 1.0, 0.0);  // Green\n        else if (fps >= 25.0) return vec3(1.0, 1.0, 0.0);  // Yellow\n        else if (fps >= 15.0) return vec3(1.0, 0.5, 0.0);  // Orange\n        else return vec3(1.0, 0.0, 0.0);                   // Red\n    }\n    \n    return vec3(-1.0); // No indicator\n}\n\n// Sample the carving texture\nfloat getCarvingDepth(vec3 p) {\n\n    vec3 np = normalize(p);\n    float theta = atan(np.z, np.x);\n    float phi = acos(clamp(np.y, -1.0, 1.0));\n    vec2 uv;\n    uv.x = (theta + 3.14159) / (2.0 * 3.14159);\n    uv.y = 1.0 - phi / 3.14159;\n    return texture(iChannel0, uv).r;\n}\n\n// Utility functions\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\nvec2 fold(vec2 p,float s){float a=3.142/s-atan(p.x,p.y),n=6.283/s;p*=rot(floor(a/n)*n);return p;}\nfloat sminCubic(float a,float b,float k){float h=max(k-abs(a-b),0.)/k;return min(a,b)-h*h*h*k*(1./6.);}\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// SDF functions\nfloat sdTorus(vec3 p,vec2 t){return length(vec2(length(p.yz)-t.x,p.x))-t.y;}\nfloat sdCube(vec3 p){vec3 q=abs(p)-.5;return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);}\nfloat sdCappedCylinder(vec3 p,float h,float r){vec2 d=abs(vec2(length(p.xz),p.y))-vec2(h,r);return min(max(d.x,d.y),0.)+length(max(d,0.));}\nfloat sdEllipsoid(vec3 p, vec3 r) {\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// Realistic pumpkin shape with ridges\nfloat sdPumpkin(vec3 p, float r) {\n    // Main pumpkin body - flattened sphere\n    vec3 bodyScale = vec3(1.0, 0.85, 1.0);\n    float body = sdEllipsoid(p, bodyScale * r);\n    \n    // Add vertical ridges\n    float angle = atan(p.z, p.x);\n    float ridgeCount = 12.0;\n    float ridgePhase = sin(angle * ridgeCount) * 0.15;\n    \n    // Modulate the ridges based on height\n    float heightFactor = smoothstep(-0.6, 0.4, p.y);\n    ridgePhase *= heightFactor;\n    \n    body += ridgePhase * r * 0.1;\n    \n    // Add slight indentation at top and bottom\n    float topIndent = smoothstep(0.3, 0.5, p.y) * 0.2 * r;\n    float bottomIndent = smoothstep(-0.5, -0.3, p.y) * 0.03 * r;\n    \n    return body+ topIndent + bottomIndent;\n}\n\n// Pumpkin stem\nfloat sdStem(vec3 p) {\n    vec3 stemPos = p - vec3(0.0, 0.45, 0.0);\n    \n    // Curved stem\n    stemPos.x += sin(stemPos.y * 3.0) * 0.1;\n    stemPos.z += cos(stemPos.y * 2.5) * 0.08;\n    \n    float stem = sdCappedCylinder(stemPos, 0.05, 0.19);\n    \n    // Add some bumps to the stem\n    float noise = sin(stemPos.y * 15.0) * sin(stemPos.x * 20.0) * 0.01;\n    return stem + noise;\n}\n\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\n// Candle flame SDF\nfloat sdFlame(vec3 p) {\n    p.x = abs(p.x)*2.5;\n    vec3 flamePos = p - vec3(0.45, -0.05, 0.0);\n    float it = iTime+p.x;\n    // Flame shape - teardrop\n    float flameHeight = 0.02;\n    float flameWidth = 0.02;\n    \n    // Add flickering animation\n    float flicker = sin(it * 19.0) * 0.02 + cos(it * 37.0) * 0.015;\n    flamePos.y += flicker;\n    flamePos.x += sin(it * 13.) * sin(it * 1.9) *0.02;\n    \n    // Flame SDF - teardrop shape\n    float flame = length(vec2(length(flamePos.xy) - flameHeight * (1.0 - flamePos.y/flameHeight), \n                             flamePos.y)) - flameWidth;\n    flame = max(flame, -flamePos.y);\n    flame = max(flame, flamePos.y - flameHeight);\n    \n    return flame;\n}\n\n\n// Main pumpkin SDF (solid shell only)\nfloat map(vec3 p) {\n    float outer = sdPumpkin(p, 0.6);\n    float inner = sdSphere(p, 0.5);\n    float shell = max(outer, -inner);\n    \n    // Enhanced carving system - subtract carved areas\n    float carving = getCarvingDepth(p);\n    if (carving > 0.3) {\n        float carveIntensity = smoothstep(0.3, 1.0, carving);\n        float expandedInner = sdSphere(p, 0.5 + carveIntensity * 0.2);\n        shell = max(shell, -expandedInner);\n    }\n    \n    // Add stem\n    float stem = sdStem(p);\n    shell = smin(shell, stem, 0.02);\n    \n    return shell;\n}\n\n// Ground plane SDF\nfloat sdGround(vec3 p) {\n    return p.y + 0.8; // Ground at y = -0.8\n}\n\n// Map function that includes flame and ground for rendering\nfloat mapWithFlame(vec3 p) {\n    float pumpkinDist = map(p);\n    float flameDist = sdFlame(p);\n    float groundDist = sdGround(p);\n    \n    // Only render flame if inside pumpkin\n    float inner = sdSphere(p, 0.45);\n    if (inner < 0.0) {\n        return min(min(pumpkinDist, flameDist), groundDist);\n    }\n    \n    return min(pumpkinDist, groundDist);\n}\n\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\n// Simple raymarch\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    \n    for (int i = 0; i < 200; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapWithFlame(p);\n        \n        if (abs(d) < 0.0001) return t;\n        if (t > 10.0) break;\n        \n        t += d * 0.4;\n    }\n    return t;\n}\n\n// Simple volumetric light extending from pumpkin surface\nvec3 renderVolumetricLayers(vec3 ro, vec3 rd, float startDist) {\n    vec3 volumetricColor = vec3(0.0);\n    \n    // Candle light properties\n    vec3 candlePos = vec3(0.0, -0.1, 0.0);\n    float flicker = 0.7 + 0.07 * sin(iTime*37.) + 0.06 * sin(iTime * 19.);\n    vec3 lightColor = vec3(1.5, 1.0, 0.5) * flicker;\n    \n    // Start from pumpkin surface and extend toward camera\n     int numSteps = VOLUMETRIC * 12;\n    float maxDist = 0.3 + float(VOLUMETRIC)*0.3;\n    float stepSize = maxDist / float(numSteps);\n    \n    // Go FROM surface TOWARD camera (negative direction)\n    float t = startDist - 0.02;\n    \n    for (int i = 0; i < numSteps; i++) {\n        //if (t <= 0.0) break; // Don't go behind camera\n        \n        vec3 p = ro + rd * t;\n        float carving = getCarvingDepth(p);\n        \n        if (carving > 0.3) {\n            float carveIntensity = smoothstep(0.3, 1.0, carving);\n            \n            float distToCandle = length(p - candlePos);\n            float attenuation = 1.0 / (1.0 + distToCandle * distToCandle * 0.8);\n            \n            // Distance from surface (how far light has traveled)\n            float distanceFromSurface = startDist - t;\n            float falloff = exp(-distanceFromSurface * 1.5);\n            \n            // Layer effect - expanding shells that move outward\n            float layerSpeed = 2.0;\n            float layerSpacing = 0.3;\n            float expandingLayers = sin((distanceFromSurface - iTime * layerSpeed) / layerSpacing) * 0.4 + 1.0;\n            \n            float contribution = carveIntensity * attenuation * falloff * expandingLayers * 0.06;\n            float smoke;\n            if (SMOKE>0){\n            vec3 sp = p;\n            sp+=1.;\n            sp.x+=iTime/10.;\n            sp*=10.;\n            if (SMOKE>1){\n            smoke = perlinNoise(sp, 1, (SMOKE*2)-2, 0.5, 2.0, 123456u);\n            }else{\n            smoke = perlinNoise(sp, 123456u);\n            }\n            smoke = (smoke + 1.0) * 0.5;\n            contribution*=smoke;\n            }\n            \n            volumetricColor += lightColor * contribution;\n        }\n        \n        t -= stepSize; // Move toward camera\n    }\n    if (SMOKE>0){\n    volumetricColor*=3.;\n    }\n    return volumetricColor;\n}\n\n\n// Get subsurface scattering color based on depth from center\nvec3 getSubsurfaceColor(float distFromCenter) {\n    // Interior glow color - warm candlelight\n    vec3 innerGlow = vec3(1.2, 0.8, 0.3);\n    \n    // Outer pumpkin color\n    vec3 outerColor = vec3(0.8, 0.35, 0.05);\n    \n    // Map distance to depth (0 = inside, 1 = outside surface)\n    float depth = (distFromCenter - 0.4) / 0.2; // 0.6 to 0.7 range\n    depth = clamp(depth, 0.0, 1.0);\n    \n    // Create gradient\n    vec3 subsurfaceColor = mix(innerGlow, outerColor, depth);\n    \n    // Add transmission falloff\n    float transmission = exp(-depth * 5.0);\n    \n    return subsurfaceColor * (0.5 + transmission * 0.5);\n}\n\n\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord, vec4 bg) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Static camera setup - moved pumpkin down slightly (compromise position)\n    vec3 ro = vec3(0.0, 0.1, -2.5);\n    vec3 rd = normalize(vec3(uv, 1.5));\n    \n    // Background\n    vec3 col = bg.rgb;\n    \n    // Raymarch solid surfaces\n    float t = raymarch(ro, rd);\n    \n    if (t < 10.0) {\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal(p);\n        float distFromCenter = length(p);\n        float carving = getCarvingDepth(p);\n        \n        // Check if we hit the flame\n        float flameDist = sdFlame(p);\n        float groundDist = sdGround(p);\n        bool isFlame = flameDist < 0.01 && sdSphere(p, 0.45) < 0.0;\n        bool isGround = groundDist < 0.01;\n        \n        if (isFlame) {\n            // Render flame\n            float flameIntensity = 1.0 - smoothstep(0.0, 0.04, flameDist);\n            float flicker = 0.8 + 0.2 * sin(iTime * 37.0) + 0.15 * sin(iTime * 19.0);\n            \n            // Flame color gradient from blue at base to yellow-orange at tip\n            float heightGradient = (p.y + 0.1) / 0.15;\n            vec3 flameColor = mix(\n                vec3(1.0, 0.9, 0.8),  // Blue base\n                vec3(0.3, 0.1, 0.0),  // Orange tip\n                heightGradient\n            );\n            \n            col = flameColor * flameIntensity * flicker * 3.0;\n        } else if (isGround) {\n            // Render ground\n            vec3 groundColor = vec3(0.3, 0.8, 0.3); // Dark earth tone\n            \n            // Key light - strong moonlight from above-behind-side\n            vec3 keyLightDir = normalize(vec3(-0.7, 1.2, -0.8));\n            vec3 keyLightColor = vec3(0.7, 0.8, 1.0) * 1.5;\n            \n            // Simple ground lighting\n            float keyDiff = max(dot(n, keyLightDir), 0.0);\n            vec3 keyDiffuse = groundColor * keyLightColor * keyDiff * 0.6;\n            \n            // Ambient for ground\n            vec3 ambient = groundColor * vec3(0.02, 0.03, 0.05);\n            \n            // Subtle glow from pumpkin onto ground\n            vec3 pumpkinPos = vec3(0.0, 0.0, 0.0);\n            float distToPumpkin = length(p - pumpkinPos);\n            float pumpkinGlow = exp(-distToPumpkin * 1.5) * 0.1;\n            vec3 pumpkinLightColor = vec3(1.0, 0.6, 0.2);\n            \n            col = ambient + keyDiffuse + pumpkinLightColor * pumpkinGlow;\n        } else {\n            // Enhanced lighting system with key light\n            vec3 candlePos = vec3(0.0, -0.3, 0.0);\n            vec3 candleLight = normalize(candlePos - p);\n            vec3 viewDir = normalize(ro - p);\n            \n            // Key light - strong moonlight from above-behind-side\n            vec3 keyLightDir = normalize(vec3(-0.7, 1.2, -0.8));;//normalize(vec3(0.5, 0.7, 2.5));\n            vec3 keyLightColor = vec3(0.8, 0.9, 1.0) * 1.5; // Cool blue moonlight\n            // Key light contribution\n            float keyDiff = max(dot(n, keyLightDir), 0.0);\n            // Flickering candle light intensity\n            float flicker = 0.8 + 0.07 * sin(iTime * 37.0) + 0.06 * sin(iTime * 19.0);\n            vec3 candleLightColor = vec3(1.2, 0.8, 0.4) * flicker;\n            \n            // Are we in a carved area?\n            if (carving > 0.6) {\n                // Enhanced subsurface scattering for carved areas\n                vec3 subsurfaceCol = getSubsurfaceColor(distFromCenter);\n                \n                // Distance-based light falloff\n                float lightDist = length(candlePos - p);\n                float attenuation = 1.5/ (2.0 + lightDist * 2.0);\n                \n                // Inner glow effect\n                float innerGlow = exp(-lightDist * 3.0);\n                \n                col = subsurfaceCol * candleLightColor * (attenuation + innerGlow * 1.5);\n                \n                // Enhanced rim lighting\n               // float rim = 2.0 - abs(dot(viewDir, n));\n                //col += candleLightColor * 4.8 * attenuation * flicker;\n                col*=1.2;\n            } else {\n                // Enhanced pumpkin surface material\n                vec3 pumpkinColor = vec3(0.9, 0.4, 0.05);\n               \n                // Add surface variation based on ridges\n                float angle = atan(p.z, p.x);\n                float ridgePhase = sin(angle * 12.0) * 0.4 + 0.5;\n                ridgePhase += ridgePhase-keyDiff; ridgePhase*=.55;\n                pumpkinColor *= 0.5 + candleLightColor * pow(ridgePhase, 8.);\n                pumpkinColor += (pumpkinColor*=pumpkinColor)/5.;\n                pumpkinColor +=  vec3(1.0, 0.3, 0.02); \n                \n                if(p.z>0.0){pumpkinColor *=1.3;} else { pumpkinColor *=0.5;}\n                // Stem coloring\n                if (p.y > 0.38) {\n                    pumpkinColor = mix(vec3(0.9, 0.4, 0.05), vec3(0.3, 0.5, 0.2), smoothstep(0.5, 0.7, p.y));\n                }\n                \n               \n                vec3 keyDiffuse = pumpkinColor * keyLightColor * keyDiff * 0.8;\n                \n                // Candle light contribution\n                float lightDist = length(candlePos - p);\n                float attenuation = 1.0 / (1.0 + lightDist * lightDist * 0.5);\n                float candleDiff = max(dot(n, candleLight), 0.0);\n                vec3 candleDiffuse = pumpkinColor * candleLightColor * candleDiff * attenuation * 0.6;\n                \n                // Ambient lighting\n                vec3 ambient = pumpkinColor * vec3(0.05, 0.08, 0.15);\n                \n                // Specular highlights from key light\n                vec3 keyHalfDir = normalize(keyLightDir + viewDir);\n                float keySpec = pow(max(dot(n, keyHalfDir), 0.0), 16.0);\n                vec3 keySpecular = keyLightColor * keySpec * 0.3;\n                \n                // Specular highlights from candle\n                vec3 candleHalfDir = normalize(candleLight + viewDir);\n                float candleSpec = pow(max(dot(n, candleHalfDir), 0.0), 8.0);\n                vec3 candleSpecular = candleLightColor * candleSpec * 0.3 * attenuation;\n                \n                col = ambient + keyDiffuse + candleDiffuse + keySpecular + candleSpecular;\n            }\n        }\n    }\n   \n   \n   sro=ro;\n   srd=rd;\n    \n    // Add UI buttons overlay\n    vec2 screenUV = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // UI button positions (moved further left)\n    vec2 buttonPos1 = vec2(-0.78, 0.42);   // Regular mode\n    vec2 buttonPos2 = vec2(-0.78, 0.31);   // Mirror mode  \n    vec2 buttonPos3 = vec2(-0.78, 0.20);   // Inverse mode\n    vec2 buttonPos4 = vec2(-0.78, 0.09);   // Mirror + Inverse mode\n    \n    // Read current mode state from BufferA\n    bool currentInverse = texelFetch(iChannel0, ivec2(38,0), 0).x > 0.5;\n    bool currentMirror = texelFetch(iChannel0, ivec2(39,0), 0).x > 0.5;\n    int currentMode = (currentMirror ? 2 : 0) + (currentInverse ? 1 : 0);\n    \n    // Read quality settings and brush size from BufferA and update global variables\n    AA = int(floor(texelFetch(iChannel0, ivec2(40,0), 0).x * 5.0));\n    VOLUMETRIC = int(floor(texelFetch(iChannel0, ivec2(41,0), 0).x * 5.0));\n    SMOKE = int(floor(texelFetch(iChannel0, ivec2(42,0), 0).x * 5.0));\n    \n    \n    float aaQuality = float(AA);\n    float volumetricQuality = float(VOLUMETRIC);\n    float smokeQuality = float(SMOKE);\n    float skiesQuality = float(SKIES);\n    float brushSize = 0.03 + texelFetch(iChannel0, ivec2(44,0), 0).x * (0.15 - 0.03);\n    \n    // Calculate FPS using stored frame timing data\n    //float currentTime = iTime;\n    //float lastFrameTime = texelFetch(iChannel0, ivec2(45,0), 0).x;\n    float deltaTime = texelFetch(iChannel0, ivec2(47,0), 0).x;\n    float fps = (deltaTime > 0.0) ? 1.0 / deltaTime : 60.0;\n    \n    // Quality slider positions (moved up from bottom)\n    vec2 aaSliderPos = vec2(0.71, -0.37);\n    vec2 volumetricSliderPos = vec2(0.76, -0.37);\n    vec2 smokeSliderPos = vec2(0.81, -0.37);\n    vec2 skiesSliderPos = vec2(0.86, -0.37);\n    \n    // Brush slider position (moved down by half its length)\n    vec2 brushSliderPos = vec2(-0.78, -0.155);\n    \n    // FPS indicator position (between original and current)\n    vec2 fpsPos = vec2(0.85, 0.465);\n    \n    // Draw mode buttons\n    vec3 btn1 = drawModeButton(screenUV, buttonPos1, false, false, currentMode == 0);\n    if (btn1.x >= 0.0) col = btn1;\n    \n    vec3 btn2 = drawModeButton(screenUV, buttonPos2, false, true, currentMode == 2);\n    if (btn2.x >= 0.0) col = btn2;\n    \n    vec3 btn3 = drawModeButton(screenUV, buttonPos3, true, false, currentMode == 1);\n    if (btn3.x >= 0.0) col = btn3;\n    \n    vec3 btn4 = drawModeButton(screenUV, buttonPos4, true, true, currentMode == 3);\n    if (btn4.x >= 0.0) col = btn4;\n    \n    // Draw quality sliders\n    vec3 aaSlider = drawQualitySlider(screenUV, aaSliderPos, aaQuality, false);\n    if (aaSlider.x >= 0.0) col = aaSlider;\n    \n    vec3 volumetricSlider = drawQualitySlider(screenUV, volumetricSliderPos, volumetricQuality, false);\n    if (volumetricSlider.x >= 0.0) col = volumetricSlider;\n    \n    vec3 smokeSlider = drawQualitySlider(screenUV, smokeSliderPos, smokeQuality, false);\n    if (smokeSlider.x >= 0.0) col = smokeSlider;\n    \n    vec3 skiesSlider = drawQualitySlider(screenUV, skiesSliderPos, skiesQuality, false);\n    if (skiesSlider.x >= 0.0) col = skiesSlider;\n    \n    // Draw brush slider\n    vec3 brushSlider = drawBrushSlider(screenUV, brushSliderPos, brushSize, false);\n    if (brushSlider.x >= 0.0) col = brushSlider;\n    \n    // Draw FPS indicator\n    vec3 fpsIndicator = drawFPSIndicator(screenUV, fpsPos, fps);\n    if (fpsIndicator.x >= 0.0) col = fpsIndicator;\n    \n    fragColor = vec4(col, 1.0);\n}\n\nvec4 mainImageBG(vec2 u) {\nSKIES = int(floor(texelFetch(iChannel0, ivec2(43,0), 0).x * 5.0));\n    float d, // total distance marched\n          n, // noise iterator\n          i, // raymarch iterator\n          s, // signed distance\n          t = iTime/6.;\n    vec3  p = iResolution;    \n    \n    // scale coords\n    u = -(u-p.xy/2.)/p.y;\n    \n    vec4 o = vec4(0);\n    for(; i++<float(SKIES)*24.;) {\n        \n        p = vec3(u*d,d+t);\n        \n        p.z *= .4;\n        \n        p.y += 4.;\n        \n        p.y += sin(.2*t+p.x*.2);\n\n        // noise loop start, march\n        for (n = .01; n < 1.+float(SKIES)/2.; n += n)\n            p += abs(dot(cos(p.x*.1 + p.z *.3+  t + p / n ), vec3(.33))) * n;\n            d += s = .2 + .7 * abs(p.y),\n            o += 1./s;\n        \n    }\n    o = vec4(0.2,0.2,0.3,0)*o/1e2;\n    o = max(o, vec4(0));\n    return o;\n}\n\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    vec4 b = mainImageBG(u);\n   \n    vec2 j = vec2(.5); \n    o = vec4(0);\n    vec4 c;\n    mainImage0(c, u, b); \n     float s = pow(2.,float(AA)), k;\n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5, b); \n        o+=c;\n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n    \n    // volumetric light after AA\n    if (VOLUMETRIC>0){\n    vec3 volumetricLight = renderVolumetricLayers(sro, srd, 1.99);\n    o.rgb += volumetricLight;\n    }\n    // gamma correction after AA\n       o.rgb = pow(o.rgb, vec3(0.6));\n       \n       //o= texture(iChannel0, u.xy/iResolution.xy, 0.);\n    \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "\nvoid draw( inout vec4 pre , in vec2 muv, in vec2 uv){\n// Static camera setup matching main image\n        vec3 ro = vec3(0.0, 0.1, -2.5);\n        vec3 rd = normalize(vec3(muv, 1.5));\n        \n        bool inverted = false;\n        bool mirrored = false;\n        \n        if(texture( iChannel0, vec2(38.5/iResolution.x, 0.5/iResolution.y)).x>0.5){inverted = true;}\n        if(texture( iChannel0, vec2(39.5/iResolution.x, 0.5/iResolution.y)).x>0.5){mirrored = true;}\n        \n        // Intersect ray with pumpkin shape (approximate with ellipsoid)\n        vec3 scale = vec3(1.0, 0.85, 1.0) * 0.6;\n        \n        // Transform ray to ellipsoid space\n        vec3 roScaled = ro / scale;\n        vec3 rdScaled = rd / scale;\n        \n        float a = dot(rdScaled, rdScaled);\n        float b = 2.0 * dot(roScaled, rdScaled);\n        float c = dot(roScaled, roScaled) - 1.0;\n        float discriminant = b*b - 4.0*a*c;\n        \n        if (discriminant > 0.0) {\n            float t = (-b - sqrt(discriminant)) / (2.0 * a);\n            if (t > 0.0) {\n                vec3 hitPoint = (ro + rd * t);\n                \n                // Convert hit point to spherical coordinates\n                vec3 np = normalize(hitPoint);\n                float hitTheta = atan(np.z, np.x);\n                float hitPhi = acos(clamp(np.y, -1.0, 1.0));\n                \n                // Current texel in spherical coords\n                float texTheta = uv.x * 2.0 * 3.14159 - 3.14159;\n                float texPhi = (1.0 - uv.y) * 3.14159;\n                \n                // Calculate angular distance with better accuracy\n                vec3 p1 = vec3(sin(texPhi) * cos(texTheta), cos(texPhi), sin(texPhi) * sin(texTheta));\n                vec3 p2 = vec3(sin(hitPhi) * cos(hitTheta), cos(hitPhi), sin(hitPhi) * sin(hitTheta));\n                \n                float dist = acos(clamp(dot(p1, p2), -1.0, 1.0));\n                \n                // Enhanced brush system with pressure sensitivity\n                float brushSize = 0.03 + texture(iChannel0, vec2(44.5/iResolution.x, 0.5/iResolution.y)).x * (0.15 - 0.03);\n                \n                if (dist < brushSize) {\n                    // Smooth falloff for natural carving\n                    float falloff = inverted ? smoothstep(0.0, brushSize, dist) : 1.0 - smoothstep(0.0, brushSize, dist);\n                    float newCarve = falloff;\n                    \n                    // Blend with existing carving\n                    // Normal mode: max (additive carving), Inverse mode: min (subtractive carving)\n                    pre.r = inverted ? min(pre.r, newCarve) : max(pre.r, newCarve);\n                }\n            }\n        }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 screenUV = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec4 prev = texture(iChannel0, uv);\n    \n    // UI button positions (moved further left)\n    vec2 buttonPos1 = vec2(-0.78, 0.42);   // Regular mode\n    vec2 buttonPos2 = vec2(-0.78, 0.31);   // Mirror mode  \n    vec2 buttonPos3 = vec2(-0.78, 0.20);   // Inverse mode\n    vec2 buttonPos4 = vec2(-0.78, 0.09);   // Mirror + Inverse mode\n    \n    // Read current mode state from previous frame\n    bool currentInverse = texture(iChannel0, vec2(38.5/iResolution.x, 0.5/iResolution.y)).x > 0.5;\n    bool currentMirror = texture(iChannel0, vec2(39.5/iResolution.x, 0.5/iResolution.y)).x > 0.5;\n    \n    // Quality slider positions (moved up from bottom)\n    vec2 aaSliderPos = vec2(0.71, -0.37);\n    vec2 volumetricSliderPos = vec2(0.76, -0.37);\n    vec2 smokeSliderPos = vec2(0.81, -0.37);\n    vec2 skiesSliderPos = vec2(0.86, -0.37);\n    \n    // Brush slider position (moved down by half its length)\n    vec2 brushSliderPos = vec2(-0.78, -0.155);\n    \n    // Handle button clicks\n    bool buttonClicked = false;\n    if (iMouse.z > 0.0) {\n        vec2 mouseScreen = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n        \n        // Check button clicks first (using smaller button size)\n        if (length(mouseScreen - buttonPos1) < 0.048) {\n            // Regular mode: mirror=false, inverse=false\n            buttonClicked = true;\n            if (ivec2(fragCoord) == ivec2(38,0)) prev.r = 0.0; // inverse = false\n            if (ivec2(fragCoord) == ivec2(39,0)) prev.r = 0.0; // mirror = false\n        }\n        else if (length(mouseScreen - buttonPos2) < 0.048) {\n            // Mirror mode: mirror=true, inverse=false  \n            buttonClicked = true;\n            if (ivec2(fragCoord) == ivec2(38,0)) prev.r = 0.0; // inverse = false\n            if (ivec2(fragCoord) == ivec2(39,0)) prev.r = 1.0; // mirror = true\n        }\n        else if (length(mouseScreen - buttonPos3) < 0.048) {\n            // Inverse mode: mirror=false, inverse=true\n            buttonClicked = true;\n            if (ivec2(fragCoord) == ivec2(38,0)) prev.r = 1.0; // inverse = true\n            if (ivec2(fragCoord) == ivec2(39,0)) prev.r = 0.0; // mirror = false\n        }\n        else if (length(mouseScreen - buttonPos4) < 0.048) {\n            // Mirror + Inverse mode: mirror=true, inverse=true\n            buttonClicked = true;\n            if (ivec2(fragCoord) == ivec2(38,0)) prev.r = 1.0; // inverse = true\n            if (ivec2(fragCoord) == ivec2(39,0)) prev.r = 1.0; // mirror = true\n        }\n        \n        // Check for slider interactions\n        else if (abs(mouseScreen.x - aaSliderPos.x) < 0.02 && abs(mouseScreen.y - aaSliderPos.y) < 0.08) {\n            // AA Quality slider\n            buttonClicked = true;\n            float sliderValue = clamp((mouseScreen.y - aaSliderPos.y + 0.08) / 0.16, 0.0, 1.0);\n            if (ivec2(fragCoord) == ivec2(40,0)) prev.r = sliderValue;\n        }\n        else if (abs(mouseScreen.x - volumetricSliderPos.x) < 0.02 && abs(mouseScreen.y - volumetricSliderPos.y) < 0.08) {\n            // Volumetric Quality slider\n            buttonClicked = true;\n            float sliderValue = clamp((mouseScreen.y - volumetricSliderPos.y + 0.08) / 0.16, 0.0, 1.0);\n            if (ivec2(fragCoord) == ivec2(41,0)) prev.r = sliderValue;\n        }\n        else if (abs(mouseScreen.x - smokeSliderPos.x) < 0.02 && abs(mouseScreen.y - smokeSliderPos.y) < 0.08) {\n            // Smoke Quality slider\n            buttonClicked = true;\n            float sliderValue = clamp((mouseScreen.y - smokeSliderPos.y + 0.08) / 0.16, 0.0, 1.0);\n            if (ivec2(fragCoord) == ivec2(42,0)) prev.r = sliderValue;\n        }\n        else if (abs(mouseScreen.x - skiesSliderPos.x) < 0.02 && abs(mouseScreen.y - skiesSliderPos.y) < 0.08) {\n            // Skies Quality slider\n            buttonClicked = true;\n            float sliderValue = clamp((mouseScreen.y - skiesSliderPos.y + 0.08) / 0.16, 0.0, 1.0);\n            if (ivec2(fragCoord) == ivec2(43,0)) prev.r = sliderValue;\n        }\n        else if (abs(mouseScreen.x - brushSliderPos.x) < 0.04 && abs(mouseScreen.y - brushSliderPos.y) < 0.18) {\n            // Brush size slider (bigger hit area)\n            buttonClicked = true;\n            float sliderValue = clamp((mouseScreen.y - brushSliderPos.y + 0.15) / 0.3, 0.0, 1.0);\n            if (ivec2(fragCoord) == ivec2(44,0)) prev.r = sliderValue;\n        }\n        \n        // Only do pumpkin carving if no button or slider was clicked\n        if (!buttonClicked) {\n            vec2 mouseUV = mouseScreen;\n            \n            // Use current brush size for carving\n            float currentBrushSize = 0.03 + texture(iChannel0, vec2(44.5/iResolution.x, 0.5/iResolution.y)).x * (0.15 - 0.03);\n            draw(prev, mouseUV, uv);\n            \n            // Apply mirroring if enabled\n            if(currentMirror){\n                mouseUV.x = -mouseUV.x;\n                draw(prev, mouseUV, uv);\n            }\n        }\n    }\n    \n    // Note: UI rendering moved to main image shader\n    // BufferA only handles button interaction logic and data storage\n    \n    // FPS calculation - update timing data\n    if (ivec2(fragCoord) == ivec2(45,0)) {\n        // Store current time in pixel 45\n        prev.r = iTime;\n    }\n    else if (ivec2(fragCoord) == ivec2(46,0)) {\n        // Calculate and store delta time in pixel 46\n        float currentTime = iTime;\n        float lastFrameTime = texture(iChannel0, vec2(45.5/iResolution.x, 0.5/iResolution.y)).x;\n        float deltaTime = currentTime - lastFrameTime;\n        prev.r = deltaTime;\n    }else if (ivec2(fragCoord) == ivec2(47,0)) {\n        // Calculate and store delta time in pixel 46\n        float currentTime = iTime;\n        float lastFrameTime = texture(iChannel0, vec2(45.5/iResolution.x, 0.5/iResolution.y)).x;\n        float deltaTime = currentTime - lastFrameTime;\n        float lastDelta = texture(iChannel0, vec2(46.5/iResolution.x, 0.5/iResolution.y)).x;\n        float lastDeltab = texture(iChannel0, vec2(47.5/iResolution.x, 0.5/iResolution.y)).x;\n        prev.r = lastDeltab - (lastDeltab - lastDelta)/15.;\n    }\n    \n    // Clear on rewind - initialize default state\n    if (iFrame < 2) {\n        prev = vec4(0.0);\n        // Set default mode (regular: no mirror, no inverse)\n        if (ivec2(fragCoord) == ivec2(38,0)) prev.r = 0.0; // inverse = false\n        if (ivec2(fragCoord) == ivec2(39,0)) prev.r = 0.0; // mirror = false\n        \n        // Set default quality values (matching original defines)\n        if (ivec2(fragCoord) == ivec2(40,0)) prev.r = 0.0 / 4.0; // AA = 0\n        if (ivec2(fragCoord) == ivec2(41,0)) prev.r = 2.0 / 4.0; // VOLUMETRIC = 2\n        if (ivec2(fragCoord) == ivec2(42,0)) prev.r = 2.0 / 4.0; // SMOKE = 2\n        if (ivec2(fragCoord) == ivec2(43,0)) prev.r = 2.0 / 4.0; // SKIES = 2\n        \n        // Set default brush size (0.09 normalized to 0-1 range)\n        if (ivec2(fragCoord) == ivec2(44,0)) prev.r = (0.09 - 0.03) / (0.15 - 0.03); // Default brush size\n        \n        // Initialize timing data\n        if (ivec2(fragCoord) == ivec2(45,0)) prev.r = iTime; // Current time\n        if (ivec2(fragCoord) == ivec2(46,0)) prev.r = 1.0/60.0; // Initial delta time (60 FPS)\n        if (ivec2(fragCoord) == ivec2(47,0)) prev.r = 1.0/60.0; // Initial delta time (60 FPS)\n    }\n    \n    fragColor = prev;\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tfBfRG",
    "date": "1758721348",
    "viewed": 108,
    "name": "Texture Drawing to SDF",
    "description": "Very crude method for drawing a dynamic 2D SDF with a texture.\nI need this for version 2 of my [url=https://shadertoy.com/view/WfffR8]Pumpkin Carver[/url]\nThere are other, better ways to do this like [url=https://shadertoy.com/view/McByRd]Jump Flood[/url]",
    "likes": 6,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "2d",
     "sdf",
     "texture",
     "drawing"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texture(iChannel0, fragCoord.xy/iResolution.xy, 0.);\n    float d = data.a;\n    d *= 3.0;\n    vec3 col = (d > 0.0) ? vec3(0.9, 0.6, 0.3) : vec3(0.65, 0.85, 1.0);\n    col *= 1.0 - exp(-6.0 * abs(d));\n    col *= 0.8 + 0.2 * cos(150.0 * d);\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.005, abs(d)));\n    fragColor = vec4(col, 1.0);\n    //fragColor = pow(texture(iChannel1, fragCoord.xy/iResolution.xy, 0.)*3., vec4(.7)); //view buffer A\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tex = texture(iChannel0, fragCoord.xy/iResolution.xy, 0.);\n    float inside = 0.02;\n    float dist = tex.r;\n    float newDist;\n    \n    if(iMouse.z > 0.0)\n    {\n        newDist = (distance(iMouse.xy, fragCoord.xy)/iResolution.x) - inside;\n        \n        if(tex.b == 0.1) {\n            newDist = min(dist, newDist);\n        }\n        \n        // Store distance in R, final corrected in G, state in B\n        fragColor = vec4(newDist, tex.g, 0.1, 1.0);\n    } \n    else if(tex.b != 0.1) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    } \n    else {\n        fragColor = tex;\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 pixelSize = 1.0/iResolution.xy;\n    \n    vec4 drawn = texture(iChannel1, uv, 0.);\n    vec4 prev = texture(iChannel0, uv, 0.);\n    \n    // If mouse is pressed, keep working with drawn data but preserve corrected\n    if(iMouse.z > 0.0) {\n        // Pass through drawn distance, but keep the corrected value\n        fragColor = vec4(drawn.r, prev.g, drawn.b, 1.0);\n        fragColor.a = (fragColor.r<0.) ? prev.g == 0.0? drawn.r:prev.g : fragColor.r;\n        return;\n    }\n    \n    float currentDist = prev.r;\n    float correctedDist = prev.g; // Final corrected distance\n    float state = prev.b;\n    \n    // Pixel-relative boundary threshold\n    float boundaryThreshold = pixelSize.x;\n    \n    // Initialize: mark pixels near boundary as correct\n    if(state == 0.1 && abs(currentDist) < boundaryThreshold) {\n        state = 0.5;\n        correctedDist = currentDist;\n    }\n    \n    // If this pixel needs fixing (not yet corrected)\n    if(state == 0.1 && currentDist < 0.0) {\n        \n        float bestDist = currentDist;\n        bool foundCorrect = false;\n        \n        // Larger kernel for faster initial propagation\n        const int kernelSize = 5; // Adjust this: 1=3x3, 2=5x5, 4=9x9, 8=17x17\n        \n        for(int y = -kernelSize; y <= kernelSize; y++) {\n            for(int x = -kernelSize; x <= kernelSize; x++) {\n                if(x == 0 && y == 0) continue;\n                \n                vec2 offset = vec2(x, y) * pixelSize;\n                vec4 neighbor = texture(iChannel0, uv + offset, 0.);\n                \n                if(neighbor.b >= 0.5) {\n                    float nDist = neighbor.g; // Use corrected distance from neighbor\n                    float stepDist = length(vec2(x, y)) * pixelSize.x;\n                    float proposedDist = nDist - stepDist;\n                    \n                    if(!foundCorrect || proposedDist > bestDist) {\n                        bestDist = proposedDist;\n                        foundCorrect = true;\n                    }\n                }\n            }\n        }\n        \n        if(foundCorrect) {\n            correctedDist = bestDist;\n            state = 0.5;\n        }\n    }\n    \n    // Corrected pixels: refine distance and apply smoothing\n    else if(state >= 0.5 && state < 1.0 && currentDist < 0.0) {\n        \n        float bestDist = correctedDist;\n        \n        // Still use larger kernel for refinement (or reduce to 1 for accuracy)\n        const int refineKernel = 2; // 5x5 for refinement phase\n        \n        for(int y = -refineKernel; y <= refineKernel; y++) {\n            for(int x = -refineKernel; x <= refineKernel; x++) {\n                if(x == 0 && y == 0) continue;\n                \n                vec2 offset = vec2(x, y) * pixelSize;\n                vec4 neighbor = texture(iChannel0, uv + offset, 0.);\n                \n                if(neighbor.b >= 0.5) {\n                    float nDist = neighbor.g; // Use corrected distance\n                    float stepDist = length(vec2(x, y)) * pixelSize.x;\n                    float proposedDist = nDist - stepDist;\n                    \n                    if(proposedDist > bestDist) {\n                        bestDist = proposedDist;\n                    }\n                }\n            }\n        }\n        \n        correctedDist = bestDist;\n        \n        // Apply smoothing\n        if(state > 0.5 && state < 0.9) {\n            float sumDist = 0.0;\n            float sumWeight = 0.0;\n            \n            for(int y = -1; y <= 1; y++) {\n                for(int x = -1; x <= 1; x++) {\n                    vec2 offset = vec2(x, y) * pixelSize;\n                    vec4 neighbor = texture(iChannel0, uv + offset, 0.);\n                    \n                    if(neighbor.b >= 0.5) {\n                        float nDist = neighbor.g; // Use corrected distance\n                        float weight = 1.0 / (1.0 + length(vec2(x, y)));\n                        sumDist += nDist * weight;\n                        sumWeight += weight;\n                    }\n                }\n            }\n            \n            if(sumWeight > 0.0) {\n                float smoothedDist = sumDist / sumWeight;\n                float smoothStrength = 0.3 * (1.0 - (state - 0.5) / 0.4);\n                correctedDist = mix(correctedDist, smoothedDist, smoothStrength);\n            }\n        }\n        \n        state = min(state + 0.009, 1.0);\n    }\n    \n    // Store: R = current/working distance, G = corrected distance, B = state\n    fragColor = vec4(currentDist, correctedDist, state, 1.0);\n    fragColor.a = (fragColor.r<0.) ? fragColor.g : fragColor.r;\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wcjfzt",
    "date": "0",
    "viewed": 0,
    "name": "Fork Texture Dr Cotterzz 395",
    "description": "Very crude method for drawing a dynamic 2D SDF with a texture.\nI need this for version 2 of my [url=https://shadertoy.com/view/WfffR8]Pumpkin Carver[/url]\nThere are other, better ways to do this like [url=https://shadertoy.com/view/McByRd]Jump Flood[/url]",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "2d",
     "sdf",
     "texture",
     "drawing"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texture(iChannel0, fragCoord.xy/iResolution.xy, 0.);\n    float d = data.a;\n    d *= 3.0;\n    vec3 col = (d > 0.0) ? vec3(0.9, 0.6, 0.3) : vec3(0.65, 0.85, 1.0);\n    col *= 1.0 - exp(-6.0 * abs(d));\n    col *= 0.8 + 0.2 * cos(150.0 * d);\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.005, abs(d)));\n    fragColor = vec4(col, 1.0);\n    //fragColor = pow(texture(iChannel1, fragCoord.xy/iResolution.xy, 0.)*3., vec4(.7)); //view buffer A\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tex = texture(iChannel0, fragCoord.xy/iResolution.xy, 0.);\n    float inside = 0.02;\n    float dist = tex.r;\n    float newDist;\n    \n    if(iMouse.z > 0.0)\n    {\n        newDist = (distance(iMouse.xy, fragCoord.xy)/iResolution.x) - inside;\n        \n        if(tex.b == 0.1) {\n            newDist = min(dist, newDist);\n        }\n        \n        // Store distance in R, final corrected in G, state in B\n        fragColor = vec4(newDist, tex.g, 0.1, 1.0);\n    } \n    else if(tex.b != 0.1) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    } \n    else {\n        fragColor = tex;\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 pixelSize = 1.0/iResolution.xy;\n    \n    vec4 drawn = texture(iChannel1, uv, 0.);\n    vec4 prev = texture(iChannel0, uv, 0.);\n    \n    // If mouse is pressed, keep working with drawn data but preserve corrected\n    if(iMouse.z > 0.0) {\n        // Pass through drawn distance, but keep the corrected value\n        fragColor = vec4(drawn.r, prev.g, drawn.b, 1.0);\n        fragColor.a = (fragColor.r<0.) ? prev.g == 0.0? drawn.r:prev.g : fragColor.r;\n        return;\n    }\n    \n    float currentDist = prev.r;\n    float correctedDist = prev.g; // Final corrected distance\n    float state = prev.b;\n    \n    // Pixel-relative boundary threshold\n    float boundaryThreshold = pixelSize.x;\n    \n    // Initialize: mark pixels near boundary as correct\n    if(state == 0.1 && abs(currentDist) < boundaryThreshold) {\n        state = 0.5;\n        correctedDist = currentDist;\n    }\n    \n    // If this pixel needs fixing (not yet corrected)\n    if(state == 0.1 && currentDist < 0.0) {\n        \n        float bestDist = currentDist;\n        bool foundCorrect = false;\n        \n        // Larger kernel for faster initial propagation\n        const int kernelSize = 5; // Adjust this: 1=3x3, 2=5x5, 4=9x9, 8=17x17\n        \n        for(int y = -kernelSize; y <= kernelSize; y++) {\n            for(int x = -kernelSize; x <= kernelSize; x++) {\n                if(x == 0 && y == 0) continue;\n                \n                vec2 offset = vec2(x, y) * pixelSize;\n                vec4 neighbor = texture(iChannel0, uv + offset, 0.);\n                \n                if(neighbor.b >= 0.5) {\n                    float nDist = neighbor.g; // Use corrected distance from neighbor\n                    float stepDist = length(vec2(x, y)) * pixelSize.x;\n                    float proposedDist = nDist - stepDist;\n                    \n                    if(!foundCorrect || proposedDist > bestDist) {\n                        bestDist = proposedDist;\n                        foundCorrect = true;\n                    }\n                }\n            }\n        }\n        \n        if(foundCorrect) {\n            correctedDist = bestDist;\n            state = 0.5;\n        }\n    }\n    \n    // Corrected pixels: refine distance and apply smoothing\n    else if(state >= 0.5 && state < 1.0 && currentDist < 0.0) {\n        \n        float bestDist = correctedDist;\n        \n        // Still use larger kernel for refinement (or reduce to 1 for accuracy)\n        const int refineKernel = 2; // 5x5 for refinement phase\n        \n        for(int y = -refineKernel; y <= refineKernel; y++) {\n            for(int x = -refineKernel; x <= refineKernel; x++) {\n                if(x == 0 && y == 0) continue;\n                \n                vec2 offset = vec2(x, y) * pixelSize;\n                vec4 neighbor = texture(iChannel0, uv + offset, 0.);\n                \n                if(neighbor.b >= 0.5) {\n                    float nDist = neighbor.g; // Use corrected distance\n                    float stepDist = length(vec2(x, y)) * pixelSize.x;\n                    float proposedDist = nDist - stepDist;\n                    \n                    if(proposedDist > bestDist) {\n                        bestDist = proposedDist;\n                    }\n                }\n            }\n        }\n        \n        correctedDist = bestDist;\n        \n        // Apply smoothing\n        if(state > 0.5 && state < 0.9) {\n            float sumDist = 0.0;\n            float sumWeight = 0.0;\n            \n            for(int y = -1; y <= 1; y++) {\n                for(int x = -1; x <= 1; x++) {\n                    vec2 offset = vec2(x, y) * pixelSize;\n                    vec4 neighbor = texture(iChannel0, uv + offset, 0.);\n                    \n                    if(neighbor.b >= 0.5) {\n                        float nDist = neighbor.g; // Use corrected distance\n                        float weight = 1.0 / (1.0 + length(vec2(x, y)));\n                        sumDist += nDist * weight;\n                        sumWeight += weight;\n                    }\n                }\n            }\n            \n            if(sumWeight > 0.0) {\n                float smoothedDist = sumDist / sumWeight;\n                float smoothStrength = 0.3 * (1.0 - (state - 0.5) / 0.4);\n                correctedDist = mix(correctedDist, smoothedDist, smoothStrength);\n            }\n        }\n        \n        state = min(state + 0.009, 1.0);\n    }\n    \n    // Store: R = current/working distance, G = corrected distance, B = state\n    fragColor = vec4(currentDist, correctedDist, state, 1.0);\n    fragColor.a = (fragColor.r<0.) ? fragColor.g : fragColor.r;\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "W3XyRn",
    "date": "1759182567",
    "viewed": 678,
    "name": "sin (sin (x) + cos (y)) =",
    "description": "Plot of sin (sin (x) + cos (y)) = cos (sin (x*y) + cos (x))\nFrom [url=https://x.com/jshguo/status/1972564708525064688]here[/url]",
    "likes": 13,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "sin",
     "cos",
     "graph",
     "equation",
     "twitter",
     "maths"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// sin (sin (x) + cos (y)) = cos (sin (x*y) + cos (x))\n\n// from Joshua Guo on x: https://x.com/jshguo/status/1972564708525064688\n\n// mouse x to zoom\n\n// mouse y to change view mode\n\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    uv *= iMouse.z!=0.?pow((iMouse.x/iResolution.x)*8., 2.5):12.;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    \n    // Implicit equation rearranged to f(x,y) = 0\n    float f = sin(sin(x) + cos(y)) - cos(sin(x*y) + cos(x));\n    \n    // Mode A: Simple zero contour\n    vec3 colorA = mix(vec3(0.1, 0.1, 0.2), vec3(1.0, 0.5, 0.0), smoothstep(0.05, 0.0, abs(f)));\n    \n    // Mode B: Grid-based\n    vec2 grid = abs(fract(uv) - 0.5);\n    float gridLine = smoothstep(0.02, 0.0, min(grid.x, grid.y));\n    float curve = smoothstep(0.03, 0.0, abs(f));\n    vec3 bgColor = vec3(0.05, 0.05, 0.1);\n    vec3 gridColor = vec3(0.2, 0.2, 0.3);\n    vec3 curveColor = vec3(1.0, 0.8, 0.2);\n    vec3 colorB = mix(bgColor, gridColor, gridLine * 0.5);\n    colorB = mix(colorB, curveColor, curve);\n    \n    // Mode C: Contour with positive/negative regions\n    float contour = sin(f * 20.0) * 0.5 + 0.5;\n    vec3 colorC;\n    if (f > 0.0) {\n        colorC = mix(vec3(0.2, 0.1, 0.4), vec3(1.0, 0.3, 0.1), contour);\n    } else {\n        colorC = mix(vec3(0.1, 0.2, 0.4), vec3(0.1, 0.7, 1.0), contour);\n    } \n    colorC = mix(colorC, vec3(1.0), smoothstep(0.02, 0.0, abs(f)));\n    \n    // Mode D: Heat map visualization\n    vec3 colorD = vec3(0.5) + 0.5 * cos(6.28 * f + vec3(0, 1, 2));\n    colorD = mix(colorD, vec3(1.0), curve);\n    \n    // Blend modes based on mouse Y position\n    float mouseY = iMouse.z != 0. ? iMouse.y / iResolution.y : 0.25;\n    float blendParam = mouseY * 3.0; \n    vec3 finalColor;\n    if (blendParam < 1.0) {\n        finalColor = mix(colorA, colorB, smoothstep(0.0, 1.0, blendParam));\n    } else if (blendParam < 2.0) {\n        finalColor = mix(colorB, colorC, smoothstep(1.0, 2.0, blendParam));\n    } else {\n        finalColor = mix(colorC, colorD, smoothstep(2.0, 3.0, blendParam));\n    }\n    fragColor = vec4(finalColor, 1.0);\n}\n\n// multisampling\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = 64., k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}  \n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tXfyRH",
    "date": "1759259006",
    "viewed": 229,
    "name": "Pumpkin Carver V2",
    "description": "This is a fork of P-Malin's amazing [url=https://shadertoy.com/view/MdBXR3]Jack-o'-lantern[/url]\nAfter [url=https://shadertoy.com/view/3cBfDw]version 1[/url], I wanted to test a different approach to the carving using a better scene with convincing SSS",
    "likes": 28,
    "published": "Public API",
    "usePreview": 1,
    "tags": [
     "fork",
     "halloween",
     "drawing",
     "pumpkin",
     "carving",
     "october",
     "jackolantern"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGRn",
       "filepath": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdfGRn",
       "filepath": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Jack-o'-lantern\" by P_Malin. https://shadertoy.com/view/MdBXR3\n// and \"Texture Drawing SDF\" by Cotterzz. https://shadertoy.com/view/3cfBzj\n// and \"Pumpkin Carver V1\" by Cotterzz. https://shadertoy.com/view/3cBfDw\n\n// I was just mucking about with this shader to see if this approach would work for version 2\n// But it turned out so well I just kept it as-is and started work on version 3\n\n// Instead of using a texture to displace an SDF and then subtracting it.\n// Using 2D SDF extrusion is a lot cleaner. (P_Malin's original shader already used this technique to cut out the face.)\n// All I needed to do was convert a brush-drawn texture into 2D SDF first, then I could still use a drawing texture like before.\n// Luckily there is a quick hack for this - comparing minimum distance with mouse position to effectively draw an SDF.\n// It's very crude, but for a single path it does a near perfect job in the positive distance.\n// And is drawn for very little performance cost in real time, so no conversion passes.\n\n#define kRaymarchMaxIter 64\n\n#define kBounceCount 1\n\nfloat kFarClip=100.0;\n\nvec2 GetWindowCoord( const in vec2 vUV );\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget );\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir );\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput );\n\nfloat GetCarving2dDistance(const in vec2 vPos );\n\nvec3 vLightPos = vec3(0.0,0.0, 0.5);\t\t\t\nvec3 vLightColour = vec3(1.0, 0.8, 0.4);\n\nfloat fCarving = 1.0;\n\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n\n    vLightColour *= hash(iTime) * 0.2 + 0.8;\n    \n    float fDist = 5.5;\n    float fAngle = 3.141;\n    float fHeight = 1.0;\n    \n    if(iTime < 1.5)\n    {\n        fDist += pow(abs(iTime - 1.5), 3.);\n    }\n        if(iTime < 3.)\n    {\n        fHeight += pow(abs(iTime -3.), 2.)/5.;\n    }\n    \n\tvec2 vMouse = iMouse.xy / iResolution.xy;\n    \n\tvec3 vCameraPos = vec3(sin(fAngle) * fDist, fHeight, cos(fAngle) * fDist);\n\tvec3 vCameraTarget = vec3(0.0, -0.5, 0.0);\n\n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n\t    \n\tvec3 vFinal = ApplyPostFX( vUV, vResult );\n\t\n\tfragColor = vec4(vFinal, 1.0);\n}\n\n// CAMERA\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 1.5);\n\n\treturn vDir;\n}\n\n// POSTFX\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.95;\n\tconst float kPower = 1.5;\n\n\treturn vInput * ((1.0 - kStrength) +  kStrength * pow(1.0 - fDist, kPower));\n}\n\nvec3 ApplyTonemap( const in vec3 vLinear )\n{\n\tfloat kExposure = 1.0;\n    \n    if(iTime < 2.0)\n    {\n        kExposure = iTime / 2.0;\n    }\n    \t\n\treturn 1.0 - exp2(vLinear * -kExposure);\t\n}\n\nvec3 ApplyGamma( const in vec3 vLinear )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow(vLinear, vec3(1.0/kGamma));\t\n}\n\nvec3 ApplyBlackLevel( const in vec3 vColour )\n{\n    float fBlackLevel = 0.1;\n    return vColour / (1.0 - fBlackLevel) - fBlackLevel;\n}\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec3 vTemp = ApplyVignetting( vUV, vInput );\t\n\t\n\tvTemp = ApplyTonemap(vTemp);\n\t\n\tvTemp = ApplyGamma(vTemp);\t\t\n    \n    vTemp = ApplyBlackLevel(vTemp);\n    \n    return vTemp;\n}\n\t\n// RAYTRACE\n\nstruct C_Intersection\n{\n\tvec3 vPos;\n\tfloat fDist;\t\n\tvec3 vNormal;\n\tvec3 vUVW;\n\tfloat fObjectId;\n};\n\n\nfloat GetCarving2dDistance(const in vec3 vPos) // Note: take full vec3\n{\n    float frontZ = -2.7; // front of pumpkin\n    vec2 surfaceXY = vPos.xy * (frontZ / vPos.z); // perspective correct projection\n    \n    vec2 uv = surfaceXY * vec2(.15,.25) + vec2(.5,.45); \n\n    float userCarving = texture(iChannel2, uv).r-texture(iChannel2, uv).g;\n    userCarving = (userCarving) * 2.0;\n    \n    return userCarving;\n}\n\nfloat GetCarvingDistance(const in vec3 vPos )\n{\n\tfloat fDist = (length(vPos * vec3(1.0, 1.4, 1.0)) - 2.7) / 1.5;\n\n    float fFaceDist = GetCarving2dDistance(vPos);\n    \n\tfloat fRearDist = vPos.z;\n\t\n\tif(fRearDist > fFaceDist)\n\t{\n\t\tfFaceDist = fRearDist;\n\t}\t\n\t\n\tif(fFaceDist < fDist )\n\t{\n\t\tfDist = fFaceDist;\n\t}\n\n    float fR = length(vPos.xz);\n   \n    float fLidDist = dot( vec2(fR, vPos.y), normalize(vec2(1.0, -1.3)));\n    \n    fLidDist = abs(fLidDist) - 0.03;\n\tif(fLidDist < fDist )\n\t{\n\t\tfDist = fLidDist;\n\t}\n   \n\treturn fDist;\n}\n\nfloat GetPumpkinDistance( out vec4 vOutUVW_Id, const in vec3 vPos )\n{\n    vec3 vSphereOrigin = vec3(0.0, 0.0, 0.0);\n    float fSphereRadius = 3.0;\n\n\tvec3 vOffset = vPos - vSphereOrigin;\n\tfloat fFirstDist = length(vOffset);\n\t\n\tfloat fOutDist;\n\tif(fFirstDist > 3.5)\n\t{\n\t\tfOutDist = fFirstDist - fSphereRadius;\n\t}\n\telse\n\t{\n\t\tfloat fAngle1 = atan(vOffset.x, vOffset.z);\n\t\tfloat fSin = sin(fAngle1 * 10.0);\n\t\tfSin = 1.0 - sqrt(abs(fSin));\n\t\tvOffset *= 1.0 + fSin * vec3(0.05, 0.025, 0.05);\n\t\tvOffset.y *= 1.0 + 0.5 * (fSphereRadius - length(vOffset.xz)) / fSphereRadius;\n\t\tfOutDist = length(vOffset) - fSphereRadius;\n\t}\n\t\n\n\tvec4 vSphere1UVW_Id = vec4(normalize(vPos - vSphereOrigin), 3.0);\n\tvOutUVW_Id = vSphere1UVW_Id;\n\t\n\tvec3 vStalkOffset = vPos;\n\tvStalkOffset.x += -(vStalkOffset.y - fSphereRadius) * 0.1;\n\tfloat fDist2d = length(vStalkOffset.xz);\n\tfloat fStalkDist = fDist2d - 0.2;\n\tfStalkDist = max(fStalkDist, vPos.y - 2.5 + vPos.x * 0.25);\n\tfStalkDist = max(fStalkDist, -vPos.y);\n\tif( fStalkDist < fOutDist )\n\t{\n\t\tfOutDist = fStalkDist;\n\t\tvOutUVW_Id = vSphere1UVW_Id;\n\t\tvOutUVW_Id.w = 2.0;\n\t}\n\n\treturn fOutDist;\n}\n\nfloat GetSceneDistance( out vec4 vOutUVW_Id, const in vec3 vPos )\n{\n\tfloat fFloorDist = vPos.y + 2.0;\n\tvec4 vFloorUVW_Id = vec4(vPos.xz, 0.0, 1.0);\n\n\t\n\tvec3 vPumpkinDomain = vPos;\n    \n\tfloat fOutDist = fFloorDist;\n\tvOutUVW_Id = vFloorUVW_Id;\n\n\tvec4 vPumpkinUVW_Id;\n\tfloat fPumpkinDist = GetPumpkinDistance( vPumpkinUVW_Id, vPumpkinDomain );\n\n\tfloat fCarvingDist = GetCarvingDistance( vPumpkinDomain );\n\t\n\tif(-fCarvingDist > fPumpkinDist)\n\t{\n\t\tfPumpkinDist = -fCarvingDist;\n\t\tvPumpkinUVW_Id = vec4(4.0);\n\t}\n\n\t\n\tif(fPumpkinDist < fOutDist)\n\t{\n\t\tfOutDist = fPumpkinDist;\n\t\tvOutUVW_Id = vPumpkinUVW_Id;\n\t}\n\t\n\treturn fOutDist;\n}\n\nvec3 GetSceneNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n\n    vec3 vDir1 = vec3( 1.0, -1.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, -1.0,  1.0);\n    vec3 vDir3 = vec3(-1.0,  1.0, -1.0);\n    vec3 vDir4 = vec3( 1.0,  1.0,  1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n    vec3 vOffset4 = vDir4 * fDelta;\n\n\tvec4 vUnused;\n    float f1 = GetSceneDistance( vUnused, vPos + vOffset1 );\n    float f2 = GetSceneDistance( vUnused, vPos + vOffset2 );\n    float f3 = GetSceneDistance( vUnused, vPos + vOffset3 );\n    float f4 = GetSceneDistance( vUnused, vPos + vOffset4 );\n\t\n    vec3 vNormal = vDir1 * f1 + vDir2 * f2 + vDir3 * f3 + vDir4 * f4;\t\n\t\t\n    return normalize( vNormal );\n}\n\nvoid TraceScene( out C_Intersection outIntersection, const in vec3 vOrigin, const in vec3 vDir )\n{\t\n\tvec4 vUVW_Id = vec4(0.0);\t\t\n\tvec3 vPos = vec3(0.0);\n\t\n\tfloat t = 0.01;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\n\t\tvPos = vOrigin + vDir * t;\n\t\tfloat fDist = GetSceneDistance(vUVW_Id, vPos);\t\t\n\t\tt += fDist;\n\t\tif(abs(fDist) < 0.001)\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\t\tif(t > 100.0)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tvPos = vOrigin + vDir * t;\n\t\t\tvUVW_Id = vec4(0.0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\toutIntersection.fDist = t;\n\toutIntersection.vPos = vPos;\n\toutIntersection.vNormal = GetSceneNormal(vPos);\n\toutIntersection.vUVW = vUVW_Id.xyz;\n\toutIntersection.fObjectId = vUVW_Id.w;\n}\n\n\nfloat TraceShadow( const in vec3 vOrigin, const in vec3 vDir, const in float fDist )\n{\n    C_Intersection shadowIntersection;\n\tTraceScene(shadowIntersection, vOrigin, vDir);\n\tif(shadowIntersection.fDist < fDist) \n\t{\n\t\treturn 0.0;\t\t\n\t}\n\t\n\treturn 1.0;\n}\n\nfloat GetSSS( const in vec3 vPos, const in vec3 vLightPos )\n{\n    vec3 vLightToPos = vPos - vLightPos;\n    vec3 vDir = normalize(vLightToPos);\n    \n\tC_Intersection intersection;\n\tTraceScene(intersection, vLightPos, vDir);\n\tfloat fOpticalDepth = length(vLightToPos) - intersection.fDist;\n\n    fOpticalDepth = max(0.00001, fOpticalDepth);\n    \n\treturn exp2( fOpticalDepth * -8.0 );\n}\n\n// LIGHTING\n\nfloat GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid AddLighting(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightColour)\n{\n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNDotL = clamp(dot(vLightDir, vNormal), 0.0, 1.0);\n\tfloat fNDotV = clamp(dot(-vViewDir, vNormal), 0.0, 1.0);\n\tfloat fNDotH = clamp(dot(vNormal, vH), 0.0, 1.0);\n\t\n\tfloat alpha = 1.0 - fSmoothness;\n\talpha = alpha * alpha;\n\t// D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNDotH * fNDotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (pi * denom * denom);\n\n\tfloat k = alpha / 2.0;\n\tfloat vis = GIV(fNDotL, k) * GIV(fNDotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;\n\tvSpecularLight += vLightColour * fSpecularIntensity;\n\n\tvDiffuseLight += vLightColour * fNDotL;\n}\n\nvoid AddPointLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n\tvec3 vToLight = vLightPos - vPos;\t\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\tvec3 vLightDir = normalize(vToLight);\n\t\n\tvec3 vShadowRayDir = vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, length(vToLight));\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\n}\n\nfloat AddDirectionalLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\n\tvec3 vShadowRayDir = -vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, 10.0);\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, -vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\t\n    \n    return fShadowFactor;\n}\n\nvoid AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(-vLightDir, vRayDir), 0.0, 1.0);\n\tfloat kSpreadPower = 4.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower);\n}\n\n// SCENE MATERIALS\n\nvoid GetSurfaceInfo(out vec3 vOutAlbedo, out vec3 vOutR0, out float fOutSmoothness, out vec3 vOutBumpNormal, const in C_Intersection intersection )\n{\n\tvOutBumpNormal = intersection.vNormal;\n\t\n\tif(intersection.fObjectId == 1.0)\n\t{\n\t\tvec2 vUV = intersection.vUVW.xy * 0.1;\n\t\tvOutAlbedo = texture(iChannel0, vUV).rgb;\n\t\tfloat fBumpScale = 10.0;\n\t\t\n\t\tvec2 vRes = iChannelResolution[0].xy;\n\t\tvec2 vDU = vec2(1.0, 0.0) / vRes;\n\t\tvec2 vDV = vec2(0.0, 1.0) / vRes;\n\t\t\n\t\tfloat fSampleW = texture(iChannel0, vUV - vDU).r;\n\t\tfloat fSampleE = texture(iChannel0, vUV + vDU).r;\n\t\tfloat fSampleN = texture(iChannel0, vUV - vDV).r;\n\t\tfloat fSampleS = texture(iChannel0, vUV + vDV).r;\n\t\t\n\t\tvec3 vNormalDelta = vec3(0.0);\n\t\tvNormalDelta.x += \n\t\t\t( fSampleW * fSampleW\n\t\t\t - fSampleE * fSampleE) * fBumpScale;\n\t\tvNormalDelta.z += \n\t\t\t(fSampleN * fSampleN\n\t\t\t - fSampleS * fSampleS) * fBumpScale;\n\t\t\n\t\tvOutBumpNormal = normalize(vOutBumpNormal + vNormalDelta);\n\n\t\tvOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n\t\tfOutSmoothness = clamp((0.8 - vOutAlbedo.r * 4.0), 0.0, 1.0);\n\t\t\n\t\tvOutR0 = vec3(0.01) * vOutAlbedo.g;\n\t}\n\telse if(intersection.fObjectId == 2.0)\n\t{\n\t\tvOutAlbedo = vec3(0.5, 0.5, 0.2);\n\t\tfOutSmoothness = 0.4;\n\t\tvOutR0 = vec3(0.05);\n\t}\n\telse if(intersection.fObjectId == 3.0)\n\t{\n        float fAngle = atan(intersection.vUVW.x, intersection.vUVW.z);\n        vec2 vUV = vec2(fAngle, intersection.vUVW.y) * vec2(1.0, 0.2) * 8.0;\n\t\tvOutAlbedo = texture(iChannel1, vUV).rgb;\n\t\tfOutSmoothness = clamp(1.0 - vOutAlbedo.r * vOutAlbedo.r * 2.0, 0.0, 1.0);\t\t\t\n\t\tvec3 vCol1 = vec3(1.0, 0.5, 0.0);\n\t\tvec3 vCol2 = vec3(0.5, 0.06, 0.0);\n\t\tvOutAlbedo = mix(vCol1, vCol2, vOutAlbedo.r * 0.5).rgb;\n\t\tvOutR0 = vec3(0.05);\n\t}\n\telse if(intersection.fObjectId == 4.0)\n    {\n\t\tvOutAlbedo = vec3(1.0, 0.824, 0.301);\n\t\tfOutSmoothness = 0.4;\n\t\tvOutR0 = vec3(0.05);\n\t}\n}\n\nvec3 GetSkyColour( const in vec3 vDir )\n{\t\n\tvec3 vResult = mix(vec3(0.02, 0.04, 0.06), vec3(0.1, 0.5, 0.8), abs(vDir.y));\n\t\n\treturn vResult;\t\n}\n\nfloat GetFogFactor(const in float fDist)\n{\n\tfloat kFogDensity = 0.025;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 GetFogColour(const in vec3 vDir)\n{\n\treturn vec3(0.01);\t\t\n}\n\nvec3 vSunLightColour = vec3(0.1, 0.2, 0.3) * 5.0;\nvec3 vSunLightDir = normalize(vec3(0.4, -0.3, -0.5));\n\t\nvoid ApplyAtmosphere(inout vec3 vColour, const in float fDist, const in vec3 vRayOrigin, const in vec3 vRayDir)\n{\t\t\n\tfloat fFogFactor = GetFogFactor(fDist);\n\tvec3 vFogColour = GetFogColour(vRayDir);\t\t\t\n\tAddDirectionalLightFlareToFog(vFogColour, vRayDir, vSunLightDir, vSunLightColour);\n\t\n\tvColour = mix(vFogColour, vColour, fFogFactor);\t\n}\n\n// TRACING LOOP\n\n\t\nvec3 GetSceneColour( in vec3 _vRayOrigin,  in vec3 _vRayDir )\n{\n    vec3 vRayOrigin = _vRayOrigin;\n    vec3 vRayDir = _vRayDir;\n\tvec3 vColour = vec3(0.0);\n\tvec3 vRemaining = vec3(1.0);\n\t\n    float fLastShadow = 1.0;\n    \n\tfor(int i=0; i<kBounceCount; i++)\n\t{\t\n\t\tvec3 vCurrRemaining = vRemaining;\n\t\tfloat fShouldApply = 1.0;\n\t\t\n\t\tC_Intersection intersection;\t\t\t\t\n\t\tTraceScene( intersection, vRayOrigin, vRayDir );\n\n\t\tvec3 vResult = vec3(0.0);\n\t\tvec3 vBlendFactor = vec3(0.0);\n\t\t\t\t\t\t\n\t\tif(intersection.fObjectId == 0.0)\n\t\t{\n\t\t\tvBlendFactor = vec3(1.0);\n\t\t\tfShouldApply = 0.0;\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tvec3 vAlbedo;\n\t\t\tvec3 vR0;\n\t\t\tfloat fSmoothness;\n\t\t\tvec3 vBumpNormal;\n\t\t\t\n\t\t\tGetSurfaceInfo( vAlbedo, vR0, fSmoothness, vBumpNormal, intersection );\t\t\t\n\t\t\n\t\t\tvec3 vDiffuseLight = vec3(0.0);\n\t\t\tvec3 vSpecularLight = vec3(0.0);\n\n            fLastShadow = AddDirectionalLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vSunLightDir, vSunLightColour);\t\t\t\t\t\t\t\t\n\n            vec3 vPointLightPos = vLightPos;\n          \n            \n\t\t\tAddPointLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vPointLightPos, vLightColour);\t\t\t\t\t\t\t\t\n          \n            if(intersection.fObjectId >= 3.0)\n            {\n                vDiffuseLight += GetSSS(intersection.vPos+vec3(0,0.0,0), vPointLightPos) * vLightColour;\n            } else\n            {\n                vec3 vToLight = vPointLightPos - intersection.vPos;\n                float fNdotL = dot(normalize(vToLight), vBumpNormal) * 0.5 + 0.5;\n\t\t\t\tvDiffuseLight += max(0.0, 1.0 - length(vToLight)/5.0) * vLightColour * fNdotL;                \n            }\n\n\t\t\tfloat fSmoothFactor = fSmoothness * 0.9 + 0.1;\n            float fFresnelClamp = 0.25; // too much fresnel produces sparkly artefacts\n            float fNdotD = clamp(dot(vBumpNormal, -vRayDir), fFresnelClamp, 1.0);\n\t\t\tvec3 vFresnel = vR0 + (1.0 - vR0) * pow(1.0 - fNdotD, 5.0) * fSmoothFactor;\n\n            \n\t\t\tvResult = mix(vAlbedo * vDiffuseLight, vSpecularLight, vFresnel);\t\t\n\t\t\tvBlendFactor = vFresnel;\n\t\t\t\n\t\t\tApplyAtmosphere(vResult, intersection.fDist, vRayOrigin, vRayDir);\t\t\n\t\t\t\n\t\t\tvRemaining *= vBlendFactor;\t\t\t\t\n\t\t\tvRayDir = normalize(reflect(vRayDir, vBumpNormal));\n\t\t\tvRayOrigin = intersection.vPos;\n\t\t}\t\t\t\n\n\t\tvColour += vResult * vCurrRemaining * fShouldApply;\t\n\t}\n\n\tvec3 vSkyColor = GetSkyColour(vRayDir);\n\t\n\tApplyAtmosphere(vSkyColor, kFarClip, vRayOrigin, vRayDir);\t\t\n\t\n    // Hack for this scene when using 1 bounce.\n    // remove final sky reflection when in shadow\n    vSkyColor *= fLastShadow; \n    \n\tvColour += vSkyColor * vRemaining;\n    // Face glow\n    float t = -(_vRayOrigin.z + 2.8) / _vRayDir.z;\n    \n    if( t > 0.0 )\n    {\n        vec3 vPos = _vRayOrigin + _vRayDir * t;\n\n        float fDist = abs(GetCarving2dDistance(vec3(vPos.xy * vec2(1.0, 1.0), -2.5)));\n        float fDot = max(0.0, _vRayDir.z);\n        fDot = fDot * fDot;\n        vColour += exp2(-fDist * 10.0) * fDot * vLightColour * 0.25;\n    }\n\treturn vColour;\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tex = texture(iChannel0, fragCoord.xy/iResolution.xy, 0.);\n    float inside = 0.015;\n    float dist = tex.r-tex.g;\n    float newDist ;\n    if(iMouse.z > 0.0)\n    {\n        newDist = (distance(iMouse.xy, fragCoord.xy)/iResolution.x) - inside;\n        \n        if(tex.b==0.1){newDist = min(dist, newDist);} // if drawing has happened compare with existing distance\n        \n        fragColor = vec4(max(newDist,0.),-min(newDist,0.),0.1,1.0);\n        \n    } else if(tex.b!=0.1){fragColor = vec4(0.5,0,0.1,1.);} else {\n        fragColor = tex;\n    }\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "t3XcRH",
    "date": "1759259735",
    "viewed": 128,
    "name": "Pumpkin Moebius",
    "description": "I needed to make a more procedural pumpkin for the next version of the pumpkin carver.\nIt is based on this desmos pumpkin equation: [url]https://www.desmos.com/3d/afwrvhoa9n[/url]\nI thought I'd have some fun with it here.",
    "likes": 21,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "procedural",
     "spiral",
     "animation",
     "halloween",
     "pumpkin",
     "moebius",
     "october",
     "jackolantern"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// rewind or resize to change the random seed\n\n// AA setting in buffer B\n\n// SDF based on:   https://www.desmos.com/3d/afwrvhoa9n\n// Fork of \"Balatro-like Shader\"              by hatenal. https://shadertoy.com/view/t3syRH\n// Fork of \"Pumpkin Carver C du\"           by Nguyen2007. https://shadertoy.com/view/wcsBDl\n// Fork of \"Pumpkin Carver V1\"               by Cotterzz. https://shadertoy.com/view/3cBfDw\n// Fork of \"Ortho Spiral Random shaders\"     by Cotterzz. https://shadertoy.com/view/WcsBWB\n// Fork of \"I heard yall like Ortho spiral?\" by frisk256. https://shadertoy.com/view/3fffRs\n\n// Credits\n// Nguyen2007/a random guy for helping fix the rotation projection issue.\n// ArmandB/Big Chungus for the Desmos pumpkin equation\n// frisk256 for the original moebius code\n// spalmer and FabriceNeyret for the multisampling code\n// chronos/Helios Hyperium for the seam fix\n// diatribes for spotting the pow issue on firefox/linux/opengl\n// vipitis/jakel101, AHSEN/01000001, kaiavintr, kukovisuals for general inspiration and ideas\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv , 0.);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Simple hash function\nfloat hash(float seed) {\n    return fract(sin(seed * 12.9898) * 43758.5453);\n}\n\n// Get 2D sdf data from font texture\nfloat GetCharacter(ivec2 ch, vec2 cuv, float th) {\n    cuv = clamp(cuv, vec2(0), vec2(1));\n    float tx = (cuv.x/16.) + (float(ch.x)*(1./16.));\n    float ty = (cuv.y/16.) + (float(ch.y)*(1./16.));\n    return (-.5*th) + texture(iChannel0, vec2(tx, ty)).a;\n}\n\nfloat char2DSDFRotated(vec2 p, vec2 scale, ivec2 ch, float angle, float th) {\n    float c = cos(angle);\n    float s = sin(angle);\n    vec2 rotP = vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n    vec2 uv = rotP / scale + 0.5;\n    return GetCharacter(ch, uv, th);\n}\n\nfloat eyesSDF(vec2 p, float scale, int index) {\n    ivec2 echars = ivec2(0);\n    float erotation = 0.;\n    vec2 escale = vec2(2,1) * scale;\n    vec2 eoffset = vec2(0,-0.4) * scale;\n    float ethickness = 1.0;\n\n    switch (index) {\n        case 0: echars = ivec2(5,15); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); erotation = -3.141; break;\n        case 1: echars = ivec2(14,14); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); erotation = -3.141; break;\n        case 2: echars = ivec2(4,15); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); escale = vec2(1,1) * scale; erotation = -3.141; break;\n        case 3: echars = ivec2(3,15); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); escale = vec2(1,1) * scale; erotation = -3.141; break;\n        case 4: echars = ivec2(12,14); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); escale = vec2(1,1) * scale; erotation = -3.141; break;\n        case 5: echars = ivec2(10,13); eoffset += vec2(-0.5,-0.2)*scale; p.x = abs(p.x); erotation = -3.141; break;\n        case 6: echars = ivec2(11,13); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); erotation = -3.141; break;\n        case 7: echars = ivec2(12,13); eoffset += vec2(-0.4,-0.4)*scale; p.x = abs(p.x); escale = vec2(2) * scale; break;\n        case 8: echars = ivec2(5,15); eoffset += vec2(-0.5,0)*scale; p.x = abs(p.x); erotation = -3.141; break;\n    }\n    return char2DSDFRotated(p + eoffset, escale, echars, erotation, ethickness);\n}\n\nfloat mouthSDF(vec2 p, float scale, int index) {\n    ivec2 mchars = ivec2(0);\n    float mrotation = 0.;\n    vec2 mscale = vec2(2,1) * scale;\n    vec2 moffset = vec2(0,0.3) * scale;\n    float mthickness = 1.0;\n\n    switch (index) {\n        case 0: mchars = ivec2(6,10); p.x = abs(p.x)<0.5?(fract(p.x * 6.)-0.5)/3.:p.x; break;\n        case 1: mchars = ivec2(15,6); moffset += vec2(-0.4,0)*scale; p.x = abs(p.x); mrotation = -.2; break;\n        case 2: mchars = ivec2(7,8); break;\n        case 3: mchars = ivec2(7,10); break;\n        case 4: mchars = ivec2(13,10); mrotation = 1.57; mscale = vec2(1.2,1.5) * scale; moffset += vec2(-0.1,0)*scale; break;\n        case 5: mchars = ivec2(13,8); mrotation = 1.57; mscale = vec2(1.2,1.5) * scale; moffset += vec2(-0.1,0)*scale; break;\n        case 6: mchars = ivec2(9,13); mrotation = 1.57; mscale = vec2(1.2,1.5) * scale; moffset += vec2(-0.1,0)*scale; break;\n        case 7: mchars = ivec2(8,13); mrotation = 1.57; mscale = vec2(1.2,1.5) * scale; moffset += vec2(-0.1,0)*scale; break;\n        case 8: mchars = ivec2(11,10); mrotation = 1.57; mscale = vec2(1.2,1.5) * scale; moffset += vec2(-0.1,0)*scale; break;\n        case 9: mchars = ivec2(6,10); p.x = abs(p.x)<0.35?(fract(p.x * 6.)-0.5)/3.:p.x; break;\n        case 10: mchars = ivec2(6,10); p.x = abs(p.x)<0.65?(fract(p.x * 6.)-0.5)/3.:p.x; break;\n        case 11: mchars = ivec2(15,5); moffset += vec2(0,0.3)*scale; break;\n        case 12: mchars = ivec2(3,15); mscale = vec2(2.5,1) * scale; break;\n        case 13: mchars = ivec2(3,15); mscale = vec2(1.5,1.5) * scale; break;\n    }\n    \n    return char2DSDFRotated(p + moffset, mscale, mchars, mrotation, mthickness);\n}\n\nfloat faceSDF(vec2 p, float scale, float mouthSliderA, float mouthSliderB, float mouthSliderC, float eyeSliderA) {\n    int mouthTypes = 10;\n    int eyeTypes = 8;\n    \n    float mouthA = mouthSDF(p, scale, int(floor(mouthSliderA * float(mouthTypes))));\n    float mouthB = mouthSDF(p, scale, 1+int(floor(mouthSliderA * float(mouthTypes))));\n    float mouthC = mouthSDF(p, scale, 13);\n    float mouthD = mouthSDF(p, scale, 12);\n    float mouthE = mouthSDF(p, scale, 11);\n    float mouth = mix(mouthA, mouthB, fract(mouthSliderA * float(mouthTypes)));\n    mouth -= (0.5-abs(fract(mouthSliderA * float(mouthTypes)) - 0.5))/15.;\n    float mouthF = mouthSliderB<0.5 ? mix(mouthC, mouthD, mouthSliderB*2.) : mix(mouthD, mouthE, (mouthSliderB-0.5)*1.6);\n    mouth = mix(mouth, mouthF, mouthSliderC);\n    \n    float eyesA = eyesSDF(p, scale, int(floor(eyeSliderA * float(eyeTypes))));\n    float eyesB = eyesSDF(p, scale, 1+int(floor(eyeSliderA * float(eyeTypes))));  \n    float eyes = mix(eyesA, eyesB, fract(eyeSliderA * float(eyeTypes)));\n    \n    return min(mouth, eyes);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // Check resolution change from top-left pixel\n    vec4 storedData = texture(iChannel1, vec2(0.5) / iResolution.xy);\n    float storedWidth = storedData.b * 4096.0;\n    float storedHeight = storedData.a * 4096.0;\n    bool resolutionChanged = abs(storedWidth - iResolution.x) > 0.5 || \n                            abs(storedHeight - iResolution.y) > 0.5;\n    if(fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n            fragColor = vec4(0.0, 0.0, iResolution.x / 4096.0, iResolution.y / 4096.0);\n            return;\n        }\n    // Redraw if first 2 frames OR resolution changed\n    if(iFrame < 10 || resolutionChanged) {\n        // Top-left pixel stores resolution metadata\n        \n        \n        vec2 cellCoord = floor(fragCoord / (iResolution.xy / vec2(8.0, 5.0)));\n        vec2 cellUV = fract(fragCoord / (iResolution.xy / vec2(8.0, 5.0)));   \n        vec2 p = (cellUV * 2.0 - 1.0) * 1.5;\n        float sec = mod(iDate.w,3600.);\n        float randomSeed = cellCoord.x + (cellCoord.y / 10.0) + sec;\n        float mouthSliderA = hash(randomSeed + 0.7);\n        float mouthSliderB = hash(randomSeed + 0.8);\n        float mouthSliderC = hash(randomSeed + 0.9);\n        mouthSliderC *= mouthSliderC*mouthSliderC*mouthSliderC; // bias to lower values\n        //mouthSliderC = 1.-mouthSliderC;\n        float eyeSliderA = hash(randomSeed + 1.1);\n        if(cellCoord==vec2(0)){\n            mouthSliderA = 0.6;\n            mouthSliderB = 0.7;\n            mouthSliderC = 0.5;\n            eyeSliderA = 0.37;\n        }\n        float scale = 1.0;\n        float dist = faceSDF(p, scale, mouthSliderA, mouthSliderB, mouthSliderC, eyeSliderA);\n        float mask = smoothstep(0.02, -0.02, dist);\n        \n        fragColor = vec4(dist * 0.5 + 0.5, mask, 0.0, 1.0);\n    } else {\n        // Keep previous frame\n        fragColor = texture(iChannel1, fragCoord.xy / iResolution.xy);\n    }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "#if HW_PERFORMANCE == 0\n#define AA 1\n#else\n#define AA 3\n#endif\n\n// set to 1 to disable antialiasing, higher numbers for smooth gfx at the expense of FPS.\n\nfloat randomSeed = 0.0;\nvec4 guv;\nvec2 bguv;\nvec2 cellID;\nfloat shadow = 0.;\n// Pumpkin shape parameters\nfloat n0, m0, k0, n1, m1, k1, n2, m2, k2;\nfloat g, p, h;\n\n// Lid parameters\nfloat thickness;\nfloat cutSphereRadius;\nfloat cutSphereY;\nfloat lidRaise;\nfloat lidTiltX;\nfloat lidTiltZ;\nfloat lidGap;\n\n// Stalk parameters\nfloat stalkRadius;\nint stalkStarN;\nfloat stalkStarM;\nfloat stalkHeight;\nfloat stalkTwist;\nfloat stalkBend;\nfloat stalkTaper;\nfloat stalkBulbHeight;\nfloat stalkBulbRadius;\nfloat stalkHeightOffset;\n\n// Face parameters\nfloat faceScale;\nfloat faceDepth;\nfloat faceZ;\nfloat stemSubtract;\nfloat mouthSliderA;\nfloat mouthSliderB;\nfloat mouthSliderC;\nfloat eyeSliderA;\nint mouthTypes = 10;\nint eyeTypes = 8;\n\n// Simple hash function\nfloat hash(float seed) {\n    return fract(sin(seed * 12.9898) * 43758.5453);\n}\nvec2 hash2(float n) {\n    return vec2(hash(n), hash(n * 1.7));\n}\n// Parameter mapping functions\nfloat mapParam(float t, float minVal, float maxVal) {\n    return mix(minVal, maxVal, t);\n}\n\nfloat mapFloor(float t, float minVal, float maxVal) {\n    return floor(mix(minVal, maxVal, clamp(t, 0.0, 1.0)));\n}\n\n// SDF Operations\nfloat opOnion(float sdf, float thickness) {\n    return abs(sdf) - thickness;\n}\n\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat sphereSDF(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\n// 2D Star SDF\nfloat sdStar(vec2 p, float r, int n, float m) {\n    float an = 3.141593 / float(n);\n    float en = 3.141593 / m;\n    vec2 acs = vec2(cos(an), sin(an));\n    vec2 ecs = vec2(cos(en), sin(en));\n\n    float bn = mod(atan(p.y, p.x), 2.0 * an) - an;\n    p = length(p) * vec2(cos(bn), abs(sin(bn)));\n    p -= r * acs;\n    p += ecs * clamp(-dot(p, ecs), 0.0, r * acs.y / ecs.y);\n    return length(p) * sign(p.x);\n}\n\nfloat faceSDF(vec2 p, float scale) {\n    // Calculate which cell in the atlas to use\n    vec2 atlasSize = vec2(8.0, 5.0);\n    vec2 atlasCellA = mod(cellID, atlasSize);\n    vec2 atlasCellB = mod(vec2(0), atlasSize);\n    // Convert p from world space to atlas UV space\n    vec2 atlasUVA = (p / scale + 1.0) * 0.5; // -1..1 to 0..1\n    atlasUVA = (atlasUVA + atlasCellA) / atlasSize;\n     // Convert p from world space to atlas UV space\n    vec2 atlasUVB = (p / scale + 1.0) * 0.5; // -1..1 to 0..1\n    atlasUVB = (atlasUVB + atlasCellB) / atlasSize;   \n    // Sample the pre-rendered face\n    vec4 tex = mix(texture(iChannel0, atlasUVB), texture(iChannel0, atlasUVA), guv.w);\n    float sdfValue = mix(1.- tex.g, tex.r, guv.w); // Use iChannel1 for Buffer A\n    \n    // Convert back from normalized range\n    return (sdfValue - 0.5) / 5.0;\n}\n\n// Extrude a 2D SDF along Z axis\nfloat extrudeSDF(vec3 pos, float char2D, float halfDepth) {\n    vec2 w = vec2(char2D, abs(pos.z) - halfDepth);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n// Twisting operation\nvec3 opTwist(vec3 p, float k) {\n    float c = cos(k * p.y);\n    float s = sin(k * p.y);\n    return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\n// Bending operation\nvec3 opBend(vec3 p, float k) {\n    float bendAmount = k * p.y * p.y / stalkHeight;\n    return vec3(p.x + bendAmount, p.y, p.z);\n}\n\n// Rotation matrices\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\n\nmat3 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n\n// Convert Cartesian to spherical coordinates\nvec3 cartesianToSpherical(vec3 pos) {\n    float rho = length(pos);\n    float theta = atan(pos.z, pos.x);\n    float phi = acos(pos.y / rho);\n    return vec3(rho, theta, phi);\n}\n\nfloat pown(float f, float p){\n    return pow(abs(f), p);\n}\n\n// Pumpkin equation SDF\nfloat pumpkinSDF(vec3 pos) {\n    vec3 spherical = cartesianToSpherical(pos);\n    float theta = spherical.y;\n    float phi = spherical.z;\n    \n    float sin_term0 = sin(n0 * theta + m0);\n    float sin_term1 = sin(n1 * theta + m1);\n    float sin_term2 = sin(n2 * theta + m2);\n    \n    float part1 = (1.0 - pown(sin_term0, 4.0)) * (k0 / n0) +\n                  (1.0 - sin_term1) * (k1 / n1) +\n                  (1.0 - sin_term2) * (k2 / n2);\n    \n    float cos_2phi = cos(2.0 * phi);\n    float part2 = pown((1.0 - cos_2phi) / 2.0, 2.0);\n    float part3 = exp(-pown(phi - 3.14159 / 2.0, 2.0)) + p;\n    float part4 = 1.0 - h * cos_2phi;\n    \n    float target_rho = (part1 * part2 + g) * part3 * part4;\n    \n    return length(pos) - target_rho;\n}\n\n// Stalk SDF\nfloat stalkSDF(vec3 pos) {\n    vec3 stalkPos = pos;\n    stalkPos.y -= lidRaise;\n    stalkPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * stalkPos;\n    stalkPos = stalkPos - vec3(0.0, stalkHeightOffset + (g * p * 1.2) - (h/3.), 0.0);\n    \n    vec3 twistedPos = opTwist(stalkPos, stalkTwist / stalkHeight);\n    vec3 bentPos = opBend(twistedPos, stalkBend / stalkHeight);\n    \n    float heightFactor = clamp((bentPos.y) / stalkHeight, 0.0, 1.0);\n    float bulbFactor = 1.0 - smoothstep(0.0, stalkBulbHeight, bentPos.y);\n    float bulbRadius = mix(stalkRadius, stalkBulbRadius, bulbFactor);\n    float taperedRadius = bulbRadius * (1.0 - stalkTaper * heightFactor);\n    \n    float starDist = sdStar(bentPos.xz, taperedRadius, stalkStarN, stalkStarM);\n    float heightDist = (abs(bentPos.y - stalkHeight * 0.5) - stalkHeight * 0.5);\n    \n    vec2 w = vec2(starDist, heightDist);\n    float stalkBase = min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n\n    return opSubtraction(stemSubtract, stalkBase);\n}\n\n// Hollow pumpkin with top cut off\nfloat hollowPumpkinSDF(vec3 pos) {\n    float pumpkin = pumpkinSDF(pos);\n    float hollow = opOnion(pumpkin, thickness);\n    \n    vec3 cutSpherePos = pos - vec3(0.0, cutSphereY, 0.0);\n    float cuttingSphere = sphereSDF(cutSpherePos, cutSphereRadius + lidGap);\n    \n    return opSubtraction(cuttingSphere, hollow);\n}\n\n// Lid SDF\nfloat lidSDF(vec3 pos) {\n    vec3 lidPos = pos;\n    lidPos.y -= lidRaise;\n    lidPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * lidPos;\n    \n    float pumpkin = pumpkinSDF(lidPos);\n    stemSubtract = pumpkin;\n    \n    float hollow = opOnion(pumpkin, thickness);\n    \n    vec3 cutSpherePos = lidPos - vec3(0.0, cutSphereY, 0.0);\n    float cuttingSphere = sphereSDF(cutSpherePos, cutSphereRadius);\n    \n    return max(hollow, cuttingSphere);\n}\n\n// Main scene SDF\nfloat sceneSDF(vec3 pos) {\n    float hollowPumpkin = hollowPumpkinSDF(pos);\n    float lid = lidSDF(pos);\n    float stalk = stalkSDF(pos);\n    \n    float faceShape = faceSDF(pos.xy, faceScale*1.4);\n    vec3 facePos = pos - vec3(0.0, 0.0, faceZ);\n    float faceCutout = extrudeSDF(facePos, faceShape, faceDepth);\n    \n    hollowPumpkin = opSubtraction(faceCutout, hollowPumpkin);\n    \n    return opUnion(opUnion(hollowPumpkin, lid), stalk);\n}\n\n// Raymarching\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 pos = ro + t * rd;\n        float d = sceneSDF(pos);\n        if (d < 0.0005) break;\n        t += d * .9;\n        if (t > 50.0) break;\n    }\n    return t;\n}\n\n// Calculate normal\nvec3 getNormal(vec3 pos) {\n    float eps = 0.001;\n    vec3 n = vec3(\n        sceneSDF(pos + vec3(eps, 0, 0)) - sceneSDF(pos - vec3(eps, 0, 0)),\n        sceneSDF(pos + vec3(0, eps, 0)) - sceneSDF(pos - vec3(0, eps, 0)),\n        sceneSDF(pos + vec3(0, 0, eps)) - sceneSDF(pos - vec3(0, 0, eps))\n    );\n    return normalize(n);\n}\n\n// Subsurface scattering\nfloat calculateSubsurface(vec3 pos, vec3 interiorLightPos, float probeDistance) {\n    vec3 toLightDir = normalize(interiorLightPos - pos);\n    float toLightDist = distance(interiorLightPos , pos);\n    vec3 probePos = pos + toLightDir * (probeDistance + 0.15);\n    float d = sceneSDF(probePos);\n    \n    // Only apply subsurface if we're actually inside the object\n    // and not just in free space\n    float surfaceDist = sceneSDF(pos);\n    if (surfaceDist > 0.001) return 0.0;  // We're not on the surface\n    \n    return clamp(max(0., (d*3.)/(toLightDist*toLightDist)), 0.0, 1.0);\n}\n\nvec3 lighting(vec3 pos, vec3 normal, vec3 viewDir, float subsurfaceDistance, float subsurfaceAttenuation, mat3 cameraMatrix) {\n    float flicker = 0.9 + hash(randomSeed) + 0.4 * sin(iTime * 37.0) + 0.2 * sin(iTime * 71.0) * (0.5 + hash(randomSeed));\n    \n    vec3 worldKeyLightDir = normalize( mix(vec3(0,1,0) , vec3(-1.,.7,-1.) , guv.x) );  // Original direction\n    vec3 keyLightDir = normalize(cameraMatrix * worldKeyLightDir);  // Transform to camera space\n    vec3 keyLightColor = mix(vec3(1) ,vec3(.1, 0.7, 1.0), guv.x);\n\n    vec3 interiorLightPos = vec3(0.0, 0.0, 0.0);\n    vec3 interiorLightColor = vec3(1.2, .8, 0.2);\n    float interiorLightIntensity = mix( 0. , flicker , guv.w);\n    \n    vec3 ambient = vec3(0.7, 0.5, 0.4)-guv.w/2.5;\n\n    float keyDiff = max(dot(normal, keyLightDir), 0.0);\n    vec3 keyDiffuse = keyDiff * keyLightColor;\n    \n    vec3 keyReflectDir = reflect(-keyLightDir, normal);\n    float keySpec = pow(max(dot(viewDir, keyReflectDir), 0.0), 32.0);\n    vec3 keySpecular = keySpec * keyLightColor;\n    \n    vec3 toInteriorLight = interiorLightPos - pos;\n    float interiorLightDist = length(toInteriorLight);\n    vec3 interiorLightDir = toInteriorLight / interiorLightDist;\n    \n    float attenuation = interiorLightIntensity / (1.0 + 0.3 * interiorLightDist * interiorLightDist);\n\n    float interiorDiff = max(dot(normal, interiorLightDir), 0.0);\n    vec3 interiorDiffuse = interiorDiff * interiorLightColor * attenuation * guv.w;\n    \n    vec3 diffuse = keyDiffuse + interiorDiffuse;\n    \n    float hollowDist = hollowPumpkinSDF(pos);\n    float lidDist = lidSDF(pos);\n    float stalkDist = stalkSDF(pos);\n    \n    vec3 materialColor;\n    float fleshSpecular = 1.0;\n    \n    if (stalkDist < hollowDist && stalkDist < lidDist) {\n        materialColor = vec3(0.36, 0.57, 0.13);\n    } else if (lidDist < hollowDist) {\n        vec3 lidPos = pos;\n        lidPos.y -= lidRaise;\n        lidPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * lidPos;\n        \n        float originalLidPumpkin = pumpkinSDF(lidPos);\n        float fleshDepth = max(0.0, -originalLidPumpkin + thickness);\n        \n        if (fleshDepth > 0.001) {\n            float depthFactor = clamp(fleshDepth / 0.1, 0.0, 1.0);\n            vec3 fleshColor = mix(vec3(1.2, 0.9, 0.4), vec3(0.8, 0.4, 0.1), depthFactor);\n            materialColor = fleshColor;\n            fleshSpecular = max(0., mix(0.8, 0.1, depthFactor * 20.));\n        } else {\n            materialColor = vec3(0.8, 0.4, 0.12);\n        }\n    } else {\n        float originalPumpkin = pumpkinSDF(pos);\n        float fleshDepth = max(0.0, -originalPumpkin + (thickness));\n        shadow = clamp(7.* clamp(-originalPumpkin, 0.01, 10.5) * (1.-guv.w), 0., 0.6);\n\n        if (fleshDepth > 0.001) {\n            float depthFactor = clamp(fleshDepth / 0.1, 0.0, 1.0);\n            vec3 fleshColor = mix(vec3(1.2, 0.9, 0.4), vec3(0.8, 0.4, 0.1), depthFactor);\n\n            materialColor = fleshColor;\n            fleshSpecular = max(0., mix(0.8, 0.1, depthFactor * 20.));\n        } else {\n            materialColor = vec3(0.9, 0.45, 0.15);\n        }\n    }\n    \n    float subsurfaceDistance_val = calculateSubsurface(pos, interiorLightPos, subsurfaceDistance);\n    float subsurfaceFactor = subsurfaceDistance_val > 0.0 ? clamp(subsurfaceDistance_val, 0.0, 1.0) : 0.0;\n    vec3 subsurfaceLight = subsurfaceFactor * interiorLightColor * guv.w;\n    \n    return (materialColor * (ambient + diffuse + subsurfaceLight - shadow) + fleshSpecular * keySpecular) ;\n}\n\nfloat sinS(float x, float skip_count) {\n    float period_length = 2.0 * 3.14159265359;\n    float period_number = floor(x / period_length);\n    float period_mod = mod(period_number, skip_count);\n    \n    if (period_mod >= skip_count - 1.0) {\n        return -cos(x);\n    } else {\n        return -1.0;\n    }\n}\nvec2 simulateCursorOrganic(float time) {\n    float changeInterval = 2.0;\n    float currentIndex = floor(time / changeInterval);\n    \n    // Generate multiple waypoints for more complex paths\n    vec2 p0 = hash2(currentIndex - 1.0);\n    vec2 p1 = hash2(currentIndex);\n    vec2 p2 = hash2(currentIndex + 1.0);\n    vec2 p3 = hash2(currentIndex + 2.0);\n    \n    float localTime = fract(time / changeInterval);\n    \n    // Elastic easing for \"darting\" with slight overshoot\n    float t = localTime;\n    if (t < 0.3) {\n        // Quick dart phase\n        t = pow(t / 0.3, 2.0);\n    } else {\n        // Settle with slight oscillation\n        t = 1.0 - pow(1.0 - (t - 0.3) / 0.7, 3.0) * 0.05 * \n            cos((t - 0.3) * 20.0);\n    }\n    \n    // Catmull-Rom spline for smoother path\n    vec2 cursor = 0.5 * (\n        (2.0 * p1) +\n        (-p0 + p2) * t +\n        (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3) * t * t +\n        (-p0 + 3.0 * p1 - 3.0 * p2 + p3) * t * t * t\n    );\n    \n    return clamp(cursor, 0.0, 1.0);\n}\nvec2 simulateCursorAdvanced(float time, float ji) {\n    float jumpInterval = 1.+4.*ji;\n    float jumpIndex = floor(time / jumpInterval);\n    float jumpProgress = fract(time / jumpInterval);\n    \n    // Multiple movement phases:\n    // 0.0-0.1: hold at start position\n    // 0.1-0.4: dart to new position\n    // 0.4-1.0: hold at end position\n    \n    float moveProgress;\n    if (jumpProgress < 0.1) {\n        moveProgress = 0.0; // Hold\n    } else if (jumpProgress < 0.4) {\n        // Quick dart motion\n        float t = (jumpProgress - 0.1) / 0.3;\n        moveProgress = 1.0 - pow(1.0 - t, 2.0); // Ease-out\n    } else {\n        moveProgress = 1.0; // Hold at destination\n    }\n    \n    vec2 fromPos = hash2(jumpIndex);\n    vec2 toPos = hash2(jumpIndex + 1.0);\n    \n    // Add some slight wobble at destination\n    if (moveProgress >= 1.0) {\n        toPos += sin(time * 10.0) * 0.01;\n    }\n    \n    return mix(fromPos, toPos, moveProgress);\n}\nvec3 mainImage1(vec2 uv, vec2 id) {\n    // Set random seed based on cell\n    randomSeed = id.x + (id.y / 10.);\n    \n    // Generate all parameters from random seed\n    float anim = (2. + randomSeed / 2.)*3.;\n    float anims = 10.;\n    float tiltPhase = 1. - fract(  ( (iTime - 0.1 + (anim * 3.)) * anims /15. ) / (2.0 * 3.14159265359)  );\n    tiltPhase *=tiltPhase;\n    lidRaise = mix(0., mapParam((sinS(   ((iTime + (anim * 3.)) * anims *2. ) , 30. ) + 1.), 0.03, 0.3)  , guv.w) ;\n    lidTiltX = mix(0., mapParam((sin(((iTime + anim * 3.) * anim)) + 1.) / 2., -0.2, 0.2)  , guv.w) * tiltPhase; \n    lidTiltX += lidRaise * 2.*(hash(randomSeed +3.)-0.5);\n    lidTiltZ = mix(0., mapParam((cos(((iTime + anim * 3.) * anim)) + 1.) / 2., -0.15, 0.15)  , guv.w) * tiltPhase;\n    lidTiltZ += lidRaise * 2.*(hash(randomSeed)-0.5);\n    uv.y -= guv.w * (sinS(((iTime + anim * 3.) * anims), 15.) + 1.)/10.;\n    \n    \n    //uv.y -= tiltPhase;\n    cutSphereY = mapParam(hash(randomSeed + 0.3), 0.5, 0.8);\n    cutSphereRadius = mapParam(hash(randomSeed + 0.4), 0.45, 0.6);\n    thickness = mapParam(hash(randomSeed + 0.5), 0.05, 0.06);\n    lidGap = mapParam(hash(randomSeed + 0.6), 0.0, 0.05);\n    \n    mouthSliderA = hash(randomSeed + 0.7);\n    mouthSliderB = hash(randomSeed + 0.8);\n    mouthSliderC = hash(randomSeed + 0.9);\n    eyeSliderA = hash(randomSeed + 1.1);\n    \n    float subsurfaceDistance = mapParam(hash(randomSeed + 1.2), 0.05, 0.08);\n    float subsurfaceAttenuation = mapParam(hash(randomSeed + 1.3), 0.2, 2.0);\n    \n    vec2 sMouse = simulateCursorAdvanced(anim+iTime*anim/7., hash(randomSeed));\n    \n    // Camera parameters\n    float focal = 0.0;\n    float baseCameraDist = mapParam(0.1, 4.0, 10.0);\n    float screenMag = mapParam(1.0, 0.75, 3.0);\n    vec2 spooky = mix(vec2(0.5), sMouse, guv.w/2.);\n    float pitch = radians(mapParam(0.5 - (0.5 - spooky.y) / 3., -89.0, 70.0));\n    float yaw = mapParam(0.5 - (0.5 - spooky.x) / 3., -4.7123, 1.5708);\n    //float yaw = mapParam(0.5 - (guv.x-0.5)/10., -4.7123, 1.5708);\n    \n    // Stalk parameters\n    stalkRadius = mapParam(hash(randomSeed + 2.0), 0.04, 0.1);\n    stalkStarN = int(mapFloor(hash(randomSeed + 2.1), 5.0, 20.0));\n    stalkStarM = mapParam(hash(randomSeed + 2.2), 1.8, 4.0);\n    stalkHeight = mapParam(hash(randomSeed + 2.3), 0.3, 0.5);\n    stalkTwist = mapParam(hash(randomSeed + 2.4), 0.0, 1.5);\n    stalkBend = mapParam(hash(randomSeed + 2.5), 0.0, 0.4);\n    stalkTaper = mapParam(hash(randomSeed + 2.6), -0.5, 0.3);\n    stalkBulbHeight = mapParam(hash(randomSeed + 2.7), 0.1, 0.3);\n    \n    // Pumpkin shape parameters\n    k2 = mapParam(hash(randomSeed + 2.8), 0.02, 0.3);\n    m2 = mapParam(hash(randomSeed + 2.9), 0.0, 6.28);\n    n2 = mapFloor(hash(randomSeed + 3.0), 4.0, 12.0);\n    k1 = mapParam(hash(randomSeed + 3.1), 0.02, 0.3);\n    m1 = mapParam(hash(randomSeed + 3.2), 0.0, 6.28);\n    n1 = mapFloor(hash(randomSeed + 3.3), 5.0, 30.0);\n    k0 = mapParam(hash(randomSeed + 3.4), 0.02, 0.3);\n    m0 = mapParam(hash(randomSeed + 3.5), 0.0, 3.14);\n    n0 = mapFloor(hash(randomSeed + 3.6), 6.0, 60.0);\n    h = mapParam( mix( 0.35, hash(randomSeed + 3.7), guv.w ), -0.3, 0.05) + guv.w * (sinS(((iTime - 0.25 + (anim * 3.)) *anims* 2.), 30.) + 1.)/15.;\n    p = mapParam( mix( 0.5, hash(randomSeed + 3.8), guv.w ), 0.5, 0.8);\n    g = mapParam( mix( 0.5, hash(randomSeed + 3.9), guv.w ), 0.5, 0.7);\n    \n    // Derived parameters\n    stalkBulbRadius = cutSphereRadius * 0.6;\n    stalkHeightOffset = 0.0;\n    faceScale = g * (p + .3) * ((h + 1.) / 3.) * mapParam(hash(randomSeed + 1.0), 3.25, 4.5);\n    faceDepth = 1.3;\n    faceZ = 1.3;\n    \n    baseCameraDist /= pow(max(0.5, focal), 2.);\n    screenMag /= pow(max(0.5, focal), 2.);\n    \n    vec2 uvScene = uv / screenMag;\n    \n    // Camera setup\n    vec3 target = vec3(0.0, 0.35, 0.0);\n    vec3 dir = vec3(cos(pitch) * cos(yaw), sin(pitch), cos(pitch) * sin(yaw));\n    vec3 ro = target - dir * baseCameraDist;\n\n    vec3 forward = normalize(target - ro);\n    vec3 upRef = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(forward, upRef));\n    vec3 up = cross(right, forward);\n// Camera to world matrix (inverse of view matrix rotation part)\nmat3 cameraMatrix = mat3(right, up, -forward);\n    vec3 rd = normalize(forward + uvScene.x * right + uvScene.y * up);\n    \n    vec3 color = mix(vec3(0.9,0.9,1.2), vec3(0.0), guv.y);\n    color = pow(1.2*mix(color, color* texture(iChannel1, bguv, 0.).rgb, guv.y), vec3(2.));\n    \n    float t = raymarch(ro, rd);\n\n    if (t < 50.0) {\n        vec3 pos = ro + t * rd;\n        vec3 normal = getNormal(pos);\n        vec3 viewDir = normalize(ro - pos);\n       color = lighting(pos, normal, viewDir, subsurfaceDistance, subsurfaceAttenuation, cameraMatrix);\n    }\n    \n    return color;\n}\n\nvoid compute_things(in vec2 p, out vec2 h, out vec2 ddx, out vec2 ddy) {\n    const float TAU = 6.28318530718;\n    const mat2 M = mat2(8.0, 5.0, -5.0, 8.0);\n\n    vec2 r = iResolution.xy;\n    vec2 s = sqrt(r / r.yx);\n    vec2 a = 2.0 / r * s;\n    vec2 u = a * p - s;\n    \n    float S = dot(u, u) + 1.0;\n    float invS = 1.0 / S;\n    float invS2 = invS * invS;\n\n    vec3 g = vec3(1.0, u.yx) * invS + vec3(-0.5, 0.0, 0.5);\n\n    float T = dot(g, g);\n    float invT = 1.0 / T;\n    float invT2 = invT * invT;\n\n    vec3 dg_dux = vec3(-2.0 * u.x * invS2, -2.0 * u.x * u.y * invS2, invS - 2.0 * u.x * u.x * invS2);\n    vec3 dg_duy = vec3(-2.0 * u.y * invS2, invS - 2.0 * u.y * u.y * invS2, -2.0 * u.x * u.y * invS2);\n\n    vec3 dg_dx = dg_dux * a.x;\n    vec3 dg_dy = dg_duy * a.y;\n\n    vec2 q = g.xy * invT;\n\n    float dTdx = 2.0 * dot(g, dg_dx);\n    float dTdy = 2.0 * dot(g, dg_dy);\n\n    vec2 dq_dx = dg_dx.xy * invT - g.xy * dTdx * invT2;\n    vec2 dq_dy = dg_dy.xy * invT - g.xy * dTdy * invT2;\n\n    float denom = dot(q, q);\n    float scale = 1.0 / (TAU * denom);\n\n    ddx = vec2(dq_dx.x * q.y - dq_dx.y * q.x, dot(dq_dx, q)) * scale;\n    ddy = vec2(dq_dy.x * q.y - dq_dy.y * q.x, dot(dq_dy, q)) * scale;\n\n    h = vec2(atan(q.x, q.y), log(length(q))) / TAU;\n    h += iTime * 0.04;\n\n    h *= M;\n    ddx *= M;\n    ddy *= M;\n}\n\nmat2 rotate(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage0(out vec4 c, vec2 p) {\n\n    vec2 h, ddx, ddy;\n    compute_things(p, h, ddx, ddy);\n \n    float a = atan(ddx.x, ddy.x);\n    cellID = floor(h);\n    cellID = mod(cellID, vec2(8, 5));\n    vec2 cellUV = fract(h);\n    \n    vec2 uv = cellUV.yx * 2.0 - 1.0;\n    //uv = mix(  uv*rotate(3.2)  ,    uv*rotate(-a), guv.y*guv.y);\n    uv *= rotate(-a);\n    //uv *= rotate(2.6);\n    vec3 col = mainImage1(uv, cellID);\n    c = vec4(col, 1.0);\n\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    //fragCoord*=1.5;\n    //fragCoord += iMouse.xy-iResolution.xy/2.;\n    vec2 uv =  fragCoord.xy/iResolution.xy;\n    guv.xy = uv;\n    bguv = uv;\n    guv = guv.xxxx;\n    guv.y /= 0.4;\n    guv.y -= .8;\n    guv.z /= 0.2;\n    guv.z -= 02.;\n   // uv.y+=(-.1 + (uv.x*.2));\n    guv.w = distance(uv, vec2(.0, .5));\n    if (uv.y<.5) {\n    guv.w = 1.-(distance(uv, vec2(1., .5)));\n    }\n    guv.y  = guv.w *2.;guv.y -=.3;\n    guv.w  = guv.w *6.;guv.w -=2.4;\n    guv = clamp(guv, vec4(0), vec4(1));\n    vec2 j = vec2(.5);\n    fragColor = vec4(0);\n    vec4 c;\n    mainImage0(c, fragCoord);\n    float s = float(AA);\n    float k;\n    for (k = s; k-- > .5;) {\n        mainImage0(c, fragCoord + j - .5);\n        fragColor += c;\n        j = fract(j + vec2(.755, .57).yx);\n    }\n    fragColor /= s;\n    fragColor.a = 1.;\n    \n    vec3 color = fragColor.rgb;\n    \n    color = atan(color);\n    fragColor = vec4(color, 1.0);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// ---------- Editable parameters ----------\nvec4 colour_1 = vec4(2,2,3, 1.0);  // replace with desired RGBA (0..1)\nvec4 colour_2 = vec4(0,0,0, 1.0);\nvec4 colour_3 = vec4(.0,0,.3, 1.0);\n\nfloat contrast = 1.0;      // tweak 0..2 (approx)\nfloat spin_amount = 1.0;   // 0..1\nfloat spin_time_mul = 1.5; // multiply iTime if you want spin to run faster/slower\n\n// ---------- Internal constants ----------\n#define PIXEL_SIZE_FAC 700.0\n#define SPIN_EASE 0.5\n\nfloat resLen(vec2 r){ return length(r); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 bguv = fragCoord.xy/iResolution.xy;\n    vec4 bgtex=texture(iChannel0, bguv, 0.);\n\n    fragCoord.x-=iResolution.x/4.;\n    vec2 screen_coords = fragCoord;\n    vec2 love_ScreenSize = iResolution.xy;\n\n    float pixel_size = resLen(love_ScreenSize) / PIXEL_SIZE_FAC;\n    vec2 uv = (floor(screen_coords * (1.0 / pixel_size)) * pixel_size - 0.5 * love_ScreenSize) \n              / resLen(love_ScreenSize) - vec2(0.12, 0.0);\n    float uv_len = length(uv);\n\n    float speed = (spin_time_mul * iTime * SPIN_EASE * 0.2) + 302.2;\n    float new_pixel_angle = atan(uv.y, uv.x) + speed \n                            - SPIN_EASE * 20.0 * (spin_amount * uv_len + (1.0 - spin_amount));\n    vec2 mid = (love_ScreenSize / resLen(love_ScreenSize)) / 2.0;\n    uv = vec2(uv_len * cos(new_pixel_angle) + mid.x,\n              uv_len * sin(new_pixel_angle) + mid.y) - mid;\n\n    uv *= 30.0;\n\n    speed = iTime * 2.0;\n    vec2 uv2 = vec2(uv.x + uv.y);\n\n    for(int i = 0; i < 5; i++) {\n        uv2 += sin(max(uv.x, uv.y)) + uv;\n        uv  += 0.5 * vec2(cos(5.1123314 + 0.353 * uv2.y + speed * 0.131121), \n                          sin(uv2.x - 0.113 * speed));\n        uv  -= cos(uv.x + uv.y) - sin(uv.x * 0.711 - uv.y);\n    }\n\n    float contrast_mod = (0.25 * contrast + 0.5 * spin_amount + 1.2);\n    float paint_res = min(2.0, max(0.0, length(uv) * 0.035 * contrast_mod));\n    float c1p = max(0.0, 1.0 - contrast_mod * abs(1.0 - paint_res));\n    float c2p = max(0.0, 1.0 - contrast_mod * abs(paint_res));\n    float c3p = 1.0 - min(1.0, c1p + c2p);\n\n    vec4 ret_col = (0.3 / contrast) * colour_1 \n                 + (1.0 - 0.3 / contrast) * (colour_1 * c1p \n                 + colour_2 * c2p \n                 + vec4(c3p * colour_3.rgb, c3p * colour_1.a));\n \n\n    fragColor = (bgtex*20. +  ret_col)/21.;\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WXscz8",
    "date": "1759421028",
    "viewed": 0,
    "name": "OJ - Ljusfärd w pumpkins",
    "description": "Full demo: https://www.youtube.com/watch?v=-helx-SxnJo",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "3d",
     "reflection",
     "lightning"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"OJ - Ljusfärd, scene 4\" by rammoskar. https://shadertoy.com/view/lsXfW4\n// 2025-09-30 21:53:19\n\n\n\n// Mode selection - comment out for random mode\n#define USE_SLIDERS\n\n// Slider values on the right are pumpkin then stalk metrics.\n// Slider values on the left are camera/view at the top, then AA, then face then lid metrics at the bottom.\n\n// iChannel0 is this buffers output, iChannel1 is the font texture\n\n// Pumpkin Shader, SDF Based on:\n// https://www.desmos.com/3d/afwrvhoa9n\n\n\n// Random seed for random mode\nfloat randomSeed = 0.0;\n\nfloat n0 = 6.0;   // Primary ridge frequency (higher = more ridges)\nfloat m0 = 0.0;    // Primary ridge offset\nfloat k0 = 0.02;    // Primary ridge amplitude\n\nfloat n1 = 20.0;    // Secondary ridge frequency\nfloat m1 = 0.5;    // Secondary ridge offset  \nfloat k1 = 0.15;   // Secondary ridge amplitude\n\nfloat n2 = 3.0;    // Tertiary ridge frequency\nfloat m2 = 0.5;    // Tertiary ridge offset\nfloat k2 = 0.1;    // Tertiary ridge amplitude\n\nfloat g = 0.6;     // Global size offset\nfloat p = 0.9;     // Vertical squash factor\nfloat h = -0.3;    // Top/bottom flattening\n\nfloat[40] sliderValues;\nbool[40] hasInteracted;\n\nfloat thickness = 0.02;    // Wall thickness for hollow effect\nfloat cutSphereRadius = 0.6; // Size of sphere to cut from top\nfloat cutSphereY = 0.5;    // Height of cutting sphere center\nfloat lidRaise = 0.0;      // How much to raise the lid\nfloat lidTiltX = 0.04;      // Tilt angle around X axis\nfloat lidTiltZ = 0.05;      // Tilt angle around Z axis\nfloat lidGap = 0.02;       // Gap between lid and opening\n\n// Stalk parameters (now adjustable via sliders)\nfloat stalkRadius = 0.04;   // Base radius of stalk\nint   stalkStarN = 10;      // Number of star points\nfloat stalkStarM = 2.5;     // Star sharpness (between 2 and n)\nfloat stalkHeight = 0.35;   // Total height of stalk\nfloat stalkTwist = 0.1;     // Twisting amount around Y axis\nfloat stalkBend = 0.1;      // Bending amount (vertical curvature)\nfloat stalkTaper = -1.2;    // Tapering factor (0 = no taper, 1 = full taper)\nfloat stalkBulbHeight = 0.22; // Height of bulbous base\nfloat stalkBulbRadius = 0.45; // Maximum radius of bulbous base\nfloat stalkHeightOffset = 0.0; //minor adjustment when it gets displaced.\n\n// Face cutout parameters\nfloat faceScale = 1.0;     // Size of face characters\nfloat faceDepth = 1.1;     // How deep the cut goes  \nfloat faceZ = -1.0;         // Z offset for face position\n\nfloat stemSubtract;\n\nfloat mouthSliderA = 0.5;        // number telling us which mouth to use\nfloat mouthSliderB = 0.5;       // number of second shape for interpolation\nfloat mouthSliderC = 0.5;       // interpolation value\nint mouthTypes = 10;       // number of possible mouths for slider bounds calculation\nfloat eyeSliderA = 0.5;       // interpolation value\nint eyeTypes = 8;       // number of possible eyes for slider bounds calculation\n\n// Slider parameters\nconst float sliderLineWidth = 0.003;   // Width of the slider line (smaller)\nconst float sliderCircleRadius = 0.012; // Radius of the slider circle (smaller)\nconst int totalSliders = 40;           // Total number of sliders\n\n// Simple hash function for deterministic random values\nfloat hash(float seed) {\n    return fract(sin(seed * 12.9898) * 43758.5453);\n}\n\n// Parameter mapping functions - convert 0-1 values to parameter ranges\nfloat mapLidRaise(float t) { return t * 0.5; }\nfloat mapLidTiltX(float t) { return (t - 0.5) * 0.4; }\nfloat mapLidTiltZ(float t) { return (t - 0.5) * 0.4; }\nfloat mapCutSphereY(float t) { return mix(0.2, 1.0, clamp(t, 0.0, 1.0)); }\nfloat mapCutSphereRadius(float t) { return mix(0.4, 0.7, clamp(t, 0.0, 1.0)); }\nfloat mapThickness(float t) { return mix(0.04, 0.08, clamp(t, 0.0, 1.0)); }\nfloat mapLidGap(float t) { return mix(0.0, 0.05, clamp(t, 0.0, 1.0)); }\nfloat mapMouthSliderA(float t) { return t; }\nfloat mapMouthSliderB(float t) { return t; }\nfloat mapMouthSliderC(float t) { return t; }\nfloat mapFaceScale(float t) { return mix(3.25, 4.5, clamp(t, 0.0, 1.0)); }\nfloat mapEyeSliderA(float t) { return t; }\nfloat mapSubsurfaceDistance(float t) { return mix(0.0001, 0.2, clamp(t, 0.0, 1.0)); }  // How far to probe into surface\nfloat mapSubsurfaceAttenuation(float t) { return mix(0.1, 10.0, clamp(t, 0.0, 1.0)); } // Light falloff strength\n\n// Camera/scene parameters (sliders 14-19, hardcoded in random mode)\nfloat mapFocal(float t) { return t * 2.0; }\nfloat mapBaseCameraDist(float t) { return mix(4.0, 10.0, clamp(t, 0.0, 1.0)); }\nfloat mapScreenMag(float t) { return (t < 0.5) ? mix(0.75, 2.0, t * 2.0) : mix(2.0, 3.0, (t - 0.5) * 2.0); }\nfloat mapPitch(float t) { return radians(mix(-89.0, 70.0, clamp(t, 0.0, 1.0))); }\nfloat mapYaw(float t) { return mix(-4.7123, 1.5708, clamp(t, 0.0, 1.0)); }\n\n// Stalk parameters (sliders 20-27)\nfloat mapStalkRadius(float t) { return mix(0.04, 0.1, clamp(t, 0.0, 1.0)); }\nfloat mapStalkStarN(float t) { return floor(mix(5.0, 20.0, clamp(t, 0.0, 1.0))); }\nfloat mapStalkStarM(float t) { return mix(1.8, 4.0, clamp(t, 0.0, 1.0)); }\nfloat mapStalkHeight(float t) { return mix(0.2, 0.5, clamp(t, 0.0, 1.0)); }\nfloat mapStalkTwist(float t) { return mix(0.0, 1.5, clamp(t, 0.0, 1.0)); }\nfloat mapStalkBend(float t) { return mix(0.0, 0.6, clamp(t, 0.0, 1.0)); }\nfloat mapStalkTaper(float t) { return mix(-0.5, 0.3, clamp(t, 0.0, 1.0)); }\nfloat mapStalkBulbHeight(float t) { return mix(0.1, 0.3, clamp(t, 0.0, 1.0)); }\n\n// Pumpkin shape parameters (sliders 28-39)\nfloat mapK2(float t) { return mix(0.02, 0.3, clamp(t, 0.0, 1.0)); }\nfloat mapM2(float t) { return mix(0.0, 6.28, clamp(t, 0.0, 1.0)); }\nfloat mapN2(float t) { return floor(mix(4.0, 12.0, clamp(t, 0.0, 1.0))); }\nfloat mapK1(float t) { return mix(0.02, 0.3, clamp(t, 0.0, 1.0)); }\nfloat mapM1(float t) { return mix(0.0, 6.28, clamp(t, 0.0, 1.0)); }\nfloat mapN1(float t) { return floor(mix(5.0, 30.0, clamp(t, 0.0, 1.0))); }\nfloat mapK0(float t) { return mix(0.02, 0.3, clamp(t, 0.0, 1.0)); }\nfloat mapM0(float t) { return mix(0.0, 3.14, clamp(t, 0.0, 1.0)); }\nfloat mapN0(float t) { return floor(mix(6.0, 60.0, clamp(t, 0.0, 1.0))); }\nfloat mapH(float t) { return mix(-0.3, -0.05, clamp(t, 0.0, 1.0)); }\nfloat mapP(float t) { return mix(0.5, 0.8, clamp(t, 0.0, 1.0)); }\nfloat mapG(float t) { return mix(0.5, 0.7, clamp(t, 0.0, 1.0)); }\n\n// Get parameter value - either from slider or random\nfloat getParamValue(int sliderIndex) {\n#ifdef USE_SLIDERS\n    return sliderValues[sliderIndex];\n#else\n    // For random mode, hardcode camera/scene values (sliders 14-19)\n    if (sliderIndex == 14) return 0.0;  // AA\n    if (sliderIndex == 15) return 0.5;  // Focal\n    if (sliderIndex == 16) return 0.5;  // Camera distance\n    if (sliderIndex == 17) return 0.5;  // Screen magnification\n    if (sliderIndex == 18) return 0.5 - (0.5-(iMouse.y/iResolution.y))/6.; ;  // Pitch\n    if (sliderIndex == 19) return 0.5 - (0.5-(iMouse.x/iResolution.x))/3.;  // Yaw\n    \n    // For other parameters, use deterministic random based on slider index\n    return hash(randomSeed + float(sliderIndex) * 0.1);\n    //return (0.5-range/2.) + (hash(randomSeed + float(sliderIndex) * 0.1))*range;\n#endif\n}\n\n// SDF Operations\nfloat opOnion(float sdf, float thickness) {\n    return abs(sdf) - thickness;\n}\n\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\n// Sphere SDF\nfloat sphereSDF(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\n// 2D Star SDF\nfloat sdStar(vec2 p, float r, int n, float m) {\n    // Precomputed values for given shape\n    float an = 3.141593 / float(n);\n    float en = 3.141593 / m;  // m is between 2 and n\n    vec2 acs = vec2(cos(an), sin(an));\n    vec2 ecs = vec2(cos(en), sin(en)); // ecs=vec2(0,1) for regular polygon\n\n    float bn = mod(atan(p.y, p.x), 2.0 * an) - an;\n    p = length(p) * vec2(cos(bn), abs(sin(bn)));\n    p -= r * acs;\n    p += ecs * clamp(-dot(p, ecs), 0.0, r * acs.y / ecs.y);\n    return length(p) * sign(p.x);\n}\n\n// get 2D sdf data from font texture.\nfloat GetCharacter(ivec2 ch, vec2 cuv, float th) {\n    cuv = clamp(cuv, vec2(0), vec2(1));\n    float tx = (cuv.x/16.) + (float(ch.x)*(1./16.));\n    float ty = (cuv.y/16.) + (float(ch.y)*(1./16.));\n    return (-.5*th) + texture(iChannel1, vec2(tx, ty)).a;\n}\n\n// Single character 2D SDF for face cutting\nfloat char2DSDF(vec2 p, float scale, ivec2 ch) {\n    // Map world XY to [0,1] glyph UV, centered at origin\n    vec2 uv = p / scale + 0.5;\n    return GetCharacter(ch, uv, 1.0);\n}\n\n// Rotated character SDF\nfloat char2DSDFRotated(vec2 p, vec2 scale, ivec2 ch, float angle, float th) {\n    float c = cos(angle);\n    float s = sin(angle);\n    vec2 rotP = vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n    vec2 uv = rotP / scale + 0.5;\n    return GetCharacter(ch, uv, th);\n}\n\nfloat eyesSDF(vec2 p, float scale, int index) {\n\n    ivec2 echars = ivec2(0);\n    float erotation = 0.;\n    vec2  escale = vec2(2,1) * scale;\n    vec2  eoffset = vec2(0,-0.4) * scale;\n    float ethickness = 1.0;\n\n    switch (index) {\n        case 0:echars = ivec2(5,15);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );erotation = -3.141;break;\n        case 1:echars = ivec2(14,14);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );erotation = -3.141;break;\n        case 2:echars = ivec2(4,15);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );escale = vec2(1,1) * scale;erotation = -3.141;break;\n        case 3:echars = ivec2(3,15);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );escale = vec2(1,1) * scale;erotation = -3.141;break;\n        case 4:echars = ivec2(12,14);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );escale = vec2(1,1) * scale;erotation = -3.141;break;\n        case 5:echars = ivec2(10,13);eoffset += vec2(-0.5,-0.2)*scale;p.x = abs (p.x );erotation = -3.141;break;\n        case 6:echars = ivec2(11,13);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );erotation = -3.141;break;\n        case 7:echars = ivec2(12,13);eoffset += vec2(-0.4,-0.4)*scale;p.x = abs (p.x );escale = vec2(2) * scale;break;\n        case 8:echars = ivec2(5,15);eoffset += vec2(-0.5,0)*scale;p.x = abs (p.x );erotation = -3.141;break;\n    }\n    return  char2DSDFRotated(p + eoffset, escale, echars, erotation, ethickness);\n}\n\nfloat mouthSDF(vec2 p, float scale, int index) {\n\n    ivec2 mchars = ivec2(0);\n    float mrotation = 0.;\n    vec2  mscale = vec2(2,1) * scale;\n    vec2  moffset = vec2(0,0.3) * scale;\n    float mthickness = 1.0;\n\n    switch (index) {\n        //-------mouth is single character\n        case 0:mchars = ivec2(6,10);p.x = abs(p.x)<0.5?(fract( p.x * 6.)-0.5)/3.:p.x;break;\n        case 1:mchars = ivec2(15,6);moffset += vec2(-0.4,0)*scale;p.x = abs (p.x );mrotation = -.2;break;\n        case 2:mchars = ivec2(7,8); break;\n        case 3:mchars = ivec2(7,10);break;\n        case 4: mchars = ivec2(13,10);mrotation = 1.57;mscale = vec2(1.2,1.5) * scale;moffset += vec2(-0.1,0)*scale;\n        break;   case 5: mchars = ivec2(13,8);mrotation = 1.57;mscale = vec2(1.2,1.5) * scale;moffset += vec2(-0.1,0)*scale;\n        break;   case 6: mchars = ivec2(9,13);mrotation = 1.57;mscale = vec2(1.2,1.5) * scale;moffset += vec2(-0.1,0)*scale;\n        break;   case 7: mchars = ivec2(8,13);mrotation = 1.57;mscale = vec2(1.2,1.5) * scale;moffset += vec2(-0.1,0)*scale;\n        break;   case 8: mchars = ivec2(11,10);mrotation = 1.57;mscale = vec2(1.2,1.5) * scale;moffset += vec2(-0.1,0)*scale; \n        break;   case 9: mchars = ivec2(6,10);p.x = abs(p.x)<0.35?(fract( p.x * 6.)-0.5)/3.:p.x;break; \n        break;  case 10:mchars = ivec2(6,10);p.x = abs(p.x)<0.65?(fract( p.x * 6.)-0.5)/3.:p.x;break;\n        break;  case 11: mchars = ivec2(15,5);moffset += vec2(0,0.3)*scale;\n        break;  case 12: mchars = ivec2(3,15);mscale = vec2(2.5,1) * scale;\n        break;  case 13: mchars = ivec2(3,15);mscale = vec2(1.5,1.5) * scale;\n    }\n    \n    return  char2DSDFRotated(p + moffset, mscale, mchars, mrotation, mthickness);\n}\n\n// Complete face SDF - combines all features\nfloat faceSDF(vec2 p, float scale) {\n\n    \n    float mouthA = mouthSDF(p, scale, int(floor(mouthSliderA * float(mouthTypes))));\n    float mouthB = mouthSDF(p, scale, 1+int(floor(mouthSliderA * float(mouthTypes))));\n    float mouthC = mouthSDF(p, scale, 13);\n    float mouthD = mouthSDF(p, scale, 12);\n    float mouthE = mouthSDF(p, scale, 11);\n    float mouth = mix(mouthA, mouthB, fract(mouthSliderA * float(mouthTypes)));\n    mouth -= (0.5-abs(fract(mouthSliderA * float(mouthTypes)) - 0.5))/15.;\n    float mouthF = mouthSliderB<0.5 ? mix(mouthC, mouthD, mouthSliderB*2.) : mix(mouthD, mouthE, (mouthSliderB-0.5)*1.6);\n    mouth = mix(mouth, mouthF, mouthSliderC);\n    \n    float eyesA = eyesSDF(p, scale, int(floor(eyeSliderA * float(eyeTypes))));\n    float eyesB = eyesSDF(p, scale, 1+int(floor(eyeSliderA * float(eyeTypes))));  \n    float eyes = mix(eyesA, eyesB, fract(eyeSliderA * float(eyeTypes)));\n    \n    return min(mouth, eyes);\n\n}\n\n\n// Extrude a 2D SDF along Z axis\nfloat extrudeSDF(vec3 pos, float char2D, float halfDepth) {\n    vec2 w = vec2(char2D, abs(pos.z) - halfDepth);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n// 3D Extrusion operation\nfloat opExtrusion(vec2 p, float h, float r, int n, float m) {\n    float d = sdStar(p, r, n, m);\n    vec2 w = vec2(d, abs(h) - stalkHeight * 0.5);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n}\n\n// Twisting operation (rotates around Y axis as Y increases)\nvec3 opTwist(vec3 p, float k) {\n    float c = cos(k * p.y);\n    float s = sin(k * p.y);\n    return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);\n}\n\n// Bending operation (curves the stalk in the XZ plane)\nvec3 opBend(vec3 p, float k) {\n    float bendAmount = k * p.y * p.y / stalkHeight; // Quadratic bend for natural curve\n    return vec3(p.x + bendAmount, p.y, p.z);\n}\n\n\n\n// Rotation matrices\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(1.0, 0.0, 0.0,\n                0.0, c, -s,\n                0.0, s, c);\n}\n\nmat3 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c, -s, 0.0,\n                s, c, 0.0,\n                0.0, 0.0, 1.0);\n}\n\n// Convert Cartesian to spherical coordinates\nvec3 cartesianToSpherical(vec3 pos) {\n    float rho = length(pos);\n    float theta = atan(pos.z, pos.x);\n    float phi = acos(pos.y / rho);\n    return vec3(rho, theta, phi);\n}\n\n// The complex pumpkin equation converted to SDF\nfloat pumpkinSDF(vec3 pos) {\n    vec3 spherical = cartesianToSpherical(pos);\n    float theta = spherical.y;\n    float phi = spherical.z;\n    \n    // Use the constant parameters directly\n    \n    // Calculate the three sin terms\n    float sin_term0 = sin(n0 * theta + m0);\n    float sin_term1 = sin(n1 * theta + m1);\n    float sin_term2 = sin(n2 * theta + m2);\n    \n    // First part: sum of the three weighted sin terms\n    float part1 = (1.0 - pow(sin_term0, 4.0)) * (k0 / n0) +\n                  (1.0 - sin_term1) * (k1 / n1) +\n                  (1.0 - sin_term2) * (k2 / n2);\n    \n    // Second part: phi modulation\n    float cos_2phi = cos(2.0 * phi);\n    float part2 = pow((1.0 - cos_2phi) / 2.0, 2.0);\n    \n    // Third part: exponential and constant term\n    float part3 = exp(-pow(phi - 3.14159 / 2.0, 2.0)) + p;\n    \n    // Fourth part: cosine modulation\n    float part4 = 1.0 - h * cos_2phi;\n    \n    // Combine all parts to get the target radius\n    float target_rho = (part1 * part2 + g) * part3 * part4;\n    \n    // Return SDF: current distance - target distance\n    return length(pos) - target_rho;\n}\n\n// Stalk SDF - curved, twisted, tapered star extrusion\nfloat stalkSDF(vec3 pos) {\n    // Transform position to match the lid's transformation\n    vec3 stalkPos = pos;\n    \n    // Move to lid's raised position\n    stalkPos.y -= lidRaise;\n    \n    // Apply inverse rotations (same as lid, but in reverse order)\n    stalkPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * stalkPos;\n    \n    // Position stalk above the lid center (now in lid's local space)\n    stalkPos = stalkPos - vec3(0.0, stalkHeightOffset + (g * p *1.2) - (h/3.), 0.0);\n    \n    // Apply twisting (the existing \"bend\" that creates spiral ridges)\n    vec3 twistedPos = opTwist(stalkPos, stalkTwist / stalkHeight);\n    \n    // Apply bending (new vertical curvature)\n    vec3 bentPos = opBend(twistedPos, stalkBend / stalkHeight);\n    \n    // Calculate radius with both tapering and bulbous base\n    float heightFactor = clamp((bentPos.y) / stalkHeight, 0.0, 1.0);\n    \n    // Bulbous base effect - smooth falloff from bulb radius to normal radius\n    float bulbFactor = 1.0 - smoothstep(0.0, stalkBulbHeight, bentPos.y);\n    float bulbRadius = mix(stalkRadius, stalkBulbRadius, bulbFactor);\n    \n    // Apply tapering on top of bulb radius\n    float taperedRadius = bulbRadius * (1.0 - stalkTaper * heightFactor);\n    \n    // Create extruded star - star shape in XZ plane, extruded along Y\n    float starDist = sdStar(bentPos.xz, taperedRadius, stalkStarN, stalkStarM);\n    float heightDist = (abs(bentPos.y - stalkHeight * 0.5) - stalkHeight * 0.5);\n    \n    // Combine using extrusion formula\n    vec2 w = vec2(starDist, heightDist);\n    float stalkBase = min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n\n    // Only show stalk outside the original pumpkin surface\n    // use stemsubtract stored in lidSDF()\n    return opSubtraction(stemSubtract, stalkBase);\n}\n\n\n\n// Hollow pumpkin with top cut off\nfloat hollowPumpkinSDF(vec3 pos) {\n    // Get the base pumpkin shape\n    float pumpkin = pumpkinSDF(pos);\n    \n    // Make it hollow using onion operation\n    float hollow = opOnion(pumpkin, thickness);\n    \n    // Create cutting sphere at the top - slightly larger for the gap\n    vec3 cutSpherePos = pos - vec3(0.0, cutSphereY, 0.0);\n    float cuttingSphere = sphereSDF(cutSpherePos, cutSphereRadius + lidGap);\n    \n    // Subtract the sphere from the hollow pumpkin\n    return opSubtraction(cuttingSphere, hollow);\n}\n\n// Lid (the cut-off part) - raised and tilted\nfloat lidSDF(vec3 pos) {\n    // Transform position for the lid\n    vec3 lidPos = pos;\n    \n    // Move down to original position, apply rotations, then raise up\n    lidPos.y -= lidRaise;\n    lidPos = rotateX(lidTiltX) * rotateZ(lidTiltZ) * lidPos;\n    \n    // Get the base pumpkin shape\n    float pumpkin = pumpkinSDF(lidPos);\n    \n    stemSubtract = pumpkin;\n    \n    // Make it hollow\n    float hollow = opOnion(pumpkin, thickness);\n    \n    // Create cutting sphere - we want only the part that was cut off\n    vec3 cutSpherePos = lidPos - vec3(0.0, cutSphereY, 0.0);\n    float cuttingSphere = sphereSDF(cutSpherePos, cutSphereRadius);\n    \n    // Return only the intersection (the part that was inside the cutting sphere)\n    // We want the hollow pumpkin AND inside the cutting sphere\n    return max(hollow, cuttingSphere);\n}\n\n// Main scene SDF\nfloat sceneSDF(vec3 pos, float sc) {\n    pos = pos.xzy;\n    pos.y = -pos.y;\n    pos/=sc;\n    float hollowPumpkin = hollowPumpkinSDF(pos);\n    float lid = lidSDF(pos);\n    float stalk = stalkSDF(pos);\n    \n    // Create complete face cutout\n    float faceShape = faceSDF(pos.xy, faceScale);\n    \n    vec3 facePos = pos - vec3(0.0, 0.0, faceZ);\n    float faceCutout = extrudeSDF(facePos, faceShape, faceDepth);\n    \n    // Subtract face cutout from hollow pumpkin only\n    hollowPumpkin = opSubtraction(faceCutout, hollowPumpkin);\n    \n    return opUnion(opUnion(hollowPumpkin, lid), stalk);\n}\n\n\n\n\n#define TIME mod(iTime, 26.0)\n#define drum pow(1.0 - 2.0 * mod(TIME, 0.5), 5.0)\n\nvec2 un(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdCylinder( vec3 p, float r )\n{\n  return length(p.xz)-r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdSphere( vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nmat3 rot(float x, float y, float z)\n{\n\tfloat cx = cos(x);\n\tfloat sx = sin(x);\n\tfloat cy = cos(y);\n\tfloat sy = sin(y);\n\tfloat cz = cos(z);\n\tfloat sz = sin(z);\n\tmat3 xm = mat3(1, 0, 0,\n\t\t\t\t\t0, cx, -sx,\n\t\t\t\t\t0, sx, cx);\n\tmat3 ym = mat3(cy, 0, sy,\n\t\t\t  \t\t0, 1, 0,\n\t\t\t  \t\t-sy, 0, cy);\n\tmat3 zm = mat3(cz, -sz, 0,\n\t\t\t\t\tsz, cz, 0,\n\t\t\t\t\t0, 0, 1);\n\treturn xm * ym * zm;\n}\n\nfloat specular(vec3 normal, vec3 light, vec3 viewdir, float s)\n{\n\tfloat nrm = (s + 8.0) / (3.1415 * 8.0);\n\tfloat k = max(0.0, dot(viewdir, reflect(light, normal)));\n    return  pow(k, s);\n}\n\n\n\nfloat smin( float a, float b)\n{\n\tfloat k = 0.5;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smink( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nvec2 sun(vec2 a, vec2 b)\n{\n\tfloat sm = smin(a.x,b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\n\treturn ca < cb ? vec2(sm, a.y) : vec2(sm, b.y);\n}\n\nvec2 sunk(vec2 a, vec2 b, float k)\n{\n\tfloat sm = smink(a.x,b.x, k);\n\tfloat m = min(a.x, b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\treturn ca < cb ? vec2(sm, a.y) : vec2(m, b.y);\n}\n\n\n#define TEX 0.2\n#define SIZE 8.0\n#define PI 3.1415\n\n#define MAT_WALL 1.0\n#define MAT_SPIN 2.0\n#define MAT_GROUND 3.0\n\n\nvec2 ground(vec3 p) {\n\tp -= vec3(0,0,5);\n\tp.y += 10.0*TIME;\n\tfloat s = 1.0;\n\tvec3 q = mod(p, s) - s * 0.5;\n\tq.z = p.z;\n\n\tq.z += sin(p.x) * 0.5;\n\tq.z += sin(p.y) * 0.5;\n\tfloat d = udRoundBox(q, vec3(s * 0.3), s * 0.3);\n\treturn vec2(d, MAT_GROUND);\n}\n\nvec2 spin(vec3 p, vec3 rd, float dir) {\n\tp.x = p.x == 0.0 ? 0.00001 : p.x;\n\n\tfloat len = length(p.xy);\n\tfloat lenSize = 6.0;\n\tfloat lenY = mod(len, lenSize) - lenSize * 0.5;\n\tfloat lenPart = floor(len / lenSize);\n\tif (lenPart < 0.5 || lenPart > 2.5) {\n\t\treturn vec2(99999,  MAT_SPIN);\n\t}\n\tfloat angle = atan(p.y, p.x);\n\tfloat numParts =  floor( 5.5*lenPart);\n\tfloat partSize = PI / numParts;\n\tangle += PI;\n\tfloat r = dir * sign(cos(lenPart*PI))* TIME * 0.4 / lenPart;\n\tfloat part = floor(mod(angle + r + (lenPart < 1.5 ? partSize / 2.0 : 0.0), PI * 2.0) / partSize);\n\n\tangle = mod(0.3*lenPart + angle + r, partSize) + partSize * 0.5 * max(0.0, numParts - 1.0);\n\n\n\tvec3 newPos = vec3(len * cos(angle), lenY * sin(angle), p.z);\n\tfloat d = sceneSDF(newPos, 2.);\n\treturn vec2(d, MAT_SPIN);\n}\n\n\n\nvec2 map(vec3 p, vec3 rd) {\n\tvec2 res = spin(p ,rd, 1.0);\n\tres = un(ground(p - vec3(0, 0, 0)), res);\n \treturn res;\n}\n\nvec4 roofLight(vec3 p) {\n\tfloat music = drum; \n\tfloat s = 15.0;\n\tp.y += 10.0*TIME;\n\tvec3 q = mod(p, s) - s * 0.5;\n\tq.z = p.z;\n\tq *= rot(0.0,0.0,TIME * 5.0 + p.x*0.1 + p.z*0.1);\n\tvec3 lightCol = vec3(0.5 + 0.5 * sin(p.x), 0.5 + 0.5 * sin(p.y), 0.1);\n\tfloat dis = sdCappedCylinder(q.zxy - vec3(-10, 0, 0), vec2(0.05, 5.0));\n\tfloat distanceToL = max(0.0001, dis);\n\tvec3 point = lightCol * 5.0/(0.1*distanceToL + 0.3*distanceToL*distanceToL);\n\n\treturn vec4(point, distanceToL);\n}\n\nvec4 sunLight(vec3 pos) {\n\tvec3 lightCol = vec3(1.0,0.8, 0.5*(cos(TIME) + 1.0));\n\n\tfloat music = drum;\n\tfloat mdis = sceneSDF(pos - vec3(0.0,0.0,0.5*sin(10.0*TIME)), 1.5 + 0.5 * music);\n\n\n\tfloat distanceToL = max(0.0001, mdis);\n\tvec3 point = lightCol * (80.0 + 80.0 * music)/(distanceToL*distanceToL);\n\n\treturn vec4(point, distanceToL);\n}\n\n\nvec3 evaluateLight(vec3 pos, inout float dis)\n{\n\tvec4 sun = sunLight(pos);\n\tvec4 rl = roofLight(pos);\n\tdis = min(sun.w, rl.w);\n\treturn sun.xyz + rl.xyz;\n}\n\nvoid addLightning(inout vec3 color, vec3 normal, vec3 eye, vec3 pos) {\n\tvec3 lpos = vec3(0, 0,0);\n\n\tfloat dis = length(lpos - pos);\n\tvec3 invLight = normalize(lpos - pos);\n\tfloat diffuse = max(0.0, dot(invLight, normal));\n\tfloat spec = specular(normal, -invLight, normalize(eye - pos), 220.0);\n\n\tfloat str = 1.0/(0.1 + 0.01*dis + 0.1*dis*dis);\n\tfloat tmp = 0.0;\n\tstr = 1.0;\n\tcolor =  color * (0.0 + 0.8*diffuse*evaluateLight(pos, tmp).xyz) + spec*str;\n}\n\n\n\nvec3 getNormal(vec3 p, vec3 rd)\n{\n\tvec3 normal;\n    vec3 ep = vec3(0.01, 0, 0);\n    normal.x = map(p + ep.xyz, rd).x - map(p - ep.xyz, rd).x;\n    normal.y = map(p + ep.yxz, rd).x - map(p - ep.yxz, rd).x;\n    normal.z = map(p + ep.yzx, rd).x - map(p - ep.yzx, rd).x;\n    return normalize(normal);\n\n}\n\nfloat occlusion(vec3 p, vec3 normal, vec3 rd)\n{\n\tfloat o = clamp(2.0*map(p + normal * 0.5, rd).x, 0.0, 1.0);\n\treturn 0.2 + 0.8*o;\n}\n\n\n\nvec3 raymarch(vec3 ro, vec3 rd, inout vec3 finalPos, vec3 eye) {\n\tfloat t = 0.0;\n\tconst int maxIter = 100;\n\tconst float maxDis = 300.0;\n\tfloat d = 0.0;\n\tvec3 p = vec3(-1.0, -1.0, -1.0);\n\tvec3 col = vec3(0);\n\tconst int jumps = 3;\n\tfloat ref = 1.0;\n\tvec3 scatteredLight = vec3(0.0);\n\tfloat transmittance = 1.0;\n\tfor (int j = 0; j < jumps; j++) {\n\t\tfor (int i = 0; i < maxIter; i++) {\n\t\t\tp = ro + rd * t;\n\n\t\t\tvec2 res = map(p, rd);\n\t\t\td = res.x;\n\t\t\tfloat fogAmount = 0.01;\n\t\t\tfloat lightDis = -1.0;\n\t\t\tvec3 light = evaluateLight(p, lightDis);\n\t\t\td = min(min(d, 1.0), max(lightDis, 0.05));\n\t\t\tvec3 lightIntegrated = light - light * exp(-fogAmount * d);\n\t\t\tscatteredLight += transmittance * lightIntegrated;\n\t\t\ttransmittance *= exp(-fogAmount * d);\n\n\t\t\tt += d;\n\t\t\tfloat m = res.y;\n\t\t\tbool end = i == maxIter - 1 ||t > maxDis;\n\t\t\tif (d < 0.01 || end) {\n\t\t\t\tvec3 c = vec3(1);\n\t\t\t\tvec3 normal = getNormal(p, rd);\n\t\t\t\tif (m == MAT_WALL) {\n\t\t\t\t\tc = vec3(1,0,0);\n\t\t\t\t} else if (m == MAT_SPIN) {\n\t\t\t\t\tc = vec3(.8,.5,0.1);\n\t\t\t\t} else if (m == MAT_GROUND) {\n\t\t\t\t\tvec3 q = floor(p);\n\t\t\t\t\tc = vec3(0.3,0.3,1);\n\t\t\t\t}\n\n\t\t\t\tc *= occlusion(p, normal, rd);\n\t\t\t\taddLightning(c, normal, eye, p);\n\t\t\t\tif (end) {\n\t\t\t\t\ttransmittance = 0.0;\n\t\t\t\t}\n\t\t\t\tcol = mix(col, transmittance * c + scatteredLight, ref);\n\t\t\t\tif (m == MAT_SPIN) {\n\t\t\t\t\tref *= 0.05;\n\t\t\t\t} else {\n\t\t\t\t\tref = 0.0;\n\t\t\t\t}\n\t\t\t\trd = reflect(rd, getNormal(p, rd));\n\t\t\t\tro = p + rd*0.05;\n\t\t\t\tt = 0.0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t > maxDis) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ref < 0.01) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfinalPos = p;\n\treturn col;\n}\n\n\n\n\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat u = (fragCoord.x / iResolution.x) * 2.0 - 1.0;\n    float v = ((fragCoord.y / iResolution.y) * 2.0 - 1.0) * (9.0/ 16.0);//* (iResolution.y/iResolution.x);\n\n    float t = TIME;\n    vec3 start = vec3(0.3*sin(t), -24.0 + 2.0*cos(t) , -4.0 );\n\n    float alpha = smoothstep(200.0, 201.0, TIME);\n\tvec3 tar = vec3(0); //eye + vec3(0.0, 0.0, 1.0);\n    vec3 eye = start + alpha*(tar - start);\n    vec3 lol = vec3(0, 1, 0);\n\n      if (t > 16.0) {\n    \teye = vec3(0.0, 0.0, -(TIME + 4.0)*3.0 + 55.0);\n    \ttar = vec3(0.1);\n    \tlol = vec3(0, 0, -1);\n\n        float alpha = smoothstep(25.0, 26.0, TIME);\n        eye = eye + alpha*(tar - eye);\n    } else if(t > 8.0) {\n    \teye = vec3(11.0*cos(0.4*t + 1.0),11.0*sin(0.4*t+1.0),-0.0);\n    \ttar = vec3(0.1, 1.0, 0.0);\n    \tlol = vec3(0.0, 0.0, -1.0);\n    }\n\n\n\tvec3 dir = normalize(tar - eye);\n\tvec3 right = normalize(cross(lol, dir));\n\tvec3 up = cross(dir, right);\n\tvec3 ro = eye;\n\tvec3 rd = normalize(dir + right*u + up*v);\n\n\tvec3 light = vec3(0.0, 0.0, 26.0 );\n\n\tvec3 finalPos = vec3(-1.0, -1.0, -1.0);\n\tfloat material = -1.0;\n\tvec3 color = raymarch(ro, rd, finalPos, eye);\n\n    fragColor = vec4(color, 1.0);\n\n}\n// multisampling\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = 1., k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n    \n        o.rgb = o.rgb / (o.rgb + vec3(1.5));\n    //fragColor.rgb = atan(fragColor.rgb);\n    //\n}  \n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "33syzM",
    "date": "1759419975",
    "viewed": 209,
    "name": "three.js challenge",
    "description": "From [url]https://x.com/threejs/status/1973620023974568360[/url]",
    "likes": 18,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "disc",
     "challenge",
     "twitter",
     "rods",
     "threejs"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#if HW_PERFORMANCE == 0\n// turn off multisampling on mobile\n#define AA 1\n#else\n// change this to 1 if it runs slowly, or increase it for more smoothness\n#define AA 2 \n#endif\n\nfloat sdCylinder(vec3 p, float r, float h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n\nfloat map(vec3 p) {\n    // Configuration\n    float spacingA = 0.45;        // Distance between rings\n    float spacingB = 0.5;         // Distance between rods\n    float rodRadius = 0.07;       // Radius of each rod\n    float rodHeight = 1.5;        // Height of each rod\n    int numRings = 12;            // Maximum ring index\n    \n    // Wave configuration\n    float waveTime = iTime * 0.9;\n    float maxRadius = (float(numRings) + 0.5) * spacingA;\n    float waveRadius = maxRadius * 0.5;\n    float waveAmplitude = 1.5;\n    float waveWidth = 2.5;\n    \n    // Two wave center positions\n    vec2 waveCenter1 = vec2(cos(waveTime), sin(waveTime)) * waveRadius;\n    vec2 waveCenter2 = -waveCenter1;\n    \n    // Get radial distance and angle\n    float radialDist = length(p.xz);\n    float angle = atan(p.z, p.x);\n    \n    // Special handling for ring 0 (center ring)\n    float minDist = 1e6;\n    \n    // Check ring 0 separately since it has special properties\n    if (radialDist < spacingA) {\n        float ringRadius = spacingA/1.7;\n        float numRods = 4.0;\n        float angleStep = 2.0 * 3.14159 / numRods;\n        \n        float rodIndex = floor(angle / angleStep + 0.5);\n        float rodAngle = rodIndex * angleStep;\n        \n        vec3 rodCenter = vec3(cos(rodAngle) * ringRadius, 0.0, sin(rodAngle) * ringRadius);\n        \n        // no wave here in the center.\n   \n        vec3 adjustedRodCenter = rodCenter;\n        minDist = sdCylinder(p - adjustedRodCenter, rodRadius, rodHeight);\n    }\n    \n    // Domain repetition for rings 1 to numRings\n    if (radialDist >= spacingA * 0.5) {\n        // Find the nearest ring index based on radial distance\n        float ring = round((radialDist - spacingA * 0.5) / spacingA);\n        ring = clamp(ring, 1.0, float(numRings));\n        \n        float ringRadius = (ring + 0.5) * spacingA;\n        float circumference = 2.0 * 3.14159 * ringRadius;\n        float numRods = floor((circumference / spacingB + 0.5) + (circumference * 2.0) - 9.4);\n        \n        // Angular domain repetition for rods in this ring\n        float angleStep = 2.0 * 3.14159 / numRods;\n        float rodIndex = floor(angle / angleStep + 0.5);\n        float rodAngle = rodIndex * angleStep;\n        \n        vec3 rodCenter = vec3(cos(rodAngle) * ringRadius, 0.0, sin(rodAngle) * ringRadius);\n        \n        // Calculate wave influence\n        vec2 rodPos2D = rodCenter.xz;\n        float dist1 = length(rodPos2D - waveCenter1);\n        float dist2 = length(rodPos2D - waveCenter2);\n        float minWaveDist = min(2.2, min(dist1, dist2));\n        \n        float wave = cos(minWaveDist / waveWidth * 3.14159) * 0.5 + 0.5;\n        wave = smoothstep(0.0, 1.0, wave);\n        float heightOffset = wave * waveAmplitude;\n        \n        vec3 adjustedRodCenter = rodCenter + vec3(0.0, heightOffset, 0.0);\n        float dist = sdCylinder(p - adjustedRodCenter, rodRadius, rodHeight);\n        minDist = min(minDist, dist);\n    }\n    \n    return minDist;\n}\n\nvec3 calcNormal(vec3 p) {\n    const vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\n\nvec3 lighting(vec3 p, vec3 normal, vec3 rayDir, vec3 lightPos) {\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 viewDir = -rayDir;\n    vec3 reflectDir = reflect(-lightDir, normal);\n    \n    float diff = max(dot(normal, lightDir), 0.0);\n    //float spec = pow(max(dot(viewDir, reflectDir), 0.0), 16.0);\n    \n    vec3 ambient = vec3(0.4);\n    vec3 diffuse = vec3(0.5) * diff;\n   // vec3 specular = vec3(0) * spec;\n    \n    return ambient + diffuse;// + specular;\n}\n\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 60; i++) {\n        vec3 p = ro + t * rd;\n        float d = map(p);\n        if (d < 0.001 || t > 50.0) break;\n        t += d/2.;\n    }\n    return t;\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float time = iTime * 0.3;\n    float camDist = 14.0;\n    float camHeight = 13.0;\n    vec3 ro = vec3(cos(time) * camDist, camHeight, sin(time) * camDist);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.5 * ww);\n\n    float t = raymarch(ro, rd);\n    vec3 bg = vec3(0.1, 0.1, 0.1);\n    vec3 color = bg;\n    \n    if (t < 40.0) {\n        vec3 p = ro + t * rd;\n        vec3 normal = calcNormal(p);\n        vec3 lightPos = vec3(0.0, 8.0, 0.0);\n        \n        color = lighting(p, normal, rd, lightPos)*(1.0+p.y/2.);\n        \n        // Add some fog for depth\n       //color = mix(color, bg, 1.0 - exp(-0.015 * t));\n    }\n    color = max(bg, color);\n    color = tanh(color*1.2);\n    fragColor = vec4(color, 1.0);\n}\n\n// multisampling\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = float(AA), k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}  \n\n/* \n// old map code with for loop\nfloat map(vec3 p) {\n    float minDist = 1e6;\n    \n    // Configuration\n    float spacingA = 0.45;        // Distance between rings\n    float spacingB = 0.5;        // Distance between rods\n    float rodRadius = 0.07;     // Radius of each rod\n    float rodHeight = 1.5;      // Height of each rod\n    int numRings = 12;          // Fixed number of rings (0-12 = 13 rings total)\n    \n    // Wave configuration\n    float waveTime = iTime * 0.9;\n    float maxRadius = (float(numRings) + 0.5) * spacingA;\n    float waveRadius = maxRadius * 0.5; // Halfway between center and edge\n    float waveAmplitude = 1.5; // How much the rods rise\n    float waveWidth = 2.5; // Width of the wave effect\n    \n    // Two wave center positions (opposite each other)\n    vec2 waveCenter1 = vec2(cos(waveTime), sin(waveTime)) * waveRadius;\n    vec2 waveCenter2 = -waveCenter1; // Opposite side\n    \n    // Concentric rings starting from ring 0\n    for (int ring = 0; ring <= numRings; ring++) {\n        float numRods;\n        float ringRadius;\n        \n        if (ring == 0) {\n            // First ring has exactly 4 rods\n            numRods = 4.0;\n            ringRadius = spacingA/1.7;\n        } else {\n            ringRadius = (float(ring)+0.5) * spacingA;\n            float circumference = 2.0 * 3.14159 * ringRadius;\n            numRods = floor((circumference / spacingB + 0.5) + (circumference*2.) -9.4);\n        }\n        \n        // Calculate angle between rods\n        float angleStep = 2.0 * 3.14159 / numRods;\n        \n        // Get current angle\n        float angle = atan(p.z, p.x);\n        \n        // Find nearest rod in this ring using domain repetition\n        float rodIndex = floor(angle / angleStep + 0.5);\n        float rodAngle = rodIndex * angleStep;\n        \n        // Position of the rod center\n        vec3 rodCenter = vec3(cos(rodAngle) * ringRadius, 0.0, sin(rodAngle) * ringRadius);\n        \n        // Calculate wave influence on this rod\n        vec2 rodPos2D = rodCenter.xz;\n        float dist1 = length(rodPos2D - waveCenter1);\n        float dist2 = length(rodPos2D - waveCenter2);\n        float minWaveDist = min( 2.2, min(dist1, dist2));\n        \n        // Create smooth wave using cosine\n        float wave = cos(minWaveDist / waveWidth * 3.14159) * 0.5 + 0.5;\n        wave = smoothstep(0.0, 1.0, wave);\n        float heightOffset = wave * waveAmplitude;\n        \n        // Adjust rod center with height offset\n        vec3 adjustedRodCenter = rodCenter + vec3(0.0, heightOffset, 0.0);\n        \n        // Distance to this rod\n        float dist = sdCylinder(p - adjustedRodCenter, rodRadius, rodHeight);\n        minDist = min(minDist, dist);\n    }\n    \n    return minDist;\n}\n\n*/",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3XXyWr",
    "date": "0",
    "viewed": 0,
    "name": "equation explrer",
    "description": "Plot of sin (sin (x) + cos (y)) = cos (sin (x*y) + cos (x))\nFrom [url=https://x.com/jshguo/status/1972564708525064688]here[/url]",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "sin",
     "cos",
     "graph",
     "equation",
     "twitter",
     "maths"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/*\n\nfloat f = pow((x-1.)*(x-1.) + y*y, 2.) - pow((x+1.)*(x+1.) + y*y, 2.) - 1.;\nfloat f = pow(x*x + y*y, 2.) - 2.*(x*x - y*y);\nfloat f = y*y*(y*y - 4.) - x*x*(x*x - 5.);\nfloat f = x*x*x*x - x*x + y*y;\nfloat f = sin(x*x + y*y) - cos(x*y);\nfloat f = sin(sqrt(x*x + y*y)) - cos(sqrt((x-2.)*(x-2.) + y*y));\nfloat f = sin(x) * cos(y) - sin(x*y) * 0.5;\nfloat f = sin(3.*atan(y,x)) - cos(sqrt(x*x + y*y));\nfloat f = x*x*x + y*y*y - 3.*x*y;\nfloat f = pow(abs(x), 2./3.) + pow(abs(y), 2./3.) - 1.;\nfloat f = pow(x*x + y*y, 3.) - 4.*x*x*y*y;\nfloat f = pow(x, 4.) - x*x*x + y*y;\nfloat f = sin(x*x - y*y) + cos(2.*x*y) - 0.5;\nfloat f = sin(x)*cos(y) - sin(x*y) + cos(x+y);\nfloat f = sin(cos(x) + sin(y)) - cos(sin(x) - cos(y));\nfloat f = sin(x*y) * cos(x-y) - sin(x+y) * cos(x*y) * 0.5;\nfloat f = r - sin(5.*theta);\nfloat f = log(r) - 0.2*theta;\nfloat f = pow(x*x + y*y + x, 2.) - x*x - y*y;\nfloat f = sin(x*x*0.5 - y*y*0.5) * cos(x*y*0.5) - sin(length(vec2(x,y)));\nfloat f = sin(5.*x)*sin(5.*y) + 0.5*sin(10.*x*y) - cos(sqrt(x*x+y*y)*3.);\nfloat f = sin(10.*theta + r) - cos(r*5. - theta*3.);\nfloat f = (x*x + y*y - 2*a*x)*(x*x + y*y - 2*a*x) - 4*a*a*(x*x + y*y);\nfloat f = r2 - cos(4.0 * theta);\nfloat f = pow((x*x + y*y), 2.0) - 2.0*a*a*(x*x - y*y) - (b*b*b*b - a*a*a*a);\nfloat f = sin(sqrt(x*x + y*y)) - cos(sqrt((x-2.0)*(x-2.0) + y*y));\nfloat f = sin(x*y) - cos(x + y);\nfloat f = sin(x) * cos(y) - sin(x*y);\nfloat f = y*y*y*y - x*x*x*x + a*y*y + b*x*x;\nfloat f = y*y*(x*x + 2.0*a*x - a*a) - (x*x + a*a)*(x*x + a*a);\nfloat f = sin(x*x + y*y) - cos(x*y + x + y);\nfloat f = x*x*x + y*y*y - 3.0*a*x*y;\nfloat f = pow(x, 2.0/3.0) + pow(y, 2.0/3.0) - pow(a, 2.0/3.0);\nfloat f = sin(sin(x)*cos(y)) - cos(sin(y)*cos(x)) + 0.3*sin(x*y);\nfloat f = pow(x*x + y*y, 2.0) - 2.0*a*a*(x*x - y*y);\nfloat f = sin(10.0*x) - sin(10.0*sqrt(x*x + y*y));\nfloat f = sin(x + sin(y)) - cos(y + cos(x));\nfloat f = (x*x + y*y - 1.) * (x*x + 0.25*y*y - 0.5) + 0.1*y;\nfloat f = y*y - x*x*x - x*x + x;\nfloat f = pow(x*x + y*y - 1., 3.) - x*x*y*y*y;\nfloat f = y - sin(x)*exp(-x*x*0.2) - sin(x*3.)*0.3;\nfloat f = sin(8.*theta)*0.3 - r + sin(r*10.)*0.1;\nfloat f = sin(x*2.)*sin(y*2.) + sin(x*3.+y*1.5)*0.5 + sin(sqrt(x*x+y*y)*5.)*0.3 - 0.5;\nfloat f = sin(x*x-y) * cos(y*y-x) + sin(x*y*2.)*0.5 - 0.3;\nfloat f = sin(x*x*x - y*y*y + x*y) - cos(x*x + y*y)*0.5;\nfloat f = sin(3.*x)*sin(3.*y) - 0.5*sin(5.*x*y) + 0.3*cos(x*x-y*y) - 0.4;\nfloat f = sin(x + sin(y*1.7))*sin(y + sin(x*1.7)) - 0.7;\nfloat f = sin(x*4.)*cos(y*4.) + sin(sqrt(x*x+y*y)*6.)*0.5 - cos(x*y*3.)*0.3 - 0.2;\nfloat f = r - (1. + 0.3*sin(6.*theta + r*3.));\nfloat f = sin(x*5.)*sin(y*5.) - sin(x*7.+1.)*sin(y*7.+1.)*0.5 + 0.1;\nfloat f = sin(r*10. + theta*2.) - 0.3;\nfloat f = sin(x*2. + sin(y*3.))*cos(y*2. + cos(x*3.)) + 0.3*sin(x*y*4.) - 0.5;\nfloat f = sin(x + 0.5*sin(y*2.))*sin(y + 0.5*sin(x*2.)) - 0.5;\nfloat f = cos(x*y) - sin(x*x - y*y) + 0.3*cos(length(vec2(x,y))*4.);\nfloat f = sin(theta*3. + 1./r) - r*0.5;\nfloat f = sin(x*3.)*0.3 - y + cos(x*3.)*0.3*sign(sin(x*6.));\nfloat f = sin(5.*theta)*cos(3.*theta) - r + sin(r*8.)*0.2 + 1.;\nfloat f = sin(r*5. - atan(y,x)*3.) * cos(r*3.) - 0.5 + r*0.1;\nfloat f = pow(sin(x)*sin(y), 2.) - 0.5*sin(x*x + y*y) + 0.2;\nfloat f = sin(x)*cos(y)*sin(x*y) - cos(x-y)*sin(x+y)*0.5;\nfloat f = sin(x*x + y) - cos(y*y + x) + 0.3*sin(x*y*5.);\nfloat f = sin(theta*4. + log(r+1.)*5.) - cos(r*3. - theta*2.)*0.5;\nfloat f = sin(r*5.) + sin(8.*theta) - cos(r*theta);\nfloat f = sin(x*x + y*y) - cos(x*x - y*y) + sin(x*y*2.) * 0.5;\nfloat f = sin(x*3.) * sin(y*3.) - cos((x+y)*2.) * cos((x-y)*2.) - 0.3;\nfloat f = sin(x*y*3.) - cos(x*x + y*y) + sin(x*5.) * cos(y*5.) * 0.3;\nfloat f = sin(x*2.) + sin((x+y*sqrt(3.))*2.) + sin((x-y*sqrt(3.))*2.) - 1.5;\nfloat f = sin(x*x*y) - cos(y*y*x) + sin((x+y)*(x-y));\nfloat f = sin(sqrt(abs(x*y))) - cos(x*x + y*y) + sin(abs(x) + abs(y)) * 0.7;\nfloat f = sin(x*x*x - 3.*x*y*y) - cos(3.*x*x*y - y*y*y);\nfloat f = sin(x*y*x) + cos(y*x*y) - sin(x*x + y*y) * cos(x*y) - 0.2;\nfloat f = sin(x*x - y) - cos(y*y - x) + sin(x*y*y) - cos(x*x*y);\nfloat f = sin(r*r) - cos(x*y*r) + sin(atan(y,x)*r);\nfloat f = sin(x/(y+0.1)) - cos(y/(x+0.1)) + sin(x*y);\nfloat f = sin(theta*r*r) - cos(r*r*r) + sin(theta*10.);\nfloat f = sin(x*x*x) + cos(y*y*y) - sin(x*x*y) - cos(x*y*y) - 0.5;\nfloat f = sin(x*y*3.) * cos(x*x - y*y) - sin((x+y)*5.) * cos((x-y)*2.);\nfloat f = sin(sqrt(x*x + y*y)*3. - atan(y,x)*5.) - cos(sqrt(x*x + y*y)*2.);\nfloat f = sin(x*5.) * cos(y*5.) - sin((x+y)*3.) + cos((x-y)*3.) - 0.8;\nfloat f = sin(abs(x*y)*2.) - cos(x*x + y*y) + sin(abs(x) - abs(y)) * 0.6;\n\n*/\n\nfloat p(in float a, int b){float r = a;for(int i = 2; i<10; i++){ r = r*a; if(i>=b){ break;} }return r;}\n\nfloat evalF(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float r = length(vec2(x,y));\n    float theta = atan(y,x);\n    float x2 = x*x;\n    float y2 = y*y;\n    float r2 = x2+y2;\n    float sx = sin(x);\n    float cx = cos(x);\n    float sy = sin(y);\n    float cy = cos(y);\n    \n    // Implicit equation rearranged to f(x,y) = 0\n    float fa = sin(sx + cy) - cos(sin(x*y) + cx);\n    float fg = sin(10.*theta + r) - cos(r*5. - theta*3.);\n    float a= 0.8; float b = 0.8;\n    return sin(x2*0.5 - y2*0.5) * cos(x*y*0.5) - sin(r);\n\n\n// * (2.0 * p(x,3) * p(y,3)) - (p(x,4) * p(y,2)) - (p(x,2) * p(y,4)) + 36.0;\n}\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    float zoom = iMouse.z!=0.?pow((iMouse.x/iResolution.x)*8., 2.5):12.;\n    uv *= zoom;\n    \n    float f = evalF(uv);\n    \n    // Check for zero crossings with neighboring pixels\n    float pixelSize = zoom / min(iResolution.x, iResolution.y);\n    vec2 dx = vec2(pixelSize, 0.0);\n    vec2 dy = vec2(0.0, pixelSize);\n    \n    float fx_plus = evalF(uv + dx);\n    float fx_minus = evalF(uv - dx);\n    float fy_plus = evalF(uv + dy);\n    float fy_minus = evalF(uv - dy);\n    \n    // Check if zero line crosses through this pixel\n    bool zeroCrossing = (f * fx_plus < 0.0) || (f * fx_minus < 0.0) || \n                        (f * fy_plus < 0.0) || (f * fy_minus < 0.0);\n    \n    // Also check diagonal neighbors for better coverage\n    float fxy_pp = evalF(uv + dx + dy);\n    float fxy_pm = evalF(uv + dx - dy);\n    float fxy_mp = evalF(uv - dx + dy);\n    float fxy_mm = evalF(uv - dx - dy);\n    \n    zeroCrossing = zeroCrossing || (f * fxy_pp < 0.0) || (f * fxy_pm < 0.0) ||\n                   (f * fxy_mp < 0.0) || (f * fxy_mm < 0.0);\n    \n    // Compute distance to zero for smooth transitions\n    float dist = abs(f);\n    if (zeroCrossing) {\n        dist = 0.0; // Force to zero if crossing detected\n    }\n\n\n\n    // Mode A: Simple zero contour\n    vec3 colorA = mix(vec3(0.1, 0.1, 0.2), vec3(1.0, 0.5, 0.0), smoothstep(0.05, 0.0, abs(f)));\n    \n    // Mode B: Grid-based with crossing detection\n    vec2 grid = abs(fract(uv) - 0.5);\n    float gridLine = smoothstep(0.02, 0.0, min(grid.x, grid.y));\n    float curve = zeroCrossing ? 1.0 : smoothstep(0.03, 0.0, dist);\n    vec3 bgColor = vec3(0.05, 0.05, 0.1);\n    vec3 gridColor = vec3(0.2, 0.2, 0.3);\n    vec3 curveColor = vec3(1.0, 0.8, 0.2);\n    vec3 colorB = mix(bgColor, gridColor, gridLine * 0.5);\n    colorB = mix(colorB, curveColor, curve);\n    \n    // Mode C: Contour with positive/negative regions\n    float contour = sin(f * 20.0) * 0.5 + 0.5;\n    vec3 colorC;\n    if (f > 0.0) {\n        colorC = mix(vec3(0.2, 0.1, 0.4), vec3(1.0, 0.3, 0.1), contour);\n    } else {\n        colorC = mix(vec3(0.1, 0.2, 0.4), vec3(0.1, 0.7, 1.0), contour);\n    } \n    colorC = mix(colorC, vec3(1.0), smoothstep(0.02, 0.0, abs(f)));\n    \n    // Mode D: Heat map visualization\n    vec3 colorD = vec3(0.5) + 0.5 * cos(6.28 * f + vec3(0, 1, 2));\n    curve = smoothstep(0.03, 0.0, abs(f));\n    colorD = mix(colorD, vec3(1.0), curve);\n    \n    // Blend modes based on mouse Y position\n    float mouseY = iMouse.z != 0. ? iMouse.y / iResolution.y : 0.25;\n    float blendParam = mouseY * 3.0; \n    vec3 finalColor;\n    if (blendParam < 1.0) {\n        finalColor = mix(colorA, colorB, smoothstep(0.0, 1.0, blendParam));\n    } else if (blendParam < 2.0) {\n        finalColor = mix(colorB, colorC, smoothstep(1.0, 2.0, blendParam));\n    } else {\n        finalColor = mix(colorC, colorD, smoothstep(2.0, 3.0, blendParam));\n    }\n    fragColor = vec4(finalColor, 1.0);\n}\n\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = 16., k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}  \n\n/* Fork of \"sin (sin (x) + cos (y)) =\" by Cotterzz. https://shadertoy.com/view/W3XyRn\n// 2025-09-29 23:53:17\n\n// sin (sin (x) + cos (y)) = cos (sin (x*y) + cos (x))\n\n// from Joshua Guo on x: https://x.com/jshguo/status/1972564708525064688\n\n// mouse x to zoom\n\n// mouse y to change view mode\n// power function without using pow() \nfloat p(in float a, in int b){float r = a;for(int i = 2; i<10; i++){ r = r*a; if(i>=b){ break;} }return r;}\n\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    uv *= iMouse.z!=0.?pow((iMouse.x/iResolution.x)*8., 2.5):12.;\n    \n    float x = uv.x;\n    float y = uv.y;\n    float r = length(vec2(x,y));\n    float theta = atan(y,x);\n    float x2 = x*x;\n    float y2 = y*y;\n    float sx = sin(x);\n    float cx = cos(x);\n    float sy = sin(y);\n    float cy = cos(y);\n    \n    // Implicit equation rearranged to f(x,y) = 0\n    float fa = sin(sx + cy) - cos(sin(x*y) + cx);\n    float fb = sin(sin(x)*cos(y)) - cos(sin(y)*cos(x)) + 0.3*sin(x*y);\n    float fc = sin(10.0*x) - sin(10.0*r);\n    float fd = sin(x + sin(y)) - cos(y + cos(x));\n    float fe = sin(x*x*sin(iTime) - y*y*cos(iTime)) * cos(x*y*0.5) - sin(r);\n    float ff = sin(5.*x)*sin(5.*y) + 0.5*sin(10.*x*y) - cos(sqrt(x*x+y*y)*3.);\n\nfloat fg = sin(10.*theta + r) - cos(r*5. - theta*3.);\n\nfloat fh = pow(x*x + y*y + x, 2.) - x*x - y*y;\n//float r = sqrt(x*x + y*y);\n//float theta = atan(y, x);\nfloat fi = log(r) - 0.2*theta;\nfloat fj = r - sin(5.*theta);\nfloat fk = sin(x*y) * cos(x-y) - sin(x+y) * cos(x*y) * 0.5;\nfloat fl = sin(cos(x) + sin(y)) - cos(sin(x) - cos(y));\nfloat fm = x*x*x*x - x*x + y*y;\nfloat fn = y*y*(y*y - 4.) - x*x*(x*x - 5.);\nfloat fo = pow(x*x + y*y, 2.) - 2.*(x*x - y*y);\nfloat fp = x*x*x + y*y*y - 3.0*0.6*x*y;\nfloat fq = sin(x*x - y*y) + cos(2.*x*y) - 0.5;\nfloat fr = sin(x)*cos(y) - sin(x*y) + cos(x+y);\nfloat ft = sin(x*x + y) - cos(y*y + x) + 0.3*sin(x*y*5.);\n\nfloat fs = sin(x)*cos(y)*sin(x*y) - cos(x-y)*sin(x+y)*cos(iTime);\n\nfloat fu = sin(theta*4. + log(r+1.)*5.) - cos(r*3. - theta*2.)*0.5;\nfloat fv = pow(sin(x)*sin(y), 2.) - 0.5*sin(x*x + y*y) + 0.2;\nfloat fw = sin(r*5. - atan(y,x)*3.) * cos(r*3.) - 0.5 + r*0.1;\n\nfloat fx = sin(7.*theta)*cos(2.*theta) - r + sin(r*4.)*0.4 + 2.;\n\nfloat fy = sin(x*3.)*0.3 - y + cos(x*3.)*0.3*sign(sin(x*6.));\nfloat fz = sin(theta*3. + 1./r) - r*0.5;\n\nfloat faa = sin(x*2. + sin(y*fv))*cos(y*fs + cos(x*fm)) + 0.3*sin(x*y*4.) - 0.5;\n\nfloat pa = ( 2.0 * p(x,3) * p(y,3) )-( p(x,4) * p(y,2) )-( p(x,2) * p(y,4) ) + 36.0;\n\nfloat fab = r - (1. + 0.6*sin(6.*theta + r*6.));\nfloat fac= sin(r*10. + theta*2.) - 0.3;\nfloat fad = sin(r*5.) + sin(8.*theta*sin(iTime)) - cos(r*theta*cos(iTime));\nfloat fae = sin(x*2.)*sin(y*2.) + sin(x*3.+y*1.5)*0.5 + sin(sqrt(x*x+y*y)*5.)*0.3 - 0.5;\nfloat faf = sin(x*x*x - y*y*y + x*y) - cos(x*x + y*y)*0.5;\nfloat fag = sin(3.*x)*sin(3.*y) - 0.5*sin(5.*x*y) + 0.3*cos(x*x-y*y) - 0.4;\nfloat fah = r - (1.5 + 1.5*sin(12.*theta*sin(iTime) + r*10.));\n    float f = pa;//fe*faa+fs;//fb*fc-fm+fo*fp;//mix(fb, fd, iMouse.y/iResolution.y);\n    // Mode A: Si+fac+mple zero contour\n    vec3 colorA = mix(vec3(0.1, 0.1, 0.2), vec3(1.0, 0.5, 0.0), smoothstep(0.05, 0.0, abs(f)));\n    \n    // Mode B: Grid-based\n    vec2 grid = abs(fract(uv) - 0.5);\n    float gridLine = smoothstep(0.02, 0.0, min(grid.x, grid.y));\n    float curve = smoothstep(0.03, 0.0, abs(f));\n    vec3 bgColor = vec3(0.05, 0.05, 0.1);\n    vec3 gridColor = vec3(0.2, 0.2, 0.3);\n    vec3 curveColor = vec3(1.0, 0.8, 0.2);\n    vec3 colorB = mix(bgColor, gridColor, gridLine * 0.5);\n    colorB = mix(colorB, curveColor, curve);\n    \n    // Mode C: Contour with positive/negative regions\n    float contour = sin(f * 20.0) * 0.5 + 0.5;\n    vec3 colorC;\n    if (f > 0.0) {\n        colorC = mix(vec3(0.2, 0.1, 0.4), vec3(1.0, 0.3, 0.1), contour);\n    } else {\n        colorC = mix(vec3(0.1, 0.2, 0.4), vec3(0.1, 0.7, 1.0), contour);\n    } \n    colorC = mix(colorC, vec3(1.0), smoothstep(0.02, 0.0, abs(f)));\n    \n    // Mode D: Heat map visualization\n    vec3 colorD = vec3(0.5) + 0.5 * cos(6.28 * f + vec3(0, 1, 2));\n    colorD = mix(colorD, vec3(1.0), curve);\n    \n    // Blend modes based on mouse Y position\n    float mouseY = iMouse.z != 0. ? iMouse.y / iResolution.y : 0.25;\n    float blendParam = mouseY * 3.0; \n    vec3 finalColor;\n    if (blendParam < 1.0) {\n        finalColor = mix(colorA, colorB, smoothstep(0.0, 1.0, blendParam));\n    } else if (blendParam < 2.0) {\n        finalColor = mix(colorB, colorC, smoothstep(1.0, 2.0, blendParam));\n    } else {\n        finalColor = mix(colorC, colorD, smoothstep(2.0, 3.0, blendParam));\n    }\n    fragColor = vec4(finalColor, 1.0);\n}\n\n// multisampling\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = 64., k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}  \n*/\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "W3fyWr",
    "date": "0",
    "viewed": 0,
    "name": "Apollonian gasket v1",
    "description": "attempt 1",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "fractal",
     "apollonian",
     "gasket"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// 3D Apollonian Gasket with individually colored, tangent cylinders\n// Raymarched with SDF for Shadertoy\n\n#define MAX_STEPS 256\n#define MAX_DIST 100.0\n#define SURF_DIST 0.0005\n\n// Rotation matrix\nmat2 rot2(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n// SDF for a cylinder along Z axis, returns (distance, cylinderID)\nvec2 sdCylinderID(vec3 p, vec2 center, float radius, float id) {\n    float d = length(p.xy - center) - radius;\n    return vec2(d, id);\n}\n\n// Combine two distance/ID pairs, keeping the closest\nvec2 opUnionID(vec2 d1, vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n// Hash function for consistent colors per cylinder\nvec3 hash3(float n) {\n    return fract(sin(vec3(n, n + 1.0, n + 2.0)) * vec3(43758.5453, 22578.1459, 19642.3490));\n}\n\n// Create the Apollonian gasket with proper tangent positioning\nvec2 apollonianCylinders(vec3 p) {\n    float extrusionLength = 3.5;\n    \n    // Apply twist along z-axis for winding effect\n    float twist = p.z * 0.18 + iTime * 0.12;\n    p.xy *= rot2(twist);\n    \n    // Apply gentle wave for organic feel\n    vec2 wave = vec2(\n        sin(p.z * 0.8 + iTime * 0.4) * 0.06,\n        cos(p.z * 1.2 - iTime * 0.3) * 0.04\n    );\n    p.xy += wave;\n    \n    // Start with impossibly far distance\n    vec2 result = vec2(1000.0, 0.0);\n    \n    // Calculate proper Apollonian gasket positions\n    // Using Descartes Circle Theorem for exact tangency\n    \n    // Three main circles with calculated radii for perfect fit\n    float R = 1.0; // Outer boundary (implicit)\n    float r1 = 0.333333; // 1/3\n    float r2 = 0.333333; // 1/3  \n    float r3 = 0.333333; // 1/3\n    \n    // Position the three main circles (120 degrees apart)\n    vec2 c1 = vec2(0.0, 0.666667);     // Top\n    vec2 c2 = vec2(0.57735, -0.333333); // Bottom right  \n    vec2 c3 = vec2(-0.57735, -0.333333); // Bottom left\n    \n    result = opUnionID(result, sdCylinderID(p, c1, r1, 1.0));\n    result = opUnionID(result, sdCylinderID(p, c2, r2, 2.0));\n    result = opUnionID(result, sdCylinderID(p, c3, r3, 3.0));\n    \n    // Central circle (tangent to all three main circles)\n    float r4 = 0.166667; // Calculated using Descartes theorem\n    vec2 c4 = vec2(0.0, 0.0);\n    result = opUnionID(result, sdCylinderID(p, c4, r4, 4.0));\n    \n    // Second generation circles (in the outer gaps)\n    float r5 = 0.083333;\n    \n    // Between c1 and outer boundary\n    vec2 c5a = vec2(0.25, 0.85);\n    vec2 c5b = vec2(-0.25, 0.85);\n    result = opUnionID(result, sdCylinderID(p, c5a, r5, 5.0));\n    result = opUnionID(result, sdCylinderID(p, c5b, r5, 6.0));\n    \n    // Between c2 and outer boundary\n    vec2 c6a = vec2(0.75, -0.15);\n    vec2 c6b = vec2(0.65, -0.6);\n    result = opUnionID(result, sdCylinderID(p, c6a, r5, 7.0));\n    result = opUnionID(result, sdCylinderID(p, c6b, r5, 8.0));\n    \n    // Between c3 and outer boundary\n    vec2 c7a = vec2(-0.75, -0.15);\n    vec2 c7b = vec2(-0.65, -0.6);\n    result = opUnionID(result, sdCylinderID(p, c7a, r5, 9.0));\n    result = opUnionID(result, sdCylinderID(p, c7b, r5, 10.0));\n    \n    // Third generation - smaller circles\n    float r8 = 0.05;\n    \n    // Around the perimeter\n    for(int i = 0; i < 8; i++) {\n        float angle = float(i) * 0.785398; // 45 degree increments\n        vec2 pos = vec2(cos(angle), sin(angle)) * 0.9;\n        result = opUnionID(result, sdCylinderID(p, pos, r8, 11.0 + float(i)));\n    }\n    \n    // Fourth generation - tiny circles in remaining gaps\n    float r9 = 0.035;\n    \n    // Between main circles\n    vec2 gap1 = (c1 + c2) * 0.5 + vec2(0.1, 0.0);\n    vec2 gap2 = (c2 + c3) * 0.5 + vec2(0.0, -0.1);\n    vec2 gap3 = (c3 + c1) * 0.5 + vec2(-0.1, 0.0);\n    \n    result = opUnionID(result, sdCylinderID(p, gap1, r9, 19.0));\n    result = opUnionID(result, sdCylinderID(p, gap2, r9, 20.0));\n    result = opUnionID(result, sdCylinderID(p, gap3, r9, 21.0));\n    \n    // More tiny circles\n    result = opUnionID(result, sdCylinderID(p, vec2(0.15, 0.25), r9, 22.0));\n    result = opUnionID(result, sdCylinderID(p, vec2(-0.15, 0.25), r9, 23.0));\n    result = opUnionID(result, sdCylinderID(p, vec2(0.3, -0.15), r9, 24.0));\n    result = opUnionID(result, sdCylinderID(p, vec2(-0.3, -0.15), r9, 25.0));\n    \n    // Fifth generation - fill more gaps\n    float r10 = 0.025;\n    result = opUnionID(result, sdCylinderID(p, vec2(0.45, 0.3), r10, 26.0));\n    result = opUnionID(result, sdCylinderID(p, vec2(-0.45, 0.3), r10, 27.0));\n    result = opUnionID(result, sdCylinderID(p, vec2(0.0, 0.45), r10, 28.0));\n    result = opUnionID(result, sdCylinderID(p, vec2(0.5, -0.4), r10, 29.0));\n    result = opUnionID(result, sdCylinderID(p, vec2(-0.5, -0.4), r10, 30.0));\n    result = opUnionID(result, sdCylinderID(p, vec2(0.0, -0.7), r10, 31.0));\n    \n    // Sixth generation - micro circles\n    float r11 = 0.018;\n    for(int i = 0; i < 6; i++) {\n        float angle = float(i) * 1.047197; // 60 degrees\n        vec2 pos = vec2(cos(angle), sin(angle)) * 0.82 + vec2(cos(angle * 2.0), sin(angle * 2.0)) * 0.08;\n        result = opUnionID(result, sdCylinderID(p, pos, r11, 32.0 + float(i)));\n    }\n    \n    // Apply extrusion limits\n    result.x = max(result.x, abs(p.z) - extrusionLength);\n    \n    return result;\n}\n\n// Scene SDF\nvec2 getDist(vec3 p) {\n    // Rotate for viewing\n    p.xz *= rot2(iTime * 0.06);\n    p.yz *= rot2(sin(iTime * 0.08) * 0.15);\n    \n    return apollonianCylinders(p);\n}\n\n// Raymarching - returns distance and material ID\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    float matID = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        vec2 res = getDist(p);\n        float dS = res.x;\n        matID = res.y;\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return vec2(dO, matID);\n}\n\n// Get normal\nvec3 getNormal(vec3 p) {\n    vec2 res = getDist(p);\n    float d = res.x;\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy).x,\n        getDist(p - e.yxy).x,\n        getDist(p - e.yyx).x\n    );\n    \n    return normalize(n);\n}\n\n// Get color based on cylinder ID\nvec3 getCylinderColor(float id) {\n    if(id < 0.5) return vec3(0.1, 0.1, 0.1); // Background\n    \n    // Use hash function for varied but consistent colors\n    vec3 baseColors[10];\n    baseColors[0] = vec3(0.8, 0.2, 0.3); // Red\n    baseColors[1] = vec3(0.2, 0.7, 0.3); // Green  \n    baseColors[2] = vec3(0.3, 0.4, 0.9); // Blue\n    baseColors[3] = vec3(0.9, 0.7, 0.2); // Orange\n    baseColors[4] = vec3(0.8, 0.3, 0.8); // Magenta\n    baseColors[5] = vec3(0.2, 0.8, 0.8); // Cyan\n    baseColors[6] = vec3(0.9, 0.9, 0.3); // Yellow\n    baseColors[7] = vec3(0.6, 0.3, 0.1); // Brown\n    baseColors[8] = vec3(0.4, 0.1, 0.7); // Purple\n    baseColors[9] = vec3(0.1, 0.6, 0.2); // Dark Green\n    \n    // For cylinders beyond the predefined colors, use hash\n    if(id < 10.5) {\n        return baseColors[int(id - 1.0)];\n    }\n    \n    // Hash-based colors for remaining cylinders\n    return hash3(id * 7.234) * 0.8 + 0.2;\n}\n\n// Lighting\nfloat getLight(vec3 p, vec3 lightPos) {\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    \n    // Soft shadow\n    vec2 res = rayMarch(p + n * SURF_DIST * 2.0, l);\n    float d = res.x;\n    if(d < length(lightPos - p)) dif *= 0.4;\n    \n    return dif;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera\n    vec3 ro = vec3(0, 2.5, 6.5);\n    vec3 lookAt = vec3(0, 0, 0);\n    \n    // Camera orbit\n    float camAngle = iTime * 0.15;\n    ro.xz = vec2(sin(camAngle), cos(camAngle)) * 6.5;\n    ro.y = 3.0 + sin(iTime * 0.25) * 1.2;\n    \n    // Camera matrix\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0, 1, 0), forward));\n    vec3 up = cross(forward, right);\n    \n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    \n    // Raymarch\n    vec2 result = rayMarch(ro, rd);\n    float d = result.x;\n    float matID = result.y;\n    \n    vec3 col = vec3(0.01, 0.02, 0.03); // Dark background\n    \n    if(d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = getNormal(p);\n        \n        // Get cylinder-specific color\n        vec3 baseColor = getCylinderColor(matID);\n        \n        // Lighting setup\n        vec3 lightPos1 = vec3(6, 8, 5);\n        vec3 lightPos2 = vec3(-4, 6, -4);\n        vec3 lightPos3 = vec3(2, -4, 3);\n        \n        float dif1 = getLight(p, lightPos1);\n        float dif2 = getLight(p, lightPos2) * 0.6;\n        float dif3 = getLight(p, lightPos3) * 0.4;\n        \n        // Add some variation within each cylinder\n        float variation = sin(p.z * 8.0 + matID * 3.14159) * 0.1 + 1.0;\n        baseColor *= variation;\n        \n        // Metallic/plastic look\n        float fresnel = pow(1.0 - abs(dot(rd, n)), 2.0);\n        vec3 specColor = mix(vec3(1.0), baseColor, 0.5);\n        \n        // Combine lighting\n        col = baseColor * (dif1 + dif2 + dif3) * 0.8;\n        col += specColor * fresnel * 0.6;\n        col += baseColor * 0.1; // Ambient\n        \n        // Subtle rim lighting\n        col += vec3(0.4, 0.5, 0.7) * pow(fresnel, 4.0) * 0.3;\n        \n        // Distance fog\n        col = mix(col,vec3(0.01, 0.02, 0.03), smoothstep(8.0, 20.0, d));\n    }\n    \n    // Tone mapping and gamma correction\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "W3XyW8",
    "date": "1759514082",
    "viewed": 9,
    "name": "Apollonian Kleinian Thing",
    "description": "Trying to make apollonian gasket but ended up here",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "fractal",
     "kaleidoscope",
     "kleinian",
     "group",
     "apollonian",
     "gasket"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec2 inv(vec2 p,vec2 c,float r){vec2 d=p-c;return c+r*r*d/dot(d,d);}\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec4 frac(vec2 z){\n    vec2 p=z;float s=5.,d=10.,n=7.+sin(iTime)*5.;\n    int lastFold=0; // Track which operation happened last\n    float totalRot=0.; // Track accumulated rotation\n    float geom=0.; // Geometric signature\n    for(int i=0;i<10;i++){\n        float a=atan(p.y,p.x),pi=3.14159;\n        a=mod(a+pi/n,2.*pi/n)-pi/n;\n        totalRot+=abs(a);\n        p=length(p)*vec2(cos(a),sin(a));\n                geom+=length(p)*0.1; // Accumulate \"path signature\"\n  \n        p=abs(p);\n        if(p.x+0.57735*p.y>1.0){\n            float dist=(p.x+0.57735*p.y-1.0)/1.1547;\n            p-=2.0*dist*vec2(0.8660,0.5);\n            lastFold=1; // Domain fold\n            geom+=1.; // Fold signature\n        }\n        \n        vec2 c=vec2(.5,.289);float r=.4+sin(iTime/3.1)*.15,l=length(p-c);\n        if(l<r){\n            p=inv(p,c,r);\n            s*=r/l;\n            lastFold=2; // Circle inversion\n            geom*=2.;\n        }\n        d=min(d,abs(l-r)/s);\n    }\n    return vec4(d,s,float(lastFold)+totalRot, geom);\n}\n\nvoid mainImage(out vec4 o,in vec2 f){\n    vec2 u=(f-.5*iResolution.xy)/iResolution.y;\n    float z=3.+sin(iTime*.5)*1.5,t=iTime*.15;\n    u*=z*mat2(cos(t),-sin(t),sin(t),cos(t));\n    \n    vec4 r=frac(u);\n    \n    float circ=smoothstep(.01,0.,r.x);\n    \n    // use r.x, r.y, r.z and r.w plus circ is useful\n    // hsl2rgb is there if needed\n    \n    vec3 c = hsl2rgb( vec3(circ+r.y, r.z, r.w/30.));\n    \n    \n    o=vec4(c,1);\n}\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "W3fyDH",
    "date": "0",
    "viewed": 0,
    "name": "Apollonian extrusion,",
    "description": "simplifying \"Colourful Apollonian III\" by mla. https://shadertoy.com/view/wdsfWX\n\nmouse control. \nclick back to bottom-left corner for demo mode.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "inversion",
     "apollonian",
     "short",
     "golf",
     "gasket"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Colourful Apollonian III - short\" by FabriceNeyret2. https://shadertoy.com/view/cl3GDl\n// 2025-10-03 22:22:53\n\nvec4 getApollonianColor(vec2 uv, vec2 interactionPoint) {\n    vec2 z = uv;\n    \n    float N = 3.;\n    float a = 3.14159/N;\n    float D = 1./cos(a);\n    float T = tan(a);\n    float K = D - T;\n    \n    float maxDepth = 10.0;\n    float depth = 0.;\n    vec2 t = vec2(0);\n    float s = T*T;\n    \n    float outerBound = (D + T) / 3.737;\n    if (length(uv) > outerBound) {\n        return vec4(0, 0, 0, 0);\n    }\n    \n    if (length(interactionPoint) < outerBound && length(interactionPoint) > 0.01) {\n        s = dot(interactionPoint, interactionPoint);\n        vec2 invCenter = interactionPoint / s;\n        float invScale = 1./s - 1.;\n        z = (z - invCenter) / dot(z - invCenter, z - invCenter) * invScale + invCenter;\n    }\n    \n    s = T*T;\n    \n    for (; depth < maxDepth && length(z) > K; depth++) {\n        z *= -K / dot(z,z);\n        \n        for (float j = 0.; j++ < N;) {\n            t = D * sin(6.28*j/N + vec2(0,1.57));\n            if (length(z-t) < T) {\n                z = (z-t) / dot(z-t,z-t) * s + t;\n                j = N;\n            }\n        }\n    }\n    \n    float alpha = 0.0;\n    if (length(z) < K) alpha = 1.0;\n    \n    for (float j = 0.; j < N; j++) {\n        vec2 center = D * sin(6.28*j/N + vec2(0,1.57));\n        if (length(z - center) < T) alpha = 1.0;\n    }\n    \n    if (alpha < 0.05 || depth > 6.7) {\n        return vec4(0, 0, 0, 0);\n    }\n    \n    vec3 color = 0.5 + 0.5 * cos(depth * 0.5 + vec3(0, 2.1, 4.2));\n    return vec4(color, 1.0);\n}\n\nfloat sdTorusDisks(vec3 p, out float diskIndex) {\n    float torusRadius = 1.5;\n    float diskRadius = 0.3;\n    float diskThickness = 0.003;\n    float spacing = 0.001;\n    \n    float angle = atan(p.z, p.x);\n    \n    // Check if in wedge gap - just return moderate distance to keep marching\n    if (p.z > 0.0 && abs(p.x) < p.z * 1.0) {\n        return 1.;  // Keep marching through gap\n    }\n    \n    // Snap to nearest disk angle\n    float nearestDiskAngle = round(angle / spacing) * spacing;\n    diskIndex = nearestDiskAngle / spacing;  // For interaction\n    \n    // Rotate point so the nearest disk is at angle 0\n    float c = cos(-nearestDiskAngle);\n    float s = sin(-nearestDiskAngle);\n    vec3 pRot;\n    pRot.x = c * p.x - s * p.z;\n    pRot.y = p.y;\n    pRot.z = s * p.x + c * p.z;\n    \n    // SDF for disk\n    float distAlongRadius = pRot.x - torusRadius;\n    float distInDisk = length(vec2(distAlongRadius, pRot.y)) - diskRadius;\n    \n    return max(distInDisk, abs(pRot.z) - diskThickness);\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy;\n    vec2 uv = (u - 0.5*R) / R.y;\n    \n    // Camera looking down from above\n    vec3 ro = vec3(2.5, 2.5, 4.0);\n    vec3 ta = vec3(0, 0, 0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = cross(uu, ww);\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 2.0*ww);\n    \n    float t = 0.0;\n    vec3 col = vec3(0.05);\n    \n    for (int i = 0; i < 200; i++) {\n        vec3 p = ro + rd * t;\n        \n        float diskIndex;\n        float d = sdTorusDisks(p, diskIndex);\n        float angle = atan(p.z, p.x);\n        \n        if (d < 0.001) {\n            float r = length(p.xz);\n            vec2 diskUV = vec2(r - 1.5, p.y);\n            \n            vec2 interactionPoint = vec2(\n                sin(angle+iTime) * 0.4,\n                cos(angle+iTime) * 0.4\n            );\n            \n            vec4 gasket = getApollonianColor(diskUV*4., interactionPoint);\n            \n            if (gasket.a > 0.1) {\n                col = gasket.rgb;\n                \n                // Color variation\n                col *= 0.9 + 0.1 * sin(diskIndex * 0.001);\n                \n                // Lighting\n                vec3 n = normalize(vec3(p.x, 0, p.z));\n                float diff = 0.7 + 0.3 * dot(n, normalize(vec3(1, 1, 0)));\n                col *= diff;\n            } else {\n                t += 0.01;\n                continue;\n            }\n            break;\n        }\n        \n        t += max(d * 0.9, 0.0005);\n        if (t > 20.0) break;\n    }\n    \n    O = vec4(col, 1.0);\n}\n\n/*\n\n// Extract your gasket logic into a function\nvec4 computeGasket(vec2 uv, vec2 warp) {\n    vec2 z = uv;\n    vec2 z_orig = z;\n    \n    float N = 3.;\n    float a = 3.14159/N;\n    float D = 1./cos(a);\n    float T = tan(a);\n    float K = D - T;\n    \n    float maxDepth = 10.0;\n    float depth = 0.;\n    vec2 t = vec2(0);\n    float s = T*T;\n    \n    float outerBound = D + T;\n    if (length(z_orig) > outerBound/3.737) {\n        return vec4(0, 0, 0, 0);\n    }\n    \n    // Apply warp transformation (replaces mouse)\n    if (length(warp) > 0.01 && length(warp) < outerBound/3.737) {\n        s = dot(warp, warp);\n        vec2 invCenter = warp / s;\n        float invScale = 1./s - 1.;\n        z = (z - invCenter) / dot(z - invCenter, z - invCenter) * invScale + invCenter;\n    }\n    \n    s = T*T;\n    \n    for (; depth < maxDepth && length(z) > K; depth++) {\n        z *= -K / dot(z,z);\n        \n        for (float j = 0.; j++ < N;) {\n            t = D * sin(6.28*j/N + vec2(0,1.57));\n            \n            if (length(z-t) < T) {\n                z = (z-t) / dot(z-t,z-t) * s + t;\n                j = N;\n            }\n        }\n    }\n    \n    float alpha = 0.0;\n    \n    if (length(z) < K) alpha = 1.0;\n    \n    for (float j = 0.; j < N; j++) {\n        vec2 center = D * sin(6.28*j/N + vec2(0,1.57));\n        if (length(z - center) < T) alpha = 1.0;\n    }\n    \n    if (alpha < 0.05 || depth > 6.7) {\n        return vec4(0, 0, 0, 0);\n    } else {\n        vec3 color = 0.5 + 0.5 * cos(depth * 0.5 + vec3(0, 2.1, 4.2));\n        return vec4(color, 1.0);\n    }\n}\n\n// Ray-plane intersection\nbool intersectPlane(vec3 ro, vec3 rd, vec3 normal, float dist, out float t) {\n    float denom = dot(rd, normal);\n    if (abs(denom) > 0.0001) {\n        t = (dist - dot(ro, normal)) / denom;\n        return t >= 0.0;\n    }\n    return false;\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy;\n    vec2 screenUV = (u * 2.0 - R) / R.y;\n    \n    // Camera setup\n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = normalize(vec3(screenUV, 1.5));\n    \n    // Plane setup (XY plane at Z=0)\n    vec3 planeNormal = vec3(0, 0, 1);\n    float planeDist = 0.0;\n    \n    float t;\n    if (intersectPlane(ro, rd, planeNormal, planeDist, t)) {\n        vec3 hitPos = ro + rd * t;\n        \n        // Use hit position XY as UV coordinates for gasket\n        vec2 gasketUV = hitPos.xy;\n        \n        // Compute warp based on 3D metric (e.g., time, position, etc.)\n        vec2 warp = vec2(0.3 * sin(iTime), 0.3 * cos(iTime));\n        \n        vec4 gasket = computeGasket(gasketUV, warp);\n        \n        if (gasket.a < 0.1) {\n            // Transparent - show background\n            O = vec4(0.1, 0.1, 0.2, 1.0);\n        } else {\n            O = gasket;\n        }\n    } else {\n        // Missed plane - background\n        O = vec4(0.1, 0.1, 0.2, 1.0);\n    }\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy;\n    vec2 z = (u+u - R) / R.y;\n    vec2 z_orig = z;  // Keep original position\n    \n    float N = 3.;\n    float a = 3.14159/N;\n    float D = 1./cos(a);\n    float T = tan(a);\n    float K = D - T;\n    \n    float maxDepth = 10.0;\n    float depth = 0.;\n    vec2 t = vec2(0);\n    float s = T*T;\n    \n    // Check if we're outside the main bounding circle\n    float outerBound = D + T;\n    if (length(z_orig) > outerBound/3.737) {\n        O = vec4(0, 0, 0, 0);  // Transparent\n        return;\n    }\n    \n    // MOUSE INTERACTION - Apply initial transformation\n    vec2 mouse = (2.*iMouse.xy - R) / R.y;\n    \n    // Only apply if mouse is inside the disk and clicked\n    if (length(iMouse.xy) > 9. && length(mouse) < outerBound/3.737) {\n        // Inversion centered at mouse position\n        s = dot(mouse, mouse);\n        vec2 invCenter = mouse / s;\n        float invScale = 1./s - 1.;\n        \n        z = (z - invCenter) / dot(z - invCenter, z - invCenter) * invScale + invCenter;\n    }\n    \n    s = T*T;  // Reset s for main iterations\n    \n    // Main iteration\n    for (; depth < maxDepth && length(z) > K; depth++) {\n        z *= -K / dot(z,z);\n        \n        // Check and invert through outer circles\n        for (float j = 0.; j++ < N;) {\n            t = D * sin(6.28*j/N + vec2(0,1.57));\n            \n            if (length(z-t) < T) {\n                z = (z-t) / dot(z-t,z-t) * s + t;\n                j = N;\n            }\n        }\n    }\n    \n    // Check if final z is inside any base circle\n    float alpha = 0.0;\n    \n    // Check center circle\n    if (length(z) < K) {\n        alpha = 1.0;\n    }\n    \n    // Check outer circles\n    for (float j = 0.; j < N; j++) {\n        vec2 center = D * sin(6.28*j/N + vec2(0,1.57));\n        if (length(z - center) < T) {\n            alpha = 1.0;\n        }\n    }\n    \n    if (alpha < 0.05 || depth > 6.7) {\n        O = vec4(0, 0, 0, 0);  // Transparent\n    } else {\n        // Color based on depth\n        vec3 color = 0.5 + 0.5 * cos(depth * 0.5 + vec3(0, 2.1, 4.2));\n        O = vec4(color, 1.0);\n    }\n}\n\n*/",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wXfyWH",
    "date": "1759539384",
    "viewed": 109,
    "name": "Extruded Apollonian fractal",
    "description": "Trying to recreate: [url]https://x.com/pickover/status/1973780504349639165[/url]\nFirst attempt using domain repetition for speed. Can probably do better",
    "likes": 14,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "inversion",
     "apollonian",
     "gasket",
     "reproduction",
     "extruded"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Colourful Apollonian III - short\" by FabriceNeyret2. https://shadertoy.com/view/cl3GDl\n//     and \"Colourful Apollonian III\"         by mla.            https://shadertoy.com/view/wdsfWX\nfloat ang;\nvec4 getApollonianColor(vec2 uv, vec2 interactionPoint) {\n    vec2 z = uv;\n    \n    float N = 3.;\n    float a = 3.14159/N;\n    float D = 1./cos(a);\n    float T = tan(a);\n    float K = D - T;\n    \n    float maxDepth = 20.;\n    float depth = 0.;\n    vec2 t = vec2(0);\n    float s = T*T;\n    \n    float outerBound = (D + T) / 3.77;\n    if (length(uv) > outerBound) {\n        return vec4(0, 0, 0, 0);\n    }\n    \n    if (length(interactionPoint) < outerBound && length(interactionPoint) > 0.01) {\n        s = dot(interactionPoint, interactionPoint);\n        vec2 invCenter = interactionPoint / s;\n        float invScale = 1./s - 1.;\n        z = (z - invCenter) / dot(z - invCenter, z - invCenter) * invScale + invCenter;\n    }\n    \n    s = T*T;\n    \n    for (; depth < maxDepth && length(z) > K; depth++) {\n        z *= -K / dot(z,z);\n        \n        for (float j = 0.; j++ < N;) {\n            t = D * sin(6.28*j/N + vec2(0,1.57));\n            if (length(z-t) < T) {\n                z = (z-t) / dot(z-t,z-t) * s + t;\n                j = N;\n            }\n        }\n    }\n    \n    float alpha = 0.0;\n    if (length(z) < K) alpha = 1.0;\n    \n    for (float j = 0.; j < N; j++) {\n        vec2 center = D * sin(6.28*j/N + vec2(0,1.57));\n        if (length(z - center) < T) alpha = 1.0;\n    }\n    \n    if (alpha < 0.05 || depth > 19.9 || (ang>0.3&&ang<1.6)) {\n        return vec4(0.0);\n    }\n    \n    vec3 color = 0.5 + 0.5 * cos(depth * 0.5 + vec3(0, 2.1, 4.2));\n    return vec4(color, 1.0);\n}\n\nfloat sdTorusDisks(vec3 p, out float diskIndex) {\n    float torusRadius = 1.5;\n    float diskRadius = 0.55;\n    float diskThickness = 0.005;\n    float spacing = 0.005;\n    \n    float angle = atan(p.z, p.x);\n    \n    float nearestDiskAngle = round(angle / spacing) * spacing;\n    diskIndex = nearestDiskAngle / spacing; \n    \n    float c = cos(-nearestDiskAngle);\n    float s = sin(-nearestDiskAngle);\n    vec3 pRot;\n    pRot.x = c * p.x - s * p.z;\n    pRot.y = p.y;\n    pRot.z = s * p.x + c * p.z;\n\n    float distAlongRadius = pRot.x - torusRadius;\n    float distInDisk = length(vec2(distAlongRadius, pRot.y)) - diskRadius;\n    \n    return max(distInDisk, abs(pRot.z) - diskThickness);\n}\n\nvoid mainImage0(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy;\n    vec2 uv = (u - 0.5*R) / R.y;\n    \n    vec3 ro = vec3(3.33, 1.5, 4.5);\n    vec3 ta = vec3(0, 0, 0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = cross(uu, ww);\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 2.0*ww);\n    \n    float t = 0.0;\n    vec3 col = vec3(0.05);\n    \n    for (int i = 0; i < 220; i++) {\n        vec3 p = ro + rd * t;\n        \n        float diskIndex;\n        float d = sdTorusDisks(p, diskIndex);\n        float angle = atan(p.z, p.x);\n        ang = angle;\n        if (d < 0.001) {\n            float r = length(p.xz);\n            vec2 diskUV = vec2(r - 1.5, p.y);\n            \n            vec2 interactionPoint = vec2(\n                sin(angle+iTime/2.) * 0.6,\n                cos(angle+iTime/1.7) * 0.6\n            );\n            \n            vec4 gasket = getApollonianColor(diskUV*2.2, interactionPoint);\n            \n            if (gasket.a > 0.1) {\n                col = gasket.rgb;\n                \n                col *= 0.9 + 0.1 * sin(diskIndex * 0.001);\n                \n                vec3 n = normalize(vec3(p.x, 0, p.z));\n                float diff = 0.7 + 0.3 * dot(n, normalize(vec3(1, 1, 0)));\n                col *= diff;\n            } else {\n                t += 0.01;\n                continue;\n            }\n            break;\n        }\n        \n        t += max(d, 0.0001);\n        if (t > 20.0) break;\n    }\n    \n    O = vec4(col, 1.0);\n}\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s =2., k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}  ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "t3fyDN",
    "date": "1759752511",
    "viewed": 5,
    "name": "cached apollonian",
    "description": "didnt work very well",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "apollonian",
     "buffer",
     "gasket"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "\nfloat sdCircle(vec2 p, vec2 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat sdApollonius(vec2 p) {\n    float d = 1e10;\n    \n    // Read metadata\n    float numCircles = texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    \n    // Distance to all circles\n    for (int i = 2; i < int(numCircles) && i < 400; i++) {\n        vec4 circle = texelFetch(iChannel0, ivec2(0, i), 0);\n        float sd = sdCircle(p, circle.xy, circle.z);\n        d = min(d, sd); // abs() for filled circles\n    }\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= 2.2; // Zoom\n    \n    // 2D view\n    float d = sdApollonius(uv);\n    \n    // Color based on distance\n    vec3 col = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n    col *= 1.0 - exp(-3.0 * abs(d));\n    col *= 0.8 + 0.2 * cos(140.0 * d);\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));\n    \n    // Show circle count\n    float numCircles = texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    fragColor = vec4(col, 1.0) + texture(iChannel0, fragCoord.xy/iResolution.xy, 0.);\n    \n}\n\n/*\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= 2.2; // Zoom\n    // Read metadata\n    float numCircles = texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    \n    // Draw all stored circles\n    vec3 col = vec3(0.05);\n    \n    for (int i = 1; i <= int(numCircles) && i < 100; i++) {\n        vec4 circle = texelFetch(iChannel0, ivec2(0, i), 0);\n        vec2 center = circle.xy;\n        float radius = circle.z;\n        float curvature = circle.w;\n        \n        float d = length(uv - center) - radius;\n        \n        // Draw circle outline\n        if (abs(d) < 0.01) {\n            col = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), float(i) / numCircles);\n        }\n        \n        // Draw center point\n        if (length(uv - center) < 0.02) {\n            col = vec3(1.0);\n        }\n    }\n    \n    // Show count\n    if (fragCoord.y < 30.0 && fragCoord.x < numCircles * 5.0) {\n        col = vec3(1.0, 1.0, 0.0);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\n*/",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "vec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float denom = dot(b, b);\n    return vec2(dot(a,b), a.y*b.x - a.x*b.y) / denom;\n}\n\nvec2 csqrt(vec2 z) {\n    float r = length(z);\n    float angle = atan(z.y, z.x) * 0.5;\n    return sqrt(r) * vec2(cos(angle), sin(angle));\n}\n\nfloat descartesCurvature(float k1, float k2, float k3, bool plus) {\n    float sum = k1 + k2 + k3;\n    float root = 2.0 * sqrt(max(0.0, k1*k2 + k2*k3 + k3*k1));\n    return sum + (plus ? root : -root);\n}\n\nvec2 descartesPosition(vec2 z1, vec2 z2, vec2 z3, \n                       float k1, float k2, float k3, float k4, bool plus) {\n    vec2 sum = k1*z1 + k2*z2 + k3*z3;\n    vec2 term1 = cmul(vec2(k1*k2, 0.0), cmul(z1, z2));\n    vec2 term2 = cmul(vec2(k2*k3, 0.0), cmul(z2, z3));  \n    vec2 term3 = cmul(vec2(k3*k1, 0.0), cmul(z3, z1));\n    vec2 sqrtArg = term1 + term2 + term3;\n    vec2 sqrtVal = csqrt(sqrtArg);\n    vec2 result = sum + (plus ? 2.0 : -2.0) * sqrtVal;\n    return cdiv(result, vec2(k4, 0.0));\n}\n\nconst float MIN_RADIUS = 0.002;\nconst int MAX_CIRCLES = 400;\n\n// STRICTER validation\nbool isValidNewCircle(vec2 pos, float r4, float k4, vec4 c1, vec4 c2, vec4 c3, int numCircles) {\n    \n    if (r4 < MIN_RADIUS || r4 > 2.0) return false;\n    if (any(isnan(pos)) || any(isinf(pos))) return false;\n    \n    // STRICT tangency check to all 3 parents\n    float d1 = length(pos - c1.xy);\n    float exp1 = (c1.w < 0.0) ? abs(c1.z - r4) : (c1.z + r4);\n    if (abs(d1 - exp1) > 0.008) return false;  // Tighter tolerance\n    \n    float d2 = length(pos - c2.xy);\n    float exp2 = (c2.w < 0.0) ? abs(c2.z - r4) : (c2.z + r4);\n    if (abs(d2 - exp2) > 0.008) return false;\n    \n    float d3 = length(pos - c3.xy);\n    float exp3 = (c3.w < 0.0) ? abs(c3.z - r4) : (c3.z + r4);\n    if (abs(d3 - exp3) > 0.008) return false;\n    \n    // Check ALL existing circles\n    for (int e = 1; e <= numCircles && e < 100; e++) {\n        vec4 ex = texelFetch(iChannel0, ivec2(0, e), 0);\n        float centerDist = distance(ex.xy, pos);\n        \n        // Duplicate check\n        if (centerDist < 0.008 && abs(ex.z - r4) < 0.008) return false;\n        \n        // Strict overlap check for internal circles\n        if (ex.w > 0.0 && k4 > 0.0) {\n            float sumRadii = ex.z + r4;\n            // Must be tangent (within tolerance) or well separated\n            if (centerDist < sumRadii - 0.005) {\n                // Overlapping - reject unless they're tangent\n                if (abs(centerDist - sumRadii) > 0.008) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 coord = ivec2(fragCoord);\n    \n    if (coord.x != 0) {\n        discard;\n        return;\n    }\n    \n    // INITIALIZATION\n    if (iFrame == 0) {\n        if (coord.y == 0) {\n            // [numCircles, tripletCounter, unused, unused]\n            fragColor = vec4(4.0, 0.0, 0.0, 0.0);\n            return;\n        }\n        \n        if (coord.y == 1) {\n            fragColor = vec4(0.0, 0.0, 1.0, -1.0);\n        }\n        else if (coord.y == 2) {\n            float r = 1.0 / (1.0 + 2.0/sqrt(3.0));\n            float y = 1.0 - r;\n            fragColor = vec4(0.0, y, r, 1.0/r);\n        }\n        else if (coord.y == 3) {\n            float r = 1.0 / (1.0 + 2.0/sqrt(3.0));\n            float d = 1.0 - r;\n            float angle = -2.0 * 3.14159265 / 3.0 + 3.14159265/2.0;\n            fragColor = vec4(d * cos(angle), d * sin(angle), r, 1.0/r);\n        }\n        else if (coord.y == 4) {\n            float r = 1.0 / (1.0 + 2.0/sqrt(3.0));\n            float d = 1.0 - r;\n            float angle = 2.0 * 3.14159265 / 3.0 + 3.14159265/2.0;\n            fragColor = vec4(d * cos(angle), d * sin(angle), r, 1.0/r);\n        }\n        return;\n    }\n    \n    vec4 prev = texelFetch(iChannel0, coord, 0);\n    fragColor = prev;\n    \n    // METADATA ROW - Systematic triplet cycling with persistent counter\n    if (coord.y == 0) {\n        float numCircles = prev.x;\n        float tripletCounter = prev.y;  // Persistent counter\n        \n        if (numCircles < float(MAX_CIRCLES)) {\n            \n            int nc = int(numCircles);\n            int maxSearches = 50;  // Increased from 30 to cover more triplets\n            bool found = false;\n            \n            for (int search = 0; search < maxSearches && !found; search++) {\n                // Wrap around when we've tried all triplets\n                int maxTriplets = (nc * (nc-1) * (nc-2)) / 6;\n                int tripletIdx = int(tripletCounter + float(search)) % max(1, maxTriplets);\n                int currentIdx = 0;\n                \n                // Systematic iteration through ALL triplets\n                for (int i = 1; i <= nc && i < 40 && !found; i++) {\n                    for (int j = i+1; j <= nc && j < 40 && !found; j++) {\n                        for (int k = j+1; k <= nc && k < 40 && !found; k++) {\n                            \n                            if (currentIdx == tripletIdx) {\n                                \n                                vec4 c1 = texelFetch(iChannel0, ivec2(0, i), 0);\n                                vec4 c2 = texelFetch(iChannel0, ivec2(0, j), 0);\n                                vec4 c3 = texelFetch(iChannel0, ivec2(0, k), 0);\n                                \n                                for (int curvSol = 0; curvSol < 2 && !found; curvSol++) {\n                                    float k4 = descartesCurvature(c1.w, c2.w, c3.w, curvSol == 0);\n                                    \n                                    if (abs(k4) < 0.01 || abs(k4) > 1000.0) continue;\n                                    \n                                    float r4 = abs(1.0 / k4);\n                                    \n                                    for (int posSol = 0; posSol < 2 && !found; posSol++) {\n                                        vec2 pos = descartesPosition(c1.xy, c2.xy, c3.xy, \n                                                                    c1.w, c2.w, c3.w, k4, posSol == 0);\n                                        \n                                        if (isValidNewCircle(pos, r4, k4, c1, c2, c3, nc)) {\n                                            fragColor.x = numCircles + 1.0;\n                                            fragColor.y = mod(tripletCounter + float(search + 1), float(maxTriplets));\n                                            found = true;\n                                        }\n                                    }\n                                }\n                            }\n                            \n                            currentIdx++;\n                        }\n                    }\n                }\n            }\n            \n            // If we didn't find anything, still increment counter and wrap\n            if (!found) {\n                int maxTriplets = (nc * (nc-1) * (nc-2)) / 6;\n                fragColor.y = mod(tripletCounter + float(maxSearches), float(max(1, maxTriplets)));\n            }\n        }\n        return;\n    }\n    \n    // WRITE NEW CIRCLE\n    vec4 metadata = texelFetch(iChannel0, ivec2(0, 0), 0);\n    float prevNumCircles = metadata.x;\n    float tripletCounter = metadata.y;\n    \n    if (coord.y == int(prevNumCircles) + 1) {\n        \n        int nc = int(prevNumCircles);\n        int maxSearches = 50;\n        int maxTriplets = (nc * (nc-1) * (nc-2)) / 6;\n        \n        for (int search = 0; search < maxSearches; search++) {\n            int tripletIdx = int(tripletCounter + float(search)) % max(1, maxTriplets);\n            int currentIdx = 0;\n            \n            for (int i = 1; i <= nc && i < 40; i++) {\n                for (int j = i+1; j <= nc && j < 40; j++) {\n                    for (int k = j+1; k <= nc && k < 40; k++) {\n                        \n                        if (currentIdx == tripletIdx) {\n                            \n                            vec4 c1 = texelFetch(iChannel0, ivec2(0, i), 0);\n                            vec4 c2 = texelFetch(iChannel0, ivec2(0, j), 0);\n                            vec4 c3 = texelFetch(iChannel0, ivec2(0, k), 0);\n                            \n                            for (int curvSol = 0; curvSol < 2; curvSol++) {\n                                float k4 = descartesCurvature(c1.w, c2.w, c3.w, curvSol == 0);\n                                \n                                if (abs(k4) < 0.01 || abs(k4) > 1000.0) continue;\n                                \n                                float r4 = abs(1.0 / k4);\n                                \n                                for (int posSol = 0; posSol < 2; posSol++) {\n                                    vec2 pos = descartesPosition(c1.xy, c2.xy, c3.xy, \n                                                                c1.w, c2.w, c3.w, k4, posSol == 0);\n                                    \n                                    if (isValidNewCircle(pos, r4, k4, c1, c2, c3, nc)) {\n                                        fragColor = vec4(pos, r4, k4);\n                                        return;\n                                    }\n                                }\n                            }\n                        }\n                        \n                        currentIdx++;\n                    }\n                }\n            }\n        }\n    }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "w3syW4",
    "date": "1759657879",
    "viewed": 3,
    "name": "motion detect abcxy",
    "description": "Motion in bottom right",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "motion"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sf3zn",
       "filepath": "/presets/webcam.png",
       "type": "webcam",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 3,
       "sampler": {
        "filter": "nearest",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Main Image: Display all 4 quadrants\n// iChannel0 = Webcam\n// iChannel1 = Buffer A (Cr, Cg, Hue)\n// iChannel2 = Buffer B (pixel delta)\n// iChannel3 = Buffer C (split: current | previous)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 quadrant = floor(uv * 2.0);\n    vec2 localUV = fract(uv * 2.0);\n    \n    vec3 col;\n    \n    if (quadrant.x == 0.0 && quadrant.y == 1.0) {\n        // Top-left: Original\n        col = texture(iChannel0, localUV).rgb;\n    }\n    else if (quadrant.x == 1.0 && quadrant.y == 1.0) {\n        // Top-right: Chromaticity + Hue\n        col = texture(iChannel1, localUV).rgb;\n    }\n    else if (quadrant.x == 0.0 && quadrant.y == 0.0) {\n        // Bottom-left: Pixel Delta (Image 3)\n        col = texture(iChannel2, localUV).rgb * 5.0;\n    }\n    else {\n        // Bottom-right: TIME DELTA of Pixel Delta (Image 4)\n        // Read left half (current) and right half (previous) from Buffer C\n        vec3 currentPixelDelta = texture(iChannel3, localUV * vec2(0.5, 1.0)).rgb;\n        vec3 previousPixelDelta = texture(iChannel3, localUV * vec2(0.5, 1.0) + vec2(0.5, 0.0)).rgb;\n        \n        vec3 timeDelta = abs(currentPixelDelta - previousPixelDelta);\n        \n        col = ((timeDelta * 10.)-texture(iChannel2, localUV).rgb * 15.0);\n    }\n    \n    // Grid lines\n    if (abs(uv.x - 0.5) < 0.002 || abs(uv.y - 0.5) < 0.002) {\n        col = vec3(0.2);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4sf3zn",
       "filepath": "/presets/webcam.png",
       "type": "webcam",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// Helper function\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// Buffer A: Convert to Cr, Cg, Hue\n// iChannel0 = Webcam\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 rgb = texture(iChannel0, uv).rgb;\n    \n    float sum = rgb.r + rgb.g + rgb.b + 0.001;\n    float cr = rgb.r / sum;\n    float cg = rgb.g / sum;\n    \n    vec3 hsv = rgb2hsv(rgb);\n    float hue = hsv.x;\n    \n    fragColor = vec4(cr, cg, hue, 1.0);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "// Buffer B: Spatial delta of Cr,Cg,Hue\n// iChannel0 = Buffer A\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    \n    vec3 center = texture(iChannel0, uv).rgb;\n    vec3 right = texture(iChannel0, uv + vec2(pixelSize.x, 0)).rgb;\n    vec3 down = texture(iChannel0, uv + vec2(0, pixelSize.y)).rgb;\n    \n    vec3 deltaX = abs(center - right);\n    vec3 deltaY = abs(center - down);\n    vec3 delta = max(deltaX, deltaY);\n    \n    fragColor = vec4(delta, 1.0);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "// Buffer C: Left half = current Buffer B, Right half = previous Buffer B\n// iChannel0 = Buffer C (itself - for previous data)\n// iChannel1 = Buffer B (current data)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    if (uv.x < 0.5) {\n        // LEFT HALF: Store current Buffer B\n        vec2 sampleUV = vec2(uv.x * 2.0, uv.y);\n        fragColor = texture(iChannel1, sampleUV);\n    } else {\n        // RIGHT HALF: Store what was in left half last frame (previous Buffer B)\n        vec2 previousUV = vec2((uv.x - 0.5) * 2.0, uv.y);\n        vec2 leftSideUV = vec2(previousUV.x * 0.5, previousUV.y);\n        // vec2 rightSideUV = leftSideUV + vec2(0.5,0);\n        if(iFrame%5 == 0){\n        fragColor = texture(iChannel0, leftSideUV);}// Read from left half of self\n        else {\n        fragColor = texture(iChannel0, uv, 0.);\n        }\n    }\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "33XcD7",
    "date": "1759682732",
    "viewed": 2,
    "name": "Cotterzz Gasket.",
    "description": "making this as an alternative to the apollonian for better extrusion.",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "2d",
     "sdf",
     "animation",
     "gasket"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "float sblend = 0.1;\nvec2 getGridPoint(int idx, float time) {\n    int x = idx % 4;\n    int y = idx / 4;\n    \n    // Base grid position (normalized to -0.5 to 0.5)\n    vec2 base = vec2(float(x), float(y)) / 3.0 - vec2(0.5);\n    // Get distance and angle from center\n    float dist = length(base);\n    if(dist < 0.001) return base; // Center point stays put\n    \n    vec2 normalized = base / dist;\n    \n    // Add animation\n    float phase = float(idx) * 0.5;\n    vec2 offset = vec2(\n        sin(time * 1.5 + phase) * 0.03,\n        cos(time * 1.7 + phase * 1.3) * 0.03\n    );\n    \n    // Radial wave\n    offset += base * sin(time * 3.0 - length(base) * 10.0) * 0.02;\n    \n    base += offset;\n    \n    // |cos| + |sin| gives us values from 1.0 (at cardinals) to sqrt(2) (at diagonals)\n    float scaleFactor = abs(normalized.x) + abs(normalized.y);\n    \n    // Pull points inward by this factor\n    vec2 distorted = 1.5 * base / pow(scaleFactor, 3.);\n\n    return distorted;\n}\n\nfloat sdTriangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    vec2 e0 = b - a;\n    vec2 e1 = c - b;\n    vec2 e2 = a - c;\n    \n    vec2 v0 = p - a;\n    vec2 v1 = p - b;\n    vec2 v2 = p - c;\n    \n    vec2 pq0 = v0 - e0 * clamp(dot(v0, e0) / dot(e0, e0), 0.0, 1.0);\n    vec2 pq1 = v1 - e1 * clamp(dot(v1, e1) / dot(e1, e1), 0.0, 1.0);\n    vec2 pq2 = v2 - e2 * clamp(dot(v2, e2) / dot(e2, e2), 0.0, 1.0);\n    \n    float s = sign(e0.x * e2.y - e0.y * e2.x);\n    vec2 d = min(min(vec2(dot(pq0, pq0), s * (v0.x * e0.y - v0.y * e0.x)),\n                     vec2(dot(pq1, pq1), s * (v1.x * e1.y - v1.y * e1.x))),\n                     vec2(dot(pq2, pq2), s * (v2.x * e2.y - v2.y * e2.x)));\n    \n    return -sqrt(d.x) * sign(d.y);\n}\nconst int N = 4;\nfloat sdPolygon( in vec2[N] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=N-1; i<N; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nfloat sdQuad(vec2 p, vec2 tl, vec2 tr, vec2 br, vec2 bl) {\n      \n    vec2[] polygon = vec2[](tl,tr,br,bl);\n    \n\treturn  sdPolygon(polygon, p);\n}\n\n// Distance from point to line segment\nfloat distToSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n\nfloat sdEllipseSimple(vec2 p, vec2 center, vec2 radii, float rotation) {\n    p -= center;\n    \n    float c = cos(rotation);\n    float s = sin(rotation);\n    p = mat2(c, s, -s, c) * p;\n    \n    vec2 np = p / max(radii, vec2(0.001));\n    float d = length(np) - 1.0;\n    \n    return d * min(radii.x, radii.y);\n}\n\n// Original working incircle\nvec4 getIncircle(vec2 a, vec2 b, vec2 c) {\n    float la = length(b - c);\n    float lb = length(c - a);\n    float lc = length(a - b);\n    float p = la + lb + lc;\n    \n    vec2 center = (la * a + lb * b + lc * c) / p;\n    \n    float s = p * 0.5;\n    float area = abs((b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y)) * 0.5;\n    float radius = area / s;\n    \n    return vec4(center, radius, 1.0);\n}\n\n// Fit an oval that touches quad edges\nvec4 fitOvalToQuad(vec2 tl, vec2 tr, vec2 bl, vec2 br) {\n    vec2 center = (tl + tr + bl + br) * 0.25;\n    \n    float distTop = distToSegment(center, tl, tr);\n    float distRight = distToSegment(center, tr, br);\n    float distBottom = distToSegment(center, bl, br);\n    float distLeft = distToSegment(center, tl, bl);\n    \n    float width = (distLeft + distRight) * 0.5 * 0.95;\n    float height = (distTop + distBottom) * 0.5 * 0.95;\n    \n    vec2 horizontal = ((tr - tl) + (br - bl)) * 0.5;\n    float rotation = atan(horizontal.y, horizontal.x);\n    \n    return vec4(width, height, rotation, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec2 grid[16];\n    for(int i = 0; i < 16; i++) {\n        grid[i] = getGridPoint(i, iTime);\n    }\n    \n    float minDist = 1e10;\n    float minAbsDist = 1e10;\n    float containerDist = 1e10;\n    vec3 nearestColor = vec3(0.0);\n    \n    for(int row = 0; row < 3; row++) {\n        for(int col = 0; col < 3; col++) {\n            int quadIdx = row * 3 + col;\n            int tl = row * 4 + col;\n            int tr = row * 4 + col + 1;\n            int bl = (row + 1) * 4 + col;\n            int br = (row + 1) * 4 + col + 1;\n            sblend = 0.4 + sin((iTime+(float(row+(col*row))))*1.5)*0.4;\n            bool useOval = (quadIdx == 2 || quadIdx == 6);\n            bool flipTri = (quadIdx == 0 || quadIdx == 4 || quadIdx == 8);\n            \n            float tri1Sdf = sdTriangle(uv, grid[tl], grid[tr], grid[bl]);\n            float tri2Sdf = sdTriangle(uv, grid[tr], grid[br], grid[bl]);\n            vec4 circ1 = getIncircle(grid[tl], grid[tr], grid[bl]);\n            vec4 circ2 = getIncircle(grid[tr], grid[br], grid[bl]);\n            if(flipTri){\n            tri1Sdf = sdTriangle(uv, grid[tr], grid[br], grid[tl]);\n            tri2Sdf = sdTriangle(uv, grid[br], grid[bl], grid[tl]);\n            circ1 = getIncircle(grid[tr], grid[br], grid[tl]);\n            circ2 = getIncircle(grid[br], grid[bl], grid[tl]);\n            }\n            \n            if(useOval) {\n                \n                float quadSdf = sdQuad(uv, grid[tl], grid[bl], grid[br], grid[tr]);\n\n                vec2 center = (grid[tl] + grid[tr] + grid[bl] + grid[br]) * 0.25;\n                vec4 oval = fitOvalToQuad(grid[tl], grid[tr], grid[bl], grid[br]);\n                float ovalSdf = sdEllipseSimple(uv, center, oval.xy, oval.z);\n                \n                float blendedSdf = mix(ovalSdf, quadSdf, sblend);\n                \n                if(abs(blendedSdf) < minAbsDist) {\n                    minAbsDist = abs(blendedSdf);\n                }\n                \n                if(blendedSdf < minDist) {\n                    minDist = blendedSdf;\n                    nearestColor = 0.5 + 0.5 * cos(vec3(0.0, 2.0, 4.0) + float(quadIdx) * 1.5);\n                    containerDist = quadSdf;\n                }\n            } else {\n                // Triangle 1\n                \n                \n                float circle1Sdf = length(uv - circ1.xy) - circ1.z;\n\n                float blend1 = mix(circle1Sdf, tri1Sdf, sblend);\n                if(abs(blend1) < minAbsDist) {\n                    minAbsDist = abs(blend1);\n                }\n                \n                if(blend1 < minDist) {\n                    minDist = blend1;\n                    nearestColor = 0.5 + 0.5 * cos(vec3(0.0, 2.0, 4.0) + float(quadIdx * 2));\n                    containerDist = tri1Sdf;\n                }\n                \n                // Triangle 2\n                \n                \n                float circle2Sdf = length(uv - circ2.xy) - circ2.z;\n                \n\n                float blend2 = mix(circle2Sdf, tri2Sdf, sblend);\n                \n                if(abs(blend2) < minAbsDist) {\n                    minAbsDist = abs(blend2);\n                }\n                \n                if(blend2 < minDist) {\n                    minDist = blend2;\n                    nearestColor = 0.5 + 0.5 * cos(vec3(1.0, 3.0, 5.0) + float(quadIdx * 2 + 1));\n                    containerDist = tri2Sdf;\n                }\n            }\n        }\n    }\n    \n    vec3 color = vec3(0.02, 0.02, 0.05);\n    \n    if(minDist < 0.0) {\n        float gradientFactor = 1.0 - smoothstep(-0.1, 0.0, containerDist);\n        color = nearestColor * (0.5 + 0.5 * gradientFactor);\n    }\n    \n    color += exp(-minAbsDist * 100.0) * vec3(1.0);\n    \n    for(int i = 0; i < 16; i++) {\n        float d = length(uv - grid[i]);\n        color += vec3(1.0) * exp(-d * 200.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "W3XcD7",
    "date": "1759683108",
    "viewed": 1,
    "name": "extruded apollonian attempt2",
    "description": "meh",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "apollonian"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Keep all the original Ball struct and helper functions from the shader\n\n#define inf              -1.\n#define MAX_ITER         50\n#define PI               3.141592653\n#define L2(x)            dot(x, x)\n#define L2XY(x, y)       dot(x - y, x - y)\n#define ZOOM             2.\n\nbvec2 displayRealBalls = bvec2(1, 1);\n\n// a1 = 3, a2 = 4, a3 = 2, a4 = 2 gives Mcleos f(3,6).\n// Vertical mirror if a3 = a4\nconst float a1 = 3.;\nconst float a2 = 4.;\nconst float a3 = 2.;\nconst float a4 = 4.;\n\n// For spheres n is the center, r is the radius\n// For planes n is the normal vector, r is the distance between the plane and the origin\n// if invert is true then the inside/outside of the sphere is interchanged (not used in this program)\n// if hasRealBall is true then this virtual ball has a real ball correspondes to it\nstruct Ball {\n    bool isplane;\n    vec2 n;\n    float r;\n    bool invert;\n    bool isRealBall;\n};\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[3] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[1] clusters;\n\nvec2 T;\n\nBall defaultBall() {\n    return Ball(false, vec2(0, 0), 1., false, false);\n}\n\n// Distance from a point to a ball\nfloat sdistanceToBall(vec2 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(B.n, B.r));\n        return k;\n    }\n    else {\n        float k = length(p - B.n) - B.r;\n        return k;\n    }\n}\n\nBall from_plane(vec2 n, float d) {\n    return Ball(true, n, d, false, false);\n}\n\nBall from_sphere(vec2 cen, float r) {\n    return Ball(false, cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\nfloat dihedral(float x) {\n    return x == inf ? 1. : cos(PI / x);\n}\n\n\nvoid translate(inout vec2 p, vec2 t) {\n    p.x = mod(p.x, t.x);\n}\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec2 p, Ball B, inout float scale) {\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(B.n, B.r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * B.n;\n        return false;\n    }\n    else {\n        vec2 cen = B.n;\n        float r = B.r;\n        vec2 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1. && B.invert) || (k > 1. && !B.invert) )\n            return true;\n        p = k * q + cen;\n        scale *= k;\n        return false;\n    }\n}\n\n \n// return distance to the scene, and get the index of the real ball hitted\nfloat DE(vec2 p, inout int index) {\n    Ball Bxy;\n\n    float scale = 3.;\n    for (int i = 0; i < MAX_ITER; i++) {\n        bool cond = true;\n\n        Bxy = coclusters[0];\n        cond = cond && try_reflect(p, Bxy, scale);\n        \n        translate(p, T);\n        Bxy = coclusters[1];\n        cond = cond && try_reflect(p, Bxy, scale);\n        \n        translate(p, T);        \n        Bxy.n = coclusters[1].n + T;\n        cond = cond && try_reflect(p, Bxy, scale);\n        \n        translate(p, T);\n        Bxy = coclusters[2];\n        cond = cond && try_reflect(p, Bxy, scale);\n\n        if (cond)\n            break;\n    }\n    \n    index = 0;\n\n    //float d1 = sdistanceToBall(p, clusters[0]);\n    //float d2 = sdistanceToBall(p, clusters[1]);\n    //d1 = abs(d1); d2 = abs(d2);\n    translate(p, T);\n    Bxy = clusters[0];\n    float d = sdistanceToBall(p, Bxy);\n    //d=abs(d);\n    return d / scale;\n}\n\n\n\nvoid init() {   \n    Ball B0 = from_plane(vec2(0, -1.), 0.);\n    \n    Ball B1 = from_sphere(vec2(0., -1.), 1./cos(PI/a1));\n    float c2=sqrt(1./cos(PI/a1)/cos(PI/a1) + 1./cos(PI/a2)/cos(PI/a2) + 2.*cos(PI/a3)/cos(PI/a1)/cos(PI/a2));\n    Ball B2 = from_sphere(vec2(c2, -1.), 1./cos(PI/a2));\n    float c3=sqrt(1./cos(PI/a1)/cos(PI/a1) + 1./cos(PI/a2)/cos(PI/a2) + 2.*cos(PI/a4)/cos(PI/a1)/cos(PI/a2));\n    T = vec2(c2+c3,0);\n    \n    invertBall(B1);\n    invertBall(B2);\n    coclusters = Ball[3] (B0,B1,B2);\n    \n    clusters[0] = from_plane(vec2(0., -1.), -1.);\n}\n\n\nfloat map(vec2 p, inout int index) {\n    vec2 mouse = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float k = 1.0;\n    //if (iMouse.z > 0.0) {\n        p -= mouse;\n        k = dot(p,p);\n        p /= k;\n        p += mouse;\n    //}\n    const float strong_factor = 4.;\n    return DE(p, index) * strong_factor;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 post_process(vec3 col, vec2 uv) {\n  col = pow(clamp(col, 0., 1.), vec3(1.0/2.2)); \n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *= 0.5 + 0.5*pow(19.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.7);\n  return col;\n}\n\n\n// Invert SDF within a circular or rectangular boundary\nfloat invertSDFWithinBounds(vec2 p, float sdf) {\n    // Define boundary - you can use different shapes\n    float boundaryDist = length(p) - 1.5;  // Circular boundary, radius 1.5\n    // Or rectangular: float boundaryDist = max(abs(p.x), abs(p.y)) - 1.5;\n    \n    // If inside boundary, invert the SDF\n    if (boundaryDist < 0.0) {\n        return -sdf;\n    }\n    \n    // Outside boundary, keep original\n    return sdf;\n}\n\n// Smooth version that blends at the boundary\nfloat invertSDFWithinBoundSmooth(vec2 p, float sdf, float boundaryRadius) {\n    float boundaryDist = length(p) - boundaryRadius;\n    \n    // Create a smooth blend factor (0 = inverted, 1 = original)\n    float blendWidth = 0.1;  // How smooth the transition is\n    float blend = smoothstep(-blendWidth, blendWidth, boundaryDist);\n    \n    return mix(-sdf, sdf, blend);\n}\n\n// Apply to your circle packing\nfloat circlePacking2DInverted(vec2 p) {\n    init();\n    int index;\n    float sdf = map(p, index);\n    \n    // Choose your boundary size\n    float boundaryRadius = 1.5;\n    return invertSDFWithinBoundSmooth(p, sdf, boundaryRadius);\n}\n\n// Or with a hard boundary (no smoothing)\nfloat circlePacking2DInvertedHard(vec2 p) {\n    init();\n    int index;\n    float sdf = map(p, index);\n    \n    float boundaryDist = length(p) - 1.5;\n    \n    if (boundaryDist < 0.0) {\n        return -sdf;  // Inverted inside\n    }\n    return sdf;  // Original outside\n}\nfloat circlePacking2DInvertedNatural(vec2 p) {\n    init();\n    int index;\n    float sdf = map(p, index);\n    \n    // Use the natural outer bound from the algorithm\n    float outerBound = (1./cos(PI/a1) + tan(PI/a1)) / 3.77 * ZOOM;\n    float boundaryDist = length(p) - outerBound;\n    \n    if (boundaryDist < 0.0) {\n        return -sdf;\n    }\n    \n    return sdf;\n}\n// Then use it in extrusion\nfloat extrudedPackingInverted(vec3 p, float height) {\n    float d2D = circlePacking2DInvertedNatural(p.xz);\n    float dExtrude = abs(p.y) - height * 0.5;\n    return max(d2D, dExtrude);\n}\n\n// First, let's wrap the 2D SDF in a clean function\nfloat circlePacking2D(vec2 p) {\n    init();  // Initialize the mirror configuration\n    int index;\n    return map(p, index);  // Returns distance to the mesh/web\n}\n\n// Basic extrusion - uniform height\nfloat extrudedPacking(vec3 p, float height) {\n    float d2D = circlePacking2D(p.xz);  // or p.xy depending on orientation\n    float dExtrude = abs(p.y) - height * 0.5;\n    return max(d2D, dExtrude);\n}\n\n// More interesting: varying thickness along height\nfloat extrudedPackingVarying(vec3 p, float height) {\n    float t = p.y / height + 0.5;  // Normalize to [0,1]\n    \n    // Scale the pattern based on height\n    float scale = mix(1.0, 0.7, t);  // Tapers from bottom to top\n    float d2D = circlePacking2D(p.xz / scale) * scale;\n    \n    // You could also add offset/bias to make the mesh thicker/thinner\n    float thickness = mix(0.0, -0.02, sin(t * 3.14159));  // Bulges in middle\n    d2D += thickness;\n    \n    float dExtrude = abs(p.y) - height * 0.5;\n    return max(d2D, dExtrude);\n}\n\n// Twisted extrusion\nfloat extrudedPackingTwisted(vec3 p, float height) {\n    float t = p.y / height + 0.5;\n    float angle = t * 3.14159 * 0.5;  // 90 degree twist\n    \n    // Rotate xz plane based on height\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 q = rot * p.xz;\n    \n    float d2D = circlePacking2D(q);\n    float dExtrude = abs(p.y) - height * 0.5;\n    return max(d2D, dExtrude);\n}\n\n// Advanced: morphing between different configurations\nfloat extrudedPackingMorph(vec3 p, float height) {\n    float t = p.y / height + 0.5;\n    \n    // You could reinitialize with different parameters at different heights\n    // This would require modifying the init() function to take parameters\n    \n    // For now, let's use a simpler approach - blend scales\n    float scale1 = 1.0;\n    float scale2 = 1.0;\n    float s = mix(scale1, scale2, smoothstep(0.2, 0.8, t));\n    \n    float d2D = circlePacking2D(p.xz / s) * s;\n    \n    // Add some wave distortion\n    //d2D += sin(p.y * 10.0) * 0.01;\n    \n    float dExtrude = abs(p.y) - height * 0.5;\n    return max(d2D, dExtrude);\n}\n\nfloat extrude(vec3 p, float height) {\n    return extrudedPackingMorph(p,height);\n}\n\n// Full raymarching setup\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera setup\n    //vec3 ro = vec3(2.0 * sin(iTime), 1.5, 2.0 * cos(iTime));\n     vec3 ro = vec3(3.5, 3.5, 5.0);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0, 1, 0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec3 rd = normalize(uv.x * uu + uv.y * vv + 1.5 * ww);\n    \n    // Raymarching\n    float t = 0.0;\n    for(int i = 0; i < 120; i++) {\n        vec3 p = ro + rd * t;\n        float d = extrude(p, 2.0);  // Try different variations!\n        \n        if(d < 0.001 || t > 30.0) break;\n        t += d * 0.4;  // Conservative marching\n    }\n    \n    // Shading\n    vec3 col = vec3(0.0);\n    if(t < 30.0) {\n        vec3 p = ro + rd * t;\n        \n        // Normal calculation\n        vec2 e = vec2(0.001, 0.0);\n        vec3 n = normalize(vec3(\n            extrude(p + e.xyy, 2.0) - extrude(p - e.xyy, 2.0),\n            extrude(p + e.yxy, 2.0) - extrude(p - e.yxy, 2.0),\n            extrude(p + e.yyx, 2.0) - extrude(p - e.yyx, 2.0)\n        ));\n        \n        // Simple lighting\n        vec3 lightPos = vec3(2.0, 4.0, 3.0);\n        vec3 l = normalize(lightPos - p);\n        float diff = max(dot(n, l), 0.0);\n        float spec = pow(max(dot(reflect(-l, n), -rd), 0.0), 32.0);\n        \n        col = vec3(0.8, 0.7, 0.6) * diff + vec3(1.0) * spec * 0.5;\n        col *= 0.5 + 0.5 * exp(-0.1 * t);  // Fog\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wXXyD7",
    "date": "1759709717",
    "viewed": 113,
    "name": "Warped Apollonian fractal",
    "description": "Trying to recreate: [url]https://x.com/pickover/status/1973780504349639165[/url]\nEnded up with this. Kinda off target but I'll take it",
    "likes": 8,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "psychedelic",
     "inversion",
     "apollonian",
     "gasket",
     "reproduction",
     "extruded"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Extruded Apollonian fractal\"      by Cotterzz.       https://shadertoy.com/view/wXfyWH\n// Fork of \"Colourful Apollonian III - short\" by FabriceNeyret2. https://shadertoy.com/view/cl3GDl\n//     and \"Colourful Apollonian III\"         by mla.            https://shadertoy.com/view/wdsfWX\n#if HW_PERFORMANCE == 0\n// turn off multisampling on mobile\n#define AA 1\n#else\n// change this to 1 if it runs slowly, or increase it for more smoothness\n#define AA 2 \n#endif\nfloat ang;\nfloat hgt;\n\nfloat getApollonianHeight(vec2 uv, vec2 interactionPoint) {\n    vec2 z = uv;\n    \n    float N = 3.;\n    float a = 3.14159/N;\n    float D = 1./cos(a);\n    float T = tan(a);\n    float K = D - T;\n    \n    float maxDepth = 20.;\n    float depth = 0.;\n    vec2 t = vec2(0);\n    float s = T*T;\n    \n    float outerBound = (D + T) / 3.77;\n    if (length(uv) > outerBound) {\n        return 0.0;\n    }\n    \n    if (length(interactionPoint) < outerBound && length(interactionPoint) > 0.01) {\n        s = dot(interactionPoint, interactionPoint);\n        vec2 invCenter = interactionPoint / s;\n        float invScale = 1./s - 1.;\n        z = (z - invCenter) / dot(z - invCenter, z - invCenter) * invScale + invCenter;\n    }\n    \n    s = T*T;\n    \n    for (; depth < maxDepth && length(z) > K; depth++) {\n        z *= -K / dot(z,z);\n        \n        for (float j = 0.; j++ < N;) {\n            t = D * sin(6.28*j/N + vec2(0,1.57));\n            if (length(z-t) < T) {\n                z = (z-t) / dot(z-t,z-t) * s + t;\n                j = N;\n            }\n        }\n    }\n    \n    float alpha = 0.0;\n    if (length(z) < K) alpha = 1.0;\n    \n    // Calculate distance to nearest circle boundary\n    float minDist = length(z) - K;  // Distance to center circle boundary\n    \n    for (float j = 0.; j < N; j++) {\n        vec2 center = D * sin(6.28*j/N + vec2(0,1.57));\n        float dist = abs(length(z - center) - T);  // Distance to this circle's boundary\n        minDist = min(minDist, dist);\n        if (length(z - center) < T) alpha = 1.0;\n    }\n    \n if (alpha < 0.05 || depth > 19.9 || (ang>0.3&&ang<1.6)) {\n        return 0.0;\n    }\n    \n    // Convert distance to height - closer to boundary = raised edge\n    // Use a smooth falloff for the circular ridges\n    float height = exp(-minDist * 8.0) * (1.0 + depth * 0.1);\n    \n    return height;\n}\n\nvec4 getApollonianColor(vec2 uv, vec2 interactionPoint) {\n    vec2 z = uv;\n    \n    float N = 3.;\n    float a = 3.14159/N;\n    float D = 1./cos(a);\n    float T = tan(a);\n    float K = D - T;\n    \n    float maxDepth = 20.;\n    float depth = 0.;\n    vec2 t = vec2(0);\n    float s = T*T;\n    \n    float outerBound = (D + T) / 3.77;\n    if (length(uv) > outerBound) {\n        return vec4(0, 0, 0, 0);\n    }\n    \n    if (length(interactionPoint) < outerBound && length(interactionPoint) > 0.01) {\n        s = dot(interactionPoint, interactionPoint);\n        vec2 invCenter = interactionPoint / s;\n        float invScale = 1./s - 1.;\n        z = (z - invCenter) / dot(z - invCenter, z - invCenter) * invScale + invCenter;\n    }\n    \n    s = T*T;\n    \n    for (; depth < maxDepth && length(z) > K; depth++) {\n        z *= -K / dot(z,z);\n        \n        for (float j = 0.; j++ < N;) {\n            t = D * sin(6.28*j/N + vec2(0,1.57));\n            if (length(z-t) < T) {\n                z = (z-t) / dot(z-t,z-t) * s + t;\n                j = N;\n            }\n        }\n    }\n    \n    float alpha = 0.0;\n    if (length(z) < K) alpha = 1.0;\n    \n       // Calculate distance to nearest circle boundary\n    float minDist = length(z) - K;  // Distance to center circle boundary\n    \n    for (float j = 0.; j < N; j++) {\n        vec2 center = D * sin(6.28*j/N + vec2(0,1.57));\n        float dist = abs(length(z - center) - T);  // Distance to this circle's boundary\n        minDist = min(minDist, dist);\n        if (length(z - center) < T) alpha = 1.0;\n    }\n    \n    if (alpha < 0.05 || depth > 19.9 || (ang>0.3&&ang<1.6)) {\n        hgt = 0.;\n        return vec4(0.0);\n    }\n    hgt= exp(-minDist * 8.0) * (1.0 + depth * 0.1);\n    \n    vec3 color = 0.5 + 0.5 * cos(depth * 0.5 + vec3(0, 2.1, 4.2));\n    return vec4(color, 1.0);\n    \n}\n\nfloat sdTorusDisks(vec3 p, out float diskIndex) {\n    float torusRadius = 1.5;\n    float diskRadius = 0.55;\n    float diskThickness = 0.001;\n    float spacing = 0.001;\n    \n    float angle = atan(p.z, p.x);\n    \n    float nearestDiskAngle = round(angle / spacing) * spacing;\n    diskIndex = nearestDiskAngle / spacing; \n    \n    float c = cos(-nearestDiskAngle);\n    float s = sin(-nearestDiskAngle);\n    vec3 pRot;\n    pRot.x = c * p.x - s * p.z;\n    pRot.y = p.y;\n    pRot.z = s * p.x + c * p.z;\n\n    float distAlongRadius = pRot.x - torusRadius;\n    float distInDisk = length(vec2(distAlongRadius, pRot.y)) - diskRadius;\n    \n    return max(distInDisk, abs(pRot.z) - diskThickness);\n}\n\nvoid mainImage0(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy;\n    vec2 uv = (u - 0.5*R) / R.y;\n    \n    vec3 ro = vec3(3.33, 1.5, 4.5);\n    vec3 ta = vec3(0, 0, 0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = cross(uu, ww);\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 2.0*ww);\n    \n    float t = 0.0;\n    vec3 col = vec3(0.05);\n    \n    for (int i = 0; i < 200; i++) {\n        vec3 p = ro + rd * t;\n        \n        float diskIndex;\n        float d = sdTorusDisks(p, diskIndex);\n        float angle = atan(p.z, p.x);\n        ang = angle;\n        if (d < 0.001) {\n            float r = length(p.xz);\n            vec2 diskUV = vec2(r - 1.5, p.y);\n            \n            vec2 interactionPoint = vec2(\n                sin(angle+iTime*1.5) * mix(0.2, vv.y, (sin(iTime/2.3)+1.)/2.),\n                cos(angle+iTime/1.7) * mix( vv.y,0.2, (sin(iTime/2.3)+1.)/2.)\n            );\n            \n            vec4 gasket = getApollonianColor(diskUV*2.2, interactionPoint);\n            \n            if (gasket.a > 0.1) {\n                col = gasket.rgb;\n                \n                col *= 0.9 + 0.1 * sin(diskIndex * 0.001);\n                \n                // Calculate normal from fractal height map using bump mapping\n                float uvScale = 2.2;\n                float bumpStrength = 0.1;  // Increased for more visible effect\n                float epsilon = 0.0001;\n                \n                // Sample fractal height at center and neighbors\n                float heightC = hgt;\n                float heightR = getApollonianHeight((diskUV + vec2(epsilon, 0)) * uvScale, interactionPoint);\n                //float heightU = getApollonianHeight((diskUV + vec2(0, epsilon)) * uvScale, interactionPoint);\n                \n                // Calculate gradients (slopes) from height differences\n                vec2 gradient = vec2(heightR - heightC, heightR - heightC) / epsilon;\n                \n                // Base normal (radial from torus center)\n                vec3 baseNormal = normalize(vec3(p.x, 0, p.z));\n                \n                // Create tangent space basis aligned with disk surface\n                vec3 tangent = normalize(cross(baseNormal, vec3(0, 1, 0)));\n                vec3 bitangent = normalize(cross(baseNormal, tangent));\n                \n                // Perturb normal with fractal height gradients\n                vec3 n = normalize(baseNormal + bumpStrength * (gradient.x * tangent + gradient.y * bitangent));\n                \n                vec3 lightDir1 = normalize(vec3(1, 1, 1));\n                vec3 lightDir2 = normalize(vec3(2, -2, -1));\n                vec3 rimLight = normalize(vec3(1, 0, 3));\n                \n                float diff1 = max(0.0, dot(n, lightDir1));\n                float diff2 = max(0.0, dot(n, lightDir2)) * 0.4;\n                float rim = pow(1.0 - abs(dot(n, normalize(-rd))), 2.0) * 0.3;\n                \n                \n                float ao = 0.7 + heightC * 0.3;\n                \n                \n                float lighting = 0.4 + 0.3 * diff1 + 0.1 * diff2 + rim;\n                col *= lighting * ao;\n            } else {\n                t += 0.01;\n                continue;\n            }\n            break;\n        }\n        \n        t += max(d/1.5, 0.01);\n        if (t > 20.0) break;\n    }\n    \n    O = vec4(tanh(col), 1.0);\n}\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s = float(AA), k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}  ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wXXcD7",
    "date": "1759713718",
    "viewed": 1,
    "name": "Apollo-extr",
    "description": "another attempt",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "apollonian"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "\nvec2 getGridPoint(int idx, float time) {\n    int x = idx % 4;\n    int y = idx / 4;\n    \n    vec2 base = vec2(float(x), float(y)) / 3.0 - vec2(0.5);\n    float dist = length(base);\n    if(dist < 0.001) return base;\n    \n    vec2 normalized = base / dist;\n    \n    float phase = float(idx) * 0.5;\n    vec2 offset = vec2(\n        sin(time * 1.5 + phase) * 0.03,\n        cos(time * 1.7 + phase * 1.3) * 0.03\n    );\n    \n    offset += base * sin(time * 3.0 - length(base) * 10.0) * 0.02;\n    base += offset;\n    \n    float scaleFactor = abs(normalized.x) + abs(normalized.y);\n    vec2 distorted = 1.5 * base / pow(scaleFactor, 3.);\n\n    return distorted;\n}\n\nfloat sdTriangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    vec2 e0 = b - a;\n    vec2 e1 = c - b;\n    vec2 e2 = a - c;\n    \n    vec2 v0 = p - a;\n    vec2 v1 = p - b;\n    vec2 v2 = p - c;\n    \n    vec2 pq0 = v0 - e0 * clamp(dot(v0, e0) / dot(e0, e0), 0.0, 1.0);\n    vec2 pq1 = v1 - e1 * clamp(dot(v1, e1) / dot(e1, e1), 0.0, 1.0);\n    vec2 pq2 = v2 - e2 * clamp(dot(v2, e2) / dot(e2, e2), 0.0, 1.0);\n    \n    float s = sign(e0.x * e2.y - e0.y * e2.x);\n    vec2 d = min(min(vec2(dot(pq0, pq0), s * (v0.x * e0.y - v0.y * e0.x)),\n                     vec2(dot(pq1, pq1), s * (v1.x * e1.y - v1.y * e1.x))),\n                     vec2(dot(pq2, pq2), s * (v2.x * e2.y - v2.y * e2.x)));\n    \n    return -sqrt(d.x) * sign(d.y);\n}\n\nconst int N = 4;\nfloat sdPolygon(in vec2[N] v, in vec2 p) {\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for(int i=0, j=N-1; i<N; j=i, i++) {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp(dot(w,e)/dot(e,e), 0.0, 1.0);\n        d = min(d, dot(b,b));\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if(all(c) || all(not(c))) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nfloat sdQuad(vec2 p, vec2 tl, vec2 tr, vec2 br, vec2 bl) {\n    vec2[] polygon = vec2[](tl,tr,br,bl);\n    return sdPolygon(polygon, p);\n}\n\nfloat distToSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdEllipseSimple(vec2 p, vec2 center, vec2 radii, float rotation) {\n    p -= center;\n    float c = cos(rotation);\n    float s = sin(rotation);\n    p = mat2(c, s, -s, c) * p;\n    vec2 np = p / max(radii, vec2(0.001));\n    float d = length(np) - 1.0;\n    return d * min(radii.x, radii.y);\n}\n\nvec4 getIncircle(vec2 a, vec2 b, vec2 c) {\n    float la = length(b - c);\n    float lb = length(c - a);\n    float lc = length(a - b);\n    float p = la + lb + lc;\n    vec2 center = (la * a + lb * b + lc * c) / p;\n    float s = p * 0.5;\n    float area = abs((b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y)) * 0.5;\n    float radius = area / s;\n    return vec4(center, radius, 1.0);\n}\n\nvec4 fitOvalToQuad(vec2 tl, vec2 tr, vec2 bl, vec2 br) {\n    vec2 center = (tl + tr + bl + br) * 0.25;\n    float distTop = distToSegment(center, tl, tr);\n    float distRight = distToSegment(center, tr, br);\n    float distBottom = distToSegment(center, bl, br);\n    float distLeft = distToSegment(center, tl, bl);\n    float width = (distLeft + distRight) * 0.5 * 0.95;\n    float height = (distTop + distBottom) * 0.5 * 0.95;\n    vec2 horizontal = ((tr - tl) + (br - bl)) * 0.5;\n    float rotation = atan(horizontal.y, horizontal.x);\n    return vec4(width, height, rotation, 0.0);\n}\n\n// Get 2D cross-section at a specific Z position\nvec4 getCrossSection(vec2 p, float z) {\n    // Create a wave that travels along the extrusion\n    float waveSpeed = 2.0;\n    float waveOffset = iTime * waveSpeed;\n    float localTime = z * 2.0 - waveOffset;\n    \n    vec2 grid[16];\n    for(int i = 0; i < 16; i++) {\n        grid[i] = getGridPoint(i, localTime);\n    }\n    \n    float minDist = 1e10;\n    vec3 nearestColor = vec3(0.0);\n    \n    for(int row = 0; row < 3; row++) {\n        for(int col = 0; col < 3; col++) {\n            int quadIdx = row * 3 + col;\n            int tl = row * 4 + col;\n            int tr = row * 4 + col + 1;\n            int bl = (row + 1) * 4 + col;\n            int br = (row + 1) * 4 + col + 1;\n            \n            float sblend = 1.-min(length(p)*1.5, 1.);//0.4 + sin(iTime * 1.5) * 0.4;\n            bool useOval = (quadIdx == 0 || quadIdx == 4 || quadIdx == 8);\n            \n            if(useOval) {\n                float quadSdf = sdQuad(p, grid[tl], grid[bl], grid[br], grid[tr]);\n                vec2 center = (grid[tl] + grid[tr] + grid[bl] + grid[br]) * 0.25;\n                vec4 oval = fitOvalToQuad(grid[tl], grid[tr], grid[bl], grid[br]);\n                float ovalSdf = sdEllipseSimple(p, center, oval.xy, oval.z);\n                float blendedSdf = mix(ovalSdf, quadSdf, sblend);\n                \n                if(blendedSdf < minDist) {\n                    minDist = blendedSdf;\n                    nearestColor = 0.5 + 0.5 * cos(vec3(0.0, 2.0, 4.0) + float(quadIdx) * 1.5);\n                }\n            } else {\n                float tri1Sdf = sdTriangle(p, grid[tl], grid[tr], grid[bl]);\n                vec4 circ1 = getIncircle(grid[tl], grid[tr], grid[bl]);\n                float circle1Sdf = length(p - circ1.xy) - circ1.z;\n                float blend1 = mix(circle1Sdf, tri1Sdf, sblend);\n                \n                if(blend1 < minDist) {\n                    minDist = blend1;\n                    nearestColor = 0.5 + 0.5 * cos(vec3(0.0, 2.0, 4.0) + float(quadIdx * 2));\n                }\n                \n                float tri2Sdf = sdTriangle(p, grid[tr], grid[br], grid[bl]);\n                vec4 circ2 = getIncircle(grid[tr], grid[br], grid[bl]);\n                float circle2Sdf = length(p - circ2.xy) - circ2.z;\n                float blend2 = mix(circle2Sdf, tri2Sdf, sblend);\n                \n                if(blend2 < minDist) {\n                    minDist = blend2;\n                    nearestColor = 0.5 + 0.5 * cos(vec3(1.0, 3.0, 5.0) + float(quadIdx * 2 + 1));\n                }\n            }\n        }\n    }\n    \n    return vec4(nearestColor, minDist);\n}\n\n// 3D SDF - extrude along a C-shaped curve\nfloat map(vec3 p, out vec3 color) {\n    // C-shape curve in XZ plane\n    float angle = p.z * 0.8 + 1.57; // Maps Z to angle, starting at π/2\n    float radius = 1.5;\n    \n    // C-shape centered at origin, opening toward +X (camera)\n    vec2 curveCenter = vec2(-radius * 0.3, 0.0); // Shift center back\n    vec2 targetPoint = curveCenter + vec2(cos(angle), sin(angle)) * radius;\n    \n    // Transform to local cross-section space\n    vec2 localP = vec2(p.x - targetPoint.x, p.y);\n    \n    // Get the 2D cross-section SDF and color\n    vec4 crossSection = getCrossSection(localP, p.z);\n    color = crossSection.xyz;\n    \n    // Limit the C-shape to about 270 degrees\n    float minZ = -2.0;\n    float maxZ = 2.0;\n    float cappedZ = max(max(minZ - p.z, p.z - maxZ), 0.0);\n    \n    return max(crossSection.w, cappedZ);\n}\n\n// Raymarching\nvec3 raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec3 color = vec3(0.0);\n    \n    for(int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        vec3 marchColor;\n        float d = map(p, marchColor);\n        \n        if(d < 0.001) {\n            color = marchColor;\n            break;\n        }\n        \n        t += d * 0.68;\n        if(t > 30.0) break;\n    }\n    \n    return vec3(t, color.x, color.y);\n}\n\n// Calculate normal\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    vec3 dummy;\n    return normalize(vec3(\n        map(p + e.xyy, dummy) - map(p - e.xyy, dummy),\n        map(p + e.yxy, dummy) - map(p - e.yxy, dummy),\n        map(p + e.yyx, dummy) - map(p - e.yyx, dummy)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Fixed camera position\n    vec3 ro = vec3(-0.5, 1.5, 5.0);\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 f = normalize(lookAt - ro);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = cross(r, f);\n    \n    vec3 rd = normalize(f + uv.x * r + uv.y * u);\n    \n    // Raymarch\n    vec3 result = raymarch(ro, rd);\n    float t = result.x;\n    \n    vec3 color = vec3(0.05, 0.05, 0.1);\n    \n    if(t < 20.0) {\n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal(p);\n        vec3 objColor;\n        map(p, objColor);\n        \n        // Lighting\n        vec3 lightPos = vec3(3.0, 4.0, 2.0);\n        vec3 l = normalize(lightPos - p);\n        float diff = max(dot(n, l), 0.0);\n        float spec = pow(max(dot(reflect(-l, n), -rd), 0.0), 32.0);\n        \n        color = objColor * (0.3 + 0.7 * diff) + vec3(0.5) * spec;\n        \n        // Fog\n        color = mix(color, vec3(0.05, 0.05, 0.1), 1.0 - exp(-t * 0.1));\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wXXyzB",
    "date": "1759783882",
    "viewed": 1,
    "name": "line square intersection.",
    "description": "calculate line square intersection area, uses samples",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "geometry",
     "claude"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Line strip with width intersecting unit square\n// Mouse controls line position and angle\n\nfloat sdLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat getIntersectionArea(vec2 linePoint, vec2 lineDir, float halfWidth) {\n    // Calculate intersection area between strip and unit square\n    // This is simplified - doing proper clipping in a shader is complex\n    // So we'll sample the area instead\n    \n    float area = 0.0;\n    const int SAMPLES = 100;\n    float step = 1.0 / float(SAMPLES);\n    \n    for(int i = 0; i < SAMPLES; i++) {\n        for(int j = 0; j < SAMPLES; j++) {\n            vec2 samplePoint = vec2(float(i) * step, float(j) * step);\n            \n                // Check if point is in strip\n                // Distance from point to line\n                vec2 lineNormal = vec2(-lineDir.y, lineDir.x);\n                float dist = abs(dot(samplePoint - linePoint, lineNormal));\n                \n                if(dist <= halfWidth) {\n                    area += step * step;\n                }\n        }\n    }\n    \n    return area;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 coord = (uv - 0.5) * aspect * 2.5;\n    \n    // Mouse position\n    vec2 mouse = (iMouse.xy / iResolution.xy - 0.5) * aspect * 2.5;\n    if(iMouse.z < 0.5) mouse = vec2(0.0);\n    \n    // Line parameters\n    float angle = iTime * 0.5;\n    vec2 lineDir = vec2(cos(angle), sin(angle));\n    vec2 linePoint = mouse;\n    float lineWidth = 0.7;\n    float halfWidth = lineWidth * 0.5;\n    \n\n    \n    // Render\n    vec3 col = vec3(0.1);\n    \n    // Draw unit square\n    vec2 squarePos = coord + vec2(0.5, 0.5);\n    if(squarePos.x >= 0.0 && squarePos.x <= 1.0 && \n       squarePos.y >= 0.0 && squarePos.y <= 1.0) {\n        col = vec3(0.3, 0.3, 0.4);\n    }\n    \n    // Draw line strip\n    vec2 lineNormal = vec2(-lineDir.y, lineDir.x);\n    float distToLine = abs(dot(coord - linePoint, lineNormal));\n    \n    if(distToLine <= halfWidth) {\n        if(squarePos.x >= 0.0 && squarePos.x <= 1.0 && \n           squarePos.y >= 0.0 && squarePos.y <= 1.0) {\n            col = vec3(0.8, 0.4, 0.4);\n        } else {\n            col = vec3(0.5, 0.5, 0.6);\n        }\n    }\n    \n    //UI\n    vec2 barPos = vec2(10., iResolution.y - 50.0);\n    vec2 barSize = vec2(iResolution.x - 20., 40.0);\n    \n    if(fragCoord.x > barPos.x && fragCoord.x < barPos.x + barSize.x &&\n       fragCoord.y > barPos.y && fragCoord.y < barPos.y + barSize.y) {\n        col = vec3(0.5);\n        // Calculate intersection area\n        float area = getIntersectionArea(linePoint + vec2(0.5), lineDir, halfWidth);\n        float fillWidth = barSize.x * area;\n        if(fragCoord.x < barPos.x + fillWidth) {\n            col = vec3(0.0, 0.3, 0);\n        }\n    }\n    fragColor = vec4(col, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WXlyzB",
    "date": "1759804621",
    "viewed": 54,
    "name": "Cymatics V1",
    "description": "Click on slider to switch to interactive mode.",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "waves",
     "frequency",
     "cymatics",
     "vibration"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "void mainImage(out vec4 color, in vec2 fragCoord)\n{\n    // Read slider values from Buffer A\n    vec3 sliderValues = vec3(\n        texelFetch(iChannel0, ivec2(0, 0), 0).r,\n        texelFetch(iChannel0, ivec2(1, 0), 0).r,\n        texelFetch(iChannel0, ivec2(2, 0), 0).r\n    );\n    \n    // Center the coordinates\n    vec2 uv = fragCoord - iResolution.xy * 0.5;\n    uv *= 35./iResolution.y;\n    // Interactive parameters from sliders\n    float waveSpacing = 1.5 + sliderValues.x * 20.0;\n    float centralFreq = 0.1 + sliderValues.y * 20.0;\n    float outerFreq = 0.7 + sliderValues.z * 2.0; \n    // Track waves separately for coloring\n    float centerWave = sin(length(uv) * centralFreq);\n    float topWave = sin(length(uv + vec2(0.0, waveSpacing)) * outerFreq);\n    float bottomWave = sin(length(uv + vec2(0.0, -waveSpacing)) * outerFreq);\n    float leftWave = sin(length(uv + vec2(-waveSpacing, 0.0)) * outerFreq);\n    float rightWave = sin(length(uv + vec2(waveSpacing, 0.0)) * outerFreq);\n    // Group waves by axis\n    float verticalWaves = topWave + bottomWave;\n    float horizontalWaves = leftWave + rightWave; \n    // Total interference pattern\n    float totalWaves = centerWave + topWave + bottomWave + leftWave + rightWave;\n    totalWaves = totalWaves * 0.2 + 0.5; \n    vec3 waveColor = vec3(\n        0.5 + 0.5 * horizontalWaves / 2.0,\n        0.5 + 0.5 * verticalWaves / 2.0,\n        0.5 + 0.5 * centerWave\n    );\n    vec3 finalColor = mix(vec3(0.0), waveColor, smoothstep(0.3, 0.7, totalWaves));\n    // Soft circular vignette\n    float dist = length(uv);\n    float circleMask = 1.0 - smoothstep(15.0, 16.5, dist);\n    finalColor *= circleMask;\n    // Draw sliders on top\n    vec2 sliderPos = vec2(iResolution.x - 90.0, 10.0);\n    float sliderWidth = 15.0;\n    float sliderHeight = 120.0;\n    float sliderSpacing = 30.0;\n    \n    for (int i = 0; i < 3; i++) {\n        vec2 thisSliderPos = sliderPos + vec2(float(i) * sliderSpacing, 0.0);\n        // Slider background\n        if (fragCoord.x > thisSliderPos.x && fragCoord.x < thisSliderPos.x + sliderWidth &&\n            fragCoord.y > thisSliderPos.y && fragCoord.y < thisSliderPos.y + sliderHeight) {\n            finalColor = vec3(0.15); \n            // Slider fill\n            if (fragCoord.y < thisSliderPos.y + sliderValues[i] * sliderHeight) {\n                finalColor = vec3(0.6, 0.6, 0.7); \n            }\n        }\n        // Slider outline\n        if (fragCoord.x > thisSliderPos.x - 1.0 && fragCoord.x < thisSliderPos.x + sliderWidth + 1.0 &&\n            fragCoord.y > thisSliderPos.y - 1.0 && fragCoord.y < thisSliderPos.y + sliderHeight + 1.0 &&\n            (fragCoord.x < thisSliderPos.x || fragCoord.x > thisSliderPos.x + sliderWidth ||\n             fragCoord.y < thisSliderPos.y || fragCoord.y > thisSliderPos.y + sliderHeight)) {\n            finalColor = vec3(0.4);\n        }\n    }\n    color = vec4(finalColor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 color, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Slider configuration\n    vec2 sliderPos = vec2(iResolution.x - 90.0, 10.0);\n    float sliderWidth = 25.0;  // Bigger click area\n    float sliderHeight = 120.0;\n    float sliderSpacing = 30.0;\n    \n    // Read previous state\n    vec3 sliderValues = vec3(\n        texelFetch(iChannel0, ivec2(0, 0), 0).r,\n        texelFetch(iChannel0, ivec2(1, 0), 0).r,\n        texelFetch(iChannel0, ivec2(2, 0), 0).r\n    );\n    float hasInteracted = texelFetch(iChannel0, ivec2(3, 0), 0).r;\n    \n    if (iFrame < 1) {\n        sliderValues = vec3(0.5, 0.5, 0.5);\n        hasInteracted = 0.0;\n    }\n    \n    if (hasInteracted < 0.5) {\n        sliderValues.x = 0.5 + 0.5 * sin(iTime * 0.7); \n        sliderValues.y = 0.5 + 0.5 * sin(iTime * 1.3); \n        sliderValues.z = 0.5 + 0.5 * sin(iTime * 2.1);  \n    }\n    \n    if (iMouse.z > 0.0) {\n        vec2 mouse = iMouse.xy;\n        \n        for (int i = 0; i < 3; i++) {\n            vec2 thisSliderPos = sliderPos + vec2(float(i) * sliderSpacing, 0.0);\n            \n            if (mouse.x > thisSliderPos.x && mouse.x < thisSliderPos.x + sliderWidth &&\n                mouse.y > thisSliderPos.y && mouse.y < thisSliderPos.y + sliderHeight) {\n                \n                float newValue = clamp((mouse.y - thisSliderPos.y) / sliderHeight, 0.0, 1.0);\n                sliderValues[i] = newValue;\n                hasInteracted = 1.0; \n            }\n        }\n    }\n    \n    // Store values in first 4 pixels\n    if (fragCoord.y < 1.0) {\n        if (fragCoord.x < 1.0) color = vec4(sliderValues.x, 0, 0, 1);\n        else if (fragCoord.x < 2.0) color = vec4(sliderValues.y, 0, 0, 1);\n        else if (fragCoord.x < 3.0) color = vec4(sliderValues.z, 0, 0, 1);\n        else if (fragCoord.x < 4.0) color = vec4(hasInteracted, 0, 0, 1);\n        else color = vec4(0);\n    } else {\n        color = vec4(0);\n    }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tXsyRS",
    "date": "1759804644",
    "viewed": 82,
    "name": "Extruded Cymatic",
    "description": "Something a bit different.",
    "likes": 11,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "cymatic",
     "extruded"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Cymatics V1\" by Cotterzz. https://shadertoy.com/view/WXlyzB\n// Fork of \"Extruded Apollonian fractal\" by Cotterzz. https://shadertoy.com/view/wXfyWH\n// Fork of \"Colourful Apollonian III - short\" by FabriceNeyret2. https://shadertoy.com/view/cl3GDl\n//     and \"Colourful Apollonian III\"         by mla.            https://shadertoy.com/view/wdsfWX\n\nfloat ang;\nvec4 getCymaticColor(vec2 uv, vec3 inpt){\n    uv *= 0.1; // Scale down for better view\n    if (length(uv) > 16.) {return vec4(0);};\n    // Interactive parameters\n    float waveSpacing = inpt.x;  // Distance of outer sources\n    float centralFreq = inpt.y;  // Central wave frequency\n    float outerFreq = inpt.z;                      // Animated outer frequency    \n    \n    // Track waves separately for coloring\n    float centerWave = sin(length(uv) * centralFreq);\n    \n    float topWave = sin(length(uv + vec2(0.0, waveSpacing)) * outerFreq);\n    float bottomWave = sin(length(uv + vec2(0.0, -waveSpacing)) * outerFreq);\n    float leftWave = sin(length(uv + vec2(-waveSpacing, 0.0)) * outerFreq);\n    float rightWave = sin(length(uv + vec2(waveSpacing, 0.0)) * outerFreq);\n    \n    // Group waves by axis\n    float verticalWaves = topWave + bottomWave;\n    float horizontalWaves = leftWave + rightWave;\n    \n    // Total interference pattern\n    float totalWaves = centerWave + topWave + bottomWave + leftWave + rightWave;\n    totalWaves = pow(totalWaves, .1)*2.;\n    //totalWaves = totalWaves * 0.2 + 0.5;\n   \n    \n    // Option 2: Color by dominant direction\nvec3 waveColor = vec3(\n    0.5 + 0.5 * horizontalWaves / 2.0,  // Red: horizontal\n    0.5 + 0.5 * verticalWaves / 2.0,    // Green: vertical\n    0.5 + 0.5 * centerWave              // Blue: center\n);\n\n    \n    // Mix between black and colored based on total wave intensity\n    // This keeps the dark interference patterns black\n   vec3 finalColor = waveColor;//mix(vec3(0.0), waveColor, smoothstep(0.5, 0.6, totalWaves));\n    //vec3 finalColor = mix(vec3(0.0), waveColor, smoothstep(0.3, 0.7, totalWaves));\n     //vec3 finalColor = mix(vec3(0.0), waveColor, totalWaves);\n     \n    if (totalWaves < 0.01 || (ang>0.0&&ang<1.6)) {\n        return vec4(0.0);\n    }\n    \n    return vec4(finalColor, totalWaves);\n\n}\n\n\n\nfloat sdTorusDisks(vec3 p, out float diskIndex) {\n    float torusRadius = 1.5;\n    float diskRadius = 0.55;\n    float diskThickness = 0.0005;\n    float spacing = 0.0005;\n    \n    float angle = atan(p.z, p.x);\n    \n    float nearestDiskAngle = round(angle / spacing) * spacing;\n    diskIndex = nearestDiskAngle / spacing; \n    \n    float c = cos(-nearestDiskAngle);\n    float s = sin(-nearestDiskAngle);\n    vec3 pRot;\n    pRot.x = c * p.x - s * p.z;\n    pRot.y = p.y;\n    pRot.z = s * p.x + c * p.z;\n\n    float distAlongRadius = pRot.x - torusRadius;\n    float distInDisk = length(vec2(distAlongRadius, pRot.y)) - diskRadius;\n    \n    return max(distInDisk, abs(pRot.z) - diskThickness);\n}\n\nvoid mainImage0(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy;\n    vec2 uv = (u - 0.5*R) / R.y;\n    \n    vec3 ro = vec3(-3.6, 1.0, -3.6);\n    vec3 ta = vec3(0, 0, 0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = cross(uu, ww);\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 2.0*ww);\n    \n    float t = 0.0;\n    vec3 col = vec3(0.05);\n    \n    for (int i = 0; i < 220; i++) {\n        vec3 p = ro + rd * t;\n        \n        float diskIndex;\n        float d = sdTorusDisks(p, diskIndex);\n        float angle = 3.1416+atan(p.z, p.x);\n        ang = angle;\n        if (d < 0.01) {\n            float r = length(p.xz);\n            vec2 diskUV = vec2(r - 1.5, p.y);\n            \n                // Interactive parameters\n\n            \n            vec3 interactionPoint = vec3(\n    1.5 + (sin((angle+iTime)/2.1)+1.) * 10.0,  // Distance of outer sources\n     0.01 + (sin((angle+iTime)/3.1)+1.) * 5.0,  // Central wave frequency\n   1.3 + (sin((angle+iTime)/4.1)+1.) * 0.6      // Animated outer frequency  \n                \n            );\n            \n            vec4 gasket = getCymaticColor(diskUV*220., interactionPoint);\n            \n            if (gasket.a > 0.8) {\n                col = (col + gasket.rgb * gasket.a)/2.;\n                \n   \n            } else if (gasket.a > 0.01) {\n                col = (col + gasket.rgb * gasket.a)/2.;\n                \n\n                t += 0.01;\n                continue;\n            } else {\n                t += 0.01;\n                continue;\n            }\n            break;\n        }\n        \n        t += max(d, 0.001);\n        if (t > 20.0) break;\n    }\n    col=tanh(col);\n    O = vec4(col, 1.0);\n}\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s =2., k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}  ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "t3fyzj",
    "date": "1759848749",
    "viewed": 78,
    "name": "Cymatics V2 - w/Audio",
    "description": "so... audio vis seems like the best use for this...\nClick on slider to switch to interactive mode.\nSliders: wave speed, reflection strength, visual gain and time smoothing",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "waves",
     "audio",
     "visualisation",
     "frequency",
     "cymatics",
     "vibration",
     "chaldni",
     "faradaywaves"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "// IF AUDIO DOESNT PLAY CLICK ON BUFFER A UP HERE ^^\n// AND THEN HIT PLAY/PAUSE ON ICHANNEL1 BELOW vv\n\n\n// Fork of \"Cymatics V1\" by Cotterzz. https://shadertoy.com/view/WXlyzB\n\nfloat getAudioSample(sampler2D buffer, float sampleOffset, vec2 resolution) {\n    int totalOffset = int(sampleOffset) % 512;  // Wrap around 512 samples\n    int row = 1 + (totalOffset / int(resolution.x));\n    int col = totalOffset % int(resolution.x);\n    \n    if (row <= 8 && col < int(resolution.x)) {\n        return texelFetch(buffer, ivec2(col, row), 0).r * 2.0 - 1.0;  \n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 color, in vec2 fragCoord)\n{\n    // Read slider values from Buffer A\n    vec4 sliderValues = vec4(\n        texelFetch(iChannel0, ivec2(0, 0), 0).r,\n        texelFetch(iChannel0, ivec2(1, 0), 0).r,\n        texelFetch(iChannel0, ivec2(2, 0), 0).r,\n        texelFetch(iChannel0, ivec2(3, 0), 0).r\n    );\n    \n    // Center the coordinates\n    vec2 uv = fragCoord - iResolution.xy * 0.5;\n    uv *= 35./iResolution.y;\n    \n    // Interactive parameters from sliders\n    float waveSpeed = 5.0 + sliderValues.x * 20.0;        // Wave propagation speed\n    float reflectionStrength = sliderValues.y;            // Reflection intensity\n    float visualGain = 1.0 + sliderValues.z * 4.0;       // Visualization sensitivity\n    \n    // Define virtual sound sources\n    vec2 source1 = vec2(0.0, 0.0);      // Center\n    vec2 source2 = vec2(-12.0, 0.0);    // Left\n    vec2 source3 = vec2(12.0, 0.0);     // Right\n    vec2 source4 = vec2(0.0, -12.0);    // Bottom\n    vec2 source5 = vec2(0.0, 12.0);     // Top\n    \n    // Calculate sample delay based on distance (in sample units)\n    // Assuming ~60fps and 44100Hz audio, each frame has ~735 samples\n    // But we only get 512, so scale accordingly\n    float sampleRate = 512.0; // samples per frame\n    \n    float delay1 = length(uv - source1) * waveSpeed;\n    float delay2 = length(uv - source2) * waveSpeed;\n    float delay3 = length(uv - source3) * waveSpeed;\n    float delay4 = length(uv - source4) * waveSpeed;\n    float delay5 = length(uv - source5) * waveSpeed;\n    \n    // Get audio samples at each delay\n    float wave1 = getAudioSample(iChannel0, delay1, iResolution.xy);\n    float wave2 = getAudioSample(iChannel0, delay2, iResolution.xy) * reflectionStrength * 0.8;\n    float wave3 = getAudioSample(iChannel0, delay3, iResolution.xy) * reflectionStrength * 0.8;\n    float wave4 = getAudioSample(iChannel0, delay4, iResolution.xy) * reflectionStrength * 0.7;\n    float wave5 = getAudioSample(iChannel0, delay5, iResolution.xy) * reflectionStrength * 0.7;\n    \n    // Create interference pattern\n    float totalWaves = (wave1 + wave2 + wave3 + wave4 + wave5) * visualGain;\n    \n    // Add some continuous wave effect based on accumulated phase\n    float phase = totalWaves * 10.0 + iTime * 2.0;\n    float continuousWave = sin(length(uv) * 0.5 + phase);\n    \n    // Mix direct audio with continuous visualization\n    totalWaves = totalWaves * 0.7 + continuousWave * 0.3 * abs(totalWaves);\n    \n    // Create color based on wave components\n    vec3 waveColor = vec3(\n        0.5 + 0.3 * (wave2 + wave3),  // Horizontal (red channel)\n        0.5 + 0.3 * (wave4 + wave5),  // Vertical (green channel)\n        0.5 + 0.5 * wave1              // Center (blue channel)\n    );\n    \n    // Apply wave intensity\n    float intensity = 0.5 + 0.5 * tanh(totalWaves);\n    vec3 finalColor = waveColor * intensity;\n    \n    // Add contour lines for cymatic pattern emphasis\n    float contourLines = abs(fract(totalWaves * 3.0 + 0.5) - 0.5);\n    finalColor *= 0.6 + 0.4 * smoothstep(0.1, 0.2, contourLines);\n    \n    // Circular boundary\n    float dist = length(uv);\n    float circleMask = 1.0 - smoothstep(15.0, 16.5, dist);\n    finalColor *= circleMask;\n    \n    // Draw sliders\n    vec2 sliderPos = vec2(iResolution.x -120.0, 10.0);\n    float sliderWidth = 15.0;\n    float sliderHeight = 120.0;\n    float sliderSpacing = 30.0;\n    \n    for (int i = 0; i < 4; i++) {\n        vec2 thisSliderPos = sliderPos + vec2(float(i) * sliderSpacing, 0.0);\n        \n        if (fragCoord.x > thisSliderPos.x && fragCoord.x < thisSliderPos.x + sliderWidth &&\n            fragCoord.y > thisSliderPos.y && fragCoord.y < thisSliderPos.y + sliderHeight) {\n            finalColor = vec3(0.15);\n            \n            if (fragCoord.y < thisSliderPos.y + sliderValues[i] * sliderHeight) {\n                finalColor = vec3(0.6, 0.6, 0.7);\n            }\n        }\n        \n        if (fragCoord.x > thisSliderPos.x - 1.0 && fragCoord.x < thisSliderPos.x + sliderWidth + 1.0 &&\n            fragCoord.y > thisSliderPos.y - 1.0 && fragCoord.y < thisSliderPos.y + sliderHeight + 1.0 &&\n            (fragCoord.x < thisSliderPos.x || fragCoord.x > thisSliderPos.x + sliderWidth ||\n             fragCoord.y < thisSliderPos.y || fragCoord.y > thisSliderPos.y + sliderHeight)) {\n            finalColor = vec3(0.4);\n        }\n    }\n    //finalColor *=2.;\n    finalColor = tanh(pow(finalColor*1.8, vec3(1.8)));\n    \n    \n    //color = texture(iChannel0, fragCoord.xy/iResolution.xy, 0.);//vec4(finalColor, 1.0);\n    color = vec4(finalColor, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4df3Rn",
       "filepath": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3",
       "type": "music",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// IF AUDIO DOESNT PLAY CLICK ON BUFFER A UP HERE ^^\n// AND THEN HIT PLAY/PAUSE ON ICHANNEL1 BELOW vv\n\n\n\nvoid mainImage(out vec4 color, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Slider configuration\n    vec2 sliderPos = vec2(iResolution.x - 120.0, 10.0);\n    float sliderWidth = 25.0;\n    float sliderHeight = 120.0;\n    float sliderSpacing = 30.0;\n    \n    // Read previous state from row 0\n    vec4 sliderValues = vec4(\n        texelFetch(iChannel0, ivec2(0, 0), 0).r,\n        texelFetch(iChannel0, ivec2(1, 0), 0).r,\n        texelFetch(iChannel0, ivec2(2, 0), 0).r,\n        texelFetch(iChannel0, ivec2(3, 0), 0).r\n    );\n    float hasInteracted = texelFetch(iChannel0, ivec2(4, 0), 0).r;\n    \n    if (iFrame < 1) {\n        sliderValues = vec4(0.5);\n        hasInteracted = 0.0;\n    }\n    \n    if (hasInteracted < 0.5) {\n        sliderValues.x = 0.5 + 0.3 * sin(iTime / 3.7); \n        sliderValues.y = 0.5 + 0.3 * sin(iTime / 4.3); \n        sliderValues.z = 0.5 + 0.3 * sin(iTime / 2.1);  \n        sliderValues.w = 0.5 + 0.3 * sin(iTime / 2.1); \n    }\n    float v4 = pow(sliderValues.w, 3.);\n    float s4 = 15.;\n    \n    if (iMouse.z > 0.0) {\n        vec2 mouse = iMouse.xy;\n        \n        for (int i = 0; i < 4; i++) {\n            vec2 thisSliderPos = sliderPos + vec2(float(i) * sliderSpacing, 0.0);\n            \n            if (mouse.x > thisSliderPos.x && mouse.x < thisSliderPos.x + sliderWidth &&\n                mouse.y > thisSliderPos.y && mouse.y < thisSliderPos.y + sliderHeight) {\n                \n                float newValue = clamp((mouse.y - thisSliderPos.y) / sliderHeight, 0.0, 1.0);\n                sliderValues[i] = newValue;\n                hasInteracted = 1.0; \n            }\n        }\n    }\n    \n    ivec2 coord = ivec2(fragCoord);\n    \n    if (coord.y == 0) {\n        // Row 0: Store slider values\n        if (coord.x == 0) color = vec4(sliderValues.x, 0, 0, 1);\n        else if (coord.x == 1) color = vec4(sliderValues.y, 0, 0, 1);\n        else if (coord.x == 2) color = vec4(sliderValues.z, 0, 0, 1);\n        else if (coord.x == 3) color = vec4(sliderValues.w, 0, 0, 1);\n        else if (coord.x == 4) color = vec4(hasInteracted, 0, 0, 1);\n        else color = vec4(0);\n    }\n    else if (coord.y >= 1 ) { // incresa to 20 just in case we need it.\n        // Rows 1-8: Store current frame's 512 audio samples\n        // Map pixel position to audio sample index\n        int row = coord.y - 1;  // 0-7\n        int sampleIndex = row * int(iResolution.x) + coord.x;\n        \n        if (sampleIndex < 512) {\n            // Store current frame's audio sample\n            float audioSample = texture(iChannel1, vec2(float(sampleIndex) / 512.0, 1.0)).r;\n            audioSample = pow(audioSample*1.2, 1.2);\n            color = (vec4(audioSample, audioSample, audioSample, 1.0) + texelFetch(iChannel0, ivec2(coord.x, coord.y + 1), 0)*(v4 * s4))/((v4 * s4)+1.);\n        } else {\n            // Beyond 512 samples, store previous frame's data for rolling history\n            // Shift data from row above (previous frame position)\n            if (coord.y > 1) {\n                color = texelFetch(iChannel0, ivec2(coord.x, coord.y - 1), 0);\n            } else {\n                color = vec4(0);\n            }\n        }\n    }\n    else {\n        color = vec4(0);\n    }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WXlyRj",
    "date": "0",
    "viewed": 0,
    "name": "Extruded Cymatic Audio",
    "description": "Something a bit different.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "cymatic",
     "extruded"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Extruded Cymatic\" by Cotterzz. https://shadertoy.com/view/tXsyRS\n// 2025-10-07 17:04:21\n\n// Fork of \"Cymatics V1\" by Cotterzz. https://shadertoy.com/view/WXlyzB\n// Fork of \"Extruded Apollonian fractal\" by Cotterzz. https://shadertoy.com/view/wXfyWH\n// Fork of \"Colourful Apollonian III - short\" by FabriceNeyret2. https://shadertoy.com/view/cl3GDl\n//     and \"Colourful Apollonian III\"         by mla.            https://shadertoy.com/view/wdsfWX\nfloat getAudioSample(sampler2D buffer, float sampleOffset, vec2 resolution) {\n    int totalOffset = int(sampleOffset) % 512;  // Wrap around 512 samples\n    int row = 1 + (totalOffset / int(resolution.x));\n    int col = totalOffset % int(resolution.x);\n    \n    if (row <= 8 && col < int(resolution.x)) {\n        return texelFetch(buffer, ivec2(col, row), 0).r * 2.0 - 1.0;  \n    }\n    return 0.0;\n}\nfloat ang;\nvec4 getCymaticColor(vec2 uv, float delay){\n   uv *= 0.1; // Scale down for better view\n    if (length(uv) > 16.) {return vec4(0);};\n\n        // Interactive parameters from sliders\n    float waveSpeed =  5.;       // Wave propagation speed\n    \n    waveSpeed += delay;\n    float reflectionStrength = 0.5;           // Reflection intensity\n    float visualGain  =5.5;        // Visualization sensitivity\n    // Define virtual sound sources\n    vec2 source1 = vec2(0.0, 0.0);      // Center\n    vec2 source2 = vec2(-12.0, 0.0);    // Left\n    vec2 source3 = vec2(12.0, 0.0);     // Right\n    vec2 source4 = vec2(0.0, -12.0);    // Bottom\n    vec2 source5 = vec2(0.0, 12.0);     // Top\n    \n    // Calculate sample delay based on distance (in sample units)\n    // Assuming ~60fps and 44100Hz audio, each frame has ~735 samples\n    // But we only get 512, so scale accordingly\n    float sampleRate = 512.0; // samples per frame\n    \n    float delay1 = length(uv - source1) * waveSpeed;\n    float delay2 = length(uv - source2) * waveSpeed;\n    float delay3 = length(uv - source3) * waveSpeed;\n    float delay4 = length(uv - source4) * waveSpeed;\n    float delay5 = length(uv - source5) * waveSpeed;\n    \n    // Get audio samples at each delay\n    float wave1 = getAudioSample(iChannel0, delay1, iResolution.xy);\n    float wave2 = getAudioSample(iChannel0, delay2, iResolution.xy) * reflectionStrength * 0.8;\n    float wave3 = getAudioSample(iChannel0, delay3, iResolution.xy) * reflectionStrength * 0.8;\n    float wave4 = getAudioSample(iChannel0, delay4, iResolution.xy) * reflectionStrength * 0.7;\n    float wave5 = getAudioSample(iChannel0, delay5, iResolution.xy) * reflectionStrength * 0.7;\n    \n    // Create interference pattern\n    float totalWaves = (wave1 + wave2 + wave3 + wave4 + wave5) * visualGain;\n    \n    // Add some continuous wave effect based on accumulated phase\n    float phase = totalWaves * 10.0 + iTime * 2.0;\n    float continuousWave = sin(length(uv) * 0.5 + phase);\n    \n    // Mix direct audio with continuous visualization\n    totalWaves = totalWaves * 0.7 + continuousWave * 0.3 * abs(totalWaves);\n   \n    \n    // Create color based on wave components\n    vec3 waveColor = vec3(\n        0.5 + 0.3 * (wave2 + wave3),  // Horizontal (red channel)\n        0.5 + 0.3 * (wave4 + wave5),  // Vertical (green channel)\n        0.5 + 0.5 * wave1              // Center (blue channel)\n    );\n\n    \n   // Apply wave intensity\n    float intensity = 0.5 + 0.5 * tanh(totalWaves);\n    vec3 finalColor = waveColor * intensity;\n    \n    // Add contour lines for cymatic pattern emphasis\n    float contourLines = abs(fract(totalWaves * 3.0 + 0.5) - 0.5);\n    finalColor *= 0.6 + 0.4 * smoothstep(0.1, 0.2, contourLines);\n    \n    // Circular boundary\n    float dist = length(uv);\n    float circleMask = 1.0 - smoothstep(15.0, 16.5, dist);\n    finalColor *= circleMask;\n     \n    if (totalWaves < 0.01 || (ang>0.0&&ang<1.6)) {\n        return vec4(0.0);\n    }\n      //finalColor = tanh(pow(finalColor*3., vec3(1.2)));\n    \n    return vec4(finalColor, totalWaves);\n\n}\n\n\n\nfloat sdTorusDisks(vec3 p, out float diskIndex) {\n    float torusRadius = 1.5;\n    float diskRadius = 0.55;\n    float diskThickness = 0.0005;\n    float spacing = 0.0005;\n    \n    float angle = atan(p.z, p.x);\n    \n    float nearestDiskAngle = round(angle / spacing) * spacing;\n    diskIndex = nearestDiskAngle / spacing; \n    \n    float c = cos(-nearestDiskAngle);\n    float s = sin(-nearestDiskAngle);\n    vec3 pRot;\n    pRot.x = c * p.x - s * p.z;\n    pRot.y = p.y;\n    pRot.z = s * p.x + c * p.z;\n\n    float distAlongRadius = pRot.x - torusRadius;\n    float distInDisk = length(vec2(distAlongRadius, pRot.y)) - diskRadius;\n    \n    return max(distInDisk, abs(pRot.z) - diskThickness);\n}\n\nvoid mainImage0(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy;\n    vec2 uv = (u - 0.5*R) / R.y;\n    \n    vec3 ro = vec3(-2.8, 1.5, -2.2);\n    vec3 ta = vec3(3.6, -1.5, 0.2);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = cross(uu, ww);\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 2.0*ww);\n    \n    float t = 0.0;\n    vec3 col = vec3(0.05);\n    \n    for (int i = 0; i < 200; i++) {\n        vec3 p = ro + rd * t;\n        \n        float diskIndex;\n        float d = sdTorusDisks(p, diskIndex);\n        float angle = 3.1416+atan(p.z, p.x);\n        ang = angle;\n        if (d < 0.03) {\n            float r = length(p.xz);\n            vec2 diskUV = vec2(r - 1.5, p.y);\n            \n                // Interactive parameters\n\n            \n            vec3 interactionPoint = vec3(\n    1.5 + (sin((angle-iTime)/2.1)+1.) * 10.0,  // Distance of outer sources\n     0.01 + (sin((angle-iTime)/3.1)+1.) * 5.0,  // Central wave frequency\n   1.3 + (sin((angle-iTime)/4.1)+1.) * 0.6      // Animated outer frequency  \n                \n            );\n            \n            vec4 gasket = getCymaticColor(diskUV*270., 1.0+(angle-1.6)*512.);\n            \n            if (gasket.a > 0.7) {\n                col =gasket.rgb;\n               // col =vec3(abs(ang-1.6));\n   \n            } else {\n                t += 0.01;\n                continue;\n            }\n            break;\n        }\n        \n        t += max(d, 0.0001);\n        if (t > 20.0) break;\n    }\n    //col=tanh(col);\n    O = vec4(col, 1.0);\n}\nvoid mainImage(out vec4 o, vec2 u) \n{ \n    float s =3., k; \n    vec2 j = vec2(.5); \n    o = vec4(0); \n    vec4 c; \n    mainImage0(c, u); \n    for (k = s; k-- > .5; ) { \n        mainImage0(c, u + j - .5); \n        o += c; \n        j = fract(j + vec2(.755, .57).yx); \n    };o /= s;o.a==1.;\n}  ",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4df3Rn",
       "filepath": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3",
       "type": "music",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 color, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    \n    ivec2 coord = ivec2(fragCoord);\n    \n if (coord.y >= 1 ) { // incresa to 20 just in case we need it.\n        // Rows 1-8: Store current frame's 512 audio samples\n        // Map pixel position to audio sample index\n        int row = coord.y - 1;  // 0-7\n        int sampleIndex = row * int(iResolution.x) + coord.x;\n        \n        if (sampleIndex < 512) {\n            // Store current frame's audio sample\n            float audioSample = texture(iChannel1, vec2(float(sampleIndex) / 512.0, 1.0)).r;\n            color = vec4(audioSample, audioSample, audioSample, 1.0);\n        } else {\n            // Beyond 512 samples, store previous frame's data for rolling history\n            // Shift data from row above (previous frame position)\n            if (coord.y > 1) {\n                color = texelFetch(iChannel0, ivec2(coord.x, coord.y - 1), 0);\n            } else {\n                color = vec4(0);\n            }\n        }\n    }\n    else {\n        color = vec4(0);\n    }\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "w3scRf",
    "date": "1759975073",
    "viewed": 1,
    "name": "Ha ha ha. synth",
    "description": "Trying to make laughter.",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "audio",
     "synthesis",
     "dsp",
     "laughter",
     "vocoding"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "float noiseAt(float tt, float rate)\n{\n\tfloat x = tt * rate;\n\tfloat xi = floor(x);\n\tfloat xf = fract(x);\n\tfloat h0 = fract(sin(xi * 12.9898 + 78.233) * 43758.5453);\n\tfloat h1 = fract(sin((xi + 1.0) * 12.9898 + 78.233) * 43758.5453);\n\tfloat u = xf * xf * (3.0 - 2.0 * xf);\n\treturn 1.*(mix(h0, h1, u) - 0.5);\n}\n\nvec2 mainSound( int samp, float time )\n{\n\t// Breathy \"ha ha ha\" with aspirated H and vowel via formants\n\tfloat t = mod(time, 1.6); // Repeat every ~1.6 seconds\n\tfloat duration = 0.5;     // Duration of each \"ha\"\n\tfloat spacing = 0.4;     // Spacing between \"ha\"s\n\tfloat amp = 0.0;\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tfloat ti = t - float(i) * (spacing/2. + spacing/float(i+2));\n\t\tif (ti > 0.0 && ti < duration) {\n\t\t\t// H\n\t\t\tfloat hDur = 0.08; // breath length\n\t\t\tfloat hSound = 0.0;\n\t\t\tif (ti < hDur) {\n\t\t\t\t// Smooth noise then emphasize highs with a tiny temporal derivative (HP-ish)\n\t\t\t\tfloat nA= noiseAt(ti, 20000.0);\n\t\t\t\tfloat nB = noiseAt(max(ti - 0.0006, 0.0), 18000.0);\n\t\t\t\tfloat breath = (nA - nB); // high-frequency emphasis like a soft hiss\n\t\t\t\t// Light band-pass feel by mixing two nearby \"rates\" (very rough spectral shaping)\n\t\t\t\tfloat nC = noiseAt(ti, 9000.0);\n\t\t\t\tbreath = mix(breath, (breath + nC * 0.6), 0.4);\n\t\t\t\t// Envelope: soft attack, gentle decay\n\t\t\t\tfloat hEnv = smoothstep(0.0, 0.07, ti) * (1.0 - smoothstep(0.01, hDur, ti));\n\t\t\t\thSound = breath * hEnv * 0.03 ;//* float(i);\n\t\t\t}\n\n\t\t\t// ah\n\t\t\tfloat vStart = 0.04; // when voicing begins after breath\n\t\t\tfloat vSound = 0.0;\n\t\t\tif (ti > vStart) {\n\t\t\t\tfloat vt = ti - vStart;\n\t\t\t\t// Fundamental with tiny vibrato and subtle pitch bend per syllable\n\t\t\t\tfloat f0Base = 110.0; // base laugh pitch\n\t\t\t\tfloat f0Jitter = 1.5 + 0.01 * sin(6.2831 * 5.5 * vt);\n\t\t\t\tfloat f0Bend = 1.0 + 0.01 * exp(-7.0 * vt); // slight down-glide\n\t\t\t\tfloat f0 = f0Base * f0Jitter * f0Bend * (1.0 - 0.03 * pow(float(i),1.5)); // rise a bit each \"ha\"\n\n\t\t\t\t// Vowel \"a\"/\"ɑ\" approximate male formants\n\t\t\t\t// Frequencies (Hz) and bandwidths (Hz)\n\t\t\t\tfloat F1 = 800.0, BW1 = 90.0;\n\t\t\t\tfloat F2 = 1200.0, BW2 = 120.0;\n\t\t\t\tfloat F3 = 3800.0, BW3 = 200.0;\n\n\t\t\t\t// Envelope: quick attack to sustain, then decay\n\t\t\t\tfloat vEnv = smoothstep(0.0, 0.03, vt) * exp(-3. * vt);\n\n\t\t\t\t// Additive harmonic stack shaped by Gaussian formant envelopes\n\t\t\t\tfloat voiced = 0.0;\n\t\t\t\tfor (int k = 1; k <= 10; k++) {\n\t\t\t\t\tfloat hk = float(k);\n\t\t\t\t\tfloat fk = f0 * hk;\n\t\t\t\t\t// Gaussian weights around formants\n\t\t\t\t\tfloat w1 = exp(-0.5 * pow((fk - F1) / BW1, 2.0));\n\t\t\t\t\tfloat w2 = exp(-0.5 * pow((fk - F2) / BW2, 2.0));\n\t\t\t\t\tfloat w3 = exp(-0.5 * pow((fk - F3) / BW3, 2.0));\n\t\t\t\t\tfloat w = (w1 * 0.9 + w2 * 0.9 + w3 * 0.4);\n\t\t\t\t\tvoiced += sin(6.2831 * fk * vt) * w;\n\t\t\t\t}\n\t\t\t\t// Normalize and apply envelope\n\t\t\t\tvSound = voiced * (1.0 / 12.0) * vEnv * 0.8;\n\n\t\t\t\t// Subtle breath mixed into vowel for naturalness\n\t\t\t\tfloat nV = noiseAt(vt, 16000.0) - noiseAt(max(vt - 0.0006, 0.0), 16000.0);\n\t\t\t\tvSound += nV * 0.06 * vEnv;\n\t\t\t}\n\n\t\t\tamp += vSound+hSound;\n\t\t}\n\t}\n\n\tamp = clamp(amp, -1.0, 1.0) * 0.8;\n\treturn vec2(amp);\n}",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WXXcRl",
    "date": "1759992665",
    "viewed": 26,
    "name": "Audio from Image",
    "description": "Turns image to audio as if it were a frequency-time graph in reverse.",
    "likes": 4,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "fft",
     "audio",
     "synthesis",
     "dsp",
     "spectrograph"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// I wanted to make a shadertoy version of this very old webaudio experiment: https://www.johnc.pro/spectrogram/\n// (You can draw and play the sound of your drawing using additive synthesis, turning the spectrograph back into sound.)\n// But this is not possible on shadertoy because the buffers aren't connected, so sound isnt interactive.\n\n// However, next best thing is a way to play any predefined drawing.\n// Replace drawFunction in common and both the image and sound tabs will display and play it!\n// Try the three modes to see examples\n// You can create sound using SDFs or anything that returns meaningful values in the 0-1 range.\n// You can even use the passed time data to change the output over time.\n// Frequency range is logarithminc so musical notes are the same distance apart.\n// Sound fidelity has it's limits, this is just a toy really.\n// I'm sure it can be improved a lot, my DSP knowledge is rudimentary. Open to ideas.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = drawFunction(uv, iTime);\n    float scanX = mod(iTime, DURATION) / DURATION;\n    float scanLine = step(0.995, 1.-abs(uv.x - scanX));\n    col = mix(col, vec3(1.0, 0.0, 0.0), scanLine);  \n    fragColor = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec2 mainSound( int samp, float time )\n{\n    vec3 t = vec3(float(samp-1) / SAMPLE_RATE , float(samp) / SAMPLE_RATE , float(samp+1) / SAMPLE_RATE );\n    vec3 x = mod(t, DURATION) / DURATION;\n    \n    float sampl = 0.0;\n    \n    // Sample vertically across frequencies\n    for (int row = 0; row < NUM_SAMPLES; row++) {\n        float y = float(row) / float(NUM_SAMPLES);\n        \n        // Sample at exact x position (no need to interpolate between columns)\n        vec3 pixel = vec3(drawFunction(vec2(x.x, y), t.x).r ,  drawFunction(vec2(x.y, y), t.y).r , drawFunction(vec2(x.z, y), t.z).r ) ; \n        pixel = clamp(pixel, 0., 1.);\n        \n        vec3 brightness = 1.0 - pixel;\n\n        float freq = frequencyFromY(y);\n        \n        vec3 triple = brightness * sin(TWO_PI * freq * fract(t));\n        \n        if(triple.x == 0. && abs(triple.y)>0.4) { triple.y /=4.; }\n        \n        if(triple.z == 0. && abs(triple.y)>0.4) { triple.y /=4.; }\n        \n        sampl += triple.y;\n        \n    }\n    \n    // Soft clip using tanh - compresses loudness gracefully\n    sampl= tanh(sampl * 0.5);\n    \n    return vec2(sampl);\n}",
     "name": "Sound",
     "description": "",
     "type": "sound"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// 0 - custom\n// 1 - musical notes\n// 2 - wavy lines\n// 3 - animated noise long compile time\n\n#define MODE 1\n\nconst float DURATION = 6.0;\nconst float SAMPLE_RATE = 44100.0;\nconst float MIN_FREQ = 16.0;\nconst float MAX_FREQ = 16000.0;\nconst int NUM_SAMPLES = 240;\nconst float TWO_PI = 6.283185307;\nfloat frequencyFromY(float y) {return floor(MIN_FREQ * pow(2.0, y * log(MAX_FREQ / MIN_FREQ) / log(2.0)));}\nfloat freqToY(float freq) {return log(freq / MIN_FREQ) / log(MAX_FREQ / MIN_FREQ);}\n\n#if MODE == 0\n\nvec3 drawFunction(vec2 uv, float t) { //use this function to draw whatever you like\n\n    vec3 col = vec3(1);\n    return col;\n}\n\n#endif\n\n#if MODE == 1\nfloat noteToFreq(int noteIndex) {\n    // F# F# D B E  G# G# A B A A D F#  F#  E E F# E\n    if (noteIndex == 0) return 369.99;  // F#4\n    if (noteIndex == 1) return 369.99;  // F#4\n    if (noteIndex == 2) return 293.66;  // D4\n    if (noteIndex == 3) return 246.94;  // B3 (low)\n    if (noteIndex == 4) return 329.63;  // E4\n    if (noteIndex == 5) return 415.30;  // G#4\n    if (noteIndex == 6) return 415.30;  // G#4\n    if (noteIndex == 7) return 440.00;  // A4\n    if (noteIndex == 8) return 493.88;  // B4 (high)\n    if (noteIndex == 9) return 440.00;  // A4\n    if (noteIndex == 10) return 440.00; // A4\n    if (noteIndex == 11) return 293.66; // D4\n    if (noteIndex == 12) return 369.99; // F#4\n    if (noteIndex == 13) return 369.99; // F#4\n    if (noteIndex == 14) return 329.63; // E4\n    if (noteIndex == 15) return 329.63; // E4\n    if (noteIndex == 16) return 369.99; // F#4\n    return 329.63; // E4\n}\n\nvec3 testFunction(vec2 uv) {  //take on me.\n    vec3 col = vec3(1.0);\n    int numNotes = 18;\n    float noteDuration = 1.0 / float(numNotes);\n    int noteIndex = int(uv.x / noteDuration) % numNotes;\n    float freq = noteToFreq(noteIndex);\n    float y = freqToY(freq);\n    float notePos = fract(uv.x / noteDuration);\n    float noteEnd = 0.3;\n    float fadeIn = smoothstep(0.0, 0.7, notePos);\n    float fadeOut = smoothstep(noteEnd, noteEnd + 0.7, notePos);\n    float envelope = fadeIn * (1.0 - fadeOut);\n    if (abs(uv.y - y) < 0.004) {\n        col = mix(vec3(1.0), vec3(0.0), envelope);\n    }\n    return col;\n}\n\nvec3 drawFunction(vec2 uv, float t) { \n    vec3 col = testFunction(uv);\n    return col;\n}\n\n#endif\n\n#if MODE == 2\n\nvec3 testFunction(vec2 uv) {\n    vec3 col = vec3(1.0); \n    float curveOffset = 0.15;\n    float y = 0.45;\n    // Upper curves\n    float curve1 = y + curveOffset + 0.05 * sin(uv.x * 20.0);\n    float curve2 = y + curveOffset * 2.0 + 0.05 * cos(uv.x * 15.0);\n    \n    // Lower curves\n    float curve3 = y - curveOffset - 0.05 * sin(uv.x * 18.0);\n    float curve4 = y - curveOffset * 2.0 - 0.05 * cos(uv.x * 12.0);\n    \n    if (abs(uv.y - curve1) < 0.003) {col = vec3(abs(uv.y - curve1)/0.003);}\n    if (abs(uv.y - curve2) < 0.009) {col = vec3(abs(uv.y - curve2)/0.009);}\n    if (abs(uv.y - curve3) < 0.02) {col = vec3(abs(uv.y - curve3)/0.02);}\n    if (abs(uv.y - curve4) < 0.005) {col = vec3(abs(uv.y - curve4)/0.005);}\n    return col;\n}\n\nvec3 drawFunction(vec2 uv, float t) { \n    vec3 col = testFunction(uv);\n    return col;\n}\n\n#endif\n\n\n#if MODE == 3\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a \n// single unsigned integer.\n\nuint hash(uint x, uint seed) {\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process input\n    uint k = x;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  \n// 2-dimensional unsigned integer input vector.\n\nuint hash(uvec2 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n\nvec2 gradientDirection(uint hash) {\n    switch (int(hash) & 3) { // look at the last two bits to pick a gradient direction\n    case 0:\n        return vec2(1.0, 1.0);\n    case 1:\n        return vec2(-1.0, 1.0);\n    case 2:\n        return vec2(1.0, -1.0);\n    case 3:\n        return vec2(-1.0, -1.0);\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, vec2 t) {\n    return mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y);\n}\n\nvec2 fade(vec2 t) {\n    // 6t^5 - 15t^4 + 10t^3\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec2 position, uint seed) {\n    vec2 floorPosition = floor(position);\n    vec2 fractPosition = position - floorPosition;\n    uvec2 cellCoordinates = uvec2(floorPosition);\n    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 0)), seed)), fractPosition - vec2(1.0, 0.0));\n    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec2(0, 1)), seed)), fractPosition - vec2(0.0, 1.0));\n    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 1)), seed)), fractPosition - vec2(1.0, 1.0));\n    return interpolate(value1, value2, value3, value4, fade(fractPosition));\n}\n\nfloat perlinNoise(vec2 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float currentFrequency = float(frequency);\n    uint currentSeed = seed;\n    for (int i = 0; i < 4; i++) {\n        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;\n        currentFrequency *= lacunarity;\n    }\n    return value;\n}\n\nvec3 drawFunction(vec2 uv, float t) { \n\n   vec3 col = vec3(   perlinNoise(uv+vec2(t/5.,t/10.), 1, 6, 0.5, 2.0, 45u)   )+sqrt(uv.y);\n    return col;\n}\n\n#endif",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WXsczs",
    "date": "1760057925",
    "viewed": 26,
    "name": "Wavetable Synth",
    "description": "Sadly this can't be interactive because of site limitations, but it really is playing the wavetable it's displaying.\nIf you want to change the texture, make sure you change it in all three buffers.\nIt may get out of sync, if it does restart it.",
    "likes": 7,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "audio",
     "synthesis",
     "wavetable",
     "dsp"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float yoffset = 0.5+sin(iTime)/2.;\n    \n    // Get the buffer contents\n    vec3 col = texture(iChannel0, uv).rgb;\n    uv+=0.1;\n    // Highlighted slice position (at 0.5)\n    float highlightPos = yoffset;\n    \n    // Draw highlighted slice with matching isometric transformation\n    vec2 centerUV = (uv - vec2(0.5, 0.5)) * 2.5;\n    \n    // Isometric projection for highlighted slice\n    float isoX = highlightPos * 0.6;  // Move right\n    float isoY = highlightPos * 0.9;  // Move up\n    \n    // Calculate x position in waveform from screen position\n    float waveX = ((centerUV.x - isoX) / 1.2) + 0.5;\n    \n    if(waveX >= 0.0 && waveX <= 1.0) {\n        float waveValue = wavetable(vec2(waveX, highlightPos), iChannel1, iTime);\n        \n        // y position: wave amplitude + isometric offset\n        float posY = waveValue * 0.25 + isoY;\n        \n        // Distance from current pixel\n        float dist = abs(centerUV.y - posY);\n        float lineThickness = 0.012;\n        float glowRadius = 0.04;\n        \n        if(dist < glowRadius) {\n            float intensity = 0.0;\n            \n            // Core line\n            if(dist < lineThickness) {\n                intensity = 1.0;\n            } else {\n                // Glow\n                intensity = 1.0 - (dist - lineThickness) / (glowRadius - lineThickness);\n                intensity *= 0.6;\n            }\n            \n            col += vec3(0.7, 1.0, 0.7) * intensity;\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Wavetable functions\nfloat wavetabletest(vec2 uv) {\n    float x = uv.x;  // Phase (0-1)\n    float y = uv.y;  // Table position (0-1)\n    \n    // Ensure continuity at boundaries\n    float phase = x * 2.0 * 3.14159265359;\n    \n    if (y < 0.5) {\n        // Interpolate between sine and square\n        float t = y * 2.0;  // 0 to 1 for first half\n        \n        // Sine wave\n        float sine = sin(phase);\n        \n        // Square wave (bandlimited with a few harmonics)\n        float square = 0.0;\n        for(int i = 1; i <= 7; i += 2) {\n            square += sin(phase * float(i)) / float(i);\n        }\n        square *= 4.0 / 3.14159265359;\n        \n        return mix(sine, square, t);\n    } else {\n        // Interpolate between square and complex wave\n        float t = (y - 0.5) * 4.0;  // 0 to 1 for second half\n        \n        // Square wave\n        float square = 0.0;\n        for(int i = 1; i <= 7; i += 2) {\n            square += sin(phase * float(i)) / float(i);\n        }\n        square *= 4.0 / 3.14159265359;\n        \n        // Complex wave (multiple harmonics)\n        float complex = sin(phase) * 0.5 +           // Fundamental\n                       sin(phase * 2.0) * 0.3 +      // 2nd harmonic\n                       sin(phase * 3.0) * 0.15 +     // 3rd harmonic\n                       sin(phase * 5.0) * 0.05;      // 5th harmonic\n        \n        return mix(square, complex, t);\n    }\n}\n\nfloat wavetable_metallic(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Start harmonic, become increasingly inharmonic\n    float wave = sin(phase);\n    \n    // Add inharmonic partials\n    wave += sin(phase * 2.1) * 0.5 * y;\n    wave += sin(phase * 3.3) * 0.3 * y;\n    wave += sin(phase * 4.7) * 0.2 * y;\n    wave += sin(phase * 6.2) * 0.15 * y;\n    wave += sin(phase * 7.9) * 0.1 * y;\n    \n    return wave / (1.0 + y);\n}\n\nfloat wavetable_fold(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Start with sine\n    float wave = sin(phase);\n    \n    // Apply wave folding - increases with y\n    float foldAmount = 1.0 + y * 4.0;\n    wave *= foldAmount;\n    \n    // Fold the wave\n    wave = abs(fract(wave * 0.25 + 0.5) * 2.0 - 1.0) * 2.0 - 1.0;\n    \n    return wave;\n}\n\nfloat wavetableTex(vec2 uv, sampler2D bmp) {\n    vec4 tex = texture(bmp, uv, 0.);\n   return ((tex.r +tex.g +tex.b)*.6666)-1.;\n}\nfloat wavetable_bitcrush(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Start with clean sine\n    float wave = sin(phase);\n    \n    // Reduce bit depth as y increases\n    float bits = 5.0 - y * 7.0; // From 16-bit to 1-bit\n    float steps = pow(2.0, bits);\n    \n    wave = floor(wave * steps) / steps;\n    \n    return wave;\n}\nfloat wavetable_vowel(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Different formant frequencies for vowel sounds\n    float wave = 0.0;\n    \n    if (y < 0.25) {\n        // A to E\n        float t = y * 4.0;\n        // A: 730, 1090, 2440\n        float a = sin(phase) + 0.5*sin(phase*1.5) + 0.3*sin(phase*3.3);\n        // E: 530, 1840, 2480\n        float e = sin(phase) + 0.4*sin(phase*3.5) + 0.3*sin(phase*4.7);\n        wave = mix(a, e, t);\n        \n    } else if (y < 0.5) {\n        // E to I\n        float t = (y - 0.25) * 4.0;\n        float e = sin(phase) + 0.4*sin(phase*3.5) + 0.3*sin(phase*4.7);\n        // I: 270, 2290, 3010\n        float i = sin(phase) + 0.3*sin(phase*8.5) + 0.2*sin(phase*11.2);\n        wave = mix(e, i, t);\n        \n    } else if (y < 0.75) {\n        // I to O\n        float t = (y - 0.5) * 4.0;\n        float i = sin(phase) + 0.3*sin(phase*8.5) + 0.2*sin(phase*11.2);\n        // O: 570, 840, 2410\n        float o = sin(phase) + 0.5*sin(phase*1.5) + 0.2*sin(phase*4.2);\n        wave = mix(i, o, t);\n        \n    } else {\n        // O to U\n        float t = (y - 0.75) * 4.0;\n        float o = sin(phase) + 0.5*sin(phase*1.5) + 0.2*sin(phase*4.2);\n        // U: 440, 1020, 2240\n        float u = sin(phase) + 0.4*sin(phase*2.3) + 0.2*sin(phase*5.1);\n        wave = mix(o, u, t);\n    }\n    \n    return wave * 0.6; // Normalize\n}\nfloat wavetable_morph(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    if (y < 0.333) {\n        // Sine to Triangle\n        float t = y * 3.0;\n        float sine = sin(phase);\n        float triangle = asin(sin(phase)) * 2.0 / 3.14159265359;\n        return mix(sine, triangle, t);\n        \n    } else if (y < 0.666) {\n        // Triangle to Sawtooth\n        float t = (y - 0.333) * 3.0;\n        float triangle = asin(sin(phase)) * 2.0 / 3.14159265359;\n        float saw = (fract(x) * 2.0 - 1.0);\n        return mix(triangle, saw, t);\n        \n    } else {\n        // Sawtooth to Square\n        float t = (y - 0.666) * 3.0;\n        float saw = (fract(x) * 2.0 - 1.0);\n        \n        // Square wave (bandlimited)\n        float square = 0.0;\n        for(int i = 1; i <= 7; i += 2) {\n            square += sin(phase * float(i)) / float(i);\n        }\n        square *= 4.0 / 3.14159265359;\n        \n        return mix(saw, square, t);\n    }\n}\nfloat wavetable_harmonic(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Start with sine, add harmonics as y increases\n    float wave = sin(phase);\n    \n    // Add harmonics progressively\n    int maxHarmonics = int(1.0 + y * 15.0);\n    for(int i = 2; i <= 16; i++) {\n        if(i <= maxHarmonics) {\n            float amplitude = 1.0 / float(i);\n            wave += sin(phase * float(i)) * amplitude;\n        }\n    }\n    \n    // Normalize\n    return wave / (1.0 + y * 2.0);\n}\nfloat wavetable_harmonic2(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    float outp = sin(phase) * 0.5;  // Fundamental always present\n    \n    // Gradually add harmonics based on table position\n    int numHarmonics = int(y * 12.0) + 1;\n    \n    for(int i = 2; i <= numHarmonics && i <= 12; i++) {\n        float harmAmp = (1.0 / float(i)) * (1.0 - float(i - 2) / 11.0 * 0.5);\n        outp += sin(phase * float(i)) * harmAmp * y;\n    }\n    \n    return outp / (1.0 + y * 0.5);  // Normalize\n}\nfloat wavetable_pwm(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Pulse width varies from 10% to 90%\n    float pulseWidth = 0.1 + y * 0.8;\n    \n    // Generate pulse wave using fourier series\n    float wave = 0.0;\n    for(int i = 1; i <= 9; i++) {\n        float n = float(i);\n        wave += (sin(n * 3.14159265359 * pulseWidth) / n) * sin(n * phase);\n    }\n    wave *= 2.0 / 3.14159265359;\n    \n    return wave;\n}\nfloat wavetable_pwm2(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Pulse width varies from 10% to 90%\n    float pulseWidth = 0.1 + y * 0.8;\n    \n    // Bandlimited pulse wave\n    float pulse = 0.0;\n    for(int i = 1; i <= 10; i++) {\n        pulse += sin(phase * float(i)) * sin(float(i) * 3.14159265359 * pulseWidth) / float(i);\n    }\n    pulse *= 4.0 / 3.14159265359;\n    \n    return pulse;\n}\nfloat wavetableclassic(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    if (y < 0.5) {\n        // Saw to Triangle\n        float t = y * 2.0;\n        \n        // Bandlimited saw wave\n        float saw = 0.0;\n        for(int i = 1; i <= 10; i++) {\n            saw += sin(phase * float(i)) / float(i);\n        }\n        saw *= -2.0 / 3.14159265359;\n        \n        // Triangle wave\n        float triangle = asin(sin(phase)) * 2.0 / 3.14159265359;\n        \n        return mix(saw, triangle, t);\n    } else {\n        // Triangle to Sine\n        float t = (y - 0.5) * 2.0;\n        float triangle = asin(sin(phase)) * 2.0 / 3.14159265359;\n        float sine = sin(phase);\n        return mix(triangle, sine, t);\n    }\n}\nfloat wavetablevoc(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    if (y < 0.33) {\n        // \"Ooh\" formant (darker)\n        float t = y * 3.0;\n        float ooh = sin(phase) * 0.8 + \n                   sin(phase * 2.0) * 0.15 * (1.0 - t) +\n                   sin(phase * 3.0) * 0.05;\n        return ooh;\n    } else if (y < 0.66) {\n        // \"Aah\" formant (brighter)\n        float t = (y - 0.33) * 3.0;\n        float aah = sin(phase) * 0.5 +\n                   sin(phase * 2.0) * 0.3 +\n                   sin(phase * 4.0) * 0.15 +\n                   sin(phase * 5.0) * 0.05;\n        return aah * (1.0 + t * 0.2);\n    } else {\n        // \"Eeh\" formant (brightest)\n        float t = (y - 0.66) * 3.0;\n        float eeh = sin(phase) * 0.4 +\n                   sin(phase * 3.0) * 0.3 +\n                   sin(phase * 5.0) * 0.2 +\n                   sin(phase * 7.0) * 0.1;\n        return eeh;\n    }\n}\nfloat wavetablebell(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    // Start with fundamental\n    float outp = sin(phase) * (1.0 - y * 0.5);\n    \n    // Add increasingly inharmonic partials\n    outp += sin(phase * 2.7) * y * 0.3;   // Minor third-ish\n    outp += sin(phase * 4.2) * y * 0.2;   // Between harmonics\n    outp += sin(phase * 5.4) * y * 0.15;  // Metallic partial\n    outp += sin(phase * 7.8) * y * 0.1;   // Bell-like partial\n    \n    if (y > 0.5) {\n        float t = (y - 0.5) * 2.0;\n        outp += sin(phase * 9.3) * t * 0.08;\n        outp += sin(phase * 11.7) * t * 0.05;\n    }\n    \n    return outp;\n}\nfloat wavetabledist(vec2 uv) {\n    float x = uv.x;\n    float y = uv.y;\n    float phase = x * 2.0 * 3.14159265359;\n    \n    float sine = sin(phase);\n    float drive = 1.0 + y * 10.0;  // Increase overdrive with y\n    \n    // Soft to hard clipping\n    float clipped = sine * drive;\n    \n    if (y < 0.5) {\n        // Soft clipping (tanh-like)\n        clipped = tanh(clipped * 2.0) * 0.9;\n    } else {\n        // Harder clipping\n        clipped = clamp(clipped, -1.0, 1.0);\n        // Add some harmonics back for bandlimiting\n        float t = (y - 0.5) * 2.0;\n        clipped = mix(tanh(sine * drive * 2.0), \n                     sign(sine) * pow(abs(sine), 0.3 - t * 0.2), \n                     t) * 0.9;\n    }\n    \n    return clipped;\n}\nfloat wavetable(vec2 uv, sampler2D bmp, float time) {\n    float period = time/6.2832;\n    int num = int(floor(period));\n    num = num%15;\n    float sampl;\n    \n    switch (num){\n        case 0: sampl = wavetablebell(uv); break;\n        case 1: sampl = wavetableTex(uv, bmp); break;\n        case 2: sampl = wavetabletest(uv); break;\n        case 3: sampl = wavetable_metallic(uv); break;\n        case 4: sampl = wavetable_fold(uv) ; break;\n        case 5: sampl = wavetable_bitcrush(uv) ; break;\n        case 6: sampl = wavetable_vowel(uv) ; break;\n        case 7: sampl = wavetable_morph(uv) ; break;\n        case 8: sampl = wavetable_harmonic(uv) ; break;\n        case 9: sampl = wavetable_harmonic2(uv) ; break;\n        case 10: sampl = wavetable_pwm(uv) ; break;\n        case 11: sampl = wavetable_pwm2(uv); break;\n        case 12: sampl = wavetableclassic( uv) ; break;\n        case 13: sampl = wavetablevoc(uv) ; break;\n        case 14: sampl = wavetabledist(uv) ; break;\n    }\n    \n   return clamp( sampl  , -1.,1.);\n}\n\n\n\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Only render on first frame, if the wavetable stays the same.\n    if (iFrame > 0) {\n        //fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        //return;\n    }\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(0.0);\n    uv+=0.1;\n    // Main wavetable display (isometric view)\n    vec2 centerUV = (uv - vec2(0.5, 0.5)) * 2.5;\n    vec2 proj = vec2(0.6,0.9);\n    // Draw reference grid below (at -1.5)\n    for(int i = 0; i < 50; i++) {\n        float tablePos = float(i) / 49.0;\n        \n        // Isometric projection\n        float isoX = tablePos * proj.x;  // Move right\n        float isoY = tablePos * proj.y;  // Move up\n        \n        // Calculate x position from screen position\n        float waveX = ((centerUV.x - isoX) / 1.2) + 0.5;\n        \n        // Check if we're within the valid range\n        if(waveX >= 0.0 && waveX <= 1.0) {\n            // Reference grid at constant -1.5\n            float refValue = -1.5;\n            float posY = refValue * 0.25 + isoY;\n            \n            // Distance from current pixel\n            float dist = abs(centerUV.y - posY);\n            float lineThickness = 0.006 / (1.0 + tablePos * 0.3); // Perspective\n            \n            if(dist < lineThickness) {\n                float intensity = 1.0 - dist / lineThickness;\n                // Fade lines towards the back\n                intensity *= 1.0 - tablePos * 0.4;\n                // Darker green for reference grid\n                col += vec3(0.0, 0.3, 0.0) * intensity * 0.5;\n            }\n        }\n    }\n    \n    // Draw vertical lines from base to waveform\n    for(int i = 0; i < 30; i++) {\n        float tablePos = float(i) / 29.0;\n        \n        // Isometric projection\n        float isoX = tablePos * proj.x;  // Move right\n        float isoY = tablePos * proj.y;  // Move up\n        \n        // Calculate x position from screen position\n        float waveX = ((centerUV.x - isoX) / 1.2) + 0.5;\n        \n        // Check if we're within the valid range\n        if(waveX >= 0.0 && waveX <= 1.05) {\n            // Sample every few pixels for vertical lines\n            float xMod = mod(waveX * 100.0, 5.0);\n            if(xMod < 0.5) {\n                float waveValue = wavetable(vec2(waveX, tablePos), iChannel1, iTime);\n                \n                // Base and top positions\n                float baseY = -1.5 * 0.25 + isoY;\n                float topY = waveValue * 0.25 + isoY;\n                \n                // Check if we're between base and top\n                float minY = min(baseY, topY);\n                float maxY = max(baseY, topY);\n                \n                if(centerUV.y >= minY && centerUV.y <= maxY) {\n                    float lineThickness = 0.003 / (1.0 + tablePos * 0.3);\n                    float intensity = 1.0 - tablePos * 0.5;\n                    if(waveX<0.05||waveX>0.99){intensity*=2.;}\n                    col += vec3(0.0, 0.35, 0.0) * intensity *0.2;\n                }\n            }\n        }\n    }\n    \n    // Draw wavetable on top\n    for(int i = 0; i < 30; i++) {\n        float tablePos = float(i) / 29.0;\n        \n        // Isometric projection\n        float isoX = tablePos * proj.x;  // Move right\n        float isoY = tablePos * proj.y;  // Move up\n        \n        // Calculate x position in waveform from screen position\n        float waveX = ((centerUV.x - isoX) / 1.2) + 0.5;\n        \n        // Check if we're within the valid waveform range\n        if(waveX >= 0.0 && waveX <= 1.0) {\n            float waveValue = wavetable(vec2(waveX, tablePos), iChannel1, iTime);\n            \n            // y position: wave amplitude + isometric offset\n            float posY = waveValue * 0.25 + isoY;\n            \n            // Distance from current pixel\n            float dist = abs(centerUV.y - posY);\n            float lineThickness = 0.008 / (1.0 + tablePos * 0.3); // Perspective\n            \n            if(dist < lineThickness) {\n                float intensity = 1.0 - dist / lineThickness;\n                // Fade lines towards the back\n                intensity *= 1.0 - tablePos * 0.4;\n                if(waveX<0.05&&waveX>0.99){intensity*=3.;}\n                col += vec3(0.0, 0.7, 0.0) * intensity;\n            }\n        }\n    }\n    uv-=0.1;\n    // 2D bitmap view in corner (properly square with aspect ratio correction)\n    float cornerSize = 0.2;\n    vec2 cornerPos = vec2(0.05, 0.75); // Bottom left corner\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    // Correct for aspect ratio to make it square\n    vec2 cornerUV = (uv - cornerPos);\n    cornerUV.x *= aspectRatio;\n    cornerUV /= cornerSize;\n    \n    if(cornerUV.x >= 0.0 && cornerUV.x <= 1.0 && \n       cornerUV.y >= 0.0 && cornerUV.y <= 1.0) {\n        float sampl = wavetable(cornerUV, iChannel1, iTime);\n        // Map -1 to 1 to dark green to light green\n        float intensity = sampl * 0.5 + 0.5;\n        col = vec3(0.0, 0.2 + intensity * 0.6, 0.0);\n    }\n    \n    fragColor = vec4(tanh(col), 1.0);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "XdX3Rn",
       "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "vec2 mainSound( int samp, float time )\n{\n    // Audio playback rate\n    float frequency = 262.0; // C3\n    float sampleRate = 44100.0;\n    \n    // Phase accumulator\n    float phase = fract(time * frequency);\n    \n    // Use middle position of wavetable (y = 0.5)\n    float tablePos = 0.5+sin(time)/2.;\n    \n    // Get sample from wavetable\n    float sampl = wavetable(vec2(phase, tablePos), iChannel0, time);\n    \n    return vec2(sampl);\n}",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  }
 ]
}